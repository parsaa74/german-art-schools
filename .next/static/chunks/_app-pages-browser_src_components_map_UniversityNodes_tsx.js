/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_components_map_UniversityNodes_tsx"],{

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/Billboard.js":
/*!**********************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Billboard.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Billboard: function() { return /* binding */ Billboard; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\");\n\n\n\n\n\n/**\n * Wraps children in a billboarded group. Sample usage:\n *\n * ```js\n * <Billboard>\n *   <Text>hi</Text>\n * </Billboard>\n * ```\n */\nconst Billboard = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function Billboard({\n  children,\n  follow = true,\n  lockX = false,\n  lockY = false,\n  lockZ = false,\n  ...props\n}, fref) {\n  const inner = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const localRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  const q = new three__WEBPACK_IMPORTED_MODULE_2__.Quaternion();\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.F)(({\n    camera\n  }) => {\n    if (!follow || !localRef.current) return;\n\n    // save previous rotation in case we're locking an axis\n    const prevRotation = localRef.current.rotation.clone();\n\n    // always face the camera\n    localRef.current.updateMatrix();\n    localRef.current.updateWorldMatrix(false, false);\n    localRef.current.getWorldQuaternion(q);\n    camera.getWorldQuaternion(inner.current.quaternion).premultiply(q.invert());\n\n    // readjust any axis that is locked\n    if (lockX) localRef.current.rotation.x = prevRotation.x;\n    if (lockY) localRef.current.rotation.y = prevRotation.y;\n    if (lockZ) localRef.current.rotation.z = prevRotation.z;\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, () => localRef.current, []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: localRef\n  }, props), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n    ref: inner\n  }, children));\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0JpbGxib2FyZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDSTtBQUNXOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsNkNBQWdCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxnQkFBZ0IseUNBQVk7QUFDNUIsbUJBQW1CLHlDQUFZO0FBQy9CLGdCQUFnQiw2Q0FBVTtBQUMxQixFQUFFLHFEQUFRO0FBQ1Y7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsc0RBQXlCO0FBQzNCLHNCQUFzQixnREFBbUIsVUFBVSw4RUFBUTtBQUMzRDtBQUNBLEdBQUcsdUJBQXVCLGdEQUFtQjtBQUM3QztBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVvQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9CaWxsYm9hcmQuanM/ZGQ2NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBRdWF0ZXJuaW9uIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuXG4vKipcbiAqIFdyYXBzIGNoaWxkcmVuIGluIGEgYmlsbGJvYXJkZWQgZ3JvdXAuIFNhbXBsZSB1c2FnZTpcbiAqXG4gKiBgYGBqc1xuICogPEJpbGxib2FyZD5cbiAqICAgPFRleHQ+aGk8L1RleHQ+XG4gKiA8L0JpbGxib2FyZD5cbiAqIGBgYFxuICovXG5jb25zdCBCaWxsYm9hcmQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIEJpbGxib2FyZCh7XG4gIGNoaWxkcmVuLFxuICBmb2xsb3cgPSB0cnVlLFxuICBsb2NrWCA9IGZhbHNlLFxuICBsb2NrWSA9IGZhbHNlLFxuICBsb2NrWiA9IGZhbHNlLFxuICAuLi5wcm9wc1xufSwgZnJlZikge1xuICBjb25zdCBpbm5lciA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3QgbG9jYWxSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHEgPSBuZXcgUXVhdGVybmlvbigpO1xuICB1c2VGcmFtZSgoe1xuICAgIGNhbWVyYVxuICB9KSA9PiB7XG4gICAgaWYgKCFmb2xsb3cgfHwgIWxvY2FsUmVmLmN1cnJlbnQpIHJldHVybjtcblxuICAgIC8vIHNhdmUgcHJldmlvdXMgcm90YXRpb24gaW4gY2FzZSB3ZSdyZSBsb2NraW5nIGFuIGF4aXNcbiAgICBjb25zdCBwcmV2Um90YXRpb24gPSBsb2NhbFJlZi5jdXJyZW50LnJvdGF0aW9uLmNsb25lKCk7XG5cbiAgICAvLyBhbHdheXMgZmFjZSB0aGUgY2FtZXJhXG4gICAgbG9jYWxSZWYuY3VycmVudC51cGRhdGVNYXRyaXgoKTtcbiAgICBsb2NhbFJlZi5jdXJyZW50LnVwZGF0ZVdvcmxkTWF0cml4KGZhbHNlLCBmYWxzZSk7XG4gICAgbG9jYWxSZWYuY3VycmVudC5nZXRXb3JsZFF1YXRlcm5pb24ocSk7XG4gICAgY2FtZXJhLmdldFdvcmxkUXVhdGVybmlvbihpbm5lci5jdXJyZW50LnF1YXRlcm5pb24pLnByZW11bHRpcGx5KHEuaW52ZXJ0KCkpO1xuXG4gICAgLy8gcmVhZGp1c3QgYW55IGF4aXMgdGhhdCBpcyBsb2NrZWRcbiAgICBpZiAobG9ja1gpIGxvY2FsUmVmLmN1cnJlbnQucm90YXRpb24ueCA9IHByZXZSb3RhdGlvbi54O1xuICAgIGlmIChsb2NrWSkgbG9jYWxSZWYuY3VycmVudC5yb3RhdGlvbi55ID0gcHJldlJvdGF0aW9uLnk7XG4gICAgaWYgKGxvY2taKSBsb2NhbFJlZi5jdXJyZW50LnJvdGF0aW9uLnogPSBwcmV2Um90YXRpb24uejtcbiAgfSk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoZnJlZiwgKCkgPT4gbG9jYWxSZWYuY3VycmVudCwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBsb2NhbFJlZlxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwge1xuICAgIHJlZjogaW5uZXJcbiAgfSwgY2hpbGRyZW4pKTtcbn0pO1xuXG5leHBvcnQgeyBCaWxsYm9hcmQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/Billboard.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/Instances.js":
/*!**********************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Instances.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Instance: function() { return /* binding */ Instance; },\n/* harmony export */   InstancedAttribute: function() { return /* binding */ InstancedAttribute; },\n/* harmony export */   Instances: function() { return /* binding */ Instances; },\n/* harmony export */   Merged: function() { return /* binding */ Merged; },\n/* harmony export */   PositionMesh: function() { return /* binding */ PositionMesh; },\n/* harmony export */   createInstances: function() { return /* binding */ createInstances; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\");\n/* harmony import */ var react_composer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-composer */ \"(app-pages-browser)/./node_modules/react-composer/es/index.js\");\n/* harmony import */ var _helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/deprecated.js */ \"(app-pages-browser)/./node_modules/@react-three/drei/helpers/deprecated.js\");\n\n\n\n\n\n\n\nfunction isFunctionChild(value) {\n  return typeof value === 'function';\n}\nconst _instanceLocalMatrix = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst _instanceWorldMatrix = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst _instanceIntersects = [];\nconst _mesh = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Mesh();\nclass PositionMesh extends three__WEBPACK_IMPORTED_MODULE_3__.Group {\n  constructor() {\n    super();\n    this.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color('white');\n    this.instance = {\n      current: undefined\n    };\n    this.instanceKey = {\n      current: undefined\n    };\n  }\n\n  // This will allow the virtual instance have bounds\n  get geometry() {\n    var _this$instance$curren;\n    return (_this$instance$curren = this.instance.current) == null ? void 0 : _this$instance$curren.geometry;\n  }\n\n  // And this will allow the virtual instance to receive events\n  raycast(raycaster, intersects) {\n    const parent = this.instance.current;\n    if (!parent) return;\n    if (!parent.geometry || !parent.material) return;\n    _mesh.geometry = parent.geometry;\n    const matrixWorld = parent.matrixWorld;\n    const instanceId = parent.userData.instances.indexOf(this.instanceKey);\n    // If the instance wasn't found or exceeds the parents draw range, bail out\n    if (instanceId === -1 || instanceId > parent.count) return;\n    // calculate the world matrix for each instance\n    parent.getMatrixAt(instanceId, _instanceLocalMatrix);\n    _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);\n    // the mesh represents this single instance\n    _mesh.matrixWorld = _instanceWorldMatrix;\n    // raycast side according to instance material\n    if (parent.material instanceof three__WEBPACK_IMPORTED_MODULE_3__.Material) _mesh.material.side = parent.material.side;else _mesh.material.side = parent.material[0].side;\n    _mesh.raycast(raycaster, _instanceIntersects);\n    // process the result of raycast\n    for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n      const intersect = _instanceIntersects[i];\n      intersect.instanceId = instanceId;\n      intersect.object = this;\n      intersects.push(intersect);\n    }\n    _instanceIntersects.length = 0;\n  }\n}\nconst globalContext = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\nconst parentMatrix = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst instanceMatrix = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst tempMatrix = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst translation = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst rotation = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Quaternion();\nconst scale = /* @__PURE__ */new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst isInstancedBufferAttribute = attr => attr.isInstancedBufferAttribute;\nconst Instance = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  context,\n  children,\n  ...props\n}, ref) => {\n  react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.e)({\n    PositionMesh\n  }), []);\n  const group = react__WEBPACK_IMPORTED_MODULE_1__.useRef();\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, () => group.current, []);\n  const {\n    subscribe,\n    getParent\n  } = react__WEBPACK_IMPORTED_MODULE_1__.useContext(context || globalContext);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => subscribe(group), []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"positionMesh\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    instance: getParent(),\n    instanceKey: group,\n    ref: group\n  }, props), children);\n});\nconst Instances = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  context,\n  children,\n  range,\n  limit = 1000,\n  frames = Infinity,\n  ...props\n}, ref) => {\n  const [{\n    localContext,\n    instance\n  }] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => {\n    const localContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\n    return {\n      localContext,\n      instance: /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, ref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Instance, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        context: localContext\n      }, props, {\n        ref: ref\n      })))\n    };\n  });\n  const parentRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(ref, () => parentRef.current, []);\n  const [instances, setInstances] = react__WEBPACK_IMPORTED_MODULE_1__.useState([]);\n  const [[matrices, colors]] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => {\n    const mArray = new Float32Array(limit * 16);\n    for (let i = 0; i < limit; i++) tempMatrix.identity().toArray(mArray, i * 16);\n    return [mArray, new Float32Array([...new Array(limit * 3)].map(() => 1))];\n  });\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    // We might be a frame too late? 🤷‍♂️\n    parentRef.current.instanceMatrix.needsUpdate = true;\n  });\n  let iterations = 0;\n  let count = 0;\n  const attributes = react__WEBPACK_IMPORTED_MODULE_1__.useRef([]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    attributes.current = Object.entries(parentRef.current.geometry.attributes).filter(([_name, value]) => isInstancedBufferAttribute(value));\n  });\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F)(() => {\n    if (frames === Infinity || iterations < frames) {\n      parentRef.current.updateMatrix();\n      parentRef.current.updateMatrixWorld();\n      parentMatrix.copy(parentRef.current.matrixWorld).invert();\n      count = Math.min(limit, range !== undefined ? range : limit, instances.length);\n      parentRef.current.count = count;\n      (0,_helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_5__.setUpdateRange)(parentRef.current.instanceMatrix, {\n        offset: 0,\n        count: count * 16\n      });\n      (0,_helpers_deprecated_js__WEBPACK_IMPORTED_MODULE_5__.setUpdateRange)(parentRef.current.instanceColor, {\n        offset: 0,\n        count: count * 3\n      });\n      for (let i = 0; i < instances.length; i++) {\n        const instance = instances[i].current;\n        // Multiply the inverse of the InstancedMesh world matrix or else\n        // Instances will be double-transformed if <Instances> isn't at identity\n        instance.matrixWorld.decompose(translation, rotation, scale);\n        instanceMatrix.compose(translation, rotation, scale).premultiply(parentMatrix);\n        instanceMatrix.toArray(matrices, i * 16);\n        parentRef.current.instanceMatrix.needsUpdate = true;\n        instance.color.toArray(colors, i * 3);\n        parentRef.current.instanceColor.needsUpdate = true;\n      }\n      iterations++;\n    }\n  });\n  const api = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => ({\n    getParent: () => parentRef,\n    subscribe: ref => {\n      setInstances(instances => [...instances, ref]);\n      return () => setInstances(instances => instances.filter(item => item.current !== ref.current));\n    }\n  }), []);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"instancedMesh\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    userData: {\n      instances,\n      limit,\n      frames\n    },\n    matrixAutoUpdate: false,\n    ref: parentRef,\n    args: [null, null, 0],\n    raycast: () => null\n  }, props), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"instancedBufferAttribute\", {\n    attach: \"instanceMatrix\",\n    count: matrices.length / 16,\n    array: matrices,\n    itemSize: 16,\n    usage: three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"instancedBufferAttribute\", {\n    attach: \"instanceColor\",\n    count: colors.length / 3,\n    array: colors,\n    itemSize: 3,\n    usage: three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n  }), isFunctionChild(children) ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(localContext.Provider, {\n    value: api\n  }, children(instance)) : context ? /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(context.Provider, {\n    value: api\n  }, children) : /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(globalContext.Provider, {\n    value: api\n  }, children));\n});\nconst Merged = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(function Merged({\n  meshes,\n  children,\n  ...props\n}, ref) {\n  const isArray = Array.isArray(meshes);\n  // Filter out meshes from collections, which may contain non-meshes\n  if (!isArray) for (const key of Object.keys(meshes)) if (!meshes[key].isMesh) delete meshes[key];\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n    ref: ref\n  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(react_composer__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n    components: (isArray ? meshes : Object.values(meshes)).map(({\n      geometry,\n      material\n    }) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Instances, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n      key: geometry.uuid,\n      geometry: geometry,\n      material: material\n    }, props)))\n  }, args => isArray ? children(...args) : children(Object.keys(meshes).filter(key => meshes[key].isMesh).reduce((acc, key, i) => ({\n    ...acc,\n    [key]: args[i]\n  }), {}))));\n});\n\n/** Idea and implementation for global instances and instanced attributes by\n/*  Matias Gonzalez Fernandez https://x.com/matiNotFound\n/*  and Paul Henschel https://x.com/0xca0a\n*/\nfunction createInstances() {\n  const context = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createContext(null);\n  return [/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, fref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Instances, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: fref,\n    context: context\n  }, props))), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef((props, fref) => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Instance, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    ref: fref,\n    context: context\n  }, props)))];\n}\nconst InstancedAttribute = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  name,\n  defaultValue,\n  normalized,\n  usage = three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage\n}, fref) => {\n  const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n  react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, () => ref.current, []);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => {\n    const parent = ref.current.__r3f.parent;\n    parent.geometry.attributes[name] = ref.current;\n    const value = Array.isArray(defaultValue) ? defaultValue : [defaultValue];\n    const array = Array.from({\n      length: parent.userData.limit\n    }, () => value).flat();\n    ref.current.array = new Float32Array(array);\n    ref.current.itemSize = value.length;\n    ref.current.count = array.length / ref.current.itemSize;\n    return () => {\n      delete parent.geometry.attributes[name];\n    };\n  }, [name]);\n  let iterations = 0;\n  (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.F)(() => {\n    const parent = ref.current.__r3f.parent;\n    if (parent.userData.frames === Infinity || iterations < parent.userData.frames) {\n      for (let i = 0; i < parent.userData.instances.length; i++) {\n        const instance = parent.userData.instances[i].current;\n        const value = instance[name];\n        if (value !== undefined) {\n          ref.current.set(Array.isArray(value) ? value : typeof value.toArray === 'function' ? value.toArray() : [value], i * ref.current.itemSize);\n          ref.current.needsUpdate = true;\n        }\n      }\n      iterations++;\n    }\n  });\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"instancedBufferAttribute\", {\n    ref: ref,\n    usage: usage,\n    normalized: normalized\n  });\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL0luc3RhbmNlcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ0E7QUFDdUI7QUFDaEI7QUFDb0I7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwwQ0FBYTtBQUM3RCxnREFBZ0QsMENBQWE7QUFDN0Q7QUFDQSxpQ0FBaUMsdUNBQVU7QUFDM0MsMkJBQTJCLHdDQUFXO0FBQ3RDO0FBQ0E7QUFDQSxxQkFBcUIsd0NBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQ0FBYyw2Q0FBNkM7QUFDOUY7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsZ0RBQW1CO0FBQ3hELHdDQUF3QywwQ0FBYTtBQUNyRCwwQ0FBMEMsMENBQWE7QUFDdkQsc0NBQXNDLDBDQUFhO0FBQ25ELHVDQUF1QywwQ0FBYTtBQUNwRCxvQ0FBb0MsNkNBQWdCO0FBQ3BELGlDQUFpQywwQ0FBYTtBQUM5QztBQUNBLGdDQUFnQyw2Q0FBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELEVBQUUsMENBQWEsT0FBTyxxREFBTTtBQUM1QjtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IseUNBQVk7QUFDNUIsRUFBRSxzREFBeUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsSUFBSSxFQUFFLDZDQUFnQjtBQUN0QixFQUFFLGtEQUFxQjtBQUN2QixzQkFBc0IsZ0RBQW1CLGlCQUFpQiw4RUFBUTtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGlDQUFpQyw2Q0FBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSSwyQ0FBYztBQUNyQixzQ0FBc0MsZ0RBQW1CO0FBQ3pEO0FBQ0E7QUFDQSw2QkFBNkIsNkNBQWdCLDhCQUE4QixnREFBbUIsV0FBVyw4RUFBUTtBQUNqSDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxvQkFBb0IseUNBQVk7QUFDaEMsRUFBRSxzREFBeUI7QUFDM0Isb0NBQW9DLDJDQUFjO0FBQ2xELCtCQUErQiwyQ0FBYztBQUM3QztBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0EsR0FBRztBQUNILEVBQUUsNENBQWU7QUFDakI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUJBQXFCLHlDQUFZO0FBQ2pDLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0EsR0FBRztBQUNILEVBQUUscURBQVE7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNFQUFjO0FBQ3BCO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTSxzRUFBYztBQUNwQjtBQUNBO0FBQ0EsT0FBTztBQUNQLHNCQUFzQixzQkFBc0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsMENBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLGtCQUFrQiw4RUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsdUJBQXVCLGdEQUFtQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQXNCO0FBQ2pDLEdBQUcsZ0JBQWdCLGdEQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbURBQXNCO0FBQ2pDLEdBQUcsNENBQTRDLGdEQUFtQjtBQUNsRTtBQUNBLEdBQUcsK0NBQStDLGdEQUFtQjtBQUNyRTtBQUNBLEdBQUcsMkJBQTJCLGdEQUFtQjtBQUNqRDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0QsOEJBQThCLDZDQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFtQjtBQUN6QztBQUNBLEdBQUcsZUFBZSxnREFBbUIsQ0FBQyxzREFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLLGtCQUFrQixnREFBbUIsWUFBWSw4RUFBUTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHLEtBQUs7QUFDUixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0RBQW1CO0FBQ2xELHVCQUF1Qiw2Q0FBZ0IsK0JBQStCLGdEQUFtQixZQUFZLDhFQUFRO0FBQzdHO0FBQ0E7QUFDQSxHQUFHLHlCQUF5Qiw2Q0FBZ0IsK0JBQStCLGdEQUFtQixXQUFXLDhFQUFRO0FBQ2pIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSx3Q0FBd0MsNkNBQWdCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbURBQXNCO0FBQ2hDLENBQUM7QUFDRCxjQUFjLHlDQUFZO0FBQzFCLEVBQUUsc0RBQXlCO0FBQzNCLEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRSxxREFBUTtBQUNWO0FBQ0E7QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUV5RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9JbnN0YW5jZXMuanM/MWU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBleHRlbmQsIHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCBDb21wb3NlciBmcm9tICdyZWFjdC1jb21wb3Nlcic7XG5pbXBvcnQgeyBzZXRVcGRhdGVSYW5nZSB9IGZyb20gJy4uL2hlbHBlcnMvZGVwcmVjYXRlZC5qcyc7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb25DaGlsZCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuY29uc3QgX2luc3RhbmNlTG9jYWxNYXRyaXggPSAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuTWF0cml4NCgpO1xuY29uc3QgX2luc3RhbmNlV29ybGRNYXRyaXggPSAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuTWF0cml4NCgpO1xuY29uc3QgX2luc3RhbmNlSW50ZXJzZWN0cyA9IFtdO1xuY29uc3QgX21lc2ggPSAvKiBAX19QVVJFX18gKi9uZXcgVEhSRUUuTWVzaCgpO1xuY2xhc3MgUG9zaXRpb25NZXNoIGV4dGVuZHMgVEhSRUUuR3JvdXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuY29sb3IgPSBuZXcgVEhSRUUuQ29sb3IoJ3doaXRlJyk7XG4gICAgdGhpcy5pbnN0YW5jZSA9IHtcbiAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdGhpcy5pbnN0YW5jZUtleSA9IHtcbiAgICAgIGN1cnJlbnQ6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgYWxsb3cgdGhlIHZpcnR1YWwgaW5zdGFuY2UgaGF2ZSBib3VuZHNcbiAgZ2V0IGdlb21ldHJ5KCkge1xuICAgIHZhciBfdGhpcyRpbnN0YW5jZSRjdXJyZW47XG4gICAgcmV0dXJuIChfdGhpcyRpbnN0YW5jZSRjdXJyZW4gPSB0aGlzLmluc3RhbmNlLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRpbnN0YW5jZSRjdXJyZW4uZ2VvbWV0cnk7XG4gIH1cblxuICAvLyBBbmQgdGhpcyB3aWxsIGFsbG93IHRoZSB2aXJ0dWFsIGluc3RhbmNlIHRvIHJlY2VpdmUgZXZlbnRzXG4gIHJheWNhc3QocmF5Y2FzdGVyLCBpbnRlcnNlY3RzKSB7XG4gICAgY29uc3QgcGFyZW50ID0gdGhpcy5pbnN0YW5jZS5jdXJyZW50O1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gICAgaWYgKCFwYXJlbnQuZ2VvbWV0cnkgfHwgIXBhcmVudC5tYXRlcmlhbCkgcmV0dXJuO1xuICAgIF9tZXNoLmdlb21ldHJ5ID0gcGFyZW50Lmdlb21ldHJ5O1xuICAgIGNvbnN0IG1hdHJpeFdvcmxkID0gcGFyZW50Lm1hdHJpeFdvcmxkO1xuICAgIGNvbnN0IGluc3RhbmNlSWQgPSBwYXJlbnQudXNlckRhdGEuaW5zdGFuY2VzLmluZGV4T2YodGhpcy5pbnN0YW5jZUtleSk7XG4gICAgLy8gSWYgdGhlIGluc3RhbmNlIHdhc24ndCBmb3VuZCBvciBleGNlZWRzIHRoZSBwYXJlbnRzIGRyYXcgcmFuZ2UsIGJhaWwgb3V0XG4gICAgaWYgKGluc3RhbmNlSWQgPT09IC0xIHx8IGluc3RhbmNlSWQgPiBwYXJlbnQuY291bnQpIHJldHVybjtcbiAgICAvLyBjYWxjdWxhdGUgdGhlIHdvcmxkIG1hdHJpeCBmb3IgZWFjaCBpbnN0YW5jZVxuICAgIHBhcmVudC5nZXRNYXRyaXhBdChpbnN0YW5jZUlkLCBfaW5zdGFuY2VMb2NhbE1hdHJpeCk7XG4gICAgX2luc3RhbmNlV29ybGRNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyhtYXRyaXhXb3JsZCwgX2luc3RhbmNlTG9jYWxNYXRyaXgpO1xuICAgIC8vIHRoZSBtZXNoIHJlcHJlc2VudHMgdGhpcyBzaW5nbGUgaW5zdGFuY2VcbiAgICBfbWVzaC5tYXRyaXhXb3JsZCA9IF9pbnN0YW5jZVdvcmxkTWF0cml4O1xuICAgIC8vIHJheWNhc3Qgc2lkZSBhY2NvcmRpbmcgdG8gaW5zdGFuY2UgbWF0ZXJpYWxcbiAgICBpZiAocGFyZW50Lm1hdGVyaWFsIGluc3RhbmNlb2YgVEhSRUUuTWF0ZXJpYWwpIF9tZXNoLm1hdGVyaWFsLnNpZGUgPSBwYXJlbnQubWF0ZXJpYWwuc2lkZTtlbHNlIF9tZXNoLm1hdGVyaWFsLnNpZGUgPSBwYXJlbnQubWF0ZXJpYWxbMF0uc2lkZTtcbiAgICBfbWVzaC5yYXljYXN0KHJheWNhc3RlciwgX2luc3RhbmNlSW50ZXJzZWN0cyk7XG4gICAgLy8gcHJvY2VzcyB0aGUgcmVzdWx0IG9mIHJheWNhc3RcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IF9pbnN0YW5jZUludGVyc2VjdHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjb25zdCBpbnRlcnNlY3QgPSBfaW5zdGFuY2VJbnRlcnNlY3RzW2ldO1xuICAgICAgaW50ZXJzZWN0Lmluc3RhbmNlSWQgPSBpbnN0YW5jZUlkO1xuICAgICAgaW50ZXJzZWN0Lm9iamVjdCA9IHRoaXM7XG4gICAgICBpbnRlcnNlY3RzLnB1c2goaW50ZXJzZWN0KTtcbiAgICB9XG4gICAgX2luc3RhbmNlSW50ZXJzZWN0cy5sZW5ndGggPSAwO1xuICB9XG59XG5jb25zdCBnbG9iYWxDb250ZXh0ID0gLyogQF9fUFVSRV9fICovUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IHBhcmVudE1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5NYXRyaXg0KCk7XG5jb25zdCBpbnN0YW5jZU1hdHJpeCA9IC8qIEBfX1BVUkVfXyAqL25ldyBUSFJFRS5NYXRyaXg0KCk7XG5jb25zdCB0ZW1wTWF0cml4ID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLk1hdHJpeDQoKTtcbmNvbnN0IHRyYW5zbGF0aW9uID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlZlY3RvcjMoKTtcbmNvbnN0IHJvdGF0aW9uID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlF1YXRlcm5pb24oKTtcbmNvbnN0IHNjYWxlID0gLyogQF9fUFVSRV9fICovbmV3IFRIUkVFLlZlY3RvcjMoKTtcbmNvbnN0IGlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gYXR0ciA9PiBhdHRyLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xuY29uc3QgSW5zdGFuY2UgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGNvbnRleHQsXG4gIGNoaWxkcmVuLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIFJlYWN0LnVzZU1lbW8oKCkgPT4gZXh0ZW5kKHtcbiAgICBQb3NpdGlvbk1lc2hcbiAgfSksIFtdKTtcbiAgY29uc3QgZ3JvdXAgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IGdyb3VwLmN1cnJlbnQsIFtdKTtcbiAgY29uc3Qge1xuICAgIHN1YnNjcmliZSxcbiAgICBnZXRQYXJlbnRcbiAgfSA9IFJlYWN0LnVzZUNvbnRleHQoY29udGV4dCB8fCBnbG9iYWxDb250ZXh0KTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHN1YnNjcmliZShncm91cCksIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicG9zaXRpb25NZXNoXCIsIF9leHRlbmRzKHtcbiAgICBpbnN0YW5jZTogZ2V0UGFyZW50KCksXG4gICAgaW5zdGFuY2VLZXk6IGdyb3VwLFxuICAgIHJlZjogZ3JvdXBcbiAgfSwgcHJvcHMpLCBjaGlsZHJlbik7XG59KTtcbmNvbnN0IEluc3RhbmNlcyA9IC8qIEBfX1BVUkVfXyAqL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHJhbmdlLFxuICBsaW1pdCA9IDEwMDAsXG4gIGZyYW1lcyA9IEluZmluaXR5LFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IFt7XG4gICAgbG9jYWxDb250ZXh0LFxuICAgIGluc3RhbmNlXG4gIH1dID0gUmVhY3QudXNlU3RhdGUoKCkgPT4ge1xuICAgIGNvbnN0IGxvY2FsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuICAgIHJldHVybiB7XG4gICAgICBsb2NhbENvbnRleHQsXG4gICAgICBpbnN0YW5jZTogLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEluc3RhbmNlLCBfZXh0ZW5kcyh7XG4gICAgICAgIGNvbnRleHQ6IGxvY2FsQ29udGV4dFxuICAgICAgfSwgcHJvcHMsIHtcbiAgICAgICAgcmVmOiByZWZcbiAgICAgIH0pKSlcbiAgICB9O1xuICB9KTtcbiAgY29uc3QgcGFyZW50UmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcGFyZW50UmVmLmN1cnJlbnQsIFtdKTtcbiAgY29uc3QgW2luc3RhbmNlcywgc2V0SW5zdGFuY2VzXSA9IFJlYWN0LnVzZVN0YXRlKFtdKTtcbiAgY29uc3QgW1ttYXRyaWNlcywgY29sb3JzXV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiB7XG4gICAgY29uc3QgbUFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShsaW1pdCAqIDE2KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbWl0OyBpKyspIHRlbXBNYXRyaXguaWRlbnRpdHkoKS50b0FycmF5KG1BcnJheSwgaSAqIDE2KTtcbiAgICByZXR1cm4gW21BcnJheSwgbmV3IEZsb2F0MzJBcnJheShbLi4ubmV3IEFycmF5KGxpbWl0ICogMyldLm1hcCgoKSA9PiAxKSldO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBXZSBtaWdodCBiZSBhIGZyYW1lIHRvbyBsYXRlPyDwn6S34oCN4pmC77iPXG4gICAgcGFyZW50UmVmLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuICB9KTtcbiAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICBsZXQgY291bnQgPSAwO1xuICBjb25zdCBhdHRyaWJ1dGVzID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBhdHRyaWJ1dGVzLmN1cnJlbnQgPSBPYmplY3QuZW50cmllcyhwYXJlbnRSZWYuY3VycmVudC5nZW9tZXRyeS5hdHRyaWJ1dGVzKS5maWx0ZXIoKFtfbmFtZSwgdmFsdWVdKSA9PiBpc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSh2YWx1ZSkpO1xuICB9KTtcbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIGlmIChmcmFtZXMgPT09IEluZmluaXR5IHx8IGl0ZXJhdGlvbnMgPCBmcmFtZXMpIHtcbiAgICAgIHBhcmVudFJlZi5jdXJyZW50LnVwZGF0ZU1hdHJpeCgpO1xuICAgICAgcGFyZW50UmVmLmN1cnJlbnQudXBkYXRlTWF0cml4V29ybGQoKTtcbiAgICAgIHBhcmVudE1hdHJpeC5jb3B5KHBhcmVudFJlZi5jdXJyZW50Lm1hdHJpeFdvcmxkKS5pbnZlcnQoKTtcbiAgICAgIGNvdW50ID0gTWF0aC5taW4obGltaXQsIHJhbmdlICE9PSB1bmRlZmluZWQgPyByYW5nZSA6IGxpbWl0LCBpbnN0YW5jZXMubGVuZ3RoKTtcbiAgICAgIHBhcmVudFJlZi5jdXJyZW50LmNvdW50ID0gY291bnQ7XG4gICAgICBzZXRVcGRhdGVSYW5nZShwYXJlbnRSZWYuY3VycmVudC5pbnN0YW5jZU1hdHJpeCwge1xuICAgICAgICBvZmZzZXQ6IDAsXG4gICAgICAgIGNvdW50OiBjb3VudCAqIDE2XG4gICAgICB9KTtcbiAgICAgIHNldFVwZGF0ZVJhbmdlKHBhcmVudFJlZi5jdXJyZW50Lmluc3RhbmNlQ29sb3IsIHtcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBjb3VudDogY291bnQgKiAzXG4gICAgICB9KTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gaW5zdGFuY2VzW2ldLmN1cnJlbnQ7XG4gICAgICAgIC8vIE11bHRpcGx5IHRoZSBpbnZlcnNlIG9mIHRoZSBJbnN0YW5jZWRNZXNoIHdvcmxkIG1hdHJpeCBvciBlbHNlXG4gICAgICAgIC8vIEluc3RhbmNlcyB3aWxsIGJlIGRvdWJsZS10cmFuc2Zvcm1lZCBpZiA8SW5zdGFuY2VzPiBpc24ndCBhdCBpZGVudGl0eVxuICAgICAgICBpbnN0YW5jZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UodHJhbnNsYXRpb24sIHJvdGF0aW9uLCBzY2FsZSk7XG4gICAgICAgIGluc3RhbmNlTWF0cml4LmNvbXBvc2UodHJhbnNsYXRpb24sIHJvdGF0aW9uLCBzY2FsZSkucHJlbXVsdGlwbHkocGFyZW50TWF0cml4KTtcbiAgICAgICAgaW5zdGFuY2VNYXRyaXgudG9BcnJheShtYXRyaWNlcywgaSAqIDE2KTtcbiAgICAgICAgcGFyZW50UmVmLmN1cnJlbnQuaW5zdGFuY2VNYXRyaXgubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICBpbnN0YW5jZS5jb2xvci50b0FycmF5KGNvbG9ycywgaSAqIDMpO1xuICAgICAgICBwYXJlbnRSZWYuY3VycmVudC5pbnN0YW5jZUNvbG9yLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGl0ZXJhdGlvbnMrKztcbiAgICB9XG4gIH0pO1xuICBjb25zdCBhcGkgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7XG4gICAgZ2V0UGFyZW50OiAoKSA9PiBwYXJlbnRSZWYsXG4gICAgc3Vic2NyaWJlOiByZWYgPT4ge1xuICAgICAgc2V0SW5zdGFuY2VzKGluc3RhbmNlcyA9PiBbLi4uaW5zdGFuY2VzLCByZWZdKTtcbiAgICAgIHJldHVybiAoKSA9PiBzZXRJbnN0YW5jZXMoaW5zdGFuY2VzID0+IGluc3RhbmNlcy5maWx0ZXIoaXRlbSA9PiBpdGVtLmN1cnJlbnQgIT09IHJlZi5jdXJyZW50KSk7XG4gICAgfVxuICB9KSwgW10pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnN0YW5jZWRNZXNoXCIsIF9leHRlbmRzKHtcbiAgICB1c2VyRGF0YToge1xuICAgICAgaW5zdGFuY2VzLFxuICAgICAgbGltaXQsXG4gICAgICBmcmFtZXNcbiAgICB9LFxuICAgIG1hdHJpeEF1dG9VcGRhdGU6IGZhbHNlLFxuICAgIHJlZjogcGFyZW50UmVmLFxuICAgIGFyZ3M6IFtudWxsLCBudWxsLCAwXSxcbiAgICByYXljYXN0OiAoKSA9PiBudWxsXG4gIH0sIHByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGVcIiwge1xuICAgIGF0dGFjaDogXCJpbnN0YW5jZU1hdHJpeFwiLFxuICAgIGNvdW50OiBtYXRyaWNlcy5sZW5ndGggLyAxNixcbiAgICBhcnJheTogbWF0cmljZXMsXG4gICAgaXRlbVNpemU6IDE2LFxuICAgIHVzYWdlOiBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZVwiLCB7XG4gICAgYXR0YWNoOiBcImluc3RhbmNlQ29sb3JcIixcbiAgICBjb3VudDogY29sb3JzLmxlbmd0aCAvIDMsXG4gICAgYXJyYXk6IGNvbG9ycyxcbiAgICBpdGVtU2l6ZTogMyxcbiAgICB1c2FnZTogVEhSRUUuRHluYW1pY0RyYXdVc2FnZVxuICB9KSwgaXNGdW5jdGlvbkNoaWxkKGNoaWxkcmVuKSA/IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGxvY2FsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBhcGlcbiAgfSwgY2hpbGRyZW4oaW5zdGFuY2UpKSA6IGNvbnRleHQgPyAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChjb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFwaVxuICB9LCBjaGlsZHJlbikgOiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChnbG9iYWxDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGFwaVxuICB9LCBjaGlsZHJlbikpO1xufSk7XG5jb25zdCBNZXJnZWQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIE1lcmdlZCh7XG4gIG1lc2hlcyxcbiAgY2hpbGRyZW4sXG4gIC4uLnByb3BzXG59LCByZWYpIHtcbiAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkobWVzaGVzKTtcbiAgLy8gRmlsdGVyIG91dCBtZXNoZXMgZnJvbSBjb2xsZWN0aW9ucywgd2hpY2ggbWF5IGNvbnRhaW4gbm9uLW1lc2hlc1xuICBpZiAoIWlzQXJyYXkpIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG1lc2hlcykpIGlmICghbWVzaGVzW2tleV0uaXNNZXNoKSBkZWxldGUgbWVzaGVzW2tleV07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIHtcbiAgICByZWY6IHJlZlxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3Nlciwge1xuICAgIGNvbXBvbmVudHM6IChpc0FycmF5ID8gbWVzaGVzIDogT2JqZWN0LnZhbHVlcyhtZXNoZXMpKS5tYXAoKHtcbiAgICAgIGdlb21ldHJ5LFxuICAgICAgbWF0ZXJpYWxcbiAgICB9KSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnN0YW5jZXMsIF9leHRlbmRzKHtcbiAgICAgIGtleTogZ2VvbWV0cnkudXVpZCxcbiAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgIG1hdGVyaWFsOiBtYXRlcmlhbFxuICAgIH0sIHByb3BzKSkpXG4gIH0sIGFyZ3MgPT4gaXNBcnJheSA/IGNoaWxkcmVuKC4uLmFyZ3MpIDogY2hpbGRyZW4oT2JqZWN0LmtleXMobWVzaGVzKS5maWx0ZXIoa2V5ID0+IG1lc2hlc1trZXldLmlzTWVzaCkucmVkdWNlKChhY2MsIGtleSwgaSkgPT4gKHtcbiAgICAuLi5hY2MsXG4gICAgW2tleV06IGFyZ3NbaV1cbiAgfSksIHt9KSkpKTtcbn0pO1xuXG4vKiogSWRlYSBhbmQgaW1wbGVtZW50YXRpb24gZm9yIGdsb2JhbCBpbnN0YW5jZXMgYW5kIGluc3RhbmNlZCBhdHRyaWJ1dGVzIGJ5XG4vKiAgTWF0aWFzIEdvbnphbGV6IEZlcm5hbmRleiBodHRwczovL3guY29tL21hdGlOb3RGb3VuZFxuLyogIGFuZCBQYXVsIEhlbnNjaGVsIGh0dHBzOi8veC5jb20vMHhjYTBhXG4qL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VzKCkge1xuICBjb25zdCBjb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4gIHJldHVybiBbLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnN0YW5jZXMsIF9leHRlbmRzKHtcbiAgICByZWY6IGZyZWYsXG4gICAgY29udGV4dDogY29udGV4dFxuICB9LCBwcm9wcykpKSwgLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHByb3BzLCBmcmVmKSA9PiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChJbnN0YW5jZSwgX2V4dGVuZHMoe1xuICAgIHJlZjogZnJlZixcbiAgICBjb250ZXh0OiBjb250ZXh0XG4gIH0sIHByb3BzKSkpXTtcbn1cbmNvbnN0IEluc3RhbmNlZEF0dHJpYnV0ZSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIG5hbWUsXG4gIGRlZmF1bHRWYWx1ZSxcbiAgbm9ybWFsaXplZCxcbiAgdXNhZ2UgPSBUSFJFRS5EeW5hbWljRHJhd1VzYWdlXG59LCBmcmVmKSA9PiB7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShmcmVmLCAoKSA9PiByZWYuY3VycmVudCwgW10pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IHJlZi5jdXJyZW50Ll9fcjNmLnBhcmVudDtcbiAgICBwYXJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlc1tuYW1lXSA9IHJlZi5jdXJyZW50O1xuICAgIGNvbnN0IHZhbHVlID0gQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpID8gZGVmYXVsdFZhbHVlIDogW2RlZmF1bHRWYWx1ZV07XG4gICAgY29uc3QgYXJyYXkgPSBBcnJheS5mcm9tKHtcbiAgICAgIGxlbmd0aDogcGFyZW50LnVzZXJEYXRhLmxpbWl0XG4gICAgfSwgKCkgPT4gdmFsdWUpLmZsYXQoKTtcbiAgICByZWYuY3VycmVudC5hcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoYXJyYXkpO1xuICAgIHJlZi5jdXJyZW50Lml0ZW1TaXplID0gdmFsdWUubGVuZ3RoO1xuICAgIHJlZi5jdXJyZW50LmNvdW50ID0gYXJyYXkubGVuZ3RoIC8gcmVmLmN1cnJlbnQuaXRlbVNpemU7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGRlbGV0ZSBwYXJlbnQuZ2VvbWV0cnkuYXR0cmlidXRlc1tuYW1lXTtcbiAgICB9O1xuICB9LCBbbmFtZV0pO1xuICBsZXQgaXRlcmF0aW9ucyA9IDA7XG4gIHVzZUZyYW1lKCgpID0+IHtcbiAgICBjb25zdCBwYXJlbnQgPSByZWYuY3VycmVudC5fX3IzZi5wYXJlbnQ7XG4gICAgaWYgKHBhcmVudC51c2VyRGF0YS5mcmFtZXMgPT09IEluZmluaXR5IHx8IGl0ZXJhdGlvbnMgPCBwYXJlbnQudXNlckRhdGEuZnJhbWVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC51c2VyRGF0YS5pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBwYXJlbnQudXNlckRhdGEuaW5zdGFuY2VzW2ldLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5zdGFuY2VbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmVmLmN1cnJlbnQuc2V0KEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiB0eXBlb2YgdmFsdWUudG9BcnJheSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvQXJyYXkoKSA6IFt2YWx1ZV0sIGkgKiByZWYuY3VycmVudC5pdGVtU2l6ZSk7XG4gICAgICAgICAgcmVmLmN1cnJlbnQubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpdGVyYXRpb25zKys7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiaW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlXCIsIHtcbiAgICByZWY6IHJlZixcbiAgICB1c2FnZTogdXNhZ2UsXG4gICAgbm9ybWFsaXplZDogbm9ybWFsaXplZFxuICB9KTtcbn0pO1xuXG5leHBvcnQgeyBJbnN0YW5jZSwgSW5zdGFuY2VkQXR0cmlidXRlLCBJbnN0YW5jZXMsIE1lcmdlZCwgUG9zaXRpb25NZXNoLCBjcmVhdGVJbnN0YW5jZXMgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/Instances.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/core/Text.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Text.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: function() { return /* binding */ Text; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(app-pages-browser)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var troika_three_text__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! troika-three-text */ \"(app-pages-browser)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! suspend-react */ \"(app-pages-browser)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\nconst Text = /* @__PURE__ */react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({\n  sdfGlyphSize = 64,\n  anchorX = 'center',\n  anchorY = 'middle',\n  font,\n  fontSize = 1,\n  children,\n  characters,\n  onSync,\n  ...props\n}, ref) => {\n  const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.D)(({\n    invalidate\n  }) => invalidate);\n  const [troikaMesh] = react__WEBPACK_IMPORTED_MODULE_1__.useState(() => new troika_three_text__WEBPACK_IMPORTED_MODULE_3__.Text());\n  const [nodes, text] = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(() => {\n    const n = [];\n    let t = '';\n    react__WEBPACK_IMPORTED_MODULE_1__.Children.forEach(children, child => {\n      if (typeof child === 'string' || typeof child === 'number') {\n        t += child;\n      } else {\n        n.push(child);\n      }\n    });\n    return [n, t];\n  }, [children]);\n  (0,suspend_react__WEBPACK_IMPORTED_MODULE_4__.suspend)(() => new Promise(res => (0,troika_three_text__WEBPACK_IMPORTED_MODULE_3__.preloadFont)({\n    font,\n    characters\n  }, res)), ['troika-text', font, characters]);\n  react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(() => void troikaMesh.sync(() => {\n    invalidate();\n    if (onSync) onSync(troikaMesh);\n  }));\n  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {\n    return () => troikaMesh.dispose();\n  }, [troikaMesh]);\n  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    object: troikaMesh,\n    ref: ref,\n    font: font,\n    text: text,\n    anchorX: anchorX,\n    anchorY: anchorY,\n    fontSize: fontSize,\n    sdfGlyphSize: sdfGlyphSize\n  }, props), nodes);\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL1RleHQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNpQztBQUNsQjtBQUNOOztBQUV4Qyw0QkFBNEIsNkNBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxxQkFBcUIscURBQVE7QUFDN0I7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLDJDQUFjLFdBQVcsbURBQU07QUFDdEQsd0JBQXdCLDBDQUFhO0FBQ3JDO0FBQ0E7QUFDQSxJQUFJLDJDQUFjO0FBQ2xCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFLHNEQUFPLDBCQUEwQiw4REFBVztBQUM5QztBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsa0RBQXFCO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRSw0Q0FBZTtBQUNqQjtBQUNBLEdBQUc7QUFDSCxzQkFBc0IsZ0RBQW1CLGNBQWMsOEVBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL1RleHQuanM/Zjg4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBUZXh0IGFzIFRleHQkMSwgcHJlbG9hZEZvbnQgfSBmcm9tICd0cm9pa2EtdGhyZWUtdGV4dCc7XG5pbXBvcnQgeyB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5pbXBvcnQgeyBzdXNwZW5kIH0gZnJvbSAnc3VzcGVuZC1yZWFjdCc7XG5cbmNvbnN0IFRleHQgPSAvKiBAX19QVVJFX18gKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIHNkZkdseXBoU2l6ZSA9IDY0LFxuICBhbmNob3JYID0gJ2NlbnRlcicsXG4gIGFuY2hvclkgPSAnbWlkZGxlJyxcbiAgZm9udCxcbiAgZm9udFNpemUgPSAxLFxuICBjaGlsZHJlbixcbiAgY2hhcmFjdGVycyxcbiAgb25TeW5jLFxuICAuLi5wcm9wc1xufSwgcmVmKSA9PiB7XG4gIGNvbnN0IGludmFsaWRhdGUgPSB1c2VUaHJlZSgoe1xuICAgIGludmFsaWRhdGVcbiAgfSkgPT4gaW52YWxpZGF0ZSk7XG4gIGNvbnN0IFt0cm9pa2FNZXNoXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IG5ldyBUZXh0JDEoKSk7XG4gIGNvbnN0IFtub2RlcywgdGV4dF0gPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBuID0gW107XG4gICAgbGV0IHQgPSAnJztcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBjaGlsZCA9PiB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHQgKz0gY2hpbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuLnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBbbiwgdF07XG4gIH0sIFtjaGlsZHJlbl0pO1xuICBzdXNwZW5kKCgpID0+IG5ldyBQcm9taXNlKHJlcyA9PiBwcmVsb2FkRm9udCh7XG4gICAgZm9udCxcbiAgICBjaGFyYWN0ZXJzXG4gIH0sIHJlcykpLCBbJ3Ryb2lrYS10ZXh0JywgZm9udCwgY2hhcmFjdGVyc10pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCB0cm9pa2FNZXNoLnN5bmMoKCkgPT4ge1xuICAgIGludmFsaWRhdGUoKTtcbiAgICBpZiAob25TeW5jKSBvblN5bmModHJvaWthTWVzaCk7XG4gIH0pKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gdHJvaWthTWVzaC5kaXNwb3NlKCk7XG4gIH0sIFt0cm9pa2FNZXNoXSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInByaW1pdGl2ZVwiLCBfZXh0ZW5kcyh7XG4gICAgb2JqZWN0OiB0cm9pa2FNZXNoLFxuICAgIHJlZjogcmVmLFxuICAgIGZvbnQ6IGZvbnQsXG4gICAgdGV4dDogdGV4dCxcbiAgICBhbmNob3JYOiBhbmNob3JYLFxuICAgIGFuY2hvclk6IGFuY2hvclksXG4gICAgZm9udFNpemU6IGZvbnRTaXplLFxuICAgIHNkZkdseXBoU2l6ZTogc2RmR2x5cGhTaXplXG4gIH0sIHByb3BzKSwgbm9kZXMpO1xufSk7XG5cbmV4cG9ydCB7IFRleHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/core/Text.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-three/drei/helpers/deprecated.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/helpers/deprecated.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LinearEncoding: function() { return /* binding */ LinearEncoding; },\n/* harmony export */   sRGBEncoding: function() { return /* binding */ sRGBEncoding; },\n/* harmony export */   setUpdateRange: function() { return /* binding */ setUpdateRange; }\n/* harmony export */ });\n/**\n * Sets `BufferAttribute.updateRange` since r159.\n */\nconst setUpdateRange = (attribute, updateRange) => {\n  if ('updateRanges' in attribute) {\n    // r159\n    // @ts-ignore\n    attribute.updateRanges[0] = updateRange;\n  } else {\n    attribute.updateRange = updateRange;\n  }\n};\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\n\n/**\n * TextureEncoding was deprecated in r152, and removed in r162.\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9oZWxwZXJzL2RlcHJlY2F0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFd0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2hlbHBlcnMvZGVwcmVjYXRlZC5qcz84NjRjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogU2V0cyBgQnVmZmVyQXR0cmlidXRlLnVwZGF0ZVJhbmdlYCBzaW5jZSByMTU5LlxuICovXG5jb25zdCBzZXRVcGRhdGVSYW5nZSA9IChhdHRyaWJ1dGUsIHVwZGF0ZVJhbmdlKSA9PiB7XG4gIGlmICgndXBkYXRlUmFuZ2VzJyBpbiBhdHRyaWJ1dGUpIHtcbiAgICAvLyByMTU5XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGF0dHJpYnV0ZS51cGRhdGVSYW5nZXNbMF0gPSB1cGRhdGVSYW5nZTtcbiAgfSBlbHNlIHtcbiAgICBhdHRyaWJ1dGUudXBkYXRlUmFuZ2UgPSB1cGRhdGVSYW5nZTtcbiAgfVxufTtcbmNvbnN0IExpbmVhckVuY29kaW5nID0gMzAwMDtcbmNvbnN0IHNSR0JFbmNvZGluZyA9IDMwMDE7XG5cbi8qKlxuICogVGV4dHVyZUVuY29kaW5nIHdhcyBkZXByZWNhdGVkIGluIHIxNTIsIGFuZCByZW1vdmVkIGluIHIxNjIuXG4gKi9cblxuZXhwb3J0IHsgTGluZWFyRW5jb2RpbmcsIHNSR0JFbmNvZGluZywgc2V0VXBkYXRlUmFuZ2UgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-three/drei/helpers/deprecated.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js":
/*!*****************************************************************!*\
  !*** ./node_modules/next/dist/build/polyfills/object-assign.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar assign = Object.assign.bind(Object);\nmodule.exports = assign;\nmodule.exports[\"default\"] = module.exports;\n\n//# sourceMappingURL=object-assign.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvcG9seWZpbGxzL29iamVjdC1hc3NpZ24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0EseUJBQXNCOztBQUV0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9vYmplY3QtYXNzaWduLmpzP2MzMDUiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbi5iaW5kKE9iamVjdCk7XG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbjtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LWFzc2lnbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/map/UniversityNodes.tsx":
/*!************************************************!*\
  !*** ./src/components/map/UniversityNodes.tsx ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ UniversityNodes; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Instances.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Billboard.js\");\n/* harmony import */ var _react_three_drei__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @react-three/drei */ \"(app-pages-browser)/./node_modules/@react-three/drei/core/Text.js\");\n/* harmony import */ var _react_spring_three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-spring/three */ \"(app-pages-browser)/./node_modules/@react-spring/three/dist/react-spring_three.modern.mjs\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst UNIVERSITIES = [\n    {\n        name: \"Bauhaus-Universit\\xe4t Weimar\",\n        location: [\n            11.329,\n            50.979\n        ],\n        type: \"University\",\n        description: \"Historic institution known for art, design, and architecture, following the Bauhaus tradition.\"\n    },\n    {\n        name: \"Burg Giebichenstein Kunsthochschule Halle\",\n        location: [\n            11.963,\n            51.489\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Renowned art and design school with a focus on practical and theoretical artistic education.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr Bildende K\\xfcnste Braunschweig\",\n        location: [\n            10.534,\n            52.273\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Specialized art academy focusing on fine arts, visual communication, and industrial design.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr Bildende K\\xfcnste Dresden\",\n        location: [\n            13.736,\n            51.052\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Leading institution for contemporary art education with strong emphasis on experimental approaches.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr Bildende K\\xfcnste Hamburg\",\n        location: [\n            9.933,\n            53.571\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Progressive art school known for its interdisciplinary approach and international network.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr Bildende K\\xfcnste Saar\",\n        location: [\n            7.024,\n            49.234\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Notable institution specializing in fine arts and artistic research in the Saarland region.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr Gestaltung Offenbach am Main\",\n        location: [\n            8.764,\n            50.107\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Innovative design school emphasizing the intersection of art, media, and technology.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr Gestaltung Schw\\xe4bisch Gm\\xfcnd\",\n        location: [\n            9.798,\n            48.801\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Specialized in interaction design, product design, and strategic design thinking.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr Grafik und Buchkunst Leipzig\",\n        location: [\n            12.368,\n            51.339\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Historic institution renowned for book art, graphic design, and photography.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr K\\xfcnste Bremen\",\n        location: [\n            8.826,\n            53.075\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Multidisciplinary arts university combining music, fine arts, and digital media.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr K\\xfcnste im Sozialen Ottersberg\",\n        location: [\n            9.153,\n            53.130\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Unique institution focusing on art therapy and social artistic practices.\"\n    },\n    {\n        name: \"Kunstakademie D\\xfcsseldorf\",\n        location: [\n            6.777,\n            51.233\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Prestigious academy known for producing influential contemporary artists.\"\n    },\n    {\n        name: \"Kunstakademie M\\xfcnster\",\n        location: [\n            7.626,\n            51.962\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Forward-thinking institution specializing in fine arts and artistic research.\"\n    },\n    {\n        name: \"Kunsthochschule Berlin-Wei\\xdfensee\",\n        location: [\n            13.463,\n            52.543\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Berlin-based art school known for its innovative approach to design and fine arts.\"\n    },\n    {\n        name: \"Kunsthochschule f\\xfcr Medien K\\xf6ln\",\n        location: [\n            6.959,\n            50.935\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Leading media arts school focusing on audiovisual arts and digital culture.\"\n    },\n    {\n        name: \"Kunsthochschule Kassel\",\n        location: [\n            9.492,\n            51.318\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Distinguished institution known for its connection to documenta art exhibition.\"\n    },\n    {\n        name: \"Kunsthochschule Mainz\",\n        location: [\n            8.274,\n            50.001\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Progressive art school emphasizing contemporary artistic practices and theory.\"\n    },\n    {\n        name: \"Muthesius Kunsthochschule Kiel\",\n        location: [\n            10.122,\n            54.323\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Specialized in fine arts, spatial strategies, and design innovation.\"\n    },\n    {\n        name: \"Staatliche Akademie der Bildenden K\\xfcnste Karlsruhe\",\n        location: [\n            8.400,\n            49.014\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Historic academy with strong traditions in painting and art theory.\"\n    },\n    {\n        name: \"Staatliche Akademie der Bildenden K\\xfcnste Stuttgart\",\n        location: [\n            9.169,\n            48.789\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Comprehensive art academy offering programs from fine arts to conservation.\"\n    },\n    {\n        name: \"Staatliche Hochschule f\\xfcr Bildende K\\xfcnste – St\\xe4delschule Frankfurt\",\n        location: [\n            8.684,\n            50.115\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Elite institution known for its influential contemporary art program.\"\n    },\n    {\n        name: \"Universit\\xe4t der K\\xfcnste Berlin\",\n        location: [\n            13.324,\n            52.507\n        ],\n        type: \"University\",\n        description: \"One of Europe's largest arts universities, covering all artistic disciplines.\"\n    },\n    {\n        name: \"Bard College Berlin\",\n        location: [\n            13.465,\n            52.557\n        ],\n        type: \"University\",\n        description: \"Liberal arts university offering interdisciplinary programs with international focus.\"\n    },\n    {\n        name: \"Folkwang Universit\\xe4t der K\\xfcnste\",\n        location: [\n            7.013,\n            51.443\n        ],\n        type: \"University\",\n        description: \"Comprehensive arts university known for music, theater, dance, and design.\"\n    },\n    {\n        name: \"Alanus University of Arts and Social Sciences\",\n        location: [\n            7.118,\n            50.737\n        ],\n        type: \"University\",\n        description: \"Private university combining artistic education with social sciences and pedagogy.\"\n    },\n    {\n        name: \"Staatliche Akademie der Bildenden K\\xfcnste M\\xfcnchen\",\n        location: [\n            11.576,\n            48.149\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Prestigious Munich-based academy with rich artistic heritage.\"\n    },\n    {\n        name: \"Akademie der Bildenden K\\xfcnste N\\xfcrnberg\",\n        location: [\n            11.077,\n            49.452\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Historic institution focusing on fine arts and artistic research.\"\n    },\n    {\n        name: \"Technische Universit\\xe4t Berlin\",\n        location: [\n            13.326,\n            52.512\n        ],\n        type: \"University\",\n        description: \"Leading technical university renowned for engineering and technology research.\"\n    },\n    {\n        name: \"Hochschule f\\xfcr Bildende K\\xfcnste Essen\",\n        location: [\n            7.014,\n            51.451\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Notable institution for contemporary art and media practices.\"\n    },\n    {\n        name: \"Staatliche Hochschule f\\xfcr Gestaltung Karlsruhe\",\n        location: [\n            8.400,\n            49.009\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Innovative design school emphasizing theory and practice in media arts.\"\n    },\n    {\n        name: \"Academy of Visual Arts Frankfurt\",\n        location: [\n            8.683,\n            50.116\n        ],\n        type: \"Kunsthochschule\",\n        description: \"Contemporary art institution known for its experimental approach.\"\n    },\n    {\n        name: \"Fachhochschule Potsdam\",\n        location: [\n            13.064,\n            52.413\n        ],\n        type: \"University\",\n        description: \"Applied sciences university with strong design and architecture programs.\"\n    },\n    {\n        name: \"Hochschule Darmstadt\",\n        location: [\n            8.651,\n            49.867\n        ],\n        type: \"University\",\n        description: \"University of applied sciences known for technology and media programs.\"\n    },\n    {\n        name: \"Hochschule Rhein-Waal\",\n        location: [\n            6.542,\n            51.831\n        ],\n        type: \"University\",\n        description: \"International university focusing on technology and natural sciences.\"\n    },\n    {\n        name: \"Technische Universit\\xe4t Chemnitz\",\n        location: [\n            12.927,\n            50.841\n        ],\n        type: \"University\",\n        description: \"Technical university specializing in engineering and natural sciences.\"\n    },\n    {\n        name: \"Hochschule Anhalt\",\n        location: [\n            12.166,\n            51.753\n        ],\n        type: \"University\",\n        description: \"University of applied sciences with focus on design and engineering.\"\n    },\n    {\n        name: \"Universit\\xe4t Trier\",\n        location: [\n            6.687,\n            49.746\n        ],\n        type: \"University\",\n        description: \"Historic university known for humanities and social sciences.\"\n    },\n    {\n        name: \"Universit\\xe4t Siegen\",\n        location: [\n            8.023,\n            50.911\n        ],\n        type: \"University\",\n        description: \"Research university with strength in engineering and social sciences.\"\n    },\n    {\n        name: \"Technische Hochschule Ingolstadt\",\n        location: [\n            11.425,\n            48.766\n        ],\n        type: \"University\",\n        description: \"Technical university specializing in automotive and technology innovation.\"\n    },\n    {\n        name: \"Hochschule Fulda\",\n        location: [\n            9.675,\n            50.565\n        ],\n        type: \"University\",\n        description: \"University of applied sciences focusing on social and health sciences.\"\n    },\n    {\n        name: \"Universit\\xe4t Passau\",\n        location: [\n            13.452,\n            48.567\n        ],\n        type: \"University\",\n        description: \"Known for international studies and computer science programs.\"\n    }\n];\nfunction latLngToVector3(lat, lng, radius) {\n    // Map German coordinates to global coordinates\n    const globalLat = (lat - 47) / (55 - 47) * 180 - 90; // Map German latitudes (47-55) to global (-90 to 90)\n    const globalLng = (lng - 6) / (15 - 6) * 360 - 180; // Map German longitudes (6-15) to global (-180 to 180)\n    // Add randomization for better distribution\n    const randomLat = globalLat + (Math.random() - 0.5) * 120; // Spread across ±60 degrees from mapped position\n    const randomLng = globalLng + (Math.random() - 0.5) * 240; // Spread across ±120 degrees from mapped position\n    // Convert to spherical coordinates\n    const phi = (90 - randomLat) * (Math.PI / 180);\n    const theta = (randomLng + 180) * (Math.PI / 180);\n    // Convert to Cartesian coordinates\n    const x = -(radius * Math.sin(phi) * Math.cos(theta));\n    const y = radius * Math.cos(phi);\n    const z = radius * Math.sin(phi) * Math.sin(theta);\n    return new three__WEBPACK_IMPORTED_MODULE_3__.Vector3(x, y, z);\n}\nfunction UniversityNodes(param) {\n    let { radius } = param;\n    _s();\n    const groupRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [selectedUniversity, setSelectedUniversity] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [hoverUniversity, setHoverUniversity] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [mounted, setMounted] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // Create materials for different university types\n    const materials = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>({\n            University: new three__WEBPACK_IMPORTED_MODULE_3__.MeshStandardMaterial({\n                color: \"#00ffd5\",\n                emissive: \"#00ffd5\",\n                emissiveIntensity: 2,\n                metalness: 0.5,\n                roughness: 0.2\n            }),\n            Kunsthochschule: new three__WEBPACK_IMPORTED_MODULE_3__.MeshStandardMaterial({\n                color: \"#ff00ff\",\n                emissive: \"#ff00ff\",\n                emissiveIntensity: 2,\n                metalness: 0.5,\n                roughness: 0.2\n            }),\n            Hochschule: new three__WEBPACK_IMPORTED_MODULE_3__.MeshStandardMaterial({\n                color: \"#ffff00\",\n                emissive: \"#ffff00\",\n                emissiveIntensity: 2,\n                metalness: 0.5,\n                roughness: 0.2\n            }),\n            Akademie: new three__WEBPACK_IMPORTED_MODULE_3__.MeshStandardMaterial({\n                color: \"#00ff00\",\n                emissive: \"#00ff00\",\n                emissiveIntensity: 2,\n                metalness: 0.5,\n                roughness: 0.2\n            })\n        }), []);\n    // Create instance data\n    const { instanceData, nodePositions } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>{\n        const instanceData = UNIVERSITIES.map((university)=>{\n            const position = latLngToVector3(university.location[1], university.location[0], radius);\n            return {\n                position,\n                university\n            };\n        });\n        const nodePositions = new Map(instanceData.map((param)=>{\n            let { university, position } = param;\n            return [\n                university.name,\n                position\n            ];\n        }));\n        return {\n            instanceData,\n            nodePositions\n        };\n    }, [\n        radius\n    ]);\n    // Animation for info box\n    const infoBoxSpring = (0,_react_spring_three__WEBPACK_IMPORTED_MODULE_2__.useSpring)({\n        scale: selectedUniversity ? 1 : 0,\n        opacity: selectedUniversity ? 1 : 0,\n        config: {\n            tension: 280,\n            friction: 60\n        }\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        setMounted(true);\n    }, []);\n    if (!mounted) return null;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"group\", {\n        ref: groupRef,\n        children: [\n            Object.entries(materials).map((param)=>/*#__PURE__*/ {\n                let [type, material] = param;\n                return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_4__.Instances, {\n                    limit: UNIVERSITIES.length,\n                    range: UNIVERSITIES.length,\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"sphereGeometry\", {\n                            args: [\n                                0.15,\n                                16,\n                                16\n                            ]\n                        }, void 0, false, {\n                            fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                            lineNumber: 369,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"primitive\", {\n                            object: material,\n                            attach: \"material\"\n                        }, void 0, false, {\n                            fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                            lineNumber: 370,\n                            columnNumber: 11\n                        }, this),\n                        instanceData.filter((param)=>{\n                            let { university } = param;\n                            return university.type === type;\n                        }).map((param)=>/*#__PURE__*/ {\n                            let { position, university } = param;\n                            return (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_4__.Instance, {\n                                position: position,\n                                onClick: ()=>setSelectedUniversity({\n                                        name: university.name,\n                                        position: position.clone().multiplyScalar(1.1),\n                                        type: university.type,\n                                        description: university.description\n                                    }),\n                                onPointerOver: ()=>setHoverUniversity(university.name),\n                                onPointerOut: ()=>setHoverUniversity(null)\n                            }, university.name, false, {\n                                fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                                lineNumber: 375,\n                                columnNumber: 15\n                            }, this);\n                        })\n                    ]\n                }, type, true, {\n                    fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                    lineNumber: 368,\n                    columnNumber: 9\n                }, this);\n            }),\n            selectedUniversity && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_spring_three__WEBPACK_IMPORTED_MODULE_2__.animated.group, {\n                position: selectedUniversity.position,\n                scale: infoBoxSpring.scale,\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_5__.Billboard, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"mesh\", {\n                            position: [\n                                0,\n                                0,\n                                -0.05\n                            ],\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"boxGeometry\", {\n                                    args: [\n                                        2.2,\n                                        1.2,\n                                        0.1\n                                    ]\n                                }, void 0, false, {\n                                    fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                                    lineNumber: 399,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"shaderMaterial\", {\n                                    uniforms: {\n                                        color: {\n                                            value: new three__WEBPACK_IMPORTED_MODULE_3__.Color(\"#000000\")\n                                        },\n                                        opacity: {\n                                            value: 0.8\n                                        },\n                                        radius: {\n                                            value: 0.1\n                                        }\n                                    },\n                                    vertexShader: \"\\n                  varying vec2 vUv;\\n                  varying vec3 vPosition;\\n                  void main() {\\n                    vUv = uv;\\n                    vPosition = position;\\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\\n                  }\\n                \",\n                                    fragmentShader: \"\\n                  uniform vec3 color;\\n                  uniform float opacity;\\n                  uniform float radius;\\n                  varying vec2 vUv;\\n                  varying vec3 vPosition;\\n\\n                  float roundedBoxSDF(vec2 centerPosition, vec2 size, float radius) {\\n                    return length(max(abs(centerPosition) - size + radius, 0.0)) - radius;\\n                  }\\n\\n                  void main() {\\n                    vec2 centerPosition = vUv * 2.0 - 1.0;\\n                    float distance = roundedBoxSDF(centerPosition, vec2(1.0, 0.5), radius);\\n                    float smoothedAlpha = 1.0 - smoothstep(-0.01, 0.01, distance);\\n                    gl_FragColor = vec4(color, smoothedAlpha * opacity);\\n                  }\\n                \",\n                                    transparent: true,\n                                    depthWrite: false\n                                }, void 0, false, {\n                                    fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                                    lineNumber: 400,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                            lineNumber: 398,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_6__.Text, {\n                            position: [\n                                0,\n                                0.3,\n                                0\n                            ],\n                            fontSize: 0.12,\n                            color: \"#ffffff\",\n                            anchorX: \"center\",\n                            anchorY: \"middle\",\n                            outlineWidth: 0.004,\n                            outlineColor: \"#000000\",\n                            outlineOpacity: 0.8,\n                            maxWidth: 2,\n                            children: selectedUniversity.name\n                        }, void 0, false, {\n                            fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                            lineNumber: 438,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_6__.Text, {\n                            position: [\n                                0,\n                                0.1,\n                                0\n                            ],\n                            fontSize: 0.09,\n                            color: \"#ffffff\",\n                            anchorX: \"center\",\n                            anchorY: \"middle\",\n                            outlineWidth: 0.003,\n                            outlineColor: \"#000000\",\n                            outlineOpacity: 0.8,\n                            children: selectedUniversity.type\n                        }, void 0, false, {\n                            fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                            lineNumber: 452,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_react_three_drei__WEBPACK_IMPORTED_MODULE_6__.Text, {\n                            position: [\n                                0,\n                                -0.2,\n                                0\n                            ],\n                            fontSize: 0.07,\n                            color: \"#ffffff\",\n                            anchorX: \"center\",\n                            anchorY: \"middle\",\n                            outlineWidth: 0.002,\n                            outlineColor: \"#000000\",\n                            outlineOpacity: 0.8,\n                            maxWidth: 1.8,\n                            children: selectedUniversity.description\n                        }, void 0, false, {\n                            fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                            lineNumber: 465,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                    lineNumber: 397,\n                    columnNumber: 11\n                }, this)\n            }, void 0, false, {\n                fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n                lineNumber: 393,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/home/parsa/map-of-german-students/src/components/map/UniversityNodes.tsx\",\n        lineNumber: 366,\n        columnNumber: 5\n    }, this);\n}\n_s(UniversityNodes, \"upUCiEtr/1SxOD4ATyf7n031cB4=\", false, function() {\n    return [\n        _react_spring_three__WEBPACK_IMPORTED_MODULE_2__.useSpring\n    ];\n});\n_c = UniversityNodes;\nvar _c;\n$RefreshReg$(_c, \"UniversityNodes\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL21hcC9Vbml2ZXJzaXR5Tm9kZXMudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBRTZEO0FBQzlCO0FBQzBDO0FBRWY7QUFTMUQsTUFBTVcsZUFBNkI7SUFDL0I7UUFDSUMsTUFBTTtRQUNOQyxVQUFVO1lBQUM7WUFBUTtTQUFPO1FBQzFCQyxNQUFNO1FBQ05DLGFBQWE7SUFDakI7SUFDQTtRQUNJSCxNQUFNO1FBQ05DLFVBQVU7WUFBQztZQUFRO1NBQU87UUFDMUJDLE1BQU07UUFDTkMsYUFBYTtJQUNqQjtJQUNBO1FBQ0lILE1BQU07UUFDTkMsVUFBVTtZQUFDO1lBQVE7U0FBTztRQUMxQkMsTUFBTTtRQUNOQyxhQUFhO0lBQ2pCO0lBQ0E7UUFDSUgsTUFBTTtRQUNOQyxVQUFVO1lBQUM7WUFBUTtTQUFPO1FBQzFCQyxNQUFNO1FBQ05DLGFBQWE7SUFDakI7SUFDQTtRQUNJSCxNQUFNO1FBQ05DLFVBQVU7WUFBQztZQUFPO1NBQU87UUFDekJDLE1BQU07UUFDTkMsYUFBYTtJQUNqQjtJQUNBO1FBQ0lILE1BQU07UUFDTkMsVUFBVTtZQUFDO1lBQU87U0FBTztRQUN6QkMsTUFBTTtRQUNOQyxhQUFhO0lBQ2pCO0lBQ0E7UUFDSUgsTUFBTTtRQUNOQyxVQUFVO1lBQUM7WUFBTztTQUFPO1FBQ3pCQyxNQUFNO1FBQ05DLGFBQWE7SUFDakI7SUFDQTtRQUNJSCxNQUFNO1FBQ05DLFVBQVU7WUFBQztZQUFPO1NBQU87UUFDekJDLE1BQU07UUFDTkMsYUFBYTtJQUNqQjtJQUNBO1FBQ0lILE1BQU07UUFDTkMsVUFBVTtZQUFDO1lBQVE7U0FBTztRQUMxQkMsTUFBTTtRQUNOQyxhQUFhO0lBQ2pCO0lBQ0E7UUFDSUgsTUFBTTtRQUNOQyxVQUFVO1lBQUM7WUFBTztTQUFPO1FBQ3pCQyxNQUFNO1FBQ05DLGFBQWE7SUFDakI7SUFDQTtRQUNJSCxNQUFNO1FBQ05DLFVBQVU7WUFBQztZQUFPO1NB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LDhEQUFDekYsbURBQUlBOzRCQUNIcUQsVUFBVTtnQ0FBQztnQ0FBRztnQ0FBSzs2QkFBRTs0QkFDckJxQyxVQUFVOzRCQUNWakQsT0FBTTs0QkFDTmtELFNBQVE7NEJBQ1JDLFNBQVE7NEJBQ1JDLGNBQWM7NEJBQ2RDLGNBQWE7NEJBQ2JDLGdCQUFnQjs0QkFDaEJDLFVBQVU7c0NBRVRoRSxtQkFBbUJ6QixJQUFJOzs7Ozs7c0NBRzFCLDhEQUFDUCxtREFBSUE7NEJBQ0hxRCxVQUFVO2dDQUFDO2dDQUFHO2dDQUFLOzZCQUFFOzRCQUNyQnFDLFVBQVU7NEJBQ1ZqRCxPQUFNOzRCQUNOa0QsU0FBUTs0QkFDUkMsU0FBUTs0QkFDUkMsY0FBYzs0QkFDZEMsY0FBYTs0QkFDYkMsZ0JBQWdCO3NDQUVmL0QsbUJBQW1CdkIsSUFBSTs7Ozs7O3NDQUcxQiw4REFBQ1QsbURBQUlBOzRCQUNIcUQsVUFBVTtnQ0FBQztnQ0FBRyxDQUFDO2dDQUFLOzZCQUFFOzRCQUN0QnFDLFVBQVU7NEJBQ1ZqRCxPQUFNOzRCQUNOa0QsU0FBUTs0QkFDUkMsU0FBUTs0QkFDUkMsY0FBYzs0QkFDZEMsY0FBYTs0QkFDYkMsZ0JBQWdCOzRCQUNoQkMsVUFBVTtzQ0FFVGhFLG1CQUFtQnRCLFdBQVc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTzdDO0dBMUx3Qm9COztRQXdEQXpCLDBEQUFTQTs7O0tBeERUeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvbWFwL1VuaXZlcnNpdHlOb2Rlcy50c3g/ODk4OSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCB7IHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFRleHQsIEJpbGxib2FyZCwgSW5zdGFuY2UsIEluc3RhbmNlcyB9IGZyb20gJ0ByZWFjdC10aHJlZS9kcmVpJztcbmltcG9ydCB7IHVzZUZyYW1lIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IGFuaW1hdGVkLCB1c2VTcHJpbmcgfSBmcm9tICdAcmVhY3Qtc3ByaW5nL3RocmVlJztcblxuaW50ZXJmYWNlIFVuaXZlcnNpdHkge1xuICBuYW1lOiBzdHJpbmc7XG4gIGxvY2F0aW9uOiBbbnVtYmVyLCBudW1iZXJdOyAvLyBbbG9uZ2l0dWRlLCBsYXRpdHVkZV1cbiAgdHlwZTogJ1VuaXZlcnNpdHknIHwgJ0hvY2hzY2h1bGUnIHwgJ0t1bnN0aG9jaHNjaHVsZScgfCAnQWthZGVtaWUnO1xuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBVTklWRVJTSVRJRVM6IFVuaXZlcnNpdHlbXSA9IFtcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiQmF1aGF1cy1Vbml2ZXJzaXTDpHQgV2VpbWFyXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbMTEuMzI5LCA1MC45NzldLFxuICAgICAgICB0eXBlOiBcIlVuaXZlcnNpdHlcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSGlzdG9yaWMgaW5zdGl0dXRpb24ga25vd24gZm9yIGFydCwgZGVzaWduLCBhbmQgYXJjaGl0ZWN0dXJlLCBmb2xsb3dpbmcgdGhlIEJhdWhhdXMgdHJhZGl0aW9uLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiQnVyZyBHaWViaWNoZW5zdGVpbiBLdW5zdGhvY2hzY2h1bGUgSGFsbGVcIixcbiAgICAgICAgbG9jYXRpb246IFsxMS45NjMsIDUxLjQ4OV0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlJlbm93bmVkIGFydCBhbmQgZGVzaWduIHNjaG9vbCB3aXRoIGEgZm9jdXMgb24gcHJhY3RpY2FsIGFuZCB0aGVvcmV0aWNhbCBhcnRpc3RpYyBlZHVjYXRpb24uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJIb2Noc2NodWxlIGbDvHIgQmlsZGVuZGUgS8O8bnN0ZSBCcmF1bnNjaHdlaWdcIixcbiAgICAgICAgbG9jYXRpb246IFsxMC41MzQsIDUyLjI3M10sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlNwZWNpYWxpemVkIGFydCBhY2FkZW15IGZvY3VzaW5nIG9uIGZpbmUgYXJ0cywgdmlzdWFsIGNvbW11bmljYXRpb24sIGFuZCBpbmR1c3RyaWFsIGRlc2lnbi5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkhvY2hzY2h1bGUgZsO8ciBCaWxkZW5kZSBLw7xuc3RlIERyZXNkZW5cIixcbiAgICAgICAgbG9jYXRpb246IFsxMy43MzYsIDUxLjA1Ml0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkxlYWRpbmcgaW5zdGl0dXRpb24gZm9yIGNvbnRlbXBvcmFyeSBhcnQgZWR1Y2F0aW9uIHdpdGggc3Ryb25nIGVtcGhhc2lzIG9uIGV4cGVyaW1lbnRhbCBhcHByb2FjaGVzLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiSG9jaHNjaHVsZSBmw7xyIEJpbGRlbmRlIEvDvG5zdGUgSGFtYnVyZ1wiLFxuICAgICAgICBsb2NhdGlvbjogWzkuOTMzLCA1My41NzFdLFxuICAgICAgICB0eXBlOiBcIkt1bnN0aG9jaHNjaHVsZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJQcm9ncmVzc2l2ZSBhcnQgc2Nob29sIGtub3duIGZvciBpdHMgaW50ZXJkaXNjaXBsaW5hcnkgYXBwcm9hY2ggYW5kIGludGVybmF0aW9uYWwgbmV0d29yay5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkhvY2hzY2h1bGUgZsO8ciBCaWxkZW5kZSBLw7xuc3RlIFNhYXJcIixcbiAgICAgICAgbG9jYXRpb246IFs3LjAyNCwgNDkuMjM0XSxcbiAgICAgICAgdHlwZTogXCJLdW5zdGhvY2hzY2h1bGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTm90YWJsZSBpbnN0aXR1dGlvbiBzcGVjaWFsaXppbmcgaW4gZmluZSBhcnRzIGFuZCBhcnRpc3RpYyByZXNlYXJjaCBpbiB0aGUgU2FhcmxhbmQgcmVnaW9uLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiSG9jaHNjaHVsZSBmw7xyIEdlc3RhbHR1bmcgT2ZmZW5iYWNoIGFtIE1haW5cIixcbiAgICAgICAgbG9jYXRpb246IFs4Ljc2NCwgNTAuMTA3XSxcbiAgICAgICAgdHlwZTogXCJLdW5zdGhvY2hzY2h1bGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSW5ub3ZhdGl2ZSBkZXNpZ24gc2Nob29sIGVtcGhhc2l6aW5nIHRoZSBpbnRlcnNlY3Rpb24gb2YgYXJ0LCBtZWRpYSwgYW5kIHRlY2hub2xvZ3kuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJIb2Noc2NodWxlIGbDvHIgR2VzdGFsdHVuZyBTY2h3w6RiaXNjaCBHbcO8bmRcIixcbiAgICAgICAgbG9jYXRpb246IFs5Ljc5OCwgNDguODAxXSxcbiAgICAgICAgdHlwZTogXCJLdW5zdGhvY2hzY2h1bGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3BlY2lhbGl6ZWQgaW4gaW50ZXJhY3Rpb24gZGVzaWduLCBwcm9kdWN0IGRlc2lnbiwgYW5kIHN0cmF0ZWdpYyBkZXNpZ24gdGhpbmtpbmcuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJIb2Noc2NodWxlIGbDvHIgR3JhZmlrIHVuZCBCdWNoa3Vuc3QgTGVpcHppZ1wiLFxuICAgICAgICBsb2NhdGlvbjogWzEyLjM2OCwgNTEuMzM5XSxcbiAgICAgICAgdHlwZTogXCJLdW5zdGhvY2hzY2h1bGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiSGlzdG9yaWMgaW5zdGl0dXRpb24gcmVub3duZWQgZm9yIGJvb2sgYXJ0LCBncmFwaGljIGRlc2lnbiwgYW5kIHBob3RvZ3JhcGh5LlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiSG9jaHNjaHVsZSBmw7xyIEvDvG5zdGUgQnJlbWVuXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbOC44MjYsIDUzLjA3NV0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk11bHRpZGlzY2lwbGluYXJ5IGFydHMgdW5pdmVyc2l0eSBjb21iaW5pbmcgbXVzaWMsIGZpbmUgYXJ0cywgYW5kIGRpZ2l0YWwgbWVkaWEuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJIb2Noc2NodWxlIGbDvHIgS8O8bnN0ZSBpbSBTb3ppYWxlbiBPdHRlcnNiZXJnXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbOS4xNTMsIDUzLjEzMF0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVuaXF1ZSBpbnN0aXR1dGlvbiBmb2N1c2luZyBvbiBhcnQgdGhlcmFweSBhbmQgc29jaWFsIGFydGlzdGljIHByYWN0aWNlcy5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkt1bnN0YWthZGVtaWUgRMO8c3NlbGRvcmZcIixcbiAgICAgICAgbG9jYXRpb246IFs2Ljc3NywgNTEuMjMzXSxcbiAgICAgICAgdHlwZTogXCJLdW5zdGhvY2hzY2h1bGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUHJlc3RpZ2lvdXMgYWNhZGVteSBrbm93biBmb3IgcHJvZHVjaW5nIGluZmx1ZW50aWFsIGNvbnRlbXBvcmFyeSBhcnRpc3RzLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiS3Vuc3Rha2FkZW1pZSBNw7xuc3RlclwiLFxuICAgICAgICBsb2NhdGlvbjogWzcuNjI2LCA1MS45NjJdLFxuICAgICAgICB0eXBlOiBcIkt1bnN0aG9jaHNjaHVsZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJGb3J3YXJkLXRoaW5raW5nIGluc3RpdHV0aW9uIHNwZWNpYWxpemluZyBpbiBmaW5lIGFydHMgYW5kIGFydGlzdGljIHJlc2VhcmNoLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiS3Vuc3Rob2Noc2NodWxlIEJlcmxpbi1XZWnDn2Vuc2VlXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbMTMuNDYzLCA1Mi41NDNdLFxuICAgICAgICB0eXBlOiBcIkt1bnN0aG9jaHNjaHVsZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJCZXJsaW4tYmFzZWQgYXJ0IHNjaG9vbCBrbm93biBmb3IgaXRzIGlubm92YXRpdmUgYXBwcm9hY2ggdG8gZGVzaWduIGFuZCBmaW5lIGFydHMuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJLdW5zdGhvY2hzY2h1bGUgZsO8ciBNZWRpZW4gS8O2bG5cIixcbiAgICAgICAgbG9jYXRpb246IFs2Ljk1OSwgNTAuOTM1XSxcbiAgICAgICAgdHlwZTogXCJLdW5zdGhvY2hzY2h1bGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiTGVhZGluZyBtZWRpYSBhcnRzIHNjaG9vbCBmb2N1c2luZyBvbiBhdWRpb3Zpc3VhbCBhcnRzIGFuZCBkaWdpdGFsIGN1bHR1cmUuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJLdW5zdGhvY2hzY2h1bGUgS2Fzc2VsXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbOS40OTIsIDUxLjMxOF0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkRpc3Rpbmd1aXNoZWQgaW5zdGl0dXRpb24ga25vd24gZm9yIGl0cyBjb25uZWN0aW9uIHRvIGRvY3VtZW50YSBhcnQgZXhoaWJpdGlvbi5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkt1bnN0aG9jaHNjaHVsZSBNYWluelwiLFxuICAgICAgICBsb2NhdGlvbjogWzguMjc0LCA1MC4wMDFdLFxuICAgICAgICB0eXBlOiBcIkt1bnN0aG9jaHNjaHVsZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJQcm9ncmVzc2l2ZSBhcnQgc2Nob29sIGVtcGhhc2l6aW5nIGNvbnRlbXBvcmFyeSBhcnRpc3RpYyBwcmFjdGljZXMgYW5kIHRoZW9yeS5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIk11dGhlc2l1cyBLdW5zdGhvY2hzY2h1bGUgS2llbFwiLFxuICAgICAgICBsb2NhdGlvbjogWzEwLjEyMiwgNTQuMzIzXSxcbiAgICAgICAgdHlwZTogXCJLdW5zdGhvY2hzY2h1bGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU3BlY2lhbGl6ZWQgaW4gZmluZSBhcnRzLCBzcGF0aWFsIHN0cmF0ZWdpZXMsIGFuZCBkZXNpZ24gaW5ub3ZhdGlvbi5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlN0YWF0bGljaGUgQWthZGVtaWUgZGVyIEJpbGRlbmRlbiBLw7xuc3RlIEthcmxzcnVoZVwiLFxuICAgICAgICBsb2NhdGlvbjogWzguNDAwLCA0OS4wMTRdLFxuICAgICAgICB0eXBlOiBcIkt1bnN0aG9jaHNjaHVsZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJIaXN0b3JpYyBhY2FkZW15IHdpdGggc3Ryb25nIHRyYWRpdGlvbnMgaW4gcGFpbnRpbmcgYW5kIGFydCB0aGVvcnkuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJTdGFhdGxpY2hlIEFrYWRlbWllIGRlciBCaWxkZW5kZW4gS8O8bnN0ZSBTdHV0dGdhcnRcIixcbiAgICAgICAgbG9jYXRpb246IFs5LjE2OSwgNDguNzg5XSxcbiAgICAgICAgdHlwZTogXCJLdW5zdGhvY2hzY2h1bGVcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ29tcHJlaGVuc2l2ZSBhcnQgYWNhZGVteSBvZmZlcmluZyBwcm9ncmFtcyBmcm9tIGZpbmUgYXJ0cyB0byBjb25zZXJ2YXRpb24uXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJTdGFhdGxpY2hlIEhvY2hzY2h1bGUgZsO8ciBCaWxkZW5kZSBLw7xuc3RlIOKAkyBTdMOkZGVsc2NodWxlIEZyYW5rZnVydFwiLFxuICAgICAgICBsb2NhdGlvbjogWzguNjg0LCA1MC4xMTVdLFxuICAgICAgICB0eXBlOiBcIkt1bnN0aG9jaHNjaHVsZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJFbGl0ZSBpbnN0aXR1dGlvbiBrbm93biBmb3IgaXRzIGluZmx1ZW50aWFsIGNvbnRlbXBvcmFyeSBhcnQgcHJvZ3JhbS5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlVuaXZlcnNpdMOkdCBkZXIgS8O8bnN0ZSBCZXJsaW5cIixcbiAgICAgICAgbG9jYXRpb246IFsxMy4zMjQsIDUyLjUwN10sXG4gICAgICAgIHR5cGU6IFwiVW5pdmVyc2l0eVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJPbmUgb2YgRXVyb3BlJ3MgbGFyZ2VzdCBhcnRzIHVuaXZlcnNpdGllcywgY292ZXJpbmcgYWxsIGFydGlzdGljIGRpc2NpcGxpbmVzLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiQmFyZCBDb2xsZWdlIEJlcmxpblwiLFxuICAgICAgICBsb2NhdGlvbjogWzEzLjQ2NSwgNTIuNTU3XSxcbiAgICAgICAgdHlwZTogXCJVbml2ZXJzaXR5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkxpYmVyYWwgYXJ0cyB1bml2ZXJzaXR5IG9mZmVyaW5nIGludGVyZGlzY2lwbGluYXJ5IHByb2dyYW1zIHdpdGggaW50ZXJuYXRpb25hbCBmb2N1cy5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkZvbGt3YW5nIFVuaXZlcnNpdMOkdCBkZXIgS8O8bnN0ZVwiLFxuICAgICAgICBsb2NhdGlvbjogWzcuMDEzLCA1MS40NDNdLFxuICAgICAgICB0eXBlOiBcIlVuaXZlcnNpdHlcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiQ29tcHJlaGVuc2l2ZSBhcnRzIHVuaXZlcnNpdHkga25vd24gZm9yIG11c2ljLCB0aGVhdGVyLCBkYW5jZSwgYW5kIGRlc2lnbi5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkFsYW51cyBVbml2ZXJzaXR5IG9mIEFydHMgYW5kIFNvY2lhbCBTY2llbmNlc1wiLFxuICAgICAgICBsb2NhdGlvbjogWzcuMTE4LCA1MC43MzddLFxuICAgICAgICB0eXBlOiBcIlVuaXZlcnNpdHlcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUHJpdmF0ZSB1bml2ZXJzaXR5IGNvbWJpbmluZyBhcnRpc3RpYyBlZHVjYXRpb24gd2l0aCBzb2NpYWwgc2NpZW5jZXMgYW5kIHBlZGFnb2d5LlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiU3RhYXRsaWNoZSBBa2FkZW1pZSBkZXIgQmlsZGVuZGVuIEvDvG5zdGUgTcO8bmNoZW5cIixcbiAgICAgICAgbG9jYXRpb246IFsxMS41NzYsIDQ4LjE0OV0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlByZXN0aWdpb3VzIE11bmljaC1iYXNlZCBhY2FkZW15IHdpdGggcmljaCBhcnRpc3RpYyBoZXJpdGFnZS5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkFrYWRlbWllIGRlciBCaWxkZW5kZW4gS8O8bnN0ZSBOw7xybmJlcmdcIixcbiAgICAgICAgbG9jYXRpb246IFsxMS4wNzcsIDQ5LjQ1Ml0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkhpc3RvcmljIGluc3RpdHV0aW9uIGZvY3VzaW5nIG9uIGZpbmUgYXJ0cyBhbmQgYXJ0aXN0aWMgcmVzZWFyY2guXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJUZWNobmlzY2hlIFVuaXZlcnNpdMOkdCBCZXJsaW5cIixcbiAgICAgICAgbG9jYXRpb246IFsxMy4zMjYsIDUyLjUxMl0sXG4gICAgICAgIHR5cGU6IFwiVW5pdmVyc2l0eVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJMZWFkaW5nIHRlY2huaWNhbCB1bml2ZXJzaXR5IHJlbm93bmVkIGZvciBlbmdpbmVlcmluZyBhbmQgdGVjaG5vbG9neSByZXNlYXJjaC5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkhvY2hzY2h1bGUgZsO8ciBCaWxkZW5kZSBLw7xuc3RlIEVzc2VuXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbNy4wMTQsIDUxLjQ1MV0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIk5vdGFibGUgaW5zdGl0dXRpb24gZm9yIGNvbnRlbXBvcmFyeSBhcnQgYW5kIG1lZGlhIHByYWN0aWNlcy5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlN0YWF0bGljaGUgSG9jaHNjaHVsZSBmw7xyIEdlc3RhbHR1bmcgS2FybHNydWhlXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbOC40MDAsIDQ5LjAwOV0sXG4gICAgICAgIHR5cGU6IFwiS3Vuc3Rob2Noc2NodWxlXCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIklubm92YXRpdmUgZGVzaWduIHNjaG9vbCBlbXBoYXNpemluZyB0aGVvcnkgYW5kIHByYWN0aWNlIGluIG1lZGlhIGFydHMuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJBY2FkZW15IG9mIFZpc3VhbCBBcnRzIEZyYW5rZnVydFwiLFxuICAgICAgICBsb2NhdGlvbjogWzguNjgzLCA1MC4xMTZdLFxuICAgICAgICB0eXBlOiBcIkt1bnN0aG9jaHNjaHVsZVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJDb250ZW1wb3JhcnkgYXJ0IGluc3RpdHV0aW9uIGtub3duIGZvciBpdHMgZXhwZXJpbWVudGFsIGFwcHJvYWNoLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiRmFjaGhvY2hzY2h1bGUgUG90c2RhbVwiLFxuICAgICAgICBsb2NhdGlvbjogWzEzLjA2NCwgNTIuNDEzXSxcbiAgICAgICAgdHlwZTogXCJVbml2ZXJzaXR5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIkFwcGxpZWQgc2NpZW5jZXMgdW5pdmVyc2l0eSB3aXRoIHN0cm9uZyBkZXNpZ24gYW5kIGFyY2hpdGVjdHVyZSBwcm9ncmFtcy5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkhvY2hzY2h1bGUgRGFybXN0YWR0XCIsXG4gICAgICAgIGxvY2F0aW9uOiBbOC42NTEsIDQ5Ljg2N10sXG4gICAgICAgIHR5cGU6IFwiVW5pdmVyc2l0eVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJVbml2ZXJzaXR5IG9mIGFwcGxpZWQgc2NpZW5jZXMga25vd24gZm9yIHRlY2hub2xvZ3kgYW5kIG1lZGlhIHByb2dyYW1zLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiSG9jaHNjaHVsZSBSaGVpbi1XYWFsXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbNi41NDIsIDUxLjgzMV0sXG4gICAgICAgIHR5cGU6IFwiVW5pdmVyc2l0eVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJJbnRlcm5hdGlvbmFsIHVuaXZlcnNpdHkgZm9jdXNpbmcgb24gdGVjaG5vbG9neSBhbmQgbmF0dXJhbCBzY2llbmNlcy5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlRlY2huaXNjaGUgVW5pdmVyc2l0w6R0IENoZW1uaXR6XCIsXG4gICAgICAgIGxvY2F0aW9uOiBbMTIuOTI3LCA1MC44NDFdLFxuICAgICAgICB0eXBlOiBcIlVuaXZlcnNpdHlcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGVjaG5pY2FsIHVuaXZlcnNpdHkgc3BlY2lhbGl6aW5nIGluIGVuZ2luZWVyaW5nIGFuZCBuYXR1cmFsIHNjaWVuY2VzLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiSG9jaHNjaHVsZSBBbmhhbHRcIixcbiAgICAgICAgbG9jYXRpb246IFsxMi4xNjYsIDUxLjc1M10sXG4gICAgICAgIHR5cGU6IFwiVW5pdmVyc2l0eVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJVbml2ZXJzaXR5IG9mIGFwcGxpZWQgc2NpZW5jZXMgd2l0aCBmb2N1cyBvbiBkZXNpZ24gYW5kIGVuZ2luZWVyaW5nLlwiXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiVW5pdmVyc2l0w6R0IFRyaWVyXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbNi42ODcsIDQ5Ljc0Nl0sXG4gICAgICAgIHR5cGU6IFwiVW5pdmVyc2l0eVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJIaXN0b3JpYyB1bml2ZXJzaXR5IGtub3duIGZvciBodW1hbml0aWVzIGFuZCBzb2NpYWwgc2NpZW5jZXMuXCJcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJVbml2ZXJzaXTDpHQgU2llZ2VuXCIsXG4gICAgICAgIGxvY2F0aW9uOiBbOC4wMjMsIDUwLjkxMV0sXG4gICAgICAgIHR5cGU6IFwiVW5pdmVyc2l0eVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJSZXNlYXJjaCB1bml2ZXJzaXR5IHdpdGggc3RyZW5ndGggaW4gZW5naW5lZXJpbmcgYW5kIHNvY2lhbCBzY2llbmNlcy5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlRlY2huaXNjaGUgSG9jaHNjaHVsZSBJbmdvbHN0YWR0XCIsXG4gICAgICAgIGxvY2F0aW9uOiBbMTEuNDI1LCA0OC43NjZdLFxuICAgICAgICB0eXBlOiBcIlVuaXZlcnNpdHlcIixcbiAgICAgICAgZGVzY3JpcHRpb246IFwiVGVjaG5pY2FsIHVuaXZlcnNpdHkgc3BlY2lhbGl6aW5nIGluIGF1dG9tb3RpdmUgYW5kIHRlY2hub2xvZ3kgaW5ub3ZhdGlvbi5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIkhvY2hzY2h1bGUgRnVsZGFcIixcbiAgICAgICAgbG9jYXRpb246IFs5LjY3NSwgNTAuNTY1XSxcbiAgICAgICAgdHlwZTogXCJVbml2ZXJzaXR5XCIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlVuaXZlcnNpdHkgb2YgYXBwbGllZCBzY2llbmNlcyBmb2N1c2luZyBvbiBzb2NpYWwgYW5kIGhlYWx0aCBzY2llbmNlcy5cIlxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcIlVuaXZlcnNpdMOkdCBQYXNzYXVcIixcbiAgICAgICAgbG9jYXRpb246IFsxMy40NTIsIDQ4LjU2N10sXG4gICAgICAgIHR5cGU6IFwiVW5pdmVyc2l0eVwiLFxuICAgICAgICBkZXNjcmlwdGlvbjogXCJLbm93biBmb3IgaW50ZXJuYXRpb25hbCBzdHVkaWVzIGFuZCBjb21wdXRlciBzY2llbmNlIHByb2dyYW1zLlwiXG4gICAgfVxuXTtcblxuaW50ZXJmYWNlIEluZm9Cb3gge1xuICBuYW1lOiBzdHJpbmc7XG4gIHBvc2l0aW9uOiBUSFJFRS5WZWN0b3IzO1xuICB0eXBlOiBzdHJpbmc7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBVbml2ZXJzaXR5Tm9kZXNQcm9wcyB7XG4gIHJhZGl1czogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBsYXRMbmdUb1ZlY3RvcjMobGF0OiBudW1iZXIsIGxuZzogbnVtYmVyLCByYWRpdXM6IG51bWJlcik6IFRIUkVFLlZlY3RvcjMge1xuICAvLyBNYXAgR2VybWFuIGNvb3JkaW5hdGVzIHRvIGdsb2JhbCBjb29yZGluYXRlc1xuICBjb25zdCBnbG9iYWxMYXQgPSAoKGxhdCAtIDQ3KSAvICg1NSAtIDQ3KSkgKiAxODAgLSA5MDsgLy8gTWFwIEdlcm1hbiBsYXRpdHVkZXMgKDQ3LTU1KSB0byBnbG9iYWwgKC05MCB0byA5MClcbiAgY29uc3QgZ2xvYmFsTG5nID0gKChsbmcgLSA2KSAvICgxNSAtIDYpKSAqIDM2MCAtIDE4MDsgIC8vIE1hcCBHZXJtYW4gbG9uZ2l0dWRlcyAoNi0xNSkgdG8gZ2xvYmFsICgtMTgwIHRvIDE4MClcblxuICAvLyBBZGQgcmFuZG9taXphdGlvbiBmb3IgYmV0dGVyIGRpc3RyaWJ1dGlvblxuICBjb25zdCByYW5kb21MYXQgPSBnbG9iYWxMYXQgKyAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiAxMjA7IC8vIFNwcmVhZCBhY3Jvc3MgwrE2MCBkZWdyZWVzIGZyb20gbWFwcGVkIHBvc2l0aW9uXG4gIGNvbnN0IHJhbmRvbUxuZyA9IGdsb2JhbExuZyArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIDI0MDsgLy8gU3ByZWFkIGFjcm9zcyDCsTEyMCBkZWdyZWVzIGZyb20gbWFwcGVkIHBvc2l0aW9uXG5cbiAgLy8gQ29udmVydCB0byBzcGhlcmljYWwgY29vcmRpbmF0ZXNcbiAgY29uc3QgcGhpID0gKDkwIC0gcmFuZG9tTGF0KSAqIChNYXRoLlBJIC8gMTgwKTtcbiAgY29uc3QgdGhldGEgPSAocmFuZG9tTG5nICsgMTgwKSAqIChNYXRoLlBJIC8gMTgwKTtcblxuICAvLyBDb252ZXJ0IHRvIENhcnRlc2lhbiBjb29yZGluYXRlc1xuICBjb25zdCB4ID0gLShyYWRpdXMgKiBNYXRoLnNpbihwaGkpICogTWF0aC5jb3ModGhldGEpKTtcbiAgY29uc3QgeSA9IHJhZGl1cyAqIE1hdGguY29zKHBoaSk7XG4gIGNvbnN0IHogPSByYWRpdXMgKiBNYXRoLnNpbihwaGkpICogTWF0aC5zaW4odGhldGEpO1xuXG4gIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMyh4LCB5LCB6KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVW5pdmVyc2l0eU5vZGVzKHsgcmFkaXVzIH06IFVuaXZlcnNpdHlOb2Rlc1Byb3BzKSB7XG4gIGNvbnN0IGdyb3VwUmVmID0gdXNlUmVmPFRIUkVFLkdyb3VwPihudWxsKTtcbiAgY29uc3QgW3NlbGVjdGVkVW5pdmVyc2l0eSwgc2V0U2VsZWN0ZWRVbml2ZXJzaXR5XSA9IHVzZVN0YXRlPEluZm9Cb3ggfCBudWxsPihudWxsKTtcbiAgY29uc3QgW2hvdmVyVW5pdmVyc2l0eSwgc2V0SG92ZXJVbml2ZXJzaXR5XSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgLy8gQ3JlYXRlIG1hdGVyaWFscyBmb3IgZGlmZmVyZW50IHVuaXZlcnNpdHkgdHlwZXNcbiAgY29uc3QgbWF0ZXJpYWxzID0gdXNlTWVtbygoKSA9PiAoe1xuICAgIFVuaXZlcnNpdHk6IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6ICcjMDBmZmQ1JyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmZkNScsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMixcbiAgICAgIG1ldGFsbmVzczogMC41LFxuICAgICAgcm91Z2huZXNzOiAwLjIsXG4gICAgfSksXG4gICAgS3Vuc3Rob2Noc2NodWxlOiBuZXcgVEhSRUUuTWVzaFN0YW5kYXJkTWF0ZXJpYWwoeyBcbiAgICAgIGNvbG9yOiAnI2ZmMDBmZicsXG4gICAgICBlbWlzc2l2ZTogJyNmZjAwZmYnLFxuICAgICAgZW1pc3NpdmVJbnRlbnNpdHk6IDIsXG4gICAgICBtZXRhbG5lc3M6IDAuNSxcbiAgICAgIHJvdWdobmVzczogMC4yLFxuICAgIH0pLFxuICAgIEhvY2hzY2h1bGU6IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6ICcjZmZmZjAwJyxcbiAgICAgIGVtaXNzaXZlOiAnI2ZmZmYwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMixcbiAgICAgIG1ldGFsbmVzczogMC41LFxuICAgICAgcm91Z2huZXNzOiAwLjIsXG4gICAgfSksXG4gICAgQWthZGVtaWU6IG5ldyBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCh7IFxuICAgICAgY29sb3I6ICcjMDBmZjAwJyxcbiAgICAgIGVtaXNzaXZlOiAnIzAwZmYwMCcsXG4gICAgICBlbWlzc2l2ZUludGVuc2l0eTogMixcbiAgICAgIG1ldGFsbmVzczogMC41LFxuICAgICAgcm91Z2huZXNzOiAwLjIsXG4gICAgfSksXG4gIH0pLCBbXSk7XG5cbiAgLy8gQ3JlYXRlIGluc3RhbmNlIGRhdGFcbiAgY29uc3QgeyBpbnN0YW5jZURhdGEsIG5vZGVQb3NpdGlvbnMgfSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlRGF0YSA9IFVOSVZFUlNJVElFUy5tYXAodW5pdmVyc2l0eSA9PiB7XG4gICAgICBjb25zdCBwb3NpdGlvbiA9IGxhdExuZ1RvVmVjdG9yMyh1bml2ZXJzaXR5LmxvY2F0aW9uWzFdLCB1bml2ZXJzaXR5LmxvY2F0aW9uWzBdLCByYWRpdXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIHVuaXZlcnNpdHksXG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgY29uc3Qgbm9kZVBvc2l0aW9ucyA9IG5ldyBNYXAoXG4gICAgICBpbnN0YW5jZURhdGEubWFwKCh7IHVuaXZlcnNpdHksIHBvc2l0aW9uIH0pID0+IFt1bml2ZXJzaXR5Lm5hbWUsIHBvc2l0aW9uXSlcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgaW5zdGFuY2VEYXRhLCBub2RlUG9zaXRpb25zIH07XG4gIH0sIFtyYWRpdXNdKTtcblxuICAvLyBBbmltYXRpb24gZm9yIGluZm8gYm94XG4gIGNvbnN0IGluZm9Cb3hTcHJpbmcgPSB1c2VTcHJpbmcoe1xuICAgIHNjYWxlOiBzZWxlY3RlZFVuaXZlcnNpdHkgPyAxIDogMCxcbiAgICBvcGFjaXR5OiBzZWxlY3RlZFVuaXZlcnNpdHkgPyAxIDogMCxcbiAgICBjb25maWc6IHsgdGVuc2lvbjogMjgwLCBmcmljdGlvbjogNjAgfSxcbiAgfSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzZXRNb3VudGVkKHRydWUpO1xuICB9LCBbXSk7XG5cbiAgaWYgKCFtb3VudGVkKSByZXR1cm4gbnVsbDtcblxuICByZXR1cm4gKFxuICAgIDxncm91cCByZWY9e2dyb3VwUmVmfT5cbiAgICAgIHtPYmplY3QuZW50cmllcyhtYXRlcmlhbHMpLm1hcCgoW3R5cGUsIG1hdGVyaWFsXSkgPT4gKFxuICAgICAgICA8SW5zdGFuY2VzIGtleT17dHlwZX0gbGltaXQ9e1VOSVZFUlNJVElFUy5sZW5ndGh9IHJhbmdlPXtVTklWRVJTSVRJRVMubGVuZ3RofT5cbiAgICAgICAgICA8c3BoZXJlR2VvbWV0cnkgYXJncz17WzAuMTUsIDE2LCAxNl19IC8+XG4gICAgICAgICAgPHByaW1pdGl2ZSBvYmplY3Q9e21hdGVyaWFsfSBhdHRhY2g9XCJtYXRlcmlhbFwiIC8+XG4gICAgICAgICAgXG4gICAgICAgICAge2luc3RhbmNlRGF0YVxuICAgICAgICAgICAgLmZpbHRlcigoeyB1bml2ZXJzaXR5IH0pID0+IHVuaXZlcnNpdHkudHlwZSA9PT0gdHlwZSlcbiAgICAgICAgICAgIC5tYXAoKHsgcG9zaXRpb24sIHVuaXZlcnNpdHkgfSkgPT4gKFxuICAgICAgICAgICAgICA8SW5zdGFuY2VcbiAgICAgICAgICAgICAgICBrZXk9e3VuaXZlcnNpdHkubmFtZX1cbiAgICAgICAgICAgICAgICBwb3NpdGlvbj17cG9zaXRpb259XG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gc2V0U2VsZWN0ZWRVbml2ZXJzaXR5KHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHVuaXZlcnNpdHkubmFtZSxcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbi5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKDEuMSksXG4gICAgICAgICAgICAgICAgICB0eXBlOiB1bml2ZXJzaXR5LnR5cGUsXG4gICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogdW5pdmVyc2l0eS5kZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICBvblBvaW50ZXJPdmVyPXsoKSA9PiBzZXRIb3ZlclVuaXZlcnNpdHkodW5pdmVyc2l0eS5uYW1lKX1cbiAgICAgICAgICAgICAgICBvblBvaW50ZXJPdXQ9eygpID0+IHNldEhvdmVyVW5pdmVyc2l0eShudWxsKX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgICkpfVxuICAgICAgICA8L0luc3RhbmNlcz5cbiAgICAgICkpfVxuXG4gICAgICB7LyogUmVuZGVyIGluZm8gYm94ICovfVxuICAgICAge3NlbGVjdGVkVW5pdmVyc2l0eSAmJiAoXG4gICAgICAgIDxhbmltYXRlZC5ncm91cFxuICAgICAgICAgIHBvc2l0aW9uPXtzZWxlY3RlZFVuaXZlcnNpdHkucG9zaXRpb259XG4gICAgICAgICAgc2NhbGU9e2luZm9Cb3hTcHJpbmcuc2NhbGV9XG4gICAgICAgID5cbiAgICAgICAgICA8QmlsbGJvYXJkPlxuICAgICAgICAgICAgPG1lc2ggcG9zaXRpb249e1swLCAwLCAtMC4wNV19PlxuICAgICAgICAgICAgICA8Ym94R2VvbWV0cnkgYXJncz17WzIuMiwgMS4yLCAwLjFdfSAvPlxuICAgICAgICAgICAgICA8c2hhZGVyTWF0ZXJpYWxcbiAgICAgICAgICAgICAgICB1bmlmb3Jtcz17e1xuICAgICAgICAgICAgICAgICAgY29sb3I6IHsgdmFsdWU6IG5ldyBUSFJFRS5Db2xvcignIzAwMDAwMCcpIH0sXG4gICAgICAgICAgICAgICAgICBvcGFjaXR5OiB7IHZhbHVlOiAwLjggfSxcbiAgICAgICAgICAgICAgICAgIHJhZGl1czogeyB2YWx1ZTogMC4xIH0sXG4gICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICB2ZXJ0ZXhTaGFkZXI9e2BcbiAgICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjMiB2VXY7XG4gICAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzMgdlBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICB2VXYgPSB1djtcbiAgICAgICAgICAgICAgICAgICAgdlBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQocG9zaXRpb24sIDEuMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYH1cbiAgICAgICAgICAgICAgICBmcmFnbWVudFNoYWRlcj17YFxuICAgICAgICAgICAgICAgICAgdW5pZm9ybSB2ZWMzIGNvbG9yO1xuICAgICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgdW5pZm9ybSBmbG9hdCByYWRpdXM7XG4gICAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzIgdlV2O1xuICAgICAgICAgICAgICAgICAgdmFyeWluZyB2ZWMzIHZQb3NpdGlvbjtcblxuICAgICAgICAgICAgICAgICAgZmxvYXQgcm91bmRlZEJveFNERih2ZWMyIGNlbnRlclBvc2l0aW9uLCB2ZWMyIHNpemUsIGZsb2F0IHJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVuZ3RoKG1heChhYnMoY2VudGVyUG9zaXRpb24pIC0gc2l6ZSArIHJhZGl1cywgMC4wKSkgLSByYWRpdXM7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjMiBjZW50ZXJQb3NpdGlvbiA9IHZVdiAqIDIuMCAtIDEuMDtcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgZGlzdGFuY2UgPSByb3VuZGVkQm94U0RGKGNlbnRlclBvc2l0aW9uLCB2ZWMyKDEuMCwgMC41KSwgcmFkaXVzKTtcbiAgICAgICAgICAgICAgICAgICAgZmxvYXQgc21vb3RoZWRBbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoLTAuMDEsIDAuMDEsIGRpc3RhbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgc21vb3RoZWRBbHBoYSAqIG9wYWNpdHkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGB9XG4gICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRcbiAgICAgICAgICAgICAgICBkZXB0aFdyaXRlPXtmYWxzZX1cbiAgICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDwvbWVzaD5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPFRleHRcbiAgICAgICAgICAgICAgcG9zaXRpb249e1swLCAwLjMsIDBdfVxuICAgICAgICAgICAgICBmb250U2l6ZT17MC4xMn1cbiAgICAgICAgICAgICAgY29sb3I9XCIjZmZmZmZmXCJcbiAgICAgICAgICAgICAgYW5jaG9yWD1cImNlbnRlclwiXG4gICAgICAgICAgICAgIGFuY2hvclk9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICBvdXRsaW5lV2lkdGg9ezAuMDA0fVxuICAgICAgICAgICAgICBvdXRsaW5lQ29sb3I9XCIjMDAwMDAwXCJcbiAgICAgICAgICAgICAgb3V0bGluZU9wYWNpdHk9ezAuOH1cbiAgICAgICAgICAgICAgbWF4V2lkdGg9ezJ9XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtzZWxlY3RlZFVuaXZlcnNpdHkubmFtZX1cbiAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgPFRleHRcbiAgICAgICAgICAgICAgcG9zaXRpb249e1swLCAwLjEsIDBdfVxuICAgICAgICAgICAgICBmb250U2l6ZT17MC4wOX1cbiAgICAgICAgICAgICAgY29sb3I9XCIjZmZmZmZmXCJcbiAgICAgICAgICAgICAgYW5jaG9yWD1cImNlbnRlclwiXG4gICAgICAgICAgICAgIGFuY2hvclk9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICBvdXRsaW5lV2lkdGg9ezAuMDAzfVxuICAgICAgICAgICAgICBvdXRsaW5lQ29sb3I9XCIjMDAwMDAwXCJcbiAgICAgICAgICAgICAgb3V0bGluZU9wYWNpdHk9ezAuOH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3NlbGVjdGVkVW5pdmVyc2l0eS50eXBlfVxuICAgICAgICAgICAgPC9UZXh0PlxuICAgICAgICAgICAgXG4gICAgICAgICAgICA8VGV4dFxuICAgICAgICAgICAgICBwb3NpdGlvbj17WzAsIC0wLjIsIDBdfVxuICAgICAgICAgICAgICBmb250U2l6ZT17MC4wN31cbiAgICAgICAgICAgICAgY29sb3I9XCIjZmZmZmZmXCJcbiAgICAgICAgICAgICAgYW5jaG9yWD1cImNlbnRlclwiXG4gICAgICAgICAgICAgIGFuY2hvclk9XCJtaWRkbGVcIlxuICAgICAgICAgICAgICBvdXRsaW5lV2lkdGg9ezAuMDAyfVxuICAgICAgICAgICAgICBvdXRsaW5lQ29sb3I9XCIjMDAwMDAwXCJcbiAgICAgICAgICAgICAgb3V0bGluZU9wYWNpdHk9ezAuOH1cbiAgICAgICAgICAgICAgbWF4V2lkdGg9ezEuOH1cbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3NlbGVjdGVkVW5pdmVyc2l0eS5kZXNjcmlwdGlvbn1cbiAgICAgICAgICAgIDwvVGV4dD5cbiAgICAgICAgICA8L0JpbGxib2FyZD5cbiAgICAgICAgPC9hbmltYXRlZC5ncm91cD5cbiAgICAgICl9XG4gICAgPC9ncm91cD5cbiAgKTtcbn0iXSwibmFtZXMiOlsidXNlTWVtbyIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiVEhSRUUiLCJUZXh0IiwiQmlsbGJvYXJkIiwiSW5zdGFuY2UiLCJJbnN0YW5jZXMiLCJhbmltYXRlZCIsInVzZVNwcmluZyIsIlVOSVZFUlNJVElFUyIsIm5hbWUiLCJsb2NhdGlvbiIsInR5cGUiLCJkZXNjcmlwdGlvbiIsImxhdExuZ1RvVmVjdG9yMyIsImxhdCIsImxuZyIsInJhZGl1cyIsImdsb2JhbExhdCIsImdsb2JhbExuZyIsInJhbmRvbUxhdCIsIk1hdGgiLCJyYW5kb20iLCJyYW5kb21MbmciLCJwaGkiLCJQSSIsInRoZXRhIiwieCIsInNpbiIsImNvcyIsInkiLCJ6IiwiVmVjdG9yMyIsIlVuaXZlcnNpdHlOb2RlcyIsImdyb3VwUmVmIiwic2VsZWN0ZWRVbml2ZXJzaXR5Iiwic2V0U2VsZWN0ZWRVbml2ZXJzaXR5IiwiaG92ZXJVbml2ZXJzaXR5Iiwic2V0SG92ZXJVbml2ZXJzaXR5IiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJtYXRlcmlhbHMiLCJVbml2ZXJzaXR5IiwiTWVzaFN0YW5kYXJkTWF0ZXJpYWwiLCJjb2xvciIsImVtaXNzaXZlIiwiZW1pc3NpdmVJbnRlbnNpdHkiLCJtZXRhbG5lc3MiLCJyb3VnaG5lc3MiLCJLdW5zdGhvY2hzY2h1bGUiLCJIb2Noc2NodWxlIiwiQWthZGVtaWUiLCJpbnN0YW5jZURhdGEiLCJub2RlUG9zaXRpb25zIiwibWFwIiwidW5pdmVyc2l0eSIsInBvc2l0aW9uIiwiTWFwIiwiaW5mb0JveFNwcmluZyIsInNjYWxlIiwib3BhY2l0eSIsImNvbmZpZyIsInRlbnNpb24iLCJmcmljdGlvbiIsImdyb3VwIiwicmVmIiwiT2JqZWN0IiwiZW50cmllcyIsIm1hdGVyaWFsIiwibGltaXQiLCJsZW5ndGgiLCJyYW5nZSIsInNwaGVyZUdlb21ldHJ5IiwiYXJncyIsInByaW1pdGl2ZSIsIm9iamVjdCIsImF0dGFjaCIsImZpbHRlciIsIm9uQ2xpY2siLCJjbG9uZSIsIm11bHRpcGx5U2NhbGFyIiwib25Qb2ludGVyT3ZlciIsIm9uUG9pbnRlck91dCIsIm1lc2giLCJib3hHZW9tZXRyeSIsInNoYWRlck1hdGVyaWFsIiwidW5pZm9ybXMiLCJ2YWx1ZSIsIkNvbG9yIiwidmVydGV4U2hhZGVyIiwiZnJhZ21lbnRTaGFkZXIiLCJ0cmFuc3BhcmVudCIsImRlcHRoV3JpdGUiLCJmb250U2l6ZSIsImFuY2hvclgiLCJhbmNob3JZIiwib3V0bGluZVdpZHRoIiwib3V0bGluZUNvbG9yIiwib3V0bGluZU9wYWNpdHkiLCJtYXhXaWR0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/map/UniversityNodes.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js":
/*!***************************************************!*\
  !*** ./node_modules/prop-types/checkPropTypes.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar printWarning = function() {};\n\nif (true) {\n  var ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n  var loggedTypeFailures = {};\n  var has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\n\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) { /**/ }\n  };\n}\n\n/**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */\nfunction checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n  if (true) {\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error;\n        // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error(\n              (componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' +\n              'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' +\n              'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.'\n            );\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n        } catch (ex) {\n          error = ex;\n        }\n        if (error && !(error instanceof Error)) {\n          printWarning(\n            (componentName || 'React class') + ': type specification of ' +\n            location + ' `' + typeSpecName + '` is invalid; the type checker ' +\n            'function must return `null` or an `Error` but returned a ' + typeof error + '. ' +\n            'You may have forgotten to pass an argument to the type checker ' +\n            'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' +\n            'shape all require an argument).'\n          );\n        }\n        if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error.message] = true;\n\n          var stack = getStack ? getStack() : '';\n\n          printWarning(\n            'Failed ' + location + ' type: ' + error.message + (stack != null ? stack : '')\n          );\n        }\n      }\n    }\n  }\n}\n\n/**\n * Resets warning cache when testing.\n *\n * @private\n */\ncheckPropTypes.resetWarningCache = function() {\n  if (true) {\n    loggedTypeFailures = {};\n  }\n}\n\nmodule.exports = checkPropTypes;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLDZCQUE2QixtQkFBTyxDQUFDLDZHQUE0QjtBQUNqRTtBQUNBLFlBQVksbUJBQU8sQ0FBQywyRUFBVzs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFlBQVk7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkdBQTZHO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcz85OTczIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gcmVxdWlyZSgnLi9saWIvaGFzJyk7XG5cbiAgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24odGV4dCkge1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyB0ZXh0O1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHsgLyoqLyB9XG4gIH07XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKFxuICAgICAgICAgICAgICAoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgK1xuICAgICAgICAgICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICtcbiAgICAgICAgICAgICAgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciAmJiAhKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJyArXG4gICAgICAgICAgICBsb2NhdGlvbiArICcgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgK1xuICAgICAgICAgICAgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICcgKyB0eXBlb2YgZXJyb3IgKyAnLiAnICtcbiAgICAgICAgICAgICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgK1xuICAgICAgICAgICAgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ZhaWxlZCAnICsgbG9jYXRpb24gKyAnIHR5cGU6ICcgKyBlcnJvci5tZXNzYWdlICsgKHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZXNldHMgd2FybmluZyBjYWNoZSB3aGVuIHRlc3RpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js":
/*!************************************************************!*\
  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\nvar assign = __webpack_require__(/*! object-assign */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/object-assign.js\");\n\nvar ReactPropTypesSecret = __webpack_require__(/*! ./lib/ReactPropTypesSecret */ \"(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\nvar has = __webpack_require__(/*! ./lib/has */ \"(app-pages-browser)/./node_modules/prop-types/lib/has.js\");\nvar checkPropTypes = __webpack_require__(/*! ./checkPropTypes */ \"(app-pages-browser)/./node_modules/prop-types/checkPropTypes.js\");\n\nvar printWarning = function() {};\n\nif (true) {\n  printWarning = function(text) {\n    var message = 'Warning: ' + text;\n    if (typeof console !== 'undefined') {\n      console.error(message);\n    }\n    try {\n      // --- Welcome to debugging React ---\n      // This error was thrown as a convenience so that you can use this stack\n      // to find the callsite that caused this warning to fire.\n      throw new Error(message);\n    } catch (x) {}\n  };\n}\n\nfunction emptyFunctionThatReturnsNull() {\n  return null;\n}\n\nmodule.exports = function(isValidElement, throwOnDirectAccess) {\n  /* global Symbol */\n  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\n  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.\n\n  /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */\n  function getIteratorFn(maybeIterable) {\n    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n    if (typeof iteratorFn === 'function') {\n      return iteratorFn;\n    }\n  }\n\n  /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */\n\n  var ANONYMOUS = '<<anonymous>>';\n\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n  var ReactPropTypes = {\n    array: createPrimitiveTypeChecker('array'),\n    bigint: createPrimitiveTypeChecker('bigint'),\n    bool: createPrimitiveTypeChecker('boolean'),\n    func: createPrimitiveTypeChecker('function'),\n    number: createPrimitiveTypeChecker('number'),\n    object: createPrimitiveTypeChecker('object'),\n    string: createPrimitiveTypeChecker('string'),\n    symbol: createPrimitiveTypeChecker('symbol'),\n\n    any: createAnyTypeChecker(),\n    arrayOf: createArrayOfTypeChecker,\n    element: createElementTypeChecker(),\n    elementType: createElementTypeTypeChecker(),\n    instanceOf: createInstanceTypeChecker,\n    node: createNodeChecker(),\n    objectOf: createObjectOfTypeChecker,\n    oneOf: createEnumTypeChecker,\n    oneOfType: createUnionTypeChecker,\n    shape: createShapeTypeChecker,\n    exact: createStrictShapeTypeChecker,\n  };\n\n  /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */\n  /*eslint-disable no-self-compare*/\n  function is(x, y) {\n    // SameValue algorithm\n    if (x === y) {\n      // Steps 1-5, 7-10\n      // Steps 6.b-6.e: +0 != -0\n      return x !== 0 || 1 / x === 1 / y;\n    } else {\n      // Step 6.a: NaN == NaN\n      return x !== x && y !== y;\n    }\n  }\n  /*eslint-enable no-self-compare*/\n\n  /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */\n  function PropTypeError(message, data) {\n    this.message = message;\n    this.data = data && typeof data === 'object' ? data: {};\n    this.stack = '';\n  }\n  // Make `instanceof Error` still work for returned errors.\n  PropTypeError.prototype = Error.prototype;\n\n  function createChainableTypeChecker(validate) {\n    if (true) {\n      var manualPropTypeCallCache = {};\n      var manualPropTypeWarningCount = 0;\n    }\n    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n      componentName = componentName || ANONYMOUS;\n      propFullName = propFullName || propName;\n\n      if (secret !== ReactPropTypesSecret) {\n        if (throwOnDirectAccess) {\n          // New behavior only for users of `prop-types` package\n          var err = new Error(\n            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n            'Use `PropTypes.checkPropTypes()` to call them. ' +\n            'Read more at http://fb.me/use-check-prop-types'\n          );\n          err.name = 'Invariant Violation';\n          throw err;\n        } else if ( true && typeof console !== 'undefined') {\n          // Old behavior for people using React.PropTypes\n          var cacheKey = componentName + ':' + propName;\n          if (\n            !manualPropTypeCallCache[cacheKey] &&\n            // Avoid spamming the console because they are often not actionable except for lib authors\n            manualPropTypeWarningCount < 3\n          ) {\n            printWarning(\n              'You are manually calling a React.PropTypes validation ' +\n              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +\n              'and will throw in the standalone `prop-types` package. ' +\n              'You may be seeing this warning due to a third-party PropTypes ' +\n              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'\n            );\n            manualPropTypeCallCache[cacheKey] = true;\n            manualPropTypeWarningCount++;\n          }\n        }\n      }\n      if (props[propName] == null) {\n        if (isRequired) {\n          if (props[propName] === null) {\n            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));\n          }\n          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));\n        }\n        return null;\n      } else {\n        return validate(props, propName, componentName, location, propFullName);\n      }\n    }\n\n    var chainedCheckType = checkType.bind(null, false);\n    chainedCheckType.isRequired = checkType.bind(null, true);\n\n    return chainedCheckType;\n  }\n\n  function createPrimitiveTypeChecker(expectedType) {\n    function validate(props, propName, componentName, location, propFullName, secret) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== expectedType) {\n        // `propValue` being instance of, say, date/regexp, pass the 'object'\n        // check, but we can offer a more precise error message here rather than\n        // 'of type `object`'.\n        var preciseType = getPreciseType(propValue);\n\n        return new PropTypeError(\n          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),\n          {expectedType: expectedType}\n        );\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createAnyTypeChecker() {\n    return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n  }\n\n  function createArrayOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');\n      }\n      var propValue = props[propName];\n      if (!Array.isArray(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));\n      }\n      for (var i = 0; i < propValue.length; i++) {\n        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);\n        if (error instanceof Error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!isValidElement(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createElementTypeTypeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      if (!ReactIs.isValidElementType(propValue)) {\n        var propType = getPropType(propValue);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createInstanceTypeChecker(expectedClass) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!(props[propName] instanceof expectedClass)) {\n        var expectedClassName = expectedClass.name || ANONYMOUS;\n        var actualClassName = getClassName(props[propName]);\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createEnumTypeChecker(expectedValues) {\n    if (!Array.isArray(expectedValues)) {\n      if (true) {\n        if (arguments.length > 1) {\n          printWarning(\n            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +\n            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'\n          );\n        } else {\n          printWarning('Invalid argument supplied to oneOf, expected an array.');\n        }\n      }\n      return emptyFunctionThatReturnsNull;\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      for (var i = 0; i < expectedValues.length; i++) {\n        if (is(propValue, expectedValues[i])) {\n          return null;\n        }\n      }\n\n      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n        var type = getPreciseType(value);\n        if (type === 'symbol') {\n          return String(value);\n        }\n        return value;\n      });\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createObjectOfTypeChecker(typeChecker) {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (typeof typeChecker !== 'function') {\n        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');\n      }\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));\n      }\n      for (var key in propValue) {\n        if (has(propValue, key)) {\n          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n          if (error instanceof Error) {\n            return error;\n          }\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createUnionTypeChecker(arrayOfTypeCheckers) {\n    if (!Array.isArray(arrayOfTypeCheckers)) {\n       true ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : 0;\n      return emptyFunctionThatReturnsNull;\n    }\n\n    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n      var checker = arrayOfTypeCheckers[i];\n      if (typeof checker !== 'function') {\n        printWarning(\n          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +\n          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'\n        );\n        return emptyFunctionThatReturnsNull;\n      }\n    }\n\n    function validate(props, propName, componentName, location, propFullName) {\n      var expectedTypes = [];\n      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {\n        var checker = arrayOfTypeCheckers[i];\n        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n        if (checkerResult == null) {\n          return null;\n        }\n        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {\n          expectedTypes.push(checkerResult.data.expectedType);\n        }\n      }\n      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';\n      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createNodeChecker() {\n    function validate(props, propName, componentName, location, propFullName) {\n      if (!isNode(props[propName])) {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function invalidValidatorError(componentName, location, propFullName, key, type) {\n    return new PropTypeError(\n      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +\n      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'\n    );\n  }\n\n  function createShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      for (var key in shapeTypes) {\n        var checker = shapeTypes[key];\n        if (typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n    return createChainableTypeChecker(validate);\n  }\n\n  function createStrictShapeTypeChecker(shapeTypes) {\n    function validate(props, propName, componentName, location, propFullName) {\n      var propValue = props[propName];\n      var propType = getPropType(propValue);\n      if (propType !== 'object') {\n        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));\n      }\n      // We need to check all keys in case some are required but missing from props.\n      var allKeys = assign({}, props[propName], shapeTypes);\n      for (var key in allKeys) {\n        var checker = shapeTypes[key];\n        if (has(shapeTypes, key) && typeof checker !== 'function') {\n          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n        }\n        if (!checker) {\n          return new PropTypeError(\n            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +\n            '\\nBad object: ' + JSON.stringify(props[propName], null, '  ') +\n            '\\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')\n          );\n        }\n        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);\n        if (error) {\n          return error;\n        }\n      }\n      return null;\n    }\n\n    return createChainableTypeChecker(validate);\n  }\n\n  function isNode(propValue) {\n    switch (typeof propValue) {\n      case 'number':\n      case 'string':\n      case 'undefined':\n        return true;\n      case 'boolean':\n        return !propValue;\n      case 'object':\n        if (Array.isArray(propValue)) {\n          return propValue.every(isNode);\n        }\n        if (propValue === null || isValidElement(propValue)) {\n          return true;\n        }\n\n        var iteratorFn = getIteratorFn(propValue);\n        if (iteratorFn) {\n          var iterator = iteratorFn.call(propValue);\n          var step;\n          if (iteratorFn !== propValue.entries) {\n            while (!(step = iterator.next()).done) {\n              if (!isNode(step.value)) {\n                return false;\n              }\n            }\n          } else {\n            // Iterator will provide entry [k,v] tuples rather than values.\n            while (!(step = iterator.next()).done) {\n              var entry = step.value;\n              if (entry) {\n                if (!isNode(entry[1])) {\n                  return false;\n                }\n              }\n            }\n          }\n        } else {\n          return false;\n        }\n\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  function isSymbol(propType, propValue) {\n    // Native Symbol.\n    if (propType === 'symbol') {\n      return true;\n    }\n\n    // falsy value can't be a Symbol\n    if (!propValue) {\n      return false;\n    }\n\n    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n    if (propValue['@@toStringTag'] === 'Symbol') {\n      return true;\n    }\n\n    // Fallback for non-spec compliant Symbols which are polyfilled.\n    if (typeof Symbol === 'function' && propValue instanceof Symbol) {\n      return true;\n    }\n\n    return false;\n  }\n\n  // Equivalent of `typeof` but with special handling for array and regexp.\n  function getPropType(propValue) {\n    var propType = typeof propValue;\n    if (Array.isArray(propValue)) {\n      return 'array';\n    }\n    if (propValue instanceof RegExp) {\n      // Old webkits (at least until Android 4.0) return 'function' rather than\n      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n      // passes PropTypes.object.\n      return 'object';\n    }\n    if (isSymbol(propType, propValue)) {\n      return 'symbol';\n    }\n    return propType;\n  }\n\n  // This handles more types than `getPropType`. Only used for error messages.\n  // See `createPrimitiveTypeChecker`.\n  function getPreciseType(propValue) {\n    if (typeof propValue === 'undefined' || propValue === null) {\n      return '' + propValue;\n    }\n    var propType = getPropType(propValue);\n    if (propType === 'object') {\n      if (propValue instanceof Date) {\n        return 'date';\n      } else if (propValue instanceof RegExp) {\n        return 'regexp';\n      }\n    }\n    return propType;\n  }\n\n  // Returns a string that is postfixed to a warning about an invalid type.\n  // For example, \"undefined\" or \"of type array\"\n  function getPostfixForTypeWarning(value) {\n    var type = getPreciseType(value);\n    switch (type) {\n      case 'array':\n      case 'object':\n        return 'an ' + type;\n      case 'boolean':\n      case 'date':\n      case 'regexp':\n        return 'a ' + type;\n      default:\n        return type;\n    }\n  }\n\n  // Returns class name of the object, if any.\n  function getClassName(propValue) {\n    if (!propValue.constructor || !propValue.constructor.name) {\n      return ANONYMOUS;\n    }\n    return propValue.constructor.name;\n  }\n\n  ReactPropTypes.checkPropTypes = checkPropTypes;\n  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixjQUFjLG1CQUFPLENBQUMsc0VBQVU7QUFDaEMsYUFBYSxtQkFBTyxDQUFDLG9HQUFlOztBQUVwQywyQkFBMkIsbUJBQU8sQ0FBQyw2R0FBNEI7QUFDL0QsVUFBVSxtQkFBTyxDQUFDLDJFQUFXO0FBQzdCLHFCQUFxQixtQkFBTyxDQUFDLHlGQUFrQjs7QUFFL0M7O0FBRUEsSUFBSSxJQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDViw4QkFBOEI7QUFDOUIsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCw0QkFBNEI7QUFDNUIsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxTQUFTLEtBQXFDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxJQUFxQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLEtBQXFDLDRGQUE0RixDQUFNO0FBQzdJO0FBQ0E7O0FBRUEsb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlIQUFpSDtBQUNqSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanM/ZGM2NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJpZ2ludDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2JpZ2ludCcpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGE6IHt9O1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICAgICAgICAgIHtleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJpbnRXYXJuaW5nKFxuICAgICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnRzIHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBhcnJheSwgZ290ICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMuICcgK1xuICAgICAgICAgICAgJ0EgY29tbW9uIG1pc3Rha2UgaXMgdG8gd3JpdGUgb25lT2YoeCwgeSwgeikgaW5zdGVhZCBvZiBvbmVPZihbeCwgeSwgel0pLidcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByaW50V2FybmluZygnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXkuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzLCBmdW5jdGlvbiByZXBsYWNlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBTdHJpbmcocHJvcFZhbHVlKSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAoaGFzKHByb3BWYWx1ZSwga2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gcHJpbnRXYXJuaW5nKCdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goY2hlY2tlclJlc3VsdC5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGVzTWVzc2FnZSA9IChleHBlY3RlZFR5cGVzLmxlbmd0aCA+IDApID8gJywgZXhwZWN0ZWQgb25lIG9mIHR5cGUgWycgKyBleHBlY3RlZFR5cGVzLmpvaW4oJywgJykgKyAnXSc6ICcnO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCcgKyBleHBlY3RlZFR5cGVzTWVzc2FnZSArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5ICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/prop-types/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (true) {\n  var ReactIs = __webpack_require__(/*! react-is */ \"(app-pages-browser)/./node_modules/react-is/index.js\");\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = __webpack_require__(/*! ./factoryWithTypeCheckers */ \"(app-pages-browser)/./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n} else {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxJQUFJLElBQXFDO0FBQ3pDLGdCQUFnQixtQkFBTyxDQUFDLHNFQUFVOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQywyR0FBMkI7QUFDdEQsRUFBRSxLQUFLLEVBSU4iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanM/YzYxZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js":
/*!*************************************************************!*\
  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!
  \*************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzPzY0MWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/ReactPropTypesSecret.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prop-types/lib/has.js":
/*!********************************************!*\
  !*** ./node_modules/prop-types/lib/has.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanMiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qcz9jMDI3Il0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prop-types/lib/has.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-composer/es/index.js":
/*!*************************************************!*\
  !*** ./node_modules/react-composer/es/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Composer; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"(app-pages-browser)/./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\nfunction Composer(props) {\n  return renderRecursive(props.children, props.components);\n}\n\nComposer.propTypes = {\n  children: (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func).isRequired,\n  components: prop_types__WEBPACK_IMPORTED_MODULE_1___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_1___default().element), (prop_types__WEBPACK_IMPORTED_MODULE_1___default().func)])).isRequired\n};\n\n/**\n * Recursively build up elements from props.components and accumulate `results` along the way.\n * @param {function} render\n * @param {Array.<ReactElement|Function>} remaining\n * @param {Array} [results]\n * @returns {ReactElement}\n */\nfunction renderRecursive(render, remaining, results) {\n  results = results || [];\n  // Once components is exhausted, we can render out the results array.\n  if (!remaining[0]) {\n    return render(results);\n  }\n\n  // Continue recursion for remaining items.\n  // results.concat([value]) ensures [...results, value] instead of [...results, ...value]\n  function nextRender(value) {\n    return renderRecursive(render, remaining.slice(1), results.concat([value]));\n  }\n\n  // Each props.components entry is either an element or function [element factory]\n  return typeof remaining[0] === 'function' ? // When it is a function, produce an element by invoking it with \"render component values\".\n  remaining[0]({ results: results, render: nextRender }) : // When it is an element, enhance the element's props with the render prop.\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.cloneElement)(remaining[0], { children: nextRender });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1jb21wb3Nlci9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxQztBQUNGOztBQUVwQjtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHdEQUFjO0FBQzFCLGNBQWMseURBQWlCLENBQUMsMkRBQW1CLEVBQUUsMkRBQWlCLEVBQUUsd0RBQWM7QUFDdEY7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLCtCQUErQjtBQUMxQyxXQUFXLE9BQU87QUFDbEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0M7QUFDdkQsRUFBRSxtREFBWSxpQkFBaUIsc0JBQXNCO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1jb21wb3Nlci9lcy9pbmRleC5qcz8xMDEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNsb25lRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENvbXBvc2VyKHByb3BzKSB7XG4gIHJldHVybiByZW5kZXJSZWN1cnNpdmUocHJvcHMuY2hpbGRyZW4sIHByb3BzLmNvbXBvbmVudHMpO1xufVxuXG5Db21wb3Nlci5wcm9wVHlwZXMgPSB7XG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICBjb21wb25lbnRzOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZWxlbWVudCwgUHJvcFR5cGVzLmZ1bmNdKSkuaXNSZXF1aXJlZFxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBidWlsZCB1cCBlbGVtZW50cyBmcm9tIHByb3BzLmNvbXBvbmVudHMgYW5kIGFjY3VtdWxhdGUgYHJlc3VsdHNgIGFsb25nIHRoZSB3YXkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSByZW5kZXJcbiAqIEBwYXJhbSB7QXJyYXkuPFJlYWN0RWxlbWVudHxGdW5jdGlvbj59IHJlbWFpbmluZ1xuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcmV0dXJucyB7UmVhY3RFbGVtZW50fVxuICovXG5mdW5jdGlvbiByZW5kZXJSZWN1cnNpdmUocmVuZGVyLCByZW1haW5pbmcsIHJlc3VsdHMpIHtcbiAgcmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG4gIC8vIE9uY2UgY29tcG9uZW50cyBpcyBleGhhdXN0ZWQsIHdlIGNhbiByZW5kZXIgb3V0IHRoZSByZXN1bHRzIGFycmF5LlxuICBpZiAoIXJlbWFpbmluZ1swXSkge1xuICAgIHJldHVybiByZW5kZXIocmVzdWx0cyk7XG4gIH1cblxuICAvLyBDb250aW51ZSByZWN1cnNpb24gZm9yIHJlbWFpbmluZyBpdGVtcy5cbiAgLy8gcmVzdWx0cy5jb25jYXQoW3ZhbHVlXSkgZW5zdXJlcyBbLi4ucmVzdWx0cywgdmFsdWVdIGluc3RlYWQgb2YgWy4uLnJlc3VsdHMsIC4uLnZhbHVlXVxuICBmdW5jdGlvbiBuZXh0UmVuZGVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHJlbmRlclJlY3Vyc2l2ZShyZW5kZXIsIHJlbWFpbmluZy5zbGljZSgxKSwgcmVzdWx0cy5jb25jYXQoW3ZhbHVlXSkpO1xuICB9XG5cbiAgLy8gRWFjaCBwcm9wcy5jb21wb25lbnRzIGVudHJ5IGlzIGVpdGhlciBhbiBlbGVtZW50IG9yIGZ1bmN0aW9uIFtlbGVtZW50IGZhY3RvcnldXG4gIHJldHVybiB0eXBlb2YgcmVtYWluaW5nWzBdID09PSAnZnVuY3Rpb24nID8gLy8gV2hlbiBpdCBpcyBhIGZ1bmN0aW9uLCBwcm9kdWNlIGFuIGVsZW1lbnQgYnkgaW52b2tpbmcgaXQgd2l0aCBcInJlbmRlciBjb21wb25lbnQgdmFsdWVzXCIuXG4gIHJlbWFpbmluZ1swXSh7IHJlc3VsdHM6IHJlc3VsdHMsIHJlbmRlcjogbmV4dFJlbmRlciB9KSA6IC8vIFdoZW4gaXQgaXMgYW4gZWxlbWVudCwgZW5oYW5jZSB0aGUgZWxlbWVudCdzIHByb3BzIHdpdGggdGhlIHJlbmRlciBwcm9wLlxuICBjbG9uZUVsZW1lbnQocmVtYWluaW5nWzBdLCB7IGNoaWxkcmVuOiBuZXh0UmVuZGVyIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-composer/es/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js":
/*!***********************************************************!*\
  !*** ./node_modules/react-is/cjs/react-is.development.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9janMvcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7OztBQUliLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEOztBQUVqRDtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQjtBQUNqQixzQkFBc0I7QUFDdEIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2Ysa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixZQUFZO0FBQ1osWUFBWTtBQUNaLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLGdCQUFnQjtBQUNoQixtQkFBbUI7QUFDbkIsd0JBQXdCO0FBQ3hCLHlCQUF5QjtBQUN6Qix5QkFBeUI7QUFDekIsaUJBQWlCO0FBQ2pCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsY0FBYztBQUNkLGNBQWM7QUFDZCxnQkFBZ0I7QUFDaEIsa0JBQWtCO0FBQ2xCLG9CQUFvQjtBQUNwQixrQkFBa0I7QUFDbEIsMEJBQTBCO0FBQzFCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcz9hMGJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMTMuMVxuICogcmVhY3QtaXMuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3I7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIDogMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJykgOiAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50JykgOiAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJykgOiAweGVhY2M7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJykgOiAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJykgOiAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpIDogMHhlYWNlOyAvLyBUT0RPOiBXZSBkb24ndCB1c2UgQXN5bmNNb2RlIG9yIENvbmN1cnJlbnRNb2RlIGFueW1vcmUuIFRoZXkgd2VyZSB0ZW1wb3Jhcnlcbi8vICh1bnN0YWJsZSkgQVBJcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkLiBDYW4gd2UgcmVtb3ZlIHRoZSBzeW1ib2xzP1xuXG52YXIgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuYXN5bmNfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QuY29uY3VycmVudF9tb2RlJykgOiAweGVhY2Y7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykgOiAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJykgOiAweGVhZDE7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpIDogMHhlYWQ4O1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKSA6IDB4ZWFkMztcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5JykgOiAweGVhZDQ7XG52YXIgUkVBQ1RfQkxPQ0tfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmJsb2NrJykgOiAweGVhZDk7XG52YXIgUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJykgOiAweGVhZDU7XG52YXIgUkVBQ1RfUkVTUE9OREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5yZXNwb25kZXInKSA6IDB4ZWFkNjtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKSA6IDB4ZWFkNztcblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyBOb3RlOiBpdHMgdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgaWYgaXQncyBhIHBvbHlmaWxsLlxuICB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUkVTUE9OREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfU0NPUEVfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFKTtcbn1cblxuZnVuY3Rpb24gdHlwZU9mKG9iamVjdCkge1xuICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyICQkdHlwZW9mID0gb2JqZWN0LiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIHZhciB0eXBlID0gb2JqZWN0LnR5cGU7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB2YXIgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKCQkdHlwZW9mVHlwZSkge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJCR0eXBlb2ZUeXBlO1xuXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgcmV0dXJuICQkdHlwZW9mO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59IC8vIEFzeW5jTW9kZSBpcyBkZXByZWNhdGVkIGFsb25nIHdpdGggaXNBc3luY01vZGVcblxudmFyIEFzeW5jTW9kZSA9IFJFQUNUX0FTWU5DX01PREVfVFlQRTtcbnZhciBDb25jdXJyZW50TW9kZSA9IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xudmFyIENvbnRleHRDb25zdW1lciA9IFJFQUNUX0NPTlRFWFRfVFlQRTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSBSRUFDVF9QUk9WSURFUl9UWVBFO1xudmFyIEVsZW1lbnQgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgRm9yd2FyZFJlZiA9IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU7XG52YXIgRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xudmFyIExhenkgPSBSRUFDVF9MQVpZX1RZUEU7XG52YXIgTWVtbyA9IFJFQUNUX01FTU9fVFlQRTtcbnZhciBQb3J0YWwgPSBSRUFDVF9QT1JUQUxfVFlQRTtcbnZhciBQcm9maWxlciA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG52YXIgU3RyaWN0TW9kZSA9IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG52YXIgU3VzcGVuc2UgPSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xudmFyIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gZmFsc2U7IC8vIEFzeW5jTW9kZSBzaG91bGQgYmUgZGVwcmVjYXRlZFxuXG5mdW5jdGlvbiBpc0FzeW5jTW9kZShvYmplY3QpIHtcbiAge1xuICAgIGlmICghaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUpIHtcbiAgICAgIGhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlID0gdHJ1ZTsgLy8gVXNpbmcgY29uc29sZVsnd2FybiddIHRvIGV2YWRlIEJhYmVsIGFuZCBFU0xpbnRcblxuICAgICAgY29uc29sZVsnd2FybiddKCdUaGUgUmVhY3RJcy5pc0FzeW5jTW9kZSgpIGFsaWFzIGhhcyBiZWVuIGRlcHJlY2F0ZWQsICcgKyAnYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBSZWFjdCAxNysuIFVwZGF0ZSB5b3VyIGNvZGUgdG8gdXNlICcgKyAnUmVhY3RJcy5pc0NvbmN1cnJlbnRNb2RlKCkgaW5zdGVhZC4gSXQgaGFzIHRoZSBleGFjdCBzYW1lIEFQSS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHx8IHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG59XG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRNb2RlKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTkNVUlJFTlRfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0Q29uc3VtZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb250ZXh0UHJvdmlkZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRm9yd2FyZFJlZihvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xufVxuZnVuY3Rpb24gaXNGcmFnbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuZnVuY3Rpb24gaXNMYXp5KG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0xBWllfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTWVtbyhvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9NRU1PX1RZUEU7XG59XG5mdW5jdGlvbiBpc1BvcnRhbChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9QT1JUQUxfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzUHJvZmlsZXIob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3RyaWN0TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNTdXNwZW5zZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFO1xufVxuXG5leHBvcnRzLkFzeW5jTW9kZSA9IEFzeW5jTW9kZTtcbmV4cG9ydHMuQ29uY3VycmVudE1vZGUgPSBDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuQ29udGV4dENvbnN1bWVyID0gQ29udGV4dENvbnN1bWVyO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSBDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLkVsZW1lbnQgPSBFbGVtZW50O1xuZXhwb3J0cy5Gb3J3YXJkUmVmID0gRm9yd2FyZFJlZjtcbmV4cG9ydHMuRnJhZ21lbnQgPSBGcmFnbWVudDtcbmV4cG9ydHMuTGF6eSA9IExhenk7XG5leHBvcnRzLk1lbW8gPSBNZW1vO1xuZXhwb3J0cy5Qb3J0YWwgPSBQb3J0YWw7XG5leHBvcnRzLlByb2ZpbGVyID0gUHJvZmlsZXI7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBTdHJpY3RNb2RlO1xuZXhwb3J0cy5TdXNwZW5zZSA9IFN1c3BlbnNlO1xuZXhwb3J0cy5pc0FzeW5jTW9kZSA9IGlzQXN5bmNNb2RlO1xuZXhwb3J0cy5pc0NvbmN1cnJlbnRNb2RlID0gaXNDb25jdXJyZW50TW9kZTtcbmV4cG9ydHMuaXNDb250ZXh0Q29uc3VtZXIgPSBpc0NvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuaXNDb250ZXh0UHJvdmlkZXIgPSBpc0NvbnRleHRQcm92aWRlcjtcbmV4cG9ydHMuaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuZXhwb3J0cy5pc0ZvcndhcmRSZWYgPSBpc0ZvcndhcmRSZWY7XG5leHBvcnRzLmlzRnJhZ21lbnQgPSBpc0ZyYWdtZW50O1xuZXhwb3J0cy5pc0xhenkgPSBpc0xhenk7XG5leHBvcnRzLmlzTWVtbyA9IGlzTWVtbztcbmV4cG9ydHMuaXNQb3J0YWwgPSBpc1BvcnRhbDtcbmV4cG9ydHMuaXNQcm9maWxlciA9IGlzUHJvZmlsZXI7XG5leHBvcnRzLmlzU3RyaWN0TW9kZSA9IGlzU3RyaWN0TW9kZTtcbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGlzU3VzcGVuc2U7XG5leHBvcnRzLmlzVmFsaWRFbGVtZW50VHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZTtcbmV4cG9ydHMudHlwZU9mID0gdHlwZU9mO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-is/index.js":
/*!****************************************!*\
  !*** ./node_modules/react-is/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-is.development.js */ \"(app-pages-browser)/./node_modules/react-is/cjs/react-is.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsb0pBQXlEO0FBQzNEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcz9kMjk0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-is/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/troika-three-text/dist/troika-three-text.esm.js":
/*!**********************************************************************!*\
  !*** ./node_modules/troika-three-text/dist/troika-three-text.esm.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BatchedText: function() { return /* binding */ BatchedText; },\n/* harmony export */   GlyphsGeometry: function() { return /* binding */ GlyphsGeometry; },\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   configureTextBuilder: function() { return /* binding */ configureTextBuilder; },\n/* harmony export */   createTextDerivedMaterial: function() { return /* binding */ createTextDerivedMaterial; },\n/* harmony export */   dumpSDFTextures: function() { return /* binding */ dumpSDFTextures; },\n/* harmony export */   fontResolverWorkerModule: function() { return /* binding */ fontResolverWorkerModule; },\n/* harmony export */   getCaretAtPoint: function() { return /* binding */ getCaretAtPoint; },\n/* harmony export */   getSelectionRects: function() { return /* binding */ getSelectionRects; },\n/* harmony export */   getTextRenderInfo: function() { return /* binding */ getTextRenderInfo; },\n/* harmony export */   preloadFont: function() { return /* binding */ preloadFont; },\n/* harmony export */   typesetterWorkerModule: function() { return /* binding */ typesetterWorkerModule; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! troika-worker-utils */ \"(app-pages-browser)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\");\n/* harmony import */ var webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! webgl-sdf-generator */ \"(app-pages-browser)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\");\n/* harmony import */ var bidi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bidi-js */ \"(app-pages-browser)/./node_modules/bidi-js/dist/bidi.mjs\");\n/* harmony import */ var troika_three_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! troika-three-utils */ \"(app-pages-browser)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\");\n\n\n\n\n\n\n/*!\nCustom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.\nOriginal MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE\n*/\nfunction typrFactory(){return \"undefined\"==typeof window&&(self.window=self),function(r){var e={parse:function(r){var t=e._bin,a=new Uint8Array(r);if(\"ttcf\"==t.readASCII(a,0,4)){var n=4;t.readUshort(a,n),n+=2,t.readUshort(a,n),n+=2;var o=t.readUint(a,n);n+=4;for(var s=[],i=0;i<o;i++){var h=t.readUint(a,n);n+=4,s.push(e._readFont(a,h));}return s}return [e._readFont(a,0)]},_readFont:function(r,t){var a=e._bin,n=t;a.readFixed(r,t),t+=4;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2;for(var s=[\"cmap\",\"head\",\"hhea\",\"maxp\",\"hmtx\",\"name\",\"OS/2\",\"post\",\"loca\",\"glyf\",\"kern\",\"CFF \",\"GDEF\",\"GPOS\",\"GSUB\",\"SVG \"],i={_data:r,_offset:n},h={},d=0;d<o;d++){var f=a.readASCII(r,t,4);t+=4,a.readUint(r,t),t+=4;var u=a.readUint(r,t);t+=4;var l=a.readUint(r,t);t+=4,h[f]={offset:u,length:l};}for(d=0;d<s.length;d++){var v=s[d];h[v]&&(i[v.trim()]=e[v.trim()].parse(r,h[v].offset,h[v].length,i));}return i},_tabOffset:function(r,t,a){for(var n=e._bin,o=n.readUshort(r,a+4),s=a+12,i=0;i<o;i++){var h=n.readASCII(r,s,4);s+=4,n.readUint(r,s),s+=4;var d=n.readUint(r,s);if(s+=4,n.readUint(r,s),s+=4,h==t)return d}return 0}};e._bin={readFixed:function(r,e){return (r[e]<<8|r[e+1])+(r[e+2]<<8|r[e+3])/65540},readF2dot14:function(r,t){return e._bin.readShort(r,t)/16384},readInt:function(r,t){return e._bin._view(r).getInt32(t)},readInt8:function(r,t){return e._bin._view(r).getInt8(t)},readShort:function(r,t){return e._bin._view(r).getInt16(t)},readUshort:function(r,t){return e._bin._view(r).getUint16(t)},readUshorts:function(r,t,a){for(var n=[],o=0;o<a;o++)n.push(e._bin.readUshort(r,t+2*o));return n},readUint:function(r,t){return e._bin._view(r).getUint32(t)},readUint64:function(r,t){return 4294967296*e._bin.readUint(r,t)+e._bin.readUint(r,t+4)},readASCII:function(r,e,t){for(var a=\"\",n=0;n<t;n++)a+=String.fromCharCode(r[e+n]);return a},readUnicode:function(r,e,t){for(var a=\"\",n=0;n<t;n++){var o=r[e++]<<8|r[e++];a+=String.fromCharCode(o);}return a},_tdec:\"undefined\"!=typeof window&&window.TextDecoder?new window.TextDecoder:null,readUTF8:function(r,t,a){var n=e._bin._tdec;return n&&0==t&&a==r.length?n.decode(r):e._bin.readASCII(r,t,a)},readBytes:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(r[e+n]);return a},readASCIIArray:function(r,e,t){for(var a=[],n=0;n<t;n++)a.push(String.fromCharCode(r[e+n]));return a},_view:function(r){return r._dataView||(r._dataView=r.buffer?new DataView(r.buffer,r.byteOffset,r.byteLength):new DataView(new Uint8Array(r).buffer))}},e._lctf={},e._lctf.parse=function(r,t,a,n,o){var s=e._bin,i={},h=t;s.readFixed(r,t),t+=4;var d=s.readUshort(r,t);t+=2;var f=s.readUshort(r,t);t+=2;var u=s.readUshort(r,t);return t+=2,i.scriptList=e._lctf.readScriptList(r,h+d),i.featureList=e._lctf.readFeatureList(r,h+f),i.lookupList=e._lctf.readLookupList(r,h+u,o),i},e._lctf.readLookupList=function(r,t,a){var n=e._bin,o=t,s=[],i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=n.readUshort(r,t);t+=2;var f=e._lctf.readLookupTable(r,o+d,a);s.push(f);}return s},e._lctf.readLookupTable=function(r,t,a){var n=e._bin,o=t,s={tabs:[]};s.ltype=n.readUshort(r,t),t+=2,s.flag=n.readUshort(r,t),t+=2;var i=n.readUshort(r,t);t+=2;for(var h=s.ltype,d=0;d<i;d++){var f=n.readUshort(r,t);t+=2;var u=a(r,h,o+f,s);s.tabs.push(u);}return s},e._lctf.numOfOnes=function(r){for(var e=0,t=0;t<32;t++)0!=(r>>>t&1)&&e++;return e},e._lctf.readClassDef=function(r,t){var a=e._bin,n=[],o=a.readUshort(r,t);if(t+=2,1==o){var s=a.readUshort(r,t);t+=2;var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++)n.push(s+h),n.push(s+h),n.push(a.readUshort(r,t)),t+=2;}if(2==o){var d=a.readUshort(r,t);t+=2;for(h=0;h<d;h++)n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2,n.push(a.readUshort(r,t)),t+=2;}return n},e._lctf.getInterval=function(r,e){for(var t=0;t<r.length;t+=3){var a=r[t],n=r[t+1];if(r[t+2],a<=e&&e<=n)return t}return -1},e._lctf.readCoverage=function(r,t){var a=e._bin,n={};n.fmt=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,1==n.fmt&&(n.tab=a.readUshorts(r,t,o)),2==n.fmt&&(n.tab=a.readUshorts(r,t,3*o)),n},e._lctf.coverageIndex=function(r,t){var a=r.tab;if(1==r.fmt)return a.indexOf(t);if(2==r.fmt){var n=e._lctf.getInterval(a,t);if(-1!=n)return a[n+2]+(t-a[n])}return -1},e._lctf.readFeatureList=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2;var f=e._lctf.readFeatureTable(r,n+d);f.tag=h.trim(),o.push(f);}return o},e._lctf.readFeatureTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.featureParams=n+s);var i=a.readUshort(r,t);t+=2,o.tab=[];for(var h=0;h<i;h++)o.tab.push(a.readUshort(r,t+2*h));return o},e._lctf.readScriptList=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readASCII(r,t,4);t+=4;var d=a.readUshort(r,t);t+=2,o[h.trim()]=e._lctf.readScriptTable(r,n+d);}return o},e._lctf.readScriptTable=function(r,t){var a=e._bin,n=t,o={},s=a.readUshort(r,t);t+=2,s>0&&(o.default=e._lctf.readLangSysTable(r,n+s));var i=a.readUshort(r,t);t+=2;for(var h=0;h<i;h++){var d=a.readASCII(r,t,4);t+=4;var f=a.readUshort(r,t);t+=2,o[d.trim()]=e._lctf.readLangSysTable(r,n+f);}return o},e._lctf.readLangSysTable=function(r,t){var a=e._bin,n={};a.readUshort(r,t),t+=2,n.reqFeature=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);return t+=2,n.features=a.readUshorts(r,t,o),n},e.CFF={},e.CFF.parse=function(r,t,a){var n=e._bin;(r=new Uint8Array(r.buffer,t,a))[t=0],r[++t],r[++t],r[++t],t++;var o=[];t=e.CFF.readIndex(r,t,o);for(var s=[],i=0;i<o.length-1;i++)s.push(n.readASCII(r,t+o[i],o[i+1]-o[i]));t+=o[o.length-1];var h=[];t=e.CFF.readIndex(r,t,h);var d=[];for(i=0;i<h.length-1;i++)d.push(e.CFF.readDict(r,t+h[i],t+h[i+1]));t+=h[h.length-1];var f=d[0],u=[];t=e.CFF.readIndex(r,t,u);var l=[];for(i=0;i<u.length-1;i++)l.push(n.readASCII(r,t+u[i],u[i+1]-u[i]));if(t+=u[u.length-1],e.CFF.readSubrs(r,t,f),f.CharStrings){t=f.CharStrings;u=[];t=e.CFF.readIndex(r,t,u);var v=[];for(i=0;i<u.length-1;i++)v.push(n.readBytes(r,t+u[i],u[i+1]-u[i]));f.CharStrings=v;}if(f.ROS){t=f.FDArray;var c=[];t=e.CFF.readIndex(r,t,c),f.FDArray=[];for(i=0;i<c.length-1;i++){var p=e.CFF.readDict(r,t+c[i],t+c[i+1]);e.CFF._readFDict(r,p,l),f.FDArray.push(p);}t+=c[c.length-1],t=f.FDSelect,f.FDSelect=[];var U=r[t];if(t++,3!=U)throw U;var g=n.readUshort(r,t);t+=2;for(i=0;i<g+1;i++)f.FDSelect.push(n.readUshort(r,t),r[t+2]),t+=3;}return f.Encoding&&(f.Encoding=e.CFF.readEncoding(r,f.Encoding,f.CharStrings.length)),f.charset&&(f.charset=e.CFF.readCharset(r,f.charset,f.CharStrings.length)),e.CFF._readFDict(r,f,l),f},e.CFF._readFDict=function(r,t,a){var n;for(var o in t.Private&&(n=t.Private[1],t.Private=e.CFF.readDict(r,n,n+t.Private[0]),t.Private.Subrs&&e.CFF.readSubrs(r,n+t.Private.Subrs,t.Private)),t)-1!=[\"FamilyName\",\"FontName\",\"FullName\",\"Notice\",\"version\",\"Copyright\"].indexOf(o)&&(t[o]=a[t[o]-426+35]);},e.CFF.readSubrs=function(r,t,a){var n=e._bin,o=[];t=e.CFF.readIndex(r,t,o);var s,i=o.length;s=i<1240?107:i<33900?1131:32768,a.Bias=s,a.Subrs=[];for(var h=0;h<o.length-1;h++)a.Subrs.push(n.readBytes(r,t+o[h],o[h+1]-o[h]));},e.CFF.tableSE=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,0,111,112,113,114,0,115,116,117,118,119,120,121,122,0,123,0,124,125,126,127,128,129,130,131,0,132,133,0,134,135,136,137,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,138,0,139,0,0,0,0,140,141,142,143,0,0,0,0,0,144,0,0,0,145,0,0,146,147,148,149,0,0,0,0],e.CFF.glyphByUnicode=function(r,e){for(var t=0;t<r.charset.length;t++)if(r.charset[t]==e)return t;return -1},e.CFF.glyphBySE=function(r,t){return t<0||t>255?-1:e.CFF.glyphByUnicode(r,e.CFF.tableSE[t])},e.CFF.readEncoding=function(r,t,a){e._bin;var n=[\".notdef\"],o=r[t];if(t++,0!=o)throw \"error: unknown encoding format: \"+o;var s=r[t];t++;for(var i=0;i<s;i++)n.push(r[t+i]);return n},e.CFF.readCharset=function(r,t,a){var n=e._bin,o=[\".notdef\"],s=r[t];if(t++,0==s)for(var i=0;i<a;i++){var h=n.readUshort(r,t);t+=2,o.push(h);}else {if(1!=s&&2!=s)throw \"error: format: \"+s;for(;o.length<a;){h=n.readUshort(r,t);t+=2;var d=0;1==s?(d=r[t],t++):(d=n.readUshort(r,t),t+=2);for(i=0;i<=d;i++)o.push(h),h++;}}return o},e.CFF.readIndex=function(r,t,a){var n=e._bin,o=n.readUshort(r,t)+1,s=r[t+=2];if(t++,1==s)for(var i=0;i<o;i++)a.push(r[t+i]);else if(2==s)for(i=0;i<o;i++)a.push(n.readUshort(r,t+2*i));else if(3==s)for(i=0;i<o;i++)a.push(16777215&n.readUint(r,t+3*i-1));else if(1!=o)throw \"unsupported offset size: \"+s+\", count: \"+o;return (t+=o*s)-1},e.CFF.getCharString=function(r,t,a){var n=e._bin,o=r[t],s=r[t+1];r[t+2],r[t+3],r[t+4];var i=1,h=null,d=null;o<=20&&(h=o,i=1),12==o&&(h=100*o+s,i=2),21<=o&&o<=27&&(h=o,i=1),28==o&&(d=n.readShort(r,t+1),i=3),29<=o&&o<=31&&(h=o,i=1),32<=o&&o<=246&&(d=o-139,i=1),247<=o&&o<=250&&(d=256*(o-247)+s+108,i=2),251<=o&&o<=254&&(d=256*-(o-251)-s-108,i=2),255==o&&(d=n.readInt(r,t+1)/65535,i=5),a.val=null!=d?d:\"o\"+h,a.size=i;},e.CFF.readCharString=function(r,t,a){for(var n=t+a,o=e._bin,s=[];t<n;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;i<=20&&(f=i,d=1),12==i&&(f=100*i+h,d=2),19!=i&&20!=i||(f=i,d=2),21<=i&&i<=27&&(f=i,d=1),28==i&&(u=o.readShort(r,t+1),d=3),29<=i&&i<=31&&(f=i,d=1),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i&&(u=o.readInt(r,t+1)/65535,d=5),s.push(null!=u?u:\"o\"+f),t+=d;}return s},e.CFF.readDict=function(r,t,a){for(var n=e._bin,o={},s=[];t<a;){var i=r[t],h=r[t+1];r[t+2],r[t+3],r[t+4];var d=1,f=null,u=null;if(28==i&&(u=n.readShort(r,t+1),d=3),29==i&&(u=n.readInt(r,t+1),d=5),32<=i&&i<=246&&(u=i-139,d=1),247<=i&&i<=250&&(u=256*(i-247)+h+108,d=2),251<=i&&i<=254&&(u=256*-(i-251)-h-108,d=2),255==i)throw u=n.readInt(r,t+1)/65535,d=5,\"unknown number\";if(30==i){var l=[];for(d=1;;){var v=r[t+d];d++;var c=v>>4,p=15&v;if(15!=c&&l.push(c),15!=p&&l.push(p),15==p)break}for(var U=\"\",g=[0,1,2,3,4,5,6,7,8,9,\".\",\"e\",\"e-\",\"reserved\",\"-\",\"endOfNumber\"],S=0;S<l.length;S++)U+=g[l[S]];u=parseFloat(U);}if(i<=21)if(f=[\"version\",\"Notice\",\"FullName\",\"FamilyName\",\"Weight\",\"FontBBox\",\"BlueValues\",\"OtherBlues\",\"FamilyBlues\",\"FamilyOtherBlues\",\"StdHW\",\"StdVW\",\"escape\",\"UniqueID\",\"XUID\",\"charset\",\"Encoding\",\"CharStrings\",\"Private\",\"Subrs\",\"defaultWidthX\",\"nominalWidthX\"][i],d=1,12==i)f=[\"Copyright\",\"isFixedPitch\",\"ItalicAngle\",\"UnderlinePosition\",\"UnderlineThickness\",\"PaintType\",\"CharstringType\",\"FontMatrix\",\"StrokeWidth\",\"BlueScale\",\"BlueShift\",\"BlueFuzz\",\"StemSnapH\",\"StemSnapV\",\"ForceBold\",0,0,\"LanguageGroup\",\"ExpansionFactor\",\"initialRandomSeed\",\"SyntheticBase\",\"PostScript\",\"BaseFontName\",\"BaseFontBlend\",0,0,0,0,0,0,\"ROS\",\"CIDFontVersion\",\"CIDFontRevision\",\"CIDFontType\",\"CIDCount\",\"UIDBase\",\"FDArray\",\"FDSelect\",\"FontName\"][h],d=2;null!=f?(o[f]=1==s.length?s[0]:s,s=[]):s.push(u),t+=d;}return o},e.cmap={},e.cmap.parse=function(r,t,a){r=new Uint8Array(r.buffer,t,a),t=0;var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2;var i=[];o.tables=[];for(var h=0;h<s;h++){var d=n.readUshort(r,t);t+=2;var f=n.readUshort(r,t);t+=2;var u=n.readUint(r,t);t+=4;var l=\"p\"+d+\"e\"+f,v=i.indexOf(u);if(-1==v){var c;v=o.tables.length,i.push(u);var p=n.readUshort(r,u);0==p?c=e.cmap.parse0(r,u):4==p?c=e.cmap.parse4(r,u):6==p?c=e.cmap.parse6(r,u):12==p?c=e.cmap.parse12(r,u):console.debug(\"unknown format: \"+p,d,f,u),o.tables.push(c);}if(null!=o[l])throw \"multiple tables for one platform+encoding\";o[l]=v;}return o},e.cmap.parse0=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2,n.map=[];for(var s=0;s<o-6;s++)n.map.push(r[t+s]);return n},e.cmap.parse4=function(r,t){var a=e._bin,n=t,o={};o.format=a.readUshort(r,t),t+=2;var s=a.readUshort(r,t);t+=2,a.readUshort(r,t),t+=2;var i=a.readUshort(r,t);t+=2;var h=i/2;o.searchRange=a.readUshort(r,t),t+=2,o.entrySelector=a.readUshort(r,t),t+=2,o.rangeShift=a.readUshort(r,t),t+=2,o.endCount=a.readUshorts(r,t,h),t+=2*h,t+=2,o.startCount=a.readUshorts(r,t,h),t+=2*h,o.idDelta=[];for(var d=0;d<h;d++)o.idDelta.push(a.readShort(r,t)),t+=2;for(o.idRangeOffset=a.readUshorts(r,t,h),t+=2*h,o.glyphIdArray=[];t<n+s;)o.glyphIdArray.push(a.readUshort(r,t)),t+=2;return o},e.cmap.parse6=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,a.readUshort(r,t),t+=2,n.firstCode=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2,n.glyphIdArray=[];for(var s=0;s<o;s++)n.glyphIdArray.push(a.readUshort(r,t)),t+=2;return n},e.cmap.parse12=function(r,t){var a=e._bin,n={};n.format=a.readUshort(r,t),t+=2,t+=2,a.readUint(r,t),t+=4,a.readUint(r,t),t+=4;var o=a.readUint(r,t);t+=4,n.groups=[];for(var s=0;s<o;s++){var i=t+12*s,h=a.readUint(r,i+0),d=a.readUint(r,i+4),f=a.readUint(r,i+8);n.groups.push([h,d,f]);}return n},e.glyf={},e.glyf.parse=function(r,e,t,a){for(var n=[],o=0;o<a.maxp.numGlyphs;o++)n.push(null);return n},e.glyf._parseGlyf=function(r,t){var a=e._bin,n=r._data,o=e._tabOffset(n,\"glyf\",r._offset)+r.loca[t];if(r.loca[t]==r.loca[t+1])return null;var s={};if(s.noc=a.readShort(n,o),o+=2,s.xMin=a.readShort(n,o),o+=2,s.yMin=a.readShort(n,o),o+=2,s.xMax=a.readShort(n,o),o+=2,s.yMax=a.readShort(n,o),o+=2,s.xMin>=s.xMax||s.yMin>=s.yMax)return null;if(s.noc>0){s.endPts=[];for(var i=0;i<s.noc;i++)s.endPts.push(a.readUshort(n,o)),o+=2;var h=a.readUshort(n,o);if(o+=2,n.length-o<h)return null;s.instructions=a.readBytes(n,o,h),o+=h;var d=s.endPts[s.noc-1]+1;s.flags=[];for(i=0;i<d;i++){var f=n[o];if(o++,s.flags.push(f),0!=(8&f)){var u=n[o];o++;for(var l=0;l<u;l++)s.flags.push(f),i++;}}s.xs=[];for(i=0;i<d;i++){var v=0!=(2&s.flags[i]),c=0!=(16&s.flags[i]);v?(s.xs.push(c?n[o]:-n[o]),o++):c?s.xs.push(0):(s.xs.push(a.readShort(n,o)),o+=2);}s.ys=[];for(i=0;i<d;i++){v=0!=(4&s.flags[i]),c=0!=(32&s.flags[i]);v?(s.ys.push(c?n[o]:-n[o]),o++):c?s.ys.push(0):(s.ys.push(a.readShort(n,o)),o+=2);}var p=0,U=0;for(i=0;i<d;i++)p+=s.xs[i],U+=s.ys[i],s.xs[i]=p,s.ys[i]=U;}else {var g;s.parts=[];do{g=a.readUshort(n,o),o+=2;var S={m:{a:1,b:0,c:0,d:1,tx:0,ty:0},p1:-1,p2:-1};if(s.parts.push(S),S.glyphIndex=a.readUshort(n,o),o+=2,1&g){var m=a.readShort(n,o);o+=2;var b=a.readShort(n,o);o+=2;}else {m=a.readInt8(n,o);o++;b=a.readInt8(n,o);o++;}2&g?(S.m.tx=m,S.m.ty=b):(S.p1=m,S.p2=b),8&g?(S.m.a=S.m.d=a.readF2dot14(n,o),o+=2):64&g?(S.m.a=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2):128&g&&(S.m.a=a.readF2dot14(n,o),o+=2,S.m.b=a.readF2dot14(n,o),o+=2,S.m.c=a.readF2dot14(n,o),o+=2,S.m.d=a.readF2dot14(n,o),o+=2);}while(32&g);if(256&g){var y=a.readUshort(n,o);o+=2,s.instr=[];for(i=0;i<y;i++)s.instr.push(n[o]),o++;}}return s},e.GDEF={},e.GDEF.parse=function(r,t,a,n){var o=t;t+=4;var s=e._bin.readUshort(r,t);return {glyphClassDef:0===s?null:e._lctf.readClassDef(r,o+s)}},e.GPOS={},e.GPOS.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GPOS.subt)},e.GPOS.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1==t||2==t||3==t||7==t||8==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,h+s);}if(1==t&&1==i.fmt){var d=o.readUshort(r,a);a+=2,0!=d&&(i.pos=e.GPOS.readValueRecord(r,a,d));}else if(2==t&&i.fmt>=1&&i.fmt<=2){d=o.readUshort(r,a);a+=2;var f=o.readUshort(r,a);a+=2;var u=e._lctf.numOfOnes(d),l=e._lctf.numOfOnes(f);if(1==i.fmt){i.pairsets=[];var v=o.readUshort(r,a);a+=2;for(var c=0;c<v;c++){var p=s+o.readUshort(r,a);a+=2;var U=o.readUshort(r,p);p+=2;for(var g=[],S=0;S<U;S++){var m=o.readUshort(r,p);p+=2,0!=d&&(P=e.GPOS.readValueRecord(r,p,d),p+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,p,f),p+=2*l),g.push({gid2:m,val1:P,val2:x});}i.pairsets.push(g);}}if(2==i.fmt){var b=o.readUshort(r,a);a+=2;var y=o.readUshort(r,a);a+=2;var F=o.readUshort(r,a);a+=2;var C=o.readUshort(r,a);a+=2,i.classDef1=e._lctf.readClassDef(r,s+b),i.classDef2=e._lctf.readClassDef(r,s+y),i.matrix=[];for(c=0;c<F;c++){var _=[];for(S=0;S<C;S++){var P=null,x=null;0!=d&&(P=e.GPOS.readValueRecord(r,a,d),a+=2*u),0!=f&&(x=e.GPOS.readValueRecord(r,a,f),a+=2*l),_.push({val1:P,val2:x});}i.matrix.push(_);}}}else if(4==t&&1==i.fmt)i.markCoverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.baseCoverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.markArray=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.baseArray=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else if(6==t&&1==i.fmt)i.mark1Coverage=e._lctf.readCoverage(r,o.readUshort(r,a)+s),i.mark2Coverage=e._lctf.readCoverage(r,o.readUshort(r,a+2)+s),i.markClassCount=o.readUshort(r,a+4),i.mark1Array=e.GPOS.readMarkArray(r,o.readUshort(r,a+6)+s),i.mark2Array=e.GPOS.readBaseArray(r,o.readUshort(r,a+8)+s,i.markClassCount);else {if(9==t&&1==i.fmt){var I=o.readUshort(r,a);a+=2;var w=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=I;else if(n.ltype!=I)throw \"invalid extension substitution\";return e.GPOS.subt(r,n.ltype,s+w)}console.debug(\"unsupported GPOS table LookupType\",t,\"format\",i.fmt);}return i},e.GPOS.readValueRecord=function(r,t,a){var n=e._bin,o=[];return o.push(1&a?n.readShort(r,t):0),t+=1&a?2:0,o.push(2&a?n.readShort(r,t):0),t+=2&a?2:0,o.push(4&a?n.readShort(r,t):0),t+=4&a?2:0,o.push(8&a?n.readShort(r,t):0),t+=8&a?2:0,o},e.GPOS.readBaseArray=function(r,t,a){var n=e._bin,o=[],s=t,i=n.readUshort(r,t);t+=2;for(var h=0;h<i;h++){for(var d=[],f=0;f<a;f++)d.push(e.GPOS.readAnchorRecord(r,s+n.readUshort(r,t))),t+=2;o.push(d);}return o},e.GPOS.readMarkArray=function(r,t){var a=e._bin,n=[],o=t,s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=e.GPOS.readAnchorRecord(r,a.readUshort(r,t+2)+o);h.markClass=a.readUshort(r,t),n.push(h),t+=4;}return n},e.GPOS.readAnchorRecord=function(r,t){var a=e._bin,n={};return n.fmt=a.readUshort(r,t),n.x=a.readShort(r,t+2),n.y=a.readShort(r,t+4),n},e.GSUB={},e.GSUB.parse=function(r,t,a,n){return e._lctf.parse(r,t,a,n,e.GSUB.subt)},e.GSUB.subt=function(r,t,a,n){var o=e._bin,s=a,i={};if(i.fmt=o.readUshort(r,a),a+=2,1!=t&&2!=t&&4!=t&&5!=t&&6!=t)return null;if(1==t||2==t||4==t||5==t&&i.fmt<=2||6==t&&i.fmt<=2){var h=o.readUshort(r,a);a+=2,i.coverage=e._lctf.readCoverage(r,s+h);}if(1==t&&i.fmt>=1&&i.fmt<=2){if(1==i.fmt)i.delta=o.readShort(r,a),a+=2;else if(2==i.fmt){var d=o.readUshort(r,a);a+=2,i.newg=o.readUshorts(r,a,d),a+=2*i.newg.length;}}else if(2==t&&1==i.fmt){d=o.readUshort(r,a);a+=2,i.seqs=[];for(var f=0;f<d;f++){var u=o.readUshort(r,a)+s;a+=2;var l=o.readUshort(r,u);i.seqs.push(o.readUshorts(r,u+2,l));}}else if(4==t){i.vals=[];d=o.readUshort(r,a);a+=2;for(f=0;f<d;f++){var v=o.readUshort(r,a);a+=2,i.vals.push(e.GSUB.readLigatureSet(r,s+v));}}else if(5==t&&2==i.fmt){if(2==i.fmt){var c=o.readUshort(r,a);a+=2,i.cDef=e._lctf.readClassDef(r,s+c),i.scset=[];var p=o.readUshort(r,a);a+=2;for(f=0;f<p;f++){var U=o.readUshort(r,a);a+=2,i.scset.push(0==U?null:e.GSUB.readSubClassSet(r,s+U));}}}else if(6==t&&3==i.fmt){if(3==i.fmt){for(f=0;f<3;f++){d=o.readUshort(r,a);a+=2;for(var g=[],S=0;S<d;S++)g.push(e._lctf.readCoverage(r,s+o.readUshort(r,a+2*S)));a+=2*d,0==f&&(i.backCvg=g),1==f&&(i.inptCvg=g),2==f&&(i.ahedCvg=g);}d=o.readUshort(r,a);a+=2,i.lookupRec=e.GSUB.readSubstLookupRecords(r,a,d);}}else {if(7==t&&1==i.fmt){var m=o.readUshort(r,a);a+=2;var b=o.readUint(r,a);if(a+=4,9==n.ltype)n.ltype=m;else if(n.ltype!=m)throw \"invalid extension substitution\";return e.GSUB.subt(r,n.ltype,s+b)}console.debug(\"unsupported GSUB table LookupType\",t,\"format\",i.fmt);}return i},e.GSUB.readSubClassSet=function(r,t){var a=e._bin.readUshort,n=t,o=[],s=a(r,t);t+=2;for(var i=0;i<s;i++){var h=a(r,t);t+=2,o.push(e.GSUB.readSubClassRule(r,n+h));}return o},e.GSUB.readSubClassRule=function(r,t){var a=e._bin.readUshort,n={},o=a(r,t),s=a(r,t+=2);t+=2,n.input=[];for(var i=0;i<o-1;i++)n.input.push(a(r,t)),t+=2;return n.substLookupRecords=e.GSUB.readSubstLookupRecords(r,t,s),n},e.GSUB.readSubstLookupRecords=function(r,t,a){for(var n=e._bin.readUshort,o=[],s=0;s<a;s++)o.push(n(r,t),n(r,t+2)),t+=4;return o},e.GSUB.readChainSubClassSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readChainSubClassRule(r,n+h));}return o},e.GSUB.readChainSubClassRule=function(r,t){for(var a=e._bin,n={},o=[\"backtrack\",\"input\",\"lookahead\"],s=0;s<o.length;s++){var i=a.readUshort(r,t);t+=2,1==s&&i--,n[o[s]]=a.readUshorts(r,t,i),t+=2*n[o[s]].length;}i=a.readUshort(r,t);return t+=2,n.subst=a.readUshorts(r,t,2*i),t+=2*n.subst.length,n},e.GSUB.readLigatureSet=function(r,t){var a=e._bin,n=t,o=[],s=a.readUshort(r,t);t+=2;for(var i=0;i<s;i++){var h=a.readUshort(r,t);t+=2,o.push(e.GSUB.readLigature(r,n+h));}return o},e.GSUB.readLigature=function(r,t){var a=e._bin,n={chain:[]};n.nglyph=a.readUshort(r,t),t+=2;var o=a.readUshort(r,t);t+=2;for(var s=0;s<o-1;s++)n.chain.push(a.readUshort(r,t)),t+=2;return n},e.head={},e.head.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.fontRevision=n.readFixed(r,t),t+=4,n.readUint(r,t),t+=4,n.readUint(r,t),t+=4,o.flags=n.readUshort(r,t),t+=2,o.unitsPerEm=n.readUshort(r,t),t+=2,o.created=n.readUint64(r,t),t+=8,o.modified=n.readUint64(r,t),t+=8,o.xMin=n.readShort(r,t),t+=2,o.yMin=n.readShort(r,t),t+=2,o.xMax=n.readShort(r,t),t+=2,o.yMax=n.readShort(r,t),t+=2,o.macStyle=n.readUshort(r,t),t+=2,o.lowestRecPPEM=n.readUshort(r,t),t+=2,o.fontDirectionHint=n.readShort(r,t),t+=2,o.indexToLocFormat=n.readShort(r,t),t+=2,o.glyphDataFormat=n.readShort(r,t),t+=2,o},e.hhea={},e.hhea.parse=function(r,t,a){var n=e._bin,o={};return n.readFixed(r,t),t+=4,o.ascender=n.readShort(r,t),t+=2,o.descender=n.readShort(r,t),t+=2,o.lineGap=n.readShort(r,t),t+=2,o.advanceWidthMax=n.readUshort(r,t),t+=2,o.minLeftSideBearing=n.readShort(r,t),t+=2,o.minRightSideBearing=n.readShort(r,t),t+=2,o.xMaxExtent=n.readShort(r,t),t+=2,o.caretSlopeRise=n.readShort(r,t),t+=2,o.caretSlopeRun=n.readShort(r,t),t+=2,o.caretOffset=n.readShort(r,t),t+=2,t+=8,o.metricDataFormat=n.readShort(r,t),t+=2,o.numberOfHMetrics=n.readUshort(r,t),t+=2,o},e.hmtx={},e.hmtx.parse=function(r,t,a,n){for(var o=e._bin,s={aWidth:[],lsBearing:[]},i=0,h=0,d=0;d<n.maxp.numGlyphs;d++)d<n.hhea.numberOfHMetrics&&(i=o.readUshort(r,t),t+=2,h=o.readShort(r,t),t+=2),s.aWidth.push(i),s.lsBearing.push(h);return s},e.kern={},e.kern.parse=function(r,t,a,n){var o=e._bin,s=o.readUshort(r,t);if(t+=2,1==s)return e.kern.parseV1(r,t-2,a,n);var i=o.readUshort(r,t);t+=2;for(var h={glyph1:[],rval:[]},d=0;d<i;d++){t+=2;a=o.readUshort(r,t);t+=2;var f=o.readUshort(r,t);t+=2;var u=f>>>8;if(0!=(u&=15))throw \"unknown kern table format: \"+u;t=e.kern.readFormat0(r,t,h);}return h},e.kern.parseV1=function(r,t,a,n){var o=e._bin;o.readFixed(r,t),t+=4;var s=o.readUint(r,t);t+=4;for(var i={glyph1:[],rval:[]},h=0;h<s;h++){o.readUint(r,t),t+=4;var d=o.readUshort(r,t);t+=2,o.readUshort(r,t),t+=2;var f=d>>>8;if(0!=(f&=15))throw \"unknown kern table format: \"+f;t=e.kern.readFormat0(r,t,i);}return i},e.kern.readFormat0=function(r,t,a){var n=e._bin,o=-1,s=n.readUshort(r,t);t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2,n.readUshort(r,t),t+=2;for(var i=0;i<s;i++){var h=n.readUshort(r,t);t+=2;var d=n.readUshort(r,t);t+=2;var f=n.readShort(r,t);t+=2,h!=o&&(a.glyph1.push(h),a.rval.push({glyph2:[],vals:[]}));var u=a.rval[a.rval.length-1];u.glyph2.push(d),u.vals.push(f),o=h;}return t},e.loca={},e.loca.parse=function(r,t,a,n){var o=e._bin,s=[],i=n.head.indexToLocFormat,h=n.maxp.numGlyphs+1;if(0==i)for(var d=0;d<h;d++)s.push(o.readUshort(r,t+(d<<1))<<1);if(1==i)for(d=0;d<h;d++)s.push(o.readUint(r,t+(d<<2)));return s},e.maxp={},e.maxp.parse=function(r,t,a){var n=e._bin,o={},s=n.readUint(r,t);return t+=4,o.numGlyphs=n.readUshort(r,t),t+=2,65536==s&&(o.maxPoints=n.readUshort(r,t),t+=2,o.maxContours=n.readUshort(r,t),t+=2,o.maxCompositePoints=n.readUshort(r,t),t+=2,o.maxCompositeContours=n.readUshort(r,t),t+=2,o.maxZones=n.readUshort(r,t),t+=2,o.maxTwilightPoints=n.readUshort(r,t),t+=2,o.maxStorage=n.readUshort(r,t),t+=2,o.maxFunctionDefs=n.readUshort(r,t),t+=2,o.maxInstructionDefs=n.readUshort(r,t),t+=2,o.maxStackElements=n.readUshort(r,t),t+=2,o.maxSizeOfInstructions=n.readUshort(r,t),t+=2,o.maxComponentElements=n.readUshort(r,t),t+=2,o.maxComponentDepth=n.readUshort(r,t),t+=2),o},e.name={},e.name.parse=function(r,t,a){var n=e._bin,o={};n.readUshort(r,t),t+=2;var s=n.readUshort(r,t);t+=2,n.readUshort(r,t);for(var i,h=[\"copyright\",\"fontFamily\",\"fontSubfamily\",\"ID\",\"fullName\",\"version\",\"postScriptName\",\"trademark\",\"manufacturer\",\"designer\",\"description\",\"urlVendor\",\"urlDesigner\",\"licence\",\"licenceURL\",\"---\",\"typoFamilyName\",\"typoSubfamilyName\",\"compatibleFull\",\"sampleText\",\"postScriptCID\",\"wwsFamilyName\",\"wwsSubfamilyName\",\"lightPalette\",\"darkPalette\"],d=t+=2,f=0;f<s;f++){var u=n.readUshort(r,t);t+=2;var l=n.readUshort(r,t);t+=2;var v=n.readUshort(r,t);t+=2;var c=n.readUshort(r,t);t+=2;var p=n.readUshort(r,t);t+=2;var U=n.readUshort(r,t);t+=2;var g,S=h[c],m=d+12*s+U;if(0==u)g=n.readUnicode(r,m,p/2);else if(3==u&&0==l)g=n.readUnicode(r,m,p/2);else if(0==l)g=n.readASCII(r,m,p);else if(1==l)g=n.readUnicode(r,m,p/2);else if(3==l)g=n.readUnicode(r,m,p/2);else {if(1!=u)throw \"unknown encoding \"+l+\", platformID: \"+u;g=n.readASCII(r,m,p),console.debug(\"reading unknown MAC encoding \"+l+\" as ASCII\");}var b=\"p\"+u+\",\"+v.toString(16);null==o[b]&&(o[b]={}),o[b][void 0!==S?S:c]=g,o[b]._lang=v;}for(var y in o)if(null!=o[y].postScriptName&&1033==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&0==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName&&3084==o[y]._lang)return o[y];for(var y in o)if(null!=o[y].postScriptName)return o[y];for(var y in o){i=y;break}return console.debug(\"returning name table with languageID \"+o[i]._lang),o[i]},e[\"OS/2\"]={},e[\"OS/2\"].parse=function(r,t,a){var n=e._bin.readUshort(r,t);t+=2;var o={};if(0==n)e[\"OS/2\"].version0(r,t,o);else if(1==n)e[\"OS/2\"].version1(r,t,o);else if(2==n||3==n||4==n)e[\"OS/2\"].version2(r,t,o);else {if(5!=n)throw \"unknown OS/2 table version: \"+n;e[\"OS/2\"].version5(r,t,o);}return o},e[\"OS/2\"].version0=function(r,t,a){var n=e._bin;return a.xAvgCharWidth=n.readShort(r,t),t+=2,a.usWeightClass=n.readUshort(r,t),t+=2,a.usWidthClass=n.readUshort(r,t),t+=2,a.fsType=n.readUshort(r,t),t+=2,a.ySubscriptXSize=n.readShort(r,t),t+=2,a.ySubscriptYSize=n.readShort(r,t),t+=2,a.ySubscriptXOffset=n.readShort(r,t),t+=2,a.ySubscriptYOffset=n.readShort(r,t),t+=2,a.ySuperscriptXSize=n.readShort(r,t),t+=2,a.ySuperscriptYSize=n.readShort(r,t),t+=2,a.ySuperscriptXOffset=n.readShort(r,t),t+=2,a.ySuperscriptYOffset=n.readShort(r,t),t+=2,a.yStrikeoutSize=n.readShort(r,t),t+=2,a.yStrikeoutPosition=n.readShort(r,t),t+=2,a.sFamilyClass=n.readShort(r,t),t+=2,a.panose=n.readBytes(r,t,10),t+=10,a.ulUnicodeRange1=n.readUint(r,t),t+=4,a.ulUnicodeRange2=n.readUint(r,t),t+=4,a.ulUnicodeRange3=n.readUint(r,t),t+=4,a.ulUnicodeRange4=n.readUint(r,t),t+=4,a.achVendID=[n.readInt8(r,t),n.readInt8(r,t+1),n.readInt8(r,t+2),n.readInt8(r,t+3)],t+=4,a.fsSelection=n.readUshort(r,t),t+=2,a.usFirstCharIndex=n.readUshort(r,t),t+=2,a.usLastCharIndex=n.readUshort(r,t),t+=2,a.sTypoAscender=n.readShort(r,t),t+=2,a.sTypoDescender=n.readShort(r,t),t+=2,a.sTypoLineGap=n.readShort(r,t),t+=2,a.usWinAscent=n.readUshort(r,t),t+=2,a.usWinDescent=n.readUshort(r,t),t+=2},e[\"OS/2\"].version1=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version0(r,t,a),a.ulCodePageRange1=n.readUint(r,t),t+=4,a.ulCodePageRange2=n.readUint(r,t),t+=4},e[\"OS/2\"].version2=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version1(r,t,a),a.sxHeight=n.readShort(r,t),t+=2,a.sCapHeight=n.readShort(r,t),t+=2,a.usDefault=n.readUshort(r,t),t+=2,a.usBreak=n.readUshort(r,t),t+=2,a.usMaxContext=n.readUshort(r,t),t+=2},e[\"OS/2\"].version5=function(r,t,a){var n=e._bin;return t=e[\"OS/2\"].version2(r,t,a),a.usLowerOpticalPointSize=n.readUshort(r,t),t+=2,a.usUpperOpticalPointSize=n.readUshort(r,t),t+=2},e.post={},e.post.parse=function(r,t,a){var n=e._bin,o={};return o.version=n.readFixed(r,t),t+=4,o.italicAngle=n.readFixed(r,t),t+=4,o.underlinePosition=n.readShort(r,t),t+=2,o.underlineThickness=n.readShort(r,t),t+=2,o},null==e&&(e={}),null==e.U&&(e.U={}),e.U.codeToGlyph=function(r,e){var t=r.cmap,a=-1;if(null!=t.p0e4?a=t.p0e4:null!=t.p3e1?a=t.p3e1:null!=t.p1e0?a=t.p1e0:null!=t.p0e3&&(a=t.p0e3),-1==a)throw \"no familiar platform and encoding!\";var n=t.tables[a];if(0==n.format)return e>=n.map.length?0:n.map[e];if(4==n.format){for(var o=-1,s=0;s<n.endCount.length;s++)if(e<=n.endCount[s]){o=s;break}if(-1==o)return 0;if(n.startCount[o]>e)return 0;return 65535&(0!=n.idRangeOffset[o]?n.glyphIdArray[e-n.startCount[o]+(n.idRangeOffset[o]>>1)-(n.idRangeOffset.length-o)]:e+n.idDelta[o])}if(12==n.format){if(e>n.groups[n.groups.length-1][1])return 0;for(s=0;s<n.groups.length;s++){var i=n.groups[s];if(i[0]<=e&&e<=i[1])return i[2]+(e-i[0])}return 0}throw \"unknown cmap table format \"+n.format},e.U.glyphToPath=function(r,t){var a={cmds:[],crds:[]};if(r.SVG&&r.SVG.entries[t]){var n=r.SVG.entries[t];return null==n?a:(\"string\"==typeof n&&(n=e.SVG.toPath(n),r.SVG.entries[t]=n),n)}if(r.CFF){var o={x:0,y:0,stack:[],nStems:0,haveWidth:!1,width:r.CFF.Private?r.CFF.Private.defaultWidthX:0,open:!1},s=r.CFF,i=r.CFF.Private;if(s.ROS){for(var h=0;s.FDSelect[h+2]<=t;)h+=2;i=s.FDArray[s.FDSelect[h+1]].Private;}e.U._drawCFF(r.CFF.CharStrings[t],o,s,i,a);}else r.glyf&&e.U._drawGlyf(t,r,a);return a},e.U._drawGlyf=function(r,t,a){var n=t.glyf[r];null==n&&(n=t.glyf[r]=e.glyf._parseGlyf(t,r)),null!=n&&(n.noc>-1?e.U._simpleGlyph(n,a):e.U._compoGlyph(n,t,a));},e.U._simpleGlyph=function(r,t){for(var a=0;a<r.noc;a++){for(var n=0==a?0:r.endPts[a-1]+1,o=r.endPts[a],s=n;s<=o;s++){var i=s==n?o:s-1,h=s==o?n:s+1,d=1&r.flags[s],f=1&r.flags[i],u=1&r.flags[h],l=r.xs[s],v=r.ys[s];if(s==n)if(d){if(!f){e.U.P.moveTo(t,l,v);continue}e.U.P.moveTo(t,r.xs[i],r.ys[i]);}else f?e.U.P.moveTo(t,r.xs[i],r.ys[i]):e.U.P.moveTo(t,(r.xs[i]+l)/2,(r.ys[i]+v)/2);d?f&&e.U.P.lineTo(t,l,v):u?e.U.P.qcurveTo(t,l,v,r.xs[h],r.ys[h]):e.U.P.qcurveTo(t,l,v,(l+r.xs[h])/2,(v+r.ys[h])/2);}e.U.P.closePath(t);}},e.U._compoGlyph=function(r,t,a){for(var n=0;n<r.parts.length;n++){var o={cmds:[],crds:[]},s=r.parts[n];e.U._drawGlyf(s.glyphIndex,t,o);for(var i=s.m,h=0;h<o.crds.length;h+=2){var d=o.crds[h],f=o.crds[h+1];a.crds.push(d*i.a+f*i.b+i.tx),a.crds.push(d*i.c+f*i.d+i.ty);}for(h=0;h<o.cmds.length;h++)a.cmds.push(o.cmds[h]);}},e.U._getGlyphClass=function(r,t){var a=e._lctf.getInterval(t,r);return -1==a?0:t[a+2]},e.U._applySubs=function(r,t,a,n){for(var o=r.length-t-1,s=0;s<a.tabs.length;s++)if(null!=a.tabs[s]){var i,h=a.tabs[s];if(!h.coverage||-1!=(i=e._lctf.coverageIndex(h.coverage,r[t])))if(1==a.ltype)r[t],1==h.fmt?r[t]=r[t]+h.delta:r[t]=h.newg[i];else if(4==a.ltype)for(var d=h.vals[i],f=0;f<d.length;f++){var u=d[f],l=u.chain.length;if(!(l>o)){for(var v=!0,c=0,p=0;p<l;p++){for(;-1==r[t+c+(1+p)];)c++;u.chain[p]!=r[t+c+(1+p)]&&(v=!1);}if(v){r[t]=u.nglyph;for(p=0;p<l+c;p++)r[t+p+1]=-1;break}}}else if(5==a.ltype&&2==h.fmt)for(var U=e._lctf.getInterval(h.cDef,r[t]),g=h.cDef[U+2],S=h.scset[g],m=0;m<S.length;m++){var b=S[m],y=b.input;if(!(y.length>o)){for(v=!0,p=0;p<y.length;p++){var F=e._lctf.getInterval(h.cDef,r[t+1+p]);if(-1==U&&h.cDef[F+2]!=y[p]){v=!1;break}}if(v){var C=b.substLookupRecords;for(f=0;f<C.length;f+=2)C[f],C[f+1];}}}else if(6==a.ltype&&3==h.fmt){if(!e.U._glsCovered(r,h.backCvg,t-h.backCvg.length))continue;if(!e.U._glsCovered(r,h.inptCvg,t))continue;if(!e.U._glsCovered(r,h.ahedCvg,t+h.inptCvg.length))continue;var _=h.lookupRec;for(m=0;m<_.length;m+=2){U=_[m];var P=n[_[m+1]];e.U._applySubs(r,t+U,P,n);}}}},e.U._glsCovered=function(r,t,a){for(var n=0;n<t.length;n++){if(-1==e._lctf.coverageIndex(t[n],r[a+n]))return !1}return !0},e.U.glyphsToPath=function(r,t,a){for(var n={cmds:[],crds:[]},o=0,s=0;s<t.length;s++){var i=t[s];if(-1!=i){for(var h=s<t.length-1&&-1!=t[s+1]?t[s+1]:0,d=e.U.glyphToPath(r,i),f=0;f<d.crds.length;f+=2)n.crds.push(d.crds[f]+o),n.crds.push(d.crds[f+1]);a&&n.cmds.push(a);for(f=0;f<d.cmds.length;f++)n.cmds.push(d.cmds[f]);a&&n.cmds.push(\"X\"),o+=r.hmtx.aWidth[i],s<t.length-1&&(o+=e.U.getPairAdjustment(r,i,h));}}return n},e.U.P={},e.U.P.moveTo=function(r,e,t){r.cmds.push(\"M\"),r.crds.push(e,t);},e.U.P.lineTo=function(r,e,t){r.cmds.push(\"L\"),r.crds.push(e,t);},e.U.P.curveTo=function(r,e,t,a,n,o,s){r.cmds.push(\"C\"),r.crds.push(e,t,a,n,o,s);},e.U.P.qcurveTo=function(r,e,t,a,n){r.cmds.push(\"Q\"),r.crds.push(e,t,a,n);},e.U.P.closePath=function(r){r.cmds.push(\"Z\");},e.U._drawCFF=function(r,t,a,n,o){for(var s=t.stack,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open,u=0,l=t.x,v=t.y,c=0,p=0,U=0,g=0,S=0,m=0,b=0,y=0,F=0,C=0,_={val:0,size:0};u<r.length;){e.CFF.getCharString(r,u,_);var P=_.val;if(u+=_.size,\"o1\"==P||\"o18\"==P)s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;else if(\"o3\"==P||\"o23\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0;}else if(\"o4\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),f&&e.U.P.closePath(o),v+=s.pop(),e.U.P.moveTo(o,l,v),f=!0;else if(\"o5\"==P)for(;s.length>0;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);else if(\"o6\"==P||\"o7\"==P)for(var x=s.length,I=\"o6\"==P,w=0;w<x;w++){var k=s.shift();I?l+=k:v+=k,I=!I,e.U.P.lineTo(o,l,v);}else if(\"o8\"==P||\"o24\"==P){x=s.length;for(var G=0;G+6<=x;)c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v),G+=6;\"o24\"==P&&(l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v));}else {if(\"o11\"==P)break;if(\"o1234\"==P||\"o1235\"==P||\"o1236\"==P||\"o1237\"==P)\"o1234\"==P&&(p=v,U=(c=l+s.shift())+s.shift(),C=g=p+s.shift(),m=g,y=v,l=(b=(S=(F=U+s.shift())+s.shift())+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1235\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),l=b+s.shift(),v=y+s.shift(),s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1236\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),C=g=p+s.shift(),m=g,b=(S=(F=U+s.shift())+s.shift())+s.shift(),y=m+s.shift(),l=b+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v)),\"o1237\"==P&&(c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),F=U+s.shift(),C=g+s.shift(),S=F+s.shift(),m=C+s.shift(),b=S+s.shift(),y=m+s.shift(),Math.abs(b-l)>Math.abs(y-v)?l=b+s.shift():v=y+s.shift(),e.U.P.curveTo(o,c,p,U,g,F,C),e.U.P.curveTo(o,S,m,b,y,l,v));else if(\"o14\"==P){if(s.length>0&&!h&&(d=s.shift()+a.nominalWidthX,h=!0),4==s.length){var O=s.shift(),T=s.shift(),D=s.shift(),B=s.shift(),A=e.CFF.glyphBySE(a,D),R=e.CFF.glyphBySE(a,B);e.U._drawCFF(a.CharStrings[A],t,a,n,o),t.x=O,t.y=T,e.U._drawCFF(a.CharStrings[R],t,a,n,o);}f&&(e.U.P.closePath(o),f=!1);}else if(\"o19\"==P||\"o20\"==P){s.length%2!=0&&!h&&(d=s.shift()+n.nominalWidthX),i+=s.length>>1,s.length=0,h=!0,u+=i+7>>3;}else if(\"o21\"==P)s.length>2&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),v+=s.pop(),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o22\"==P)s.length>1&&!h&&(d=s.shift()+n.nominalWidthX,h=!0),l+=s.pop(),f&&e.U.P.closePath(o),e.U.P.moveTo(o,l,v),f=!0;else if(\"o25\"==P){for(;s.length>6;)l+=s.shift(),v+=s.shift(),e.U.P.lineTo(o,l,v);c=l+s.shift(),p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);}else if(\"o26\"==P)for(s.length%2&&(l+=s.shift());s.length>0;)c=l,p=v+s.shift(),l=U=c+s.shift(),v=(g=p+s.shift())+s.shift(),e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o27\"==P)for(s.length%2&&(v+=s.shift());s.length>0;)p=v,U=(c=l+s.shift())+s.shift(),g=p+s.shift(),l=U+s.shift(),v=g,e.U.P.curveTo(o,c,p,U,g,l,v);else if(\"o10\"==P||\"o29\"==P){var L=\"o10\"==P?n:a;if(0==s.length)console.debug(\"error: empty stack\");else {var W=s.pop(),M=L.Subrs[W+L.Bias];t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f,e.U._drawCFF(M,t,a,n,o),l=t.x,v=t.y,i=t.nStems,h=t.haveWidth,d=t.width,f=t.open;}}else if(\"o30\"==P||\"o31\"==P){var V=s.length,E=(G=0,\"o31\"==P);for(G+=V-(x=-3&V);G<x;)E?(p=v,U=(c=l+s.shift())+s.shift(),v=(g=p+s.shift())+s.shift(),x-G==5?(l=U+s.shift(),G++):l=U,E=!1):(c=l,p=v+s.shift(),U=c+s.shift(),g=p+s.shift(),l=U+s.shift(),x-G==5?(v=g+s.shift(),G++):v=g,E=!0),e.U.P.curveTo(o,c,p,U,g,l,v),G+=4;}else {if(\"o\"==(P+\"\").charAt(0))throw console.debug(\"Unknown operation: \"+P,r),P;s.push(P);}}}t.x=l,t.y=v,t.nStems=i,t.haveWidth=h,t.width=d,t.open=f;};var t=e,a={Typr:t};return r.Typr=t,r.default=a,Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).Typr}\n\n/*!\nCustom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate\n(https://github.com/101arrowz/fflate) for use in Troika text rendering. \nOriginal licenses apply: \n- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)\n- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)\n*/\nfunction woff2otfFactory(){return function(r){var e=Uint8Array,n=Uint16Array,t=Uint32Array,a=new e([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),i=new e([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),o=new e([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),f=function(r,e){for(var a=new n(31),i=0;i<31;++i)a[i]=e+=1<<r[i-1];var o=new t(a[30]);for(i=1;i<30;++i)for(var f=a[i];f<a[i+1];++f)o[f]=f-a[i]<<5|i;return [a,o]},u=f(a,2),v=u[0],s=u[1];v[28]=258,s[258]=28;for(var l=f(i,0)[0],c=new n(32768),g=0;g<32768;++g){var h=(43690&g)>>>1|(21845&g)<<1;h=(61680&(h=(52428&h)>>>2|(13107&h)<<2))>>>4|(3855&h)<<4,c[g]=((65280&h)>>>8|(255&h)<<8)>>>1;}var w=function(r,e,t){for(var a=r.length,i=0,o=new n(e);i<a;++i)++o[r[i]-1];var f,u=new n(e);for(i=0;i<e;++i)u[i]=u[i-1]+o[i-1]<<1;if(t){f=new n(1<<e);var v=15-e;for(i=0;i<a;++i)if(r[i])for(var s=i<<4|r[i],l=e-r[i],g=u[r[i]-1]++<<l,h=g|(1<<l)-1;g<=h;++g)f[c[g]>>>v]=s;}else for(f=new n(a),i=0;i<a;++i)r[i]&&(f[i]=c[u[r[i]-1]++]>>>15-r[i]);return f},d=new e(288);for(g=0;g<144;++g)d[g]=8;for(g=144;g<256;++g)d[g]=9;for(g=256;g<280;++g)d[g]=7;for(g=280;g<288;++g)d[g]=8;var m=new e(32);for(g=0;g<32;++g)m[g]=5;var b=w(d,9,1),p=w(m,5,1),y=function(r){for(var e=r[0],n=1;n<r.length;++n)r[n]>e&&(e=r[n]);return e},L=function(r,e,n){var t=e/8|0;return (r[t]|r[t+1]<<8)>>(7&e)&n},U=function(r,e){var n=e/8|0;return (r[n]|r[n+1]<<8|r[n+2]<<16)>>(7&e)},k=[\"unexpected EOF\",\"invalid block type\",\"invalid length/literal\",\"invalid distance\",\"stream finished\",\"no stream handler\",,\"no callback\",\"invalid UTF-8 data\",\"extra field too long\",\"date not in range 1980-2099\",\"filename too long\",\"stream finishing\",\"invalid zip data\"],T=function(r,e,n){var t=new Error(e||k[r]);if(t.code=r,Error.captureStackTrace&&Error.captureStackTrace(t,T),!n)throw t;return t},O=function(r,f,u){var s=r.length;if(!s||u&&!u.l&&s<5)return f||new e(0);var c=!f||u,g=!u||u.i;u||(u={}),f||(f=new e(3*s));var h,d=function(r){var n=f.length;if(r>n){var t=new e(Math.max(2*n,r));t.set(f),f=t;}},m=u.f||0,k=u.p||0,O=u.b||0,A=u.l,x=u.d,E=u.m,D=u.n,M=8*s;do{if(!A){u.f=m=L(r,k,1);var S=L(r,k+1,3);if(k+=3,!S){var V=r[(I=((h=k)/8|0)+(7&h&&1)+4)-4]|r[I-3]<<8,_=I+V;if(_>s){g&&T(0);break}c&&d(O+V),f.set(r.subarray(I,_),O),u.b=O+=V,u.p=k=8*_;continue}if(1==S)A=b,x=p,E=9,D=5;else if(2==S){var j=L(r,k,31)+257,z=L(r,k+10,15)+4,C=j+L(r,k+5,31)+1;k+=14;for(var F=new e(C),P=new e(19),q=0;q<z;++q)P[o[q]]=L(r,k+3*q,7);k+=3*z;var B=y(P),G=(1<<B)-1,H=w(P,B,1);for(q=0;q<C;){var I,J=H[L(r,k,G)];if(k+=15&J,(I=J>>>4)<16)F[q++]=I;else {var K=0,N=0;for(16==I?(N=3+L(r,k,3),k+=2,K=F[q-1]):17==I?(N=3+L(r,k,7),k+=3):18==I&&(N=11+L(r,k,127),k+=7);N--;)F[q++]=K;}}var Q=F.subarray(0,j),R=F.subarray(j);E=y(Q),D=y(R),A=w(Q,E,1),x=w(R,D,1);}else T(1);if(k>M){g&&T(0);break}}c&&d(O+131072);for(var W=(1<<E)-1,X=(1<<D)-1,Y=k;;Y=k){var Z=(K=A[U(r,k)&W])>>>4;if((k+=15&K)>M){g&&T(0);break}if(K||T(2),Z<256)f[O++]=Z;else {if(256==Z){Y=k,A=null;break}var $=Z-254;if(Z>264){var rr=a[q=Z-257];$=L(r,k,(1<<rr)-1)+v[q],k+=rr;}var er=x[U(r,k)&X],nr=er>>>4;er||T(3),k+=15&er;R=l[nr];if(nr>3){rr=i[nr];R+=U(r,k)&(1<<rr)-1,k+=rr;}if(k>M){g&&T(0);break}c&&d(O+131072);for(var tr=O+$;O<tr;O+=4)f[O]=f[O-R],f[O+1]=f[O+1-R],f[O+2]=f[O+2-R],f[O+3]=f[O+3-R];O=tr;}}u.l=A,u.p=Y,u.b=O,A&&(m=1,u.m=E,u.d=x,u.n=D);}while(!m);return O==f.length?f:function(r,a,i){(null==a||a<0)&&(a=0),(null==i||i>r.length)&&(i=r.length);var o=new(r instanceof n?n:r instanceof t?t:e)(i-a);return o.set(r.subarray(a,i)),o}(f,0,O)},A=new e(0);var x=\"undefined\"!=typeof TextDecoder&&new TextDecoder;try{x.decode(A,{stream:!0}),1;}catch(r){}return r.convert_streams=function(r){var e=new DataView(r),n=0;function t(){var r=e.getUint16(n);return n+=2,r}function a(){var r=e.getUint32(n);return n+=4,r}function i(r){m.setUint16(b,r),b+=2;}function o(r){m.setUint32(b,r),b+=4;}for(var f={signature:a(),flavor:a(),length:a(),numTables:t(),reserved:t(),totalSfntSize:a(),majorVersion:t(),minorVersion:t(),metaOffset:a(),metaLength:a(),metaOrigLength:a(),privOffset:a(),privLength:a()},u=0;Math.pow(2,u)<=f.numTables;)u++;u--;for(var v=16*Math.pow(2,u),s=16*f.numTables-v,l=12,c=[],g=0;g<f.numTables;g++)c.push({tag:a(),offset:a(),compLength:a(),origLength:a(),origChecksum:a()}),l+=16;var h,w=new Uint8Array(12+16*c.length+c.reduce((function(r,e){return r+e.origLength+4}),0)),d=w.buffer,m=new DataView(d),b=0;return o(f.flavor),i(f.numTables),i(v),i(u),i(s),c.forEach((function(r){o(r.tag),o(r.origChecksum),o(l),o(r.origLength),r.outOffset=l,(l+=r.origLength)%4!=0&&(l+=4-l%4);})),c.forEach((function(e){var n,t=r.slice(e.offset,e.offset+e.compLength);if(e.compLength!=e.origLength){var a=new Uint8Array(e.origLength);n=new Uint8Array(t,2),O(n,a);}else a=new Uint8Array(t);w.set(a,e.outOffset);var i=0;(l=e.outOffset+e.origLength)%4!=0&&(i=4-l%4),w.set(new Uint8Array(i).buffer,e.outOffset+e.origLength),h=l+i;})),d.slice(0,h)},Object.defineProperty(r,\"__esModule\",{value:!0}),r}({}).convert_streams}\n\n/**\n * A factory wrapper parsing a font file using Typr.\n * Also adds support for WOFF files (not WOFF2).\n */\n\n/**\n * @typedef ParsedFont\n * @property {number} ascender\n * @property {number} descender\n * @property {number} xHeight\n * @property {(number) => boolean} supportsCodePoint\n * @property {(text:string, fontSize:number, letterSpacing:number, callback) => number} forEachGlyph\n * @property {number} lineGap\n * @property {number} capHeight\n * @property {number} unitsPerEm\n */\n\n/**\n * @typedef {(buffer: ArrayBuffer) => ParsedFont} FontParser\n */\n\n/**\n * @returns {FontParser}\n */\nfunction parserFactory(Typr, woff2otf) {\n  const cmdArgLengths = {\n    M: 2,\n    L: 2,\n    Q: 4,\n    C: 6,\n    Z: 0\n  };\n\n  // {joinType: \"skip+step,...\"}\n  const joiningTypeRawData = {\"C\":\"18g,ca,368,1kz\",\"D\":\"17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v\",\"R\":\"17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6\",\"L\":\"x9u,jff,a,fd,jv\",\"T\":\"4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n\"};\n\n  const JT_LEFT = 1, //indicates that a character joins with the subsequent character, but does not join with the preceding character.\n    JT_RIGHT = 2, //indicates that a character joins with the preceding character, but does not join with the subsequent character.\n    JT_DUAL = 4, //indicates that a character joins with the preceding character and joins with the subsequent character.\n    JT_TRANSPARENT = 8, //indicates that the character does not join with adjacent characters and that the character must be skipped over when the shaping engine is evaluating the joining positions in a sequence of characters. When a JT_TRANSPARENT character is encountered in a sequence, the JOINING_TYPE of the preceding character passes through. Diacritical marks are frequently assigned this value.\n    JT_JOIN_CAUSING = 16, //indicates that the character forces the use of joining forms with the preceding and subsequent characters. Kashidas and the Zero Width Joiner (U+200D) are both JOIN_CAUSING characters.\n    JT_NON_JOINING = 32; //indicates that a character does not join with the preceding or with the subsequent character.,\n\n  let joiningTypeMap;\n  function getCharJoiningType(ch) {\n    if (!joiningTypeMap) {\n      const m = {\n        R: JT_RIGHT,\n        L: JT_LEFT,\n        D: JT_DUAL,\n        C: JT_JOIN_CAUSING,\n        U: JT_NON_JOINING,\n        T: JT_TRANSPARENT\n      };\n      joiningTypeMap = new Map();\n      for (let type in joiningTypeRawData) {\n        let lastCode = 0;\n        joiningTypeRawData[type].split(',').forEach(range => {\n          let [skip, step] = range.split('+');\n          skip = parseInt(skip,36);\n          step = step ? parseInt(step, 36) : 0;\n          joiningTypeMap.set(lastCode += skip, m[type]);\n          for (let i = step; i--;) {\n            joiningTypeMap.set(++lastCode, m[type]);\n          }\n        });\n      }\n    }\n    return joiningTypeMap.get(ch) || JT_NON_JOINING\n  }\n\n  const ISOL = 1, INIT = 2, FINA = 3, MEDI = 4;\n  const formsToFeatures = [null, 'isol', 'init', 'fina', 'medi'];\n\n  function detectJoiningForms(str) {\n    // This implements the algorithm described here:\n    // https://github.com/n8willis/opentype-shaping-documents/blob/master/opentype-shaping-arabic-general.md\n    const joiningForms = new Uint8Array(str.length);\n    let prevJoiningType = JT_NON_JOINING;\n    let prevForm = ISOL;\n    let prevIndex = -1;\n    for (let i = 0; i < str.length; i++) {\n      const code = str.codePointAt(i);\n      let joiningType = getCharJoiningType(code) | 0;\n      let form = ISOL;\n      if (joiningType & JT_TRANSPARENT) {\n        continue\n      }\n      if (prevJoiningType & (JT_LEFT | JT_DUAL | JT_JOIN_CAUSING)) {\n        if (joiningType & (JT_RIGHT | JT_DUAL | JT_JOIN_CAUSING)) {\n          form = FINA;\n          // isol->init, fina->medi\n          if (prevForm === ISOL || prevForm === FINA) {\n            joiningForms[prevIndex]++;\n          }\n        }\n        else if (joiningType & (JT_LEFT | JT_NON_JOINING)) {\n          // medi->fina, init->isol\n          if (prevForm === INIT || prevForm === MEDI) {\n            joiningForms[prevIndex]--;\n          }\n        }\n      }\n      else if (prevJoiningType & (JT_RIGHT | JT_NON_JOINING)) {\n        // medi->fina, init->isol\n        if (prevForm === INIT || prevForm === MEDI) {\n          joiningForms[prevIndex]--;\n        }\n      }\n      prevForm = joiningForms[i] = form;\n      prevJoiningType = joiningType;\n      prevIndex = i;\n      if (code > 0xffff) i++;\n    }\n    // console.log(str.split('').map(ch => ch.codePointAt(0).toString(16)))\n    // console.log(str.split('').map(ch => getCharJoiningType(ch.codePointAt(0))))\n    // console.log(Array.from(joiningForms).map(f => formsToFeatures[f] || 'none'))\n    return joiningForms\n  }\n\n  function stringToGlyphs (font, str) {\n    const glyphIds = [];\n    for (let i = 0; i < str.length; i++) {\n      const cc = str.codePointAt(i);\n      if (cc > 0xffff) i++;\n      glyphIds.push(Typr.U.codeToGlyph(font, cc));\n    }\n\n    const gsub = font['GSUB'];\n    if (gsub) {\n      const {lookupList, featureList} = gsub;\n      let joiningForms;\n      const supportedFeatures = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/;\n      const usedLookups = [];\n      featureList.forEach(feature => {\n        if (supportedFeatures.test(feature.tag)) {\n          for (let ti = 0; ti < feature.tab.length; ti++) {\n            if (usedLookups[feature.tab[ti]]) continue\n            usedLookups[feature.tab[ti]] = true;\n            const tab = lookupList[feature.tab[ti]];\n            const isJoiningFeature = /^(isol|init|fina|medi)$/.test(feature.tag);\n            if (isJoiningFeature && !joiningForms) { //lazy\n              joiningForms = detectJoiningForms(str);\n            }\n            for (let ci = 0; ci < glyphIds.length; ci++) {\n              if (!joiningForms || !isJoiningFeature || formsToFeatures[joiningForms[ci]] === feature.tag) {\n                Typr.U._applySubs(glyphIds, ci, tab, lookupList);\n              }\n            }\n          }\n        }\n      });\n    }\n\n    return glyphIds\n  }\n\n  // Calculate advances and x/y offsets for each glyph, e.g. kerning and mark\n  // attachments. This is a more complete version of Typr.U.getPairAdjustment\n  // and should become an upstream replacement eventually.\n  function calcGlyphPositions(font, glyphIds) {\n    const positions = new Int16Array(glyphIds.length * 3); // [offsetX, offsetY, advanceX, ...]\n    let glyphIndex = 0;\n    for (; glyphIndex < glyphIds.length; glyphIndex++) {\n      const glyphId = glyphIds[glyphIndex];\n      if (glyphId === -1) continue;\n\n      positions[glyphIndex * 3 + 2] = font.hmtx.aWidth[glyphId]; // populate advanceX in...advance.\n\n      const gpos = font.GPOS;\n      if (gpos) {\n        const llist = gpos.lookupList;\n        for (let i = 0; i < llist.length; i++) {\n          const lookup = llist[i];\n          for (let j = 0; j < lookup.tabs.length; j++) {\n            const tab = lookup.tabs[j];\n            // Single char placement\n            if (lookup.ltype === 1) {\n              const ind = Typr._lctf.coverageIndex(tab.coverage, glyphId);\n              if (ind !== -1 && tab.pos) {\n                applyValueRecord(tab.pos, glyphIndex);\n                break\n              }\n            }\n            // Pairs (kerning)\n            else if (lookup.ltype === 2) {\n              let adj = null;\n              let prevGlyphIndex = getPrevGlyphIndex();\n              if (prevGlyphIndex !== -1) {\n                const coverageIndex = Typr._lctf.coverageIndex(tab.coverage, glyphIds[prevGlyphIndex]);\n                if (coverageIndex !== -1) {\n                  if (tab.fmt === 1) {\n                    const right = tab.pairsets[coverageIndex];\n                    for (let k = 0; k < right.length; k++) {\n                      if (right[k].gid2 === glyphId) adj = right[k];\n                    }\n                  } else if (tab.fmt === 2) {\n                    const c1 = Typr.U._getGlyphClass(glyphIds[prevGlyphIndex], tab.classDef1);\n                    const c2 = Typr.U._getGlyphClass(glyphId, tab.classDef2);\n                    adj = tab.matrix[c1][c2];\n                  }\n                  if (adj) {\n                    if (adj.val1) applyValueRecord(adj.val1, prevGlyphIndex);\n                    if (adj.val2) applyValueRecord(adj.val2, glyphIndex);\n                    break\n                  }\n                }\n              }\n            }\n            // Mark to base\n            else if (lookup.ltype === 4) {\n              const markArrIndex = Typr._lctf.coverageIndex(tab.markCoverage, glyphId);\n              if (markArrIndex !== -1) {\n                const baseGlyphIndex = getPrevGlyphIndex(isBaseGlyph);\n                const baseArrIndex = baseGlyphIndex === -1 ? -1 : Typr._lctf.coverageIndex(tab.baseCoverage, glyphIds[baseGlyphIndex]);\n                if (baseArrIndex !== -1) {\n                  const markRecord = tab.markArray[markArrIndex];\n                  const baseAnchor = tab.baseArray[baseArrIndex][markRecord.markClass];\n                  positions[glyphIndex * 3] = baseAnchor.x - markRecord.x + positions[baseGlyphIndex * 3] - positions[baseGlyphIndex * 3 + 2];\n                  positions[glyphIndex * 3 + 1] = baseAnchor.y - markRecord.y + positions[baseGlyphIndex * 3 + 1];\n                  break;\n                }\n              }\n            }\n            // Mark to mark\n            else if (lookup.ltype === 6) {\n              const mark1ArrIndex = Typr._lctf.coverageIndex(tab.mark1Coverage, glyphId);\n              if (mark1ArrIndex !== -1) {\n                const prevGlyphIndex = getPrevGlyphIndex();\n                if (prevGlyphIndex !== -1) {\n                  const prevGlyphId = glyphIds[prevGlyphIndex];\n                  if (getGlyphClass(font, prevGlyphId) === 3) { // only check mark glyphs\n                    const mark2ArrIndex = Typr._lctf.coverageIndex(tab.mark2Coverage, prevGlyphId);\n                    if (mark2ArrIndex !== -1) {\n                      const mark1Record = tab.mark1Array[mark1ArrIndex];\n                      const mark2Anchor = tab.mark2Array[mark2ArrIndex][mark1Record.markClass];\n                      positions[glyphIndex * 3] = mark2Anchor.x - mark1Record.x + positions[prevGlyphIndex * 3] - positions[prevGlyphIndex * 3 + 2];\n                      positions[glyphIndex * 3 + 1] = mark2Anchor.y - mark1Record.y + positions[prevGlyphIndex * 3 + 1];\n                      break;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      // Check kern table if no GPOS\n      else if (font.kern && !font.cff) {\n        const prevGlyphIndex = getPrevGlyphIndex();\n        if (prevGlyphIndex !== -1) {\n          const ind1 = font.kern.glyph1.indexOf(glyphIds[prevGlyphIndex]);\n          if (ind1 !== -1) {\n            const ind2 = font.kern.rval[ind1].glyph2.indexOf(glyphId);\n            if (ind2 !== -1) {\n              positions[prevGlyphIndex * 3 + 2] += font.kern.rval[ind1].vals[ind2];\n            }\n          }\n        }\n      }\n    }\n\n    return positions;\n\n    function getPrevGlyphIndex(filter) {\n      for (let i = glyphIndex - 1; i >=0; i--) {\n        if (glyphIds[i] !== -1 && (!filter || filter(glyphIds[i]))) {\n          return i\n        }\n      }\n      return -1;\n    }\n\n    function isBaseGlyph(glyphId) {\n      return getGlyphClass(font, glyphId) === 1;\n    }\n\n    function applyValueRecord(source, gi) {\n      for (let i = 0; i < 3; i++) {\n        positions[gi * 3 + i] += source[i] || 0;\n      }\n    }\n  }\n\n  function getGlyphClass(font, glyphId) {\n    const classDef = font.GDEF && font.GDEF.glyphClassDef;\n    return classDef ? Typr.U._getGlyphClass(glyphId, classDef) : 0;\n  }\n\n  function firstNum(...args) {\n    for (let i = 0; i < args.length; i++) {\n      if (typeof args[i] === 'number') {\n        return args[i]\n      }\n    }\n  }\n\n  /**\n   * @returns ParsedFont\n   */\n  function wrapFontObj(typrFont) {\n    const glyphMap = Object.create(null);\n\n    const os2 = typrFont['OS/2'];\n    const hhea = typrFont.hhea;\n    const unitsPerEm = typrFont.head.unitsPerEm;\n    const ascender = firstNum(os2 && os2.sTypoAscender, hhea && hhea.ascender, unitsPerEm);\n\n    /** @type ParsedFont */\n    const fontObj = {\n      unitsPerEm,\n      ascender,\n      descender: firstNum(os2 && os2.sTypoDescender, hhea && hhea.descender, 0),\n      capHeight: firstNum(os2 && os2.sCapHeight, ascender),\n      xHeight: firstNum(os2 && os2.sxHeight, ascender),\n      lineGap: firstNum(os2 && os2.sTypoLineGap, hhea && hhea.lineGap),\n      supportsCodePoint(code) {\n        return Typr.U.codeToGlyph(typrFont, code) > 0\n      },\n      forEachGlyph(text, fontSize, letterSpacing, callback) {\n        let penX = 0;\n        const fontScale = 1 / fontObj.unitsPerEm * fontSize;\n\n        const glyphIds = stringToGlyphs(typrFont, text);\n        let charIndex = 0;\n        const positions = calcGlyphPositions(typrFont, glyphIds);\n\n        glyphIds.forEach((glyphId, i) => {\n          // Typr returns a glyph index per string codepoint, with -1s in place of those that\n          // were omitted due to ligature substitution. So we can track original index in the\n          // string via simple increment, and skip everything else when seeing a -1.\n          if (glyphId !== -1) {\n            let glyphObj = glyphMap[glyphId];\n            if (!glyphObj) {\n              const {cmds, crds} = Typr.U.glyphToPath(typrFont, glyphId);\n\n              // Build path string\n              let path = '';\n              let crdsIdx = 0;\n              for (let i = 0, len = cmds.length; i < len; i++) {\n                const numArgs = cmdArgLengths[cmds[i]];\n                path += cmds[i];\n                for (let j = 1; j <= numArgs; j++) {\n                  path += (j > 1 ? ',' : '') + crds[crdsIdx++];\n                }\n              }\n\n              // Find extents - Glyf gives this in metadata but not CFF, and Typr doesn't\n              // normalize the two, so it's simplest just to iterate ourselves.\n              let xMin, yMin, xMax, yMax;\n              if (crds.length) {\n                xMin = yMin = Infinity;\n                xMax = yMax = -Infinity;\n                for (let i = 0, len = crds.length; i < len; i += 2) {\n                  let x = crds[i];\n                  let y = crds[i + 1];\n                  if (x < xMin) xMin = x;\n                  if (y < yMin) yMin = y;\n                  if (x > xMax) xMax = x;\n                  if (y > yMax) yMax = y;\n                }\n              } else {\n                xMin = xMax = yMin = yMax = 0;\n              }\n\n              glyphObj = glyphMap[glyphId] = {\n                index: glyphId,\n                advanceWidth: typrFont.hmtx.aWidth[glyphId],\n                xMin,\n                yMin,\n                xMax,\n                yMax,\n                path,\n              };\n            }\n\n            callback.call(\n              null,\n              glyphObj,\n              penX + positions[i * 3] * fontScale,\n              positions[i * 3 + 1] * fontScale,\n              charIndex\n            );\n\n            penX += positions[i * 3 + 2] * fontScale;\n            if (letterSpacing) {\n              penX += letterSpacing * fontSize;\n            }\n          }\n          charIndex += (text.codePointAt(charIndex) > 0xffff ? 2 : 1);\n        });\n\n        return penX\n      }\n    };\n\n    return fontObj\n  }\n\n  /**\n   * @type FontParser\n   */\n  return function parse(buffer) {\n    // Look to see if we have a WOFF file and convert it if so:\n    const peek = new Uint8Array(buffer, 0, 4);\n    const tag = Typr._bin.readASCII(peek, 0, 4);\n    if (tag === 'wOFF') {\n      buffer = woff2otf(buffer);\n    } else if (tag === 'wOF2') {\n      throw new Error('woff2 fonts not supported')\n    }\n    return wrapFontObj(Typr.parse(buffer)[0])\n  }\n}\n\n\nconst workerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typr Font Parser',\n  dependencies: [typrFactory, woff2otfFactory, parserFactory],\n  init(typrFactory, woff2otfFactory, parserFactory) {\n    const Typr = typrFactory();\n    const woff2otf = woff2otfFactory();\n    return parserFactory(Typr, woff2otf)\n  }\n});\n\n/*!\nCustom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)\nfor use in Troika text rendering. \nOriginal MIT license applies\n*/\nfunction unicodeFontResolverClientFactory(){return function(t){var n=function(){this.buckets=new Map;};n.prototype.add=function(t){var n=t>>5;this.buckets.set(n,(this.buckets.get(n)||0)|1<<(31&t));},n.prototype.has=function(t){var n=this.buckets.get(t>>5);return void 0!==n&&0!=(n&1<<(31&t))},n.prototype.serialize=function(){var t=[];return this.buckets.forEach((function(n,r){t.push((+r).toString(36)+\":\"+n.toString(36));})),t.join(\",\")},n.prototype.deserialize=function(t){var n=this;this.buckets.clear(),t.split(\",\").forEach((function(t){var r=t.split(\":\");n.buckets.set(parseInt(r[0],36),parseInt(r[1],36));}));};var r=Math.pow(2,8),e=r-1,o=~e;function a(t){var n=function(t){return t&o}(t).toString(16),e=function(t){return (t&o)+r-1}(t).toString(16);return \"codepoint-index/plane\"+(t>>16)+\"/\"+n+\"-\"+e+\".json\"}function i(t,n){var r=t&e,o=n.codePointAt(r/6|0);return 0!=((o=(o||48)-48)&1<<r%6)}function u(t,n){var r;(r=t,r.replace(/U\\+/gi,\"\").replace(/^,+|,+$/g,\"\").split(/,+/).map((function(t){return t.split(\"-\").map((function(t){return parseInt(t.trim(),16)}))}))).forEach((function(t){var r=t[0],e=t[1];void 0===e&&(e=r),n(r,e);}));}function c(t,n){u(t,(function(t,r){for(var e=t;e<=r;e++)n(e);}));}var s={},f={},l=new WeakMap,v=\"https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data\";function d(t){var r=l.get(t);return r||(r=new n,c(t.ranges,(function(t){return r.add(t)})),l.set(t,r)),r}var h,p=new Map;function g(t,n,r){return t[n]?n:t[r]?r:function(t){for(var n in t)return n}(t)}function w(t,n){var r=n;if(!t.includes(r)){r=1/0;for(var e=0;e<t.length;e++)Math.abs(t[e]-n)<Math.abs(r-n)&&(r=t[e]);}return r}function k(t){return h||(h=new Set,c(\"9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000\",(function(t){h.add(t);}))),h.has(t)}return t.CodePointSet=n,t.clearCache=function(){s={},f={};},t.getFontsForString=function(t,n){void 0===n&&(n={});var r,e=n.lang;void 0===e&&(e=/\\p{Script=Hangul}/u.test(r=t)?\"ko\":/\\p{Script=Hiragana}|\\p{Script=Katakana}/u.test(r)?\"ja\":\"en\");var o=n.category;void 0===o&&(o=\"sans-serif\");var u=n.style;void 0===u&&(u=\"normal\");var c=n.weight;void 0===c&&(c=400);var l=(n.dataUrl||v).replace(/\\/$/g,\"\"),h=new Map,y=new Uint8Array(t.length),b={},m={},A=new Array(t.length),S=new Map,j=!1;function M(t){var n=p.get(t);return n||(n=fetch(l+\"/\"+t).then((function(t){if(!t.ok)throw new Error(t.statusText);return t.json().then((function(t){if(!Array.isArray(t)||1!==t[0])throw new Error(\"Incorrect schema version; need 1, got \"+t[0]);return t[1]}))})).catch((function(n){if(l!==v)return j||(console.error('unicode-font-resolver: Failed loading from dataUrl \"'+l+'\", trying default CDN. '+n.message),j=!0),l=v,p.delete(t),M(t);throw n})),p.set(t,n)),n}for(var P=function(n){var r=t.codePointAt(n),e=a(r);A[n]=e,s[e]||S.has(e)||S.set(e,M(e).then((function(t){s[e]=t;}))),r>65535&&(n++,E=n);},E=0;E<t.length;E++)P(E);return Promise.all(S.values()).then((function(){S.clear();for(var n=function(n){var o=t.codePointAt(n),a=null,u=s[A[n]],c=void 0;for(var l in u){var v=m[l];if(void 0===v&&(v=m[l]=new RegExp(l).test(e||\"en\")),v){for(var d in c=l,u[l])if(i(o,u[l][d])){a=d;break}break}}if(!a)t:for(var h in u)if(h!==c)for(var p in u[h])if(i(o,u[h][p])){a=p;break t}a||(console.debug(\"No font coverage for U+\"+o.toString(16)),a=\"latin\"),A[n]=a,f[a]||S.has(a)||S.set(a,M(\"font-meta/\"+a+\".json\").then((function(t){f[a]=t;}))),o>65535&&(n++,r=n);},r=0;r<t.length;r++)n(r);return Promise.all(S.values())})).then((function(){for(var n,r=null,e=0;e<t.length;e++){var a=t.codePointAt(e);if(r&&(k(a)||d(r).has(a)))y[e]=y[e-1];else {r=f[A[e]];var i=b[r.id];if(!i){var s=r.typeforms,v=g(s,o,\"sans-serif\"),p=g(s[v],u,\"normal\"),m=w(null===(n=s[v])||void 0===n?void 0:n[p],c);i=b[r.id]=l+\"/font-files/\"+r.id+\"/\"+v+\".\"+p+\".\"+m+\".woff\";}var S=h.get(i);null==S&&(S=h.size,h.set(i,S)),y[e]=S;}a>65535&&(e++,y[e]=y[e-1]);}return {fontUrls:Array.from(h.keys()),chars:y}}))},Object.defineProperty(t,\"__esModule\",{value:!0}),t}({})}\n\n/**\n * @typedef {string | {src:string, label?:string, unicodeRange?:string, lang?:string}} UserFont\n */\n\n/**\n * @typedef {ClientOptions} FontResolverOptions\n * @property {Array<UserFont>|UserFont} [fonts]\n * @property {'normal'|'italic'} [style]\n * @property {'normal'|'bold'|number} [style]\n * @property {string} [unicodeFontsURL]\n */\n\n/**\n * @typedef {Object} FontResolverResult\n * @property {Uint8Array} chars\n * @property {Array<ParsedFont & {src:string}>} fonts\n */\n\n/**\n * @typedef {function} FontResolver\n * @param {string} text\n * @param {(FontResolverResult) => void} callback\n * @param {FontResolverOptions} [options]\n */\n\n/**\n * Factory for the FontResolver function.\n * @param {FontParser} fontParser\n * @param {{getFontsForString: function, CodePointSet: function}} unicodeFontResolverClient\n * @return {FontResolver}\n */\nfunction createFontResolver(fontParser, unicodeFontResolverClient) {\n  /**\n   * @type {Record<string, ParsedFont>}\n   */\n  const parsedFonts = Object.create(null);\n\n  /**\n   * @type {Record<string, Array<(ParsedFont) => void>>}\n   */\n  const loadingFonts = Object.create(null);\n\n  /**\n   * Load a given font url\n   */\n  function doLoadFont(url, callback) {\n    const onError = err => {\n      console.error(`Failure loading font ${url}`, err);\n    };\n    try {\n      const request = new XMLHttpRequest();\n      request.open('get', url, true);\n      request.responseType = 'arraybuffer';\n      request.onload = function () {\n        if (request.status >= 400) {\n          onError(new Error(request.statusText));\n        }\n        else if (request.status > 0) {\n          try {\n            const fontObj = fontParser(request.response);\n            fontObj.src = url;\n            callback(fontObj);\n          } catch (e) {\n            onError(e);\n          }\n        }\n      };\n      request.onerror = onError;\n      request.send();\n    } catch(err) {\n      onError(err);\n    }\n  }\n\n\n  /**\n   * Load a given font url if needed, invoking a callback when it's loaded. If already\n   * loaded, the callback will be called synchronously.\n   * @param {string} fontUrl\n   * @param {(font: ParsedFont) => void} callback\n   */\n  function loadFont(fontUrl, callback) {\n    let font = parsedFonts[fontUrl];\n    if (font) {\n      callback(font);\n    } else if (loadingFonts[fontUrl]) {\n      loadingFonts[fontUrl].push(callback);\n    } else {\n      loadingFonts[fontUrl] = [callback];\n      doLoadFont(fontUrl, fontObj => {\n        fontObj.src = fontUrl;\n        parsedFonts[fontUrl] = fontObj;\n        loadingFonts[fontUrl].forEach(cb => cb(fontObj));\n        delete loadingFonts[fontUrl];\n      });\n    }\n  }\n\n  /**\n   * For a given string of text, determine which fonts are required to fully render it and\n   * ensure those fonts are loaded.\n   */\n  return function (text, callback, {\n    lang,\n    fonts: userFonts = [],\n    style = 'normal',\n    weight = 'normal',\n    unicodeFontsURL\n  } = {}) {\n    const charResolutions = new Uint8Array(text.length);\n    const fontResolutions = [];\n    if (!text.length) {\n      allDone();\n    }\n\n    const fontIndices = new Map();\n    const fallbackRanges = []; // [[start, end], ...]\n\n    if (style !== 'italic') style = 'normal';\n    if (typeof weight !== 'number') {\n      weight = weight === 'bold' ? 700 : 400;\n    }\n\n    if (userFonts && !Array.isArray(userFonts)) {\n      userFonts = [userFonts];\n    }\n    userFonts = userFonts.slice()\n      // filter by language\n      .filter(def => !def.lang || def.lang.test(lang))\n      // switch order for easier iteration\n      .reverse();\n    if (userFonts.length) {\n      const UNKNOWN = 0;\n      const RESOLVED = 1;\n      const NEEDS_FALLBACK = 2;\n      let prevCharResult = UNKNOWN\n\n      ;(function resolveUserFonts (startIndex = 0) {\n        for (let i = startIndex, iLen = text.length; i < iLen; i++) {\n          const codePoint = text.codePointAt(i);\n          // Carry previous character's result forward if:\n          // - it resolved to a font that also covers this character\n          // - this character is whitespace\n          if (\n            (prevCharResult === RESOLVED && fontResolutions[charResolutions[i - 1]].supportsCodePoint(codePoint)) ||\n            (i > 0 && /\\s/.test(text[i]))\n          ) {\n            charResolutions[i] = charResolutions[i - 1];\n            if (prevCharResult === NEEDS_FALLBACK) {\n              fallbackRanges[fallbackRanges.length - 1][1] = i;\n            }\n          } else {\n            for (let j = charResolutions[i], jLen = userFonts.length; j <= jLen; j++) {\n              if (j === jLen) {\n                // none of the user fonts matched; needs fallback\n                const range = prevCharResult === NEEDS_FALLBACK ?\n                  fallbackRanges[fallbackRanges.length - 1] :\n                  (fallbackRanges[fallbackRanges.length] = [i, i]);\n                range[1] = i;\n                prevCharResult = NEEDS_FALLBACK;\n              } else {\n                charResolutions[i] = j;\n                const { src, unicodeRange } = userFonts[j];\n                // filter by optional explicit unicode ranges\n                if (!unicodeRange || isCodeInRanges(codePoint, unicodeRange)) {\n                  const fontObj = parsedFonts[src];\n                  // font not yet loaded, load it and resume\n                  if (!fontObj) {\n                    loadFont(src, () => {\n                      resolveUserFonts(i);\n                    });\n                    return;\n                  }\n                  // if the font actually contains a glyph for this char, lock it in\n                  if (fontObj.supportsCodePoint(codePoint)) {\n                    let fontIndex = fontIndices.get(fontObj);\n                    if (typeof fontIndex !== 'number') {\n                      fontIndex = fontResolutions.length;\n                      fontResolutions.push(fontObj);\n                      fontIndices.set(fontObj, fontIndex);\n                    }\n                    charResolutions[i] = fontIndex;\n                    prevCharResult = RESOLVED;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n\n          if (codePoint > 0xffff && i + 1 < iLen) {\n            charResolutions[i + 1] = charResolutions[i];\n            i++;\n            if (prevCharResult === NEEDS_FALLBACK) {\n              fallbackRanges[fallbackRanges.length - 1][1] = i;\n            }\n          }\n        }\n        resolveFallbacks();\n      })();\n    } else {\n      fallbackRanges.push([0, text.length - 1]);\n      resolveFallbacks();\n    }\n\n    function resolveFallbacks() {\n      if (fallbackRanges.length) {\n        // Combine all fallback substrings into a single string for querying\n        const fallbackString = fallbackRanges.map(range => text.substring(range[0], range[1] + 1)).join('\\n');\n        unicodeFontResolverClient.getFontsForString(fallbackString, {\n          lang: lang || undefined,\n          style,\n          weight,\n          dataUrl: unicodeFontsURL\n        }).then(({fontUrls, chars}) => {\n          // Extract results and put them back in the main array\n          const fontIndexOffset = fontResolutions.length;\n          let charIdx = 0;\n          fallbackRanges.forEach(range => {\n            for (let i = 0, endIdx = range[1] - range[0]; i <= endIdx; i++) {\n              charResolutions[range[0] + i] = chars[charIdx++] + fontIndexOffset;\n            }\n            charIdx++; //skip segment separator\n          });\n\n          // Load and parse the fallback fonts - avoiding Promise here to prevent polyfills in the worker\n          let loadedCount = 0;\n          fontUrls.forEach((url, i) => {\n            loadFont(url, fontObj => {\n              fontResolutions[i + fontIndexOffset] = fontObj;\n              if (++loadedCount === fontUrls.length) {\n                allDone();\n              }\n            });\n          });\n        });\n      } else {\n        allDone();\n      }\n    }\n\n    function allDone() {\n      callback({\n        chars: charResolutions,\n        fonts: fontResolutions\n      });\n    }\n\n    function isCodeInRanges(code, ranges) {\n      // todo optimize search - CodePointSet from unicode-font-resolver?\n      for (let k = 0; k < ranges.length; k++) {\n        const [start, end = start] = ranges[k];\n        if (start <= code && code <= end) {\n          return true\n        }\n      }\n      return false\n    }\n  }\n}\n\nconst fontResolverWorkerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'FontResolver',\n  dependencies: [\n    createFontResolver,\n    workerModule,\n    unicodeFontResolverClientFactory,\n  ],\n  init(createFontResolver, fontParser, unicodeFontResolverClientFactory) {\n    return createFontResolver(fontParser, unicodeFontResolverClientFactory());\n  }\n});\n\n/**\n * @typedef {number|'left'|'center'|'right'} AnchorXValue\n */\n/**\n * @typedef {number|'top'|'top-baseline'|'top-cap'|'top-ex'|'middle'|'bottom-baseline'|'bottom'} AnchorYValue\n */\n\n/**\n * @typedef {object} TypesetParams\n * @property {string} text\n * @property {UserFont|UserFont[]} [font]\n * @property {string} [lang]\n * @property {number} [sdfGlyphSize=64]\n * @property {number} [fontSize=1]\n * @property {number|'normal'|'bold'} [fontWeight='normal']\n * @property {'normal'|'italic'} [fontStyle='normal']\n * @property {number} [letterSpacing=0]\n * @property {'normal'|number} [lineHeight='normal']\n * @property {number} [maxWidth]\n * @property {'ltr'|'rtl'} [direction='ltr']\n * @property {string} [textAlign='left']\n * @property {number} [textIndent=0]\n * @property {'normal'|'nowrap'} [whiteSpace='normal']\n * @property {'normal'|'break-word'} [overflowWrap='normal']\n * @property {AnchorXValue} [anchorX=0]\n * @property {AnchorYValue} [anchorY=0]\n * @property {boolean} [metricsOnly=false]\n * @property {string} [unicodeFontsURL]\n * @property {FontResolverResult} [preResolvedFonts]\n * @property {boolean} [includeCaretPositions=false]\n * @property {number} [chunkedBoundsSize=8192]\n * @property {{[rangeStartIndex]: number}} [colorRanges]\n */\n\n/**\n * @typedef {object} TypesetResult\n * @property {Uint16Array} glyphIds id for each glyph, specific to that glyph's font\n * @property {Uint8Array} glyphFontIndices index into fontData for each glyph\n * @property {Float32Array} glyphPositions x,y of each glyph's origin in layout\n * @property {{[font]: {[glyphId]: {path: string, pathBounds: number[]}}}} glyphData data about each glyph appearing in the text\n * @property {TypesetFontData[]} fontData data about each font used in the text\n * @property {Float32Array} [caretPositions] startX,endX,bottomY caret positions for each char\n * @property {Uint8Array} [glyphColors] color for each glyph, if color ranges supplied\n *         chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n *         fontSize, //calculated em height\n *         topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n *         blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n *           anchorXOffset,\n *           anchorYOffset - totalHeight,\n *           anchorXOffset + maxLineWidth,\n *           anchorYOffset\n *         ],\n *         visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n *         timings\n */\n\n/**\n * @typedef {object} TypesetFontData\n * @property src\n * @property unitsPerEm\n * @property ascender\n * @property descender\n * @property lineHeight\n * @property capHeight\n * @property xHeight\n */\n\n/**\n * @typedef {function} TypesetterTypesetFunction - compute fonts and layout for some text.\n * @param {TypesetParams} params\n * @param {(TypesetResult) => void} callback - function called when typesetting is complete.\n *    If the params included `preResolvedFonts`, this will be called synchronously.\n */\n\n/**\n * @typedef {function} TypesetterMeasureFunction - compute width/height for some text.\n * @param {TypesetParams} params\n * @param {(width:number, height:number) => void} callback - function called when measurement is complete.\n *    If the params included `preResolvedFonts`, this will be called synchronously.\n */\n\n\n/**\n * Factory function that creates a self-contained environment for processing text typesetting requests.\n *\n * It is important that this function has no closure dependencies, so that it can be easily injected\n * into the source for a Worker without requiring a build step or complex dependency loading. All its\n * dependencies must be passed in at initialization.\n *\n * @param {FontResolver} resolveFonts - function to resolve a string to parsed fonts\n * @param {object} bidi - the bidi.js implementation object\n * @return {{typeset: TypesetterTypesetFunction, measure: TypesetterMeasureFunction}}\n */\nfunction createTypesetter(resolveFonts, bidi) {\n  const INF = Infinity;\n\n  // Set of Unicode Default_Ignorable_Code_Point characters, these will not produce visible glyphs\n  // eslint-disable-next-line no-misleading-character-class\n  const DEFAULT_IGNORABLE_CHARS = /[\\u00AD\\u034F\\u061C\\u115F-\\u1160\\u17B4-\\u17B5\\u180B-\\u180E\\u200B-\\u200F\\u202A-\\u202E\\u2060-\\u206F\\u3164\\uFE00-\\uFE0F\\uFEFF\\uFFA0\\uFFF0-\\uFFF8]/;\n\n  // This regex (instead of /\\s/) allows us to select all whitespace EXCEPT for non-breaking white spaces\n  const lineBreakingWhiteSpace = `[^\\\\S\\\\u00A0]`;\n\n  // Incomplete set of characters that allow line breaking after them\n  // In the future we may consider a full Unicode line breaking algorithm impl: https://www.unicode.org/reports/tr14\n  const BREAK_AFTER_CHARS = new RegExp(`${lineBreakingWhiteSpace}|[\\\\-\\\\u007C\\\\u00AD\\\\u2010\\\\u2012-\\\\u2014\\\\u2027\\\\u2056\\\\u2E17\\\\u2E40]`);\n\n  /**\n   * Load and parse all the necessary fonts to render a given string of text, then group\n   * them into consecutive runs of characters sharing a font.\n   */\n  function calculateFontRuns({text, lang, fonts, style, weight, preResolvedFonts, unicodeFontsURL}, onDone) {\n    const onResolved = ({chars, fonts: parsedFonts}) => {\n      let curRun, prevVal;\n      const runs = [];\n      for (let i = 0; i < chars.length; i++) {\n        if (chars[i] !== prevVal) {\n          prevVal = chars[i];\n          runs.push(curRun = { start: i, end: i, fontObj: parsedFonts[chars[i]]});\n        } else {\n          curRun.end = i;\n        }\n      }\n      onDone(runs);\n    };\n    if (preResolvedFonts) {\n      onResolved(preResolvedFonts);\n    } else {\n      resolveFonts(\n        text,\n        onResolved,\n        { lang, fonts, style, weight, unicodeFontsURL }\n      );\n    }\n  }\n\n  /**\n   * Main entry point.\n   * Process a text string with given font and formatting parameters, and return all info\n   * necessary to render all its glyphs.\n   * @type TypesetterTypesetFunction\n   */\n  function typeset(\n    {\n      text='',\n      font,\n      lang,\n      sdfGlyphSize=64,\n      fontSize=400,\n      fontWeight=1,\n      fontStyle='normal',\n      letterSpacing=0,\n      lineHeight='normal',\n      maxWidth=INF,\n      direction,\n      textAlign='left',\n      textIndent=0,\n      whiteSpace='normal',\n      overflowWrap='normal',\n      anchorX = 0,\n      anchorY = 0,\n      metricsOnly=false,\n      unicodeFontsURL,\n      preResolvedFonts=null,\n      includeCaretPositions=false,\n      chunkedBoundsSize=8192,\n      colorRanges=null\n    },\n    callback\n  ) {\n    const mainStart = now();\n    const timings = {fontLoad: 0, typesetting: 0};\n\n    // Ensure newlines are normalized\n    if (text.indexOf('\\r') > -1) {\n      console.info('Typesetter: got text with \\\\r chars; normalizing to \\\\n');\n      text = text.replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n');\n    }\n\n    // Ensure we've got numbers not strings\n    fontSize = +fontSize;\n    letterSpacing = +letterSpacing;\n    maxWidth = +maxWidth;\n    lineHeight = lineHeight || 'normal';\n    textIndent = +textIndent;\n\n    calculateFontRuns({\n      text,\n      lang,\n      style: fontStyle,\n      weight: fontWeight,\n      fonts: typeof font === 'string' ? [{src: font}] : font,\n      unicodeFontsURL,\n      preResolvedFonts\n    }, runs => {\n      timings.fontLoad = now() - mainStart;\n      const hasMaxWidth = isFinite(maxWidth);\n      let glyphIds = null;\n      let glyphFontIndices = null;\n      let glyphPositions = null;\n      let glyphData = null;\n      let glyphColors = null;\n      let caretPositions = null;\n      let visibleBounds = null;\n      let chunkedBounds = null;\n      let maxLineWidth = 0;\n      let renderableGlyphCount = 0;\n      let canWrap = whiteSpace !== 'nowrap';\n      const metricsByFont = new Map(); // fontObj -> metrics\n      const typesetStart = now();\n\n      // Distribute glyphs into lines based on wrapping\n      let lineXOffset = textIndent;\n      let prevRunEndX = 0;\n      let currentLine = new TextLine();\n      const lines = [currentLine];\n      runs.forEach(run => {\n        const { fontObj } = run;\n        const { ascender, descender, unitsPerEm, lineGap, capHeight, xHeight } = fontObj;\n\n        // Calculate metrics for each font used\n        let fontData = metricsByFont.get(fontObj);\n        if (!fontData) {\n          // Find conversion between native font units and fontSize units\n          const fontSizeMult = fontSize / unitsPerEm;\n\n          // Determine appropriate value for 'normal' line height based on the font's actual metrics\n          // This does not guarantee individual glyphs won't exceed the line height, e.g. Roboto; should we use yMin/Max instead?\n          const calcLineHeight = lineHeight === 'normal' ?\n            (ascender - descender + lineGap) * fontSizeMult : lineHeight * fontSize;\n\n          // Determine line height and leading adjustments\n          const halfLeading = (calcLineHeight - (ascender - descender) * fontSizeMult) / 2;\n          const caretHeight = Math.min(calcLineHeight, (ascender - descender) * fontSizeMult);\n          const caretTop = (ascender + descender) / 2 * fontSizeMult + caretHeight / 2;\n          fontData = {\n            index: metricsByFont.size,\n            src: fontObj.src,\n            fontObj,\n            fontSizeMult,\n            unitsPerEm,\n            ascender: ascender * fontSizeMult,\n            descender: descender * fontSizeMult,\n            capHeight: capHeight * fontSizeMult,\n            xHeight: xHeight * fontSizeMult,\n            lineHeight: calcLineHeight,\n            baseline: -halfLeading - ascender * fontSizeMult, // baseline offset from top of line height\n            // cap: -halfLeading - capHeight * fontSizeMult, // cap from top of line height\n            // ex: -halfLeading - xHeight * fontSizeMult, // ex from top of line height\n            caretTop,\n            caretBottom: caretTop - caretHeight\n          };\n          metricsByFont.set(fontObj, fontData);\n        }\n        const { fontSizeMult } = fontData;\n\n        const runText = text.slice(run.start, run.end + 1);\n        let prevGlyphX, prevGlyphObj;\n        fontObj.forEachGlyph(runText, fontSize, letterSpacing, (glyphObj, glyphX, glyphY, charIndex) => {\n          glyphX += prevRunEndX;\n          charIndex += run.start;\n          prevGlyphX = glyphX;\n          prevGlyphObj = glyphObj;\n          const char = text.charAt(charIndex);\n          const glyphWidth = glyphObj.advanceWidth * fontSizeMult;\n          const curLineCount = currentLine.count;\n          let nextLine;\n\n          // Calc isWhitespace and isEmpty once per glyphObj\n          if (!('isEmpty' in glyphObj)) {\n            glyphObj.isWhitespace = !!char && new RegExp(lineBreakingWhiteSpace).test(char);\n            glyphObj.canBreakAfter = !!char && BREAK_AFTER_CHARS.test(char);\n            glyphObj.isEmpty = glyphObj.xMin === glyphObj.xMax || glyphObj.yMin === glyphObj.yMax || DEFAULT_IGNORABLE_CHARS.test(char);\n          }\n          if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n            renderableGlyphCount++;\n          }\n\n          // If a non-whitespace character overflows the max width, we need to soft-wrap\n          if (canWrap && hasMaxWidth && !glyphObj.isWhitespace && glyphX + glyphWidth + lineXOffset > maxWidth && curLineCount) {\n            // If it's the first char after a whitespace, start a new line\n            if (currentLine.glyphAt(curLineCount - 1).glyphObj.canBreakAfter) {\n              nextLine = new TextLine();\n              lineXOffset = -glyphX;\n            } else {\n              // Back up looking for a whitespace character to wrap at\n              for (let i = curLineCount; i--;) {\n                // If we got the start of the line there's no soft break point; make hard break if overflowWrap='break-word'\n                if (i === 0 && overflowWrap === 'break-word') {\n                  nextLine = new TextLine();\n                  lineXOffset = -glyphX;\n                  break\n                }\n                // Found a soft break point; move all chars since it to a new line\n                else if (currentLine.glyphAt(i).glyphObj.canBreakAfter) {\n                  nextLine = currentLine.splitAt(i + 1);\n                  const adjustX = nextLine.glyphAt(0).x;\n                  lineXOffset -= adjustX;\n                  for (let j = nextLine.count; j--;) {\n                    nextLine.glyphAt(j).x -= adjustX;\n                  }\n                  break\n                }\n              }\n            }\n            if (nextLine) {\n              currentLine.isSoftWrapped = true;\n              currentLine = nextLine;\n              lines.push(currentLine);\n              maxLineWidth = maxWidth; //after soft wrapping use maxWidth as calculated width\n            }\n          }\n\n          let fly = currentLine.glyphAt(currentLine.count);\n          fly.glyphObj = glyphObj;\n          fly.x = glyphX + lineXOffset;\n          fly.y = glyphY;\n          fly.width = glyphWidth;\n          fly.charIndex = charIndex;\n          fly.fontData = fontData;\n\n          // Handle hard line breaks\n          if (char === '\\n') {\n            currentLine = new TextLine();\n            lines.push(currentLine);\n            lineXOffset = -(glyphX + glyphWidth + (letterSpacing * fontSize)) + textIndent;\n          }\n        });\n        // At the end of a run we must capture the x position as the starting point for the next run\n        prevRunEndX = prevGlyphX + prevGlyphObj.advanceWidth * fontSizeMult + letterSpacing * fontSize;\n      });\n\n      // Calculate width/height/baseline of each line (excluding trailing whitespace) and maximum block width\n      let totalHeight = 0;\n      lines.forEach(line => {\n        let isTrailingWhitespace = true;\n        for (let i = line.count; i--;) {\n          const glyphInfo = line.glyphAt(i);\n          // omit trailing whitespace from width calculation\n          if (isTrailingWhitespace && !glyphInfo.glyphObj.isWhitespace) {\n            line.width = glyphInfo.x + glyphInfo.width;\n            if (line.width > maxLineWidth) {\n              maxLineWidth = line.width;\n            }\n            isTrailingWhitespace = false;\n          }\n          // use the tallest line height, lowest baseline, and highest cap/ex\n          let {lineHeight, capHeight, xHeight, baseline} = glyphInfo.fontData;\n          if (lineHeight > line.lineHeight) line.lineHeight = lineHeight;\n          const baselineDiff = baseline - line.baseline;\n          if (baselineDiff < 0) { //shift all metrics down\n            line.baseline += baselineDiff;\n            line.cap += baselineDiff;\n            line.ex += baselineDiff;\n          }\n          // compare cap/ex based on new lowest baseline\n          line.cap = Math.max(line.cap, line.baseline + capHeight);\n          line.ex = Math.max(line.ex, line.baseline + xHeight);\n        }\n        line.baseline -= totalHeight;\n        line.cap -= totalHeight;\n        line.ex -= totalHeight;\n        totalHeight += line.lineHeight;\n      });\n\n      // Find overall position adjustments for anchoring\n      let anchorXOffset = 0;\n      let anchorYOffset = 0;\n      if (anchorX) {\n        if (typeof anchorX === 'number') {\n          anchorXOffset = -anchorX;\n        }\n        else if (typeof anchorX === 'string') {\n          anchorXOffset = -maxLineWidth * (\n            anchorX === 'left' ? 0 :\n            anchorX === 'center' ? 0.5 :\n            anchorX === 'right' ? 1 :\n            parsePercent(anchorX)\n          );\n        }\n      }\n      if (anchorY) {\n        if (typeof anchorY === 'number') {\n          anchorYOffset = -anchorY;\n        }\n        else if (typeof anchorY === 'string') {\n          anchorYOffset = anchorY === 'top' ? 0 :\n            anchorY === 'top-baseline' ? -lines[0].baseline :\n            anchorY === 'top-cap' ? -lines[0].cap :\n            anchorY === 'top-ex' ? -lines[0].ex :\n            anchorY === 'middle' ? totalHeight / 2 :\n            anchorY === 'bottom' ? totalHeight :\n            anchorY === 'bottom-baseline' ? -lines[lines.length - 1].baseline :\n            parsePercent(anchorY) * totalHeight;\n        }\n      }\n\n      if (!metricsOnly) {\n        // Resolve bidi levels\n        const bidiLevelsResult = bidi.getEmbeddingLevels(text, direction);\n\n        // Process each line, applying alignment offsets, adding each glyph to the atlas, and\n        // collecting all renderable glyphs into a single collection.\n        glyphIds = new Uint16Array(renderableGlyphCount);\n        glyphFontIndices = new Uint8Array(renderableGlyphCount);\n        glyphPositions = new Float32Array(renderableGlyphCount * 2);\n        glyphData = {};\n        visibleBounds = [INF, INF, -INF, -INF];\n        chunkedBounds = [];\n        if (includeCaretPositions) {\n          caretPositions = new Float32Array(text.length * 4);\n        }\n        if (colorRanges) {\n          glyphColors = new Uint8Array(renderableGlyphCount * 3);\n        }\n        let renderableGlyphIndex = 0;\n        let prevCharIndex = -1;\n        let colorCharIndex = -1;\n        let chunk;\n        let currentColor;\n        lines.forEach((line, lineIndex) => {\n          let {count:lineGlyphCount, width:lineWidth} = line;\n\n          // Ignore empty lines\n          if (lineGlyphCount > 0) {\n            // Count trailing whitespaces, we want to ignore these for certain things\n            let trailingWhitespaceCount = 0;\n            for (let i = lineGlyphCount; i-- && line.glyphAt(i).glyphObj.isWhitespace;) {\n              trailingWhitespaceCount++;\n            }\n\n            // Apply horizontal alignment adjustments\n            let lineXOffset = 0;\n            let justifyAdjust = 0;\n            if (textAlign === 'center') {\n              lineXOffset = (maxLineWidth - lineWidth) / 2;\n            } else if (textAlign === 'right') {\n              lineXOffset = maxLineWidth - lineWidth;\n            } else if (textAlign === 'justify' && line.isSoftWrapped) {\n              // count non-trailing whitespace characters, and we'll adjust the offsets per character in the next loop\n              let whitespaceCount = 0;\n              for (let i = lineGlyphCount - trailingWhitespaceCount; i--;) {\n                if (line.glyphAt(i).glyphObj.isWhitespace) {\n                  whitespaceCount++;\n                }\n              }\n              justifyAdjust = (maxLineWidth - lineWidth) / whitespaceCount;\n            }\n            if (justifyAdjust || lineXOffset) {\n              let justifyOffset = 0;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                let glyphInfo = line.glyphAt(i);\n                const glyphObj = glyphInfo.glyphObj;\n                glyphInfo.x += lineXOffset + justifyOffset;\n                // Expand non-trailing whitespaces for justify alignment\n                if (justifyAdjust !== 0 && glyphObj.isWhitespace && i < lineGlyphCount - trailingWhitespaceCount) {\n                  justifyOffset += justifyAdjust;\n                  glyphInfo.width += justifyAdjust;\n                }\n              }\n            }\n\n            // Perform bidi range flipping\n            const flips = bidi.getReorderSegments(\n              text, bidiLevelsResult, line.glyphAt(0).charIndex, line.glyphAt(line.count - 1).charIndex\n            );\n            for (let fi = 0; fi < flips.length; fi++) {\n              const [start, end] = flips[fi];\n              // Map start/end string indices to indices in the line\n              let left = Infinity, right = -Infinity;\n              for (let i = 0; i < lineGlyphCount; i++) {\n                if (line.glyphAt(i).charIndex >= start) { // gte to handle removed characters\n                  let startInLine = i, endInLine = i;\n                  for (; endInLine < lineGlyphCount; endInLine++) {\n                    let info = line.glyphAt(endInLine);\n                    if (info.charIndex > end) {\n                      break\n                    }\n                    if (endInLine < lineGlyphCount - trailingWhitespaceCount) { //don't include trailing ws in flip width\n                      left = Math.min(left, info.x);\n                      right = Math.max(right, info.x + info.width);\n                    }\n                  }\n                  for (let j = startInLine; j < endInLine; j++) {\n                    const glyphInfo = line.glyphAt(j);\n                    glyphInfo.x = right - (glyphInfo.x + glyphInfo.width - left);\n                  }\n                  break\n                }\n              }\n            }\n\n            // Assemble final data arrays\n            let glyphObj;\n            const setGlyphObj = g => glyphObj = g;\n            for (let i = 0; i < lineGlyphCount; i++) {\n              const glyphInfo = line.glyphAt(i);\n              glyphObj = glyphInfo.glyphObj;\n              const glyphId = glyphObj.index;\n\n              // Replace mirrored characters in rtl\n              const rtl = bidiLevelsResult.levels[glyphInfo.charIndex] & 1; //odd level means rtl\n              if (rtl) {\n                const mirrored = bidi.getMirroredCharacter(text[glyphInfo.charIndex]);\n                if (mirrored) {\n                  glyphInfo.fontData.fontObj.forEachGlyph(mirrored, 0, 0, setGlyphObj);\n                }\n              }\n\n              // Add caret positions\n              if (includeCaretPositions) {\n                const {charIndex, fontData} = glyphInfo;\n                const caretLeft = glyphInfo.x + anchorXOffset;\n                const caretRight = glyphInfo.x + glyphInfo.width + anchorXOffset;\n                caretPositions[charIndex * 4] = rtl ? caretRight : caretLeft; //start edge x\n                caretPositions[charIndex * 4 + 1] = rtl ? caretLeft : caretRight; //end edge x\n                caretPositions[charIndex * 4 + 2] = line.baseline + fontData.caretBottom + anchorYOffset; //common bottom y\n                caretPositions[charIndex * 4 + 3] = line.baseline + fontData.caretTop + anchorYOffset; //common top y\n\n                // If we skipped any chars from the previous glyph (due to ligature subs), fill in caret\n                // positions for those missing char indices; currently this uses a best-guess by dividing\n                // the ligature's width evenly. In the future we may try to use the font's LigatureCaretList\n                // table to get better interior caret positions.\n                const ligCount = charIndex - prevCharIndex;\n                if (ligCount > 1) {\n                  fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n                }\n                prevCharIndex = charIndex;\n              }\n\n              // Track current color range\n              if (colorRanges) {\n                const {charIndex} = glyphInfo;\n                while(charIndex > colorCharIndex) {\n                  colorCharIndex++;\n                  if (colorRanges.hasOwnProperty(colorCharIndex)) {\n                    currentColor = colorRanges[colorCharIndex];\n                  }\n                }\n              }\n\n              // Get atlas data for renderable glyphs\n              if (!glyphObj.isWhitespace && !glyphObj.isEmpty) {\n                const idx = renderableGlyphIndex++;\n                const {fontSizeMult, src: fontSrc, index: fontIndex} = glyphInfo.fontData;\n\n                // Add this glyph's path data\n                const fontGlyphData = glyphData[fontSrc] || (glyphData[fontSrc] = {});\n                if (!fontGlyphData[glyphId]) {\n                  fontGlyphData[glyphId] = {\n                    path: glyphObj.path,\n                    pathBounds: [glyphObj.xMin, glyphObj.yMin, glyphObj.xMax, glyphObj.yMax]\n                  };\n                }\n\n                // Determine final glyph position and add to glyphPositions array\n                const glyphX = glyphInfo.x + anchorXOffset;\n                const glyphY = glyphInfo.y + line.baseline + anchorYOffset;\n                glyphPositions[idx * 2] = glyphX;\n                glyphPositions[idx * 2 + 1] = glyphY;\n\n                // Track total visible bounds\n                const visX0 = glyphX + glyphObj.xMin * fontSizeMult;\n                const visY0 = glyphY + glyphObj.yMin * fontSizeMult;\n                const visX1 = glyphX + glyphObj.xMax * fontSizeMult;\n                const visY1 = glyphY + glyphObj.yMax * fontSizeMult;\n                if (visX0 < visibleBounds[0]) visibleBounds[0] = visX0;\n                if (visY0 < visibleBounds[1]) visibleBounds[1] = visY0;\n                if (visX1 > visibleBounds[2]) visibleBounds[2] = visX1;\n                if (visY1 > visibleBounds[3]) visibleBounds[3] = visY1;\n\n                // Track bounding rects for each chunk of N glyphs\n                if (idx % chunkedBoundsSize === 0) {\n                  chunk = {start: idx, end: idx, rect: [INF, INF, -INF, -INF]};\n                  chunkedBounds.push(chunk);\n                }\n                chunk.end++;\n                const chunkRect = chunk.rect;\n                if (visX0 < chunkRect[0]) chunkRect[0] = visX0;\n                if (visY0 < chunkRect[1]) chunkRect[1] = visY0;\n                if (visX1 > chunkRect[2]) chunkRect[2] = visX1;\n                if (visY1 > chunkRect[3]) chunkRect[3] = visY1;\n\n                // Add to glyph ids and font indices arrays\n                glyphIds[idx] = glyphId;\n                glyphFontIndices[idx] = fontIndex;\n\n                // Add colors\n                if (colorRanges) {\n                  const start = idx * 3;\n                  glyphColors[start] = currentColor >> 16 & 255;\n                  glyphColors[start + 1] = currentColor >> 8 & 255;\n                  glyphColors[start + 2] = currentColor & 255;\n                }\n              }\n            }\n          }\n        });\n\n        // Fill in remaining caret positions in case the final character was a ligature\n        if (caretPositions) {\n          const ligCount = text.length - prevCharIndex;\n          if (ligCount > 1) {\n            fillLigatureCaretPositions(caretPositions, prevCharIndex, ligCount);\n          }\n        }\n      }\n\n      // Assemble final data about each font used\n      const fontData = [];\n      metricsByFont.forEach(({index, src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight}) => {\n        fontData[index] = {src, unitsPerEm, ascender, descender, lineHeight, capHeight, xHeight};\n      });\n\n      // Timing stats\n      timings.typesetting = now() - typesetStart;\n\n      callback({\n        glyphIds, //id for each glyph, specific to that glyph's font\n        glyphFontIndices, //index into fontData for each glyph\n        glyphPositions, //x,y of each glyph's origin in layout\n        glyphData, //dict holding data about each glyph appearing in the text\n        fontData, //data about each font used in the text\n        caretPositions, //startX,endX,bottomY caret positions for each char\n        // caretHeight, //height of cursor from bottom to top - todo per glyph?\n        glyphColors, //color for each glyph, if color ranges supplied\n        chunkedBounds, //total rects per (n=chunkedBoundsSize) consecutive glyphs\n        fontSize, //calculated em height\n        topBaseline: anchorYOffset + lines[0].baseline, //y coordinate of the top line's baseline\n        blockBounds: [ //bounds for the whole block of text, including vertical padding for lineHeight\n          anchorXOffset,\n          anchorYOffset - totalHeight,\n          anchorXOffset + maxLineWidth,\n          anchorYOffset\n        ],\n        visibleBounds, //total bounds of visible text paths, may be larger or smaller than blockBounds\n        timings\n      });\n    });\n  }\n\n\n  /**\n   * For a given text string and font parameters, determine the resulting block dimensions\n   * after wrapping for the given maxWidth.\n   * @param args\n   * @param callback\n   */\n  function measure(args, callback) {\n    typeset({...args, metricsOnly: true}, (result) => {\n      const [x0, y0, x1, y1] = result.blockBounds;\n      callback({\n        width: x1 - x0,\n        height: y1 - y0\n      });\n    });\n  }\n\n  function parsePercent(str) {\n    let match = str.match(/^([\\d.]+)%$/);\n    let pct = match ? parseFloat(match[1]) : NaN;\n    return isNaN(pct) ? 0 : pct / 100\n  }\n\n  function fillLigatureCaretPositions(caretPositions, ligStartIndex, ligCount) {\n    const ligStartX = caretPositions[ligStartIndex * 4];\n    const ligEndX = caretPositions[ligStartIndex * 4 + 1];\n    const ligBottom = caretPositions[ligStartIndex * 4 + 2];\n    const ligTop = caretPositions[ligStartIndex * 4 + 3];\n    const guessedAdvanceX = (ligEndX - ligStartX) / ligCount;\n    for (let i = 0; i < ligCount; i++) {\n      const startIndex = (ligStartIndex + i) * 4;\n      caretPositions[startIndex] = ligStartX + guessedAdvanceX * i;\n      caretPositions[startIndex + 1] = ligStartX + guessedAdvanceX * (i + 1);\n      caretPositions[startIndex + 2] = ligBottom;\n      caretPositions[startIndex + 3] = ligTop;\n    }\n  }\n\n  function now() {\n    return (self.performance || Date).now()\n  }\n\n  // Array-backed structure for a single line's glyphs data\n  function TextLine() {\n    this.data = [];\n  }\n  const textLineProps = ['glyphObj', 'x', 'y', 'width', 'charIndex', 'fontData'];\n  TextLine.prototype = {\n    width: 0,\n    lineHeight: 0,\n    baseline: 0,\n    cap: 0,\n    ex: 0,\n    isSoftWrapped: false,\n    get count() {\n      return Math.ceil(this.data.length / textLineProps.length)\n    },\n    glyphAt(i) {\n      let fly = TextLine.flyweight;\n      fly.data = this.data;\n      fly.index = i;\n      return fly\n    },\n    splitAt(i) {\n      let newLine = new TextLine();\n      newLine.data = this.data.splice(i * textLineProps.length);\n      return newLine\n    }\n  };\n  TextLine.flyweight = textLineProps.reduce((obj, prop, i, all) => {\n    Object.defineProperty(obj, prop, {\n      get() {\n        return this.data[this.index * textLineProps.length + i]\n      },\n      set(val) {\n        this.data[this.index * textLineProps.length + i] = val;\n      }\n    });\n    return obj\n  }, {data: null, index: 0});\n\n\n  return {\n    typeset,\n    measure,\n  }\n}\n\nconst now = () => (self.performance || Date).now();\n\nconst mainThreadGenerator = /*#__PURE__*/ (0,webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\nlet warned;\n\n/**\n * Generate an SDF texture image for a single glyph path, placing the result into a webgl canvas at a\n * given location and channel. Utilizes the webgl-sdf-generator external package for GPU-accelerated SDF\n * generation when supported.\n */\nfunction generateSDF(width, height, path, viewBox, distance, exponent, canvas, x, y, channel, useWebGL = true) {\n  // Allow opt-out\n  if (!useWebGL) {\n    return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n  }\n\n  // Attempt GPU-accelerated generation first\n  return generateSDF_GL(width, height, path, viewBox, distance, exponent, canvas, x, y, channel).then(\n    null,\n    err => {\n      // WebGL failed either due to a hard error or unexpected results; fall back to JS in workers\n      if (!warned) {\n        console.warn(`WebGL SDF generation failed, falling back to JS`, err);\n        warned = true;\n      }\n      return generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel)\n    }\n  )\n}\n\nconst queue = [];\nconst chunkTimeBudget = 5; // ms\nlet timer = 0;\n\nfunction nextChunk() {\n  const start = now();\n  while (queue.length && now() - start < chunkTimeBudget) {\n    queue.shift()();\n  }\n  timer = queue.length ? setTimeout(nextChunk, 0) : 0;\n}\n\n/**\n * WebGL-based implementation executed on the main thread. Requests are executed in time-bounded\n * macrotask chunks to allow render frames to execute in between.\n */\nconst generateSDF_GL = (...args) => {\n  return new Promise((resolve, reject) => {\n    queue.push(() => {\n      const start = now();\n      try {\n        mainThreadGenerator.webgl.generateIntoCanvas(...args);\n        resolve({ timing: now() - start });\n      } catch (err) {\n        reject(err);\n      }\n    });\n    if (!timer) {\n      timer = setTimeout(nextChunk, 0);\n    }\n  })\n};\n\nconst threadCount = 4; // how many workers to spawn\nconst idleTimeout = 2000; // workers will be terminated after being idle this many milliseconds\nconst threads = {};\nlet callNum = 0;\n\n/**\n * Fallback JS-based implementation, fanned out to a number of worker threads for parallelism\n */\nfunction generateSDF_JS_Worker(width, height, path, viewBox, distance, exponent, canvas, x, y, channel) {\n  const workerId = 'TroikaTextSDFGenerator_JS_' + ((callNum++) % threadCount);\n  let thread = threads[workerId];\n  if (!thread) {\n    thread = threads[workerId] = {\n      workerModule: (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n        name: workerId,\n        workerId,\n        dependencies: [\n          webgl_sdf_generator__WEBPACK_IMPORTED_MODULE_0__[\"default\"],\n          now\n        ],\n        init(_createSDFGenerator, now) {\n          const generate = _createSDFGenerator().javascript.generate;\n          return function (...args) {\n            const start = now();\n            const textureData = generate(...args);\n            return {\n              textureData,\n              timing: now() - start\n            }\n          }\n        },\n        getTransferables(result) {\n          return [result.textureData.buffer]\n        }\n      }),\n      requests: 0,\n      idleTimer: null\n    };\n  }\n\n  thread.requests++;\n  clearTimeout(thread.idleTimer);\n  return thread.workerModule(width, height, path, viewBox, distance, exponent)\n    .then(({ textureData, timing }) => {\n      // copy result data into the canvas\n      const start = now();\n      // expand single-channel data into rgba\n      const imageData = new Uint8Array(textureData.length * 4);\n      for (let i = 0; i < textureData.length; i++) {\n        imageData[i * 4 + channel] = textureData[i];\n      }\n      mainThreadGenerator.webglUtils.renderImageData(canvas, imageData, x, y, width, height, 1 << (3 - channel));\n      timing += now() - start;\n\n      // clean up workers after a while\n      if (--thread.requests === 0) {\n        thread.idleTimer = setTimeout(() => { (0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.terminateWorker)(workerId); }, idleTimeout);\n      }\n      return { timing }\n    })\n}\n\nfunction warmUpSDFCanvas(canvas) {\n  if (!canvas._warm) {\n    mainThreadGenerator.webgl.isSupported(canvas);\n    canvas._warm = true;\n  }\n}\n\nconst resizeWebGLCanvasWithoutClearing = mainThreadGenerator.webglUtils.resizeWebGLCanvasWithoutClearing;\n\nconst CONFIG = {\n  defaultFontURL: null,\n  unicodeFontsURL: null,\n  sdfGlyphSize: 64,\n  sdfMargin: 1 / 16,\n  sdfExponent: 9,\n  textureWidth: 2048,\n  useWorker: true,\n};\nconst tempColor = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_3__.Color();\nlet hasRequested = false;\n\nfunction now$1() {\n  return (self.performance || Date).now()\n}\n\n/**\n * Customizes the text builder configuration. This must be called prior to the first font processing\n * request, and applies to all fonts.\n *\n * @param {String} config.defaultFontURL - The URL of the default font to use for text processing\n *                 requests, in case none is specified or the specifiede font fails to load or parse.\n *                 Defaults to \"Roboto Regular\" from Google Fonts.\n * @param {String} config.unicodeFontsURL - A custom location for the fallback unicode-font-resolver\n *                 data and font files, if you don't want to use the default CDN. See\n *                 https://github.com/lojjic/unicode-font-resolver for details. It can also be\n *                 configured per text instance, but this lets you do it once globally.\n * @param {Number} config.sdfGlyphSize - The default size of each glyph's SDF (signed distance field)\n *                 texture used for rendering. Must be a power-of-two number, and applies to all fonts,\n *                 but note that this can also be overridden per call to `getTextRenderInfo()`.\n *                 Larger sizes can improve the quality of glyph rendering by increasing the sharpness\n *                 of corners and preventing loss of very thin lines, at the expense of memory. Defaults\n *                 to 64 which is generally a good balance of size and quality.\n * @param {Number} config.sdfExponent - The exponent used when encoding the SDF values. A higher exponent\n *                 shifts the encoded 8-bit values to achieve higher precision/accuracy at texels nearer\n *                 the glyph's path, with lower precision further away. Defaults to 9.\n * @param {Number} config.sdfMargin - How much space to reserve in the SDF as margin outside the glyph's\n *                 path, as a percentage of the SDF width. A larger margin increases the quality of\n *                 extruded glyph outlines, but decreases the precision available for the glyph itself.\n *                 Defaults to 1/16th of the glyph size.\n * @param {Number} config.textureWidth - The width of the SDF texture; must be a power of 2. Defaults to\n *                 2048 which is a safe maximum texture dimension according to the stats at\n *                 https://webglstats.com/webgl/parameter/MAX_TEXTURE_SIZE and should allow for a\n *                 reasonably large number of glyphs (default glyph size of 64^2 and safe texture size of\n *                 2048^2, times 4 channels, allows for 4096 glyphs.) This can be increased if you need to\n *                 increase the glyph size and/or have an extraordinary number of glyphs.\n * @param {Boolean} config.useWorker - Whether to run typesetting in a web worker. Defaults to true.\n */\nfunction configureTextBuilder(config) {\n  if (hasRequested) {\n    console.warn('configureTextBuilder called after first font request; will be ignored.');\n  } else {\n    assign(CONFIG, config);\n  }\n}\n\n/**\n * Repository for all font SDF atlas textures and their glyph mappings. There is a separate atlas for\n * each sdfGlyphSize. Each atlas has a single Texture that holds all glyphs for all fonts.\n *\n *   {\n *     [sdfGlyphSize]: {\n *       glyphCount: number,\n *       sdfGlyphSize: number,\n *       sdfTexture: Texture,\n *       sdfCanvas: HTMLCanvasElement,\n *       contextLost: boolean,\n *       glyphsByFont: Map<fontURL, Map<glyphID, {path, atlasIndex, sdfViewBox}>>\n *     }\n *   }\n */\nconst atlases = Object.create(null);\n\n/**\n * @typedef {object} TroikaTextRenderInfo - Format of the result from `getTextRenderInfo`.\n * @property {TypesetParams} parameters - The normalized input arguments to the render call.\n * @property {Texture} sdfTexture - The SDF atlas texture.\n * @property {number} sdfGlyphSize - The size of each glyph's SDF; see `configureTextBuilder`.\n * @property {number} sdfExponent - The exponent used in encoding the SDF's values; see `configureTextBuilder`.\n * @property {Float32Array} glyphBounds - List of [minX, minY, maxX, maxY] quad bounds for each glyph.\n * @property {Float32Array} glyphAtlasIndices - List holding each glyph's index in the SDF atlas.\n * @property {Uint8Array} [glyphColors] - List holding each glyph's [r, g, b] color, if `colorRanges` was supplied.\n * @property {Float32Array} [caretPositions] - A list of caret positions for all characters in the string; each is\n *           four elements: the starting X, the ending X, the bottom Y, and the top Y for the caret.\n * @property {number} [caretHeight] - An appropriate height for all selection carets.\n * @property {number} ascender - The font's ascender metric.\n * @property {number} descender - The font's descender metric.\n * @property {number} capHeight - The font's cap height metric, based on the height of Latin capital letters.\n * @property {number} xHeight - The font's x height metric, based on the height of Latin lowercase letters.\n * @property {number} lineHeight - The final computed lineHeight measurement.\n * @property {number} topBaseline - The y position of the top line's baseline.\n * @property {Array<number>} blockBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           this can include extra vertical space beyond the visible glyphs due to lineHeight, and is\n *           equivalent to the dimensions of a block-level text element in CSS.\n * @property {Array<number>} visibleBounds - The total [minX, minY, maxX, maxY] rect of the whole text block;\n *           unlike `blockBounds` this is tightly wrapped to the visible glyph paths.\n * @property {Array<object>} chunkedBounds - List of bounding rects for each consecutive set of N glyphs,\n *           in the format `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`.\n * @property {object} timings - Timing info for various parts of the rendering logic including SDF\n *           generation, typesetting, etc.\n * @frozen\n */\n\n/**\n * @callback getTextRenderInfo~callback\n * @param {TroikaTextRenderInfo} textRenderInfo\n */\n\n/**\n * Main entry point for requesting the data needed to render a text string with given font parameters.\n * This is an asynchronous call, performing most of the logic in a web worker thread.\n * @param {TypesetParams} args\n * @param {getTextRenderInfo~callback} callback\n */\nfunction getTextRenderInfo(args, callback) {\n  hasRequested = true;\n  args = assign({}, args);\n  const totalStart = now$1();\n\n  // Convert relative URL to absolute so it can be resolved in the worker, and add fallbacks.\n  // In the future we'll allow args.font to be a list with unicode ranges too.\n  const { defaultFontURL } = CONFIG;\n  const fonts = [];\n  if (defaultFontURL) {\n    fonts.push({label: 'default', src: toAbsoluteURL(defaultFontURL)});\n  }\n  if (args.font) {\n    fonts.push({label: 'user', src: toAbsoluteURL(args.font)});\n  }\n  args.font = fonts;\n\n  // Normalize text to a string\n  args.text = '' + args.text;\n\n  args.sdfGlyphSize = args.sdfGlyphSize || CONFIG.sdfGlyphSize;\n  args.unicodeFontsURL = args.unicodeFontsURL || CONFIG.unicodeFontsURL;\n\n  // Normalize colors\n  if (args.colorRanges != null) {\n    let colors = {};\n    for (let key in args.colorRanges) {\n      if (args.colorRanges.hasOwnProperty(key)) {\n        let val = args.colorRanges[key];\n        if (typeof val !== 'number') {\n          val = tempColor.set(val).getHex();\n        }\n        colors[key] = val;\n      }\n    }\n    args.colorRanges = colors;\n  }\n\n  Object.freeze(args);\n\n  // Init the atlas if needed\n  const {textureWidth, sdfExponent} = CONFIG;\n  const {sdfGlyphSize} = args;\n  const glyphsPerRow = (textureWidth / sdfGlyphSize * 4);\n  let atlas = atlases[sdfGlyphSize];\n  if (!atlas) {\n    const canvas = document.createElement('canvas');\n    canvas.width = textureWidth;\n    canvas.height = sdfGlyphSize * 256 / glyphsPerRow; // start tall enough to fit 256 glyphs\n    atlas = atlases[sdfGlyphSize] = {\n      glyphCount: 0,\n      sdfGlyphSize,\n      sdfCanvas: canvas,\n      sdfTexture: new three__WEBPACK_IMPORTED_MODULE_3__.Texture(\n        canvas,\n        undefined,\n        undefined,\n        undefined,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter,\n        three__WEBPACK_IMPORTED_MODULE_3__.LinearFilter\n      ),\n      contextLost: false,\n      glyphsByFont: new Map()\n    };\n    atlas.sdfTexture.generateMipmaps = false;\n    initContextLossHandling(atlas);\n  }\n\n  const {sdfTexture, sdfCanvas} = atlas;\n\n  // Issue request to the typesetting engine in the worker\n  const typeset = CONFIG.useWorker ? typesetInWorker : typesetOnMainThread;\n  typeset(args).then(result => {\n    const {glyphIds, glyphFontIndices, fontData, glyphPositions, fontSize, timings} = result;\n    const neededSDFs = [];\n    const glyphBounds = new Float32Array(glyphIds.length * 4);\n    let boundsIdx = 0;\n    let positionsIdx = 0;\n    const quadsStart = now$1();\n\n    const fontGlyphMaps = fontData.map(font => {\n      let map = atlas.glyphsByFont.get(font.src);\n      if (!map) {\n        atlas.glyphsByFont.set(font.src, map = new Map());\n      }\n      return map\n    });\n\n    glyphIds.forEach((glyphId, i) => {\n      const fontIndex = glyphFontIndices[i];\n      const {src: fontSrc, unitsPerEm} = fontData[fontIndex];\n      let glyphInfo = fontGlyphMaps[fontIndex].get(glyphId);\n\n      // If this is a glyphId not seen before, add it to the atlas\n      if (!glyphInfo) {\n        const {path, pathBounds} = result.glyphData[fontSrc][glyphId];\n\n        // Margin around path edges in SDF, based on a percentage of the glyph's max dimension.\n        // Note we add an extra 0.5 px over the configured value because the outer 0.5 doesn't contain\n        // useful interpolated values and will be ignored anyway.\n        const fontUnitsMargin = Math.max(pathBounds[2] - pathBounds[0], pathBounds[3] - pathBounds[1])\n          / sdfGlyphSize * (CONFIG.sdfMargin * sdfGlyphSize + 0.5);\n\n        const atlasIndex = atlas.glyphCount++;\n        const sdfViewBox = [\n          pathBounds[0] - fontUnitsMargin,\n          pathBounds[1] - fontUnitsMargin,\n          pathBounds[2] + fontUnitsMargin,\n          pathBounds[3] + fontUnitsMargin,\n        ];\n        fontGlyphMaps[fontIndex].set(glyphId, (glyphInfo = { path, atlasIndex, sdfViewBox }));\n\n        // Collect those that need SDF generation\n        neededSDFs.push(glyphInfo);\n      }\n\n      // Calculate bounds for renderable quads\n      // TODO can we get this back off the main thread?\n      const {sdfViewBox} = glyphInfo;\n      const posX = glyphPositions[positionsIdx++];\n      const posY = glyphPositions[positionsIdx++];\n      const fontSizeMult = fontSize / unitsPerEm;\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[0] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[1] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posX + sdfViewBox[2] * fontSizeMult;\n      glyphBounds[boundsIdx++] = posY + sdfViewBox[3] * fontSizeMult;\n\n      // Convert glyphId to SDF index for the shader\n      glyphIds[i] = glyphInfo.atlasIndex;\n    });\n    timings.quads = (timings.quads || 0) + (now$1() - quadsStart);\n\n    const sdfStart = now$1();\n    timings.sdf = {};\n\n    // Grow the texture height by power of 2 if needed\n    const currentHeight = sdfCanvas.height;\n    const neededRows = Math.ceil(atlas.glyphCount / glyphsPerRow);\n    const neededHeight = Math.pow(2, Math.ceil(Math.log2(neededRows * sdfGlyphSize)));\n    if (neededHeight > currentHeight) {\n      // Since resizing the canvas clears its render buffer, it needs special handling to copy the old contents over\n      console.info(`Increasing SDF texture size ${currentHeight}->${neededHeight}`);\n      resizeWebGLCanvasWithoutClearing(sdfCanvas, textureWidth, neededHeight);\n      // As of Three r136 textures cannot be resized once they're allocated on the GPU, we must dispose to reallocate it\n      sdfTexture.dispose();\n    }\n\n    Promise.all(neededSDFs.map(glyphInfo =>\n      generateGlyphSDF(glyphInfo, atlas, args.gpuAccelerateSDF).then(({timing}) => {\n        timings.sdf[glyphInfo.atlasIndex] = timing;\n      })\n    )).then(() => {\n      if (neededSDFs.length && !atlas.contextLost) {\n        safariPre15Workaround(atlas);\n        sdfTexture.needsUpdate = true;\n      }\n      timings.sdfTotal = now$1() - sdfStart;\n      timings.total = now$1() - totalStart;\n      // console.log(`SDF - ${timings.sdfTotal}, Total - ${timings.total - timings.fontLoad}`)\n\n      // Invoke callback with the text layout arrays and updated texture\n      callback(Object.freeze({\n        parameters: args,\n        sdfTexture,\n        sdfGlyphSize,\n        sdfExponent,\n        glyphBounds,\n        glyphAtlasIndices: glyphIds,\n        glyphColors: result.glyphColors,\n        caretPositions: result.caretPositions,\n        chunkedBounds: result.chunkedBounds,\n        ascender: result.ascender,\n        descender: result.descender,\n        lineHeight: result.lineHeight,\n        capHeight: result.capHeight,\n        xHeight: result.xHeight,\n        topBaseline: result.topBaseline,\n        blockBounds: result.blockBounds,\n        visibleBounds: result.visibleBounds,\n        timings: result.timings,\n      }));\n    });\n  });\n\n  // While the typesetting request is being handled, go ahead and make sure the atlas canvas context is\n  // \"warmed up\"; the first request will be the longest due to shader program compilation so this gets\n  // a head start on that process before SDFs actually start getting processed.\n  Promise.resolve().then(() => {\n    if (!atlas.contextLost) {\n      warmUpSDFCanvas(sdfCanvas);\n    }\n  });\n}\n\nfunction generateGlyphSDF({path, atlasIndex, sdfViewBox}, {sdfGlyphSize, sdfCanvas, contextLost}, useGPU) {\n  if (contextLost) {\n    // If the context is lost there's nothing we can do, just quit silently and let it\n    // get regenerated when the context is restored\n    return Promise.resolve({timing: -1})\n  }\n  const {textureWidth, sdfExponent} = CONFIG;\n  const maxDist = Math.max(sdfViewBox[2] - sdfViewBox[0], sdfViewBox[3] - sdfViewBox[1]);\n  const squareIndex = Math.floor(atlasIndex / 4);\n  const x = squareIndex % (textureWidth / sdfGlyphSize) * sdfGlyphSize;\n  const y = Math.floor(squareIndex / (textureWidth / sdfGlyphSize)) * sdfGlyphSize;\n  const channel = atlasIndex % 4;\n  return generateSDF(sdfGlyphSize, sdfGlyphSize, path, sdfViewBox, maxDist, sdfExponent, sdfCanvas, x, y, channel, useGPU)\n}\n\nfunction initContextLossHandling(atlas) {\n  const canvas = atlas.sdfCanvas;\n\n  /*\n  // Begin context loss simulation\n  if (!window.WebGLDebugUtils) {\n    let script = document.getElementById('WebGLDebugUtilsScript')\n    if (!script) {\n      script = document.createElement('script')\n      script.id = 'WebGLDebugUtils'\n      document.head.appendChild(script)\n      script.src = 'https://cdn.jsdelivr.net/gh/KhronosGroup/WebGLDeveloperTools@b42e702/src/debug/webgl-debug.js'\n    }\n    script.addEventListener('load', () => {\n      initContextLossHandling(atlas)\n    })\n    return\n  }\n  window.WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)\n  canvas.loseContextInNCalls(500)\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    canvas.loseContextInNCalls(5000)\n  })\n  // End context loss simulation\n  */\n\n  canvas.addEventListener('webglcontextlost', (event) => {\n    console.log('Context Lost', event);\n    event.preventDefault();\n    atlas.contextLost = true;\n  });\n  canvas.addEventListener('webglcontextrestored', (event) => {\n    console.log('Context Restored', event);\n    atlas.contextLost = false;\n    // Regenerate all glyphs into the restored canvas:\n    const promises = [];\n    atlas.glyphsByFont.forEach(glyphMap => {\n      glyphMap.forEach(glyph => {\n        promises.push(generateGlyphSDF(glyph, atlas, true));\n      });\n    });\n    Promise.all(promises).then(() => {\n      safariPre15Workaround(atlas);\n      atlas.sdfTexture.needsUpdate = true;\n    });\n  });\n}\n\n/**\n * Preload a given font and optionally pre-generate glyph SDFs for one or more character sequences.\n * This can be useful to avoid long pauses when first showing text in a scene, by preloading the\n * needed fonts and glyphs up front along with other assets.\n *\n * @param {object} options\n * @param {string} options.font - URL of the font file to preload. If not given, the default font will\n *        be loaded.\n * @param {string|string[]} options.characters - One or more character sequences for which to pre-\n *        generate glyph SDFs. Note that this will honor ligature substitution, so you may need\n *        to specify ligature sequences in addition to their individual characters to get all\n *        possible glyphs, e.g. `[\"t\", \"h\", \"th\"]` to get the \"t\" and \"h\" glyphs plus the \"th\" ligature.\n * @param {number} options.sdfGlyphSize - The size at which to prerender the SDF textures for the\n *        specified `characters`.\n * @param {function} callback - A function that will be called when the preloading is complete.\n */\nfunction preloadFont({font, characters, sdfGlyphSize}, callback) {\n  let text = Array.isArray(characters) ? characters.join('\\n') : '' + characters;\n  getTextRenderInfo({ font, sdfGlyphSize, text }, callback);\n}\n\n\n// Local assign impl so we don't have to import troika-core\nfunction assign(toObj, fromObj) {\n  for (let key in fromObj) {\n    if (fromObj.hasOwnProperty(key)) {\n      toObj[key] = fromObj[key];\n    }\n  }\n  return toObj\n}\n\n// Utility for making URLs absolute\nlet linkEl;\nfunction toAbsoluteURL(path) {\n  if (!linkEl) {\n    linkEl = typeof document === 'undefined' ? {} : document.createElement('a');\n  }\n  linkEl.href = path;\n  return linkEl.href\n}\n\n/**\n * Safari < v15 seems unable to use the SDF webgl canvas as a texture. This applies a workaround\n * where it reads the pixels out of that canvas and uploads them as a data texture instead, at\n * a slight performance cost.\n */\nfunction safariPre15Workaround(atlas) {\n  // Use createImageBitmap support as a proxy for Safari<15, all other mainstream browsers\n  // have supported it for a long while so any false positives should be minimal.\n  if (typeof createImageBitmap !== 'function') {\n    console.info('Safari<15: applying SDF canvas workaround');\n    const {sdfCanvas, sdfTexture} = atlas;\n    const {width, height} = sdfCanvas;\n    const gl = atlas.sdfCanvas.getContext('webgl');\n    let pixels = sdfTexture.image.data;\n    if (!pixels || pixels.length !== width * height * 4) {\n      pixels = new Uint8Array(width * height * 4);\n      sdfTexture.image = {width, height, data: pixels};\n      sdfTexture.flipY = false;\n      sdfTexture.isDataTexture = true;\n    }\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n  }\n}\n\nconst typesetterWorkerModule = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    createTypesetter,\n    fontResolverWorkerModule,\n    bidi_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  ],\n  init(createTypesetter, fontResolver, bidiFactory) {\n    return createTypesetter(fontResolver, bidiFactory())\n  }\n});\n\nconst typesetInWorker = /*#__PURE__*/(0,troika_worker_utils__WEBPACK_IMPORTED_MODULE_2__.defineWorkerModule)({\n  name: 'Typesetter',\n  dependencies: [\n    typesetterWorkerModule,\n  ],\n  init(typesetter) {\n    return function(args) {\n      return new Promise(resolve => {\n        typesetter.typeset(args, resolve);\n      })\n    }\n  },\n  getTransferables(result) {\n    // Mark array buffers as transferable to avoid cloning during postMessage\n    const transferables = [];\n    for (let p in result) {\n      if (result[p] && result[p].buffer) {\n        transferables.push(result[p].buffer);\n      }\n    }\n    return transferables\n  }\n});\n\nconst typesetOnMainThread = typesetInWorker.onMainThread;\n\nfunction dumpSDFTextures() {\n  Object.keys(atlases).forEach(size => {\n    const canvas = atlases[size].sdfCanvas;\n    const {width, height} = canvas;\n    console.log(\"%c.\", `\n      background: url(${canvas.toDataURL()});\n      background-size: ${width}px ${height}px;\n      color: transparent;\n      font-size: 0;\n      line-height: ${height}px;\n      padding-left: ${width}px;\n    `);\n  });\n}\n\nconst templateGeometries = {};\n\nfunction getTemplateGeometry(detail) {\n  let geom = templateGeometries[detail];\n  if (!geom) {\n    geom = templateGeometries[detail] = new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, detail, detail).translate(0.5, 0.5, 0);\n  }\n  return geom\n}\n\nconst glyphBoundsAttrName = 'aTroikaGlyphBounds';\nconst glyphIndexAttrName = 'aTroikaGlyphIndex';\nconst glyphColorAttrName = 'aTroikaGlyphColor';\n\n/**\n@class GlyphsGeometry\n\nA specialized Geometry for rendering a set of text glyphs. Uses InstancedBufferGeometry to\nrender the glyphs using GPU instancing of a single quad, rather than constructing a whole\ngeometry with vertices, for much smaller attribute arraybuffers according to this math:\n\n  Where N = number of glyphs...\n\n  Instanced:\n  - position: 4 * 3\n  - index: 2 * 3\n  - normal: 4 * 3\n  - uv: 4 * 2\n  - glyph x/y bounds: N * 4\n  - glyph indices: N * 1\n  = 5N + 38\n\n  Non-instanced:\n  - position: N * 4 * 3\n  - index: N * 2 * 3\n  - normal: N * 4 * 3\n  - uv: N * 4 * 2\n  - glyph indices: N * 1\n  = 39N\n\nA downside of this is the rare-but-possible lack of the instanced arrays extension,\nwhich we could potentially work around with a fallback non-instanced implementation.\n\n*/\nclass GlyphsGeometry extends three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferGeometry {\n  constructor() {\n    super();\n\n    this.detail = 1;\n    this.curveRadius = 0;\n\n    // Define groups for rendering text outline as a separate pass; these will only\n    // be used when the `material` getter returns an array, i.e. outlineWidth > 0.\n    this.groups = [\n      {start: 0, count: Infinity, materialIndex: 0},\n      {start: 0, count: Infinity, materialIndex: 1}\n    ];\n\n    // Preallocate empty bounding objects\n    this.boundingSphere = new three__WEBPACK_IMPORTED_MODULE_3__.Sphere();\n    this.boundingBox = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\n  }\n\n  computeBoundingSphere () {\n    // No-op; we'll sync the boundingSphere proactively when needed.\n  }\n\n  computeBoundingBox() {\n    // No-op; we'll sync the boundingBox proactively when needed.\n  }\n\n  set detail(detail) {\n    if (detail !== this._detail) {\n      this._detail = detail;\n      if (typeof detail !== 'number' || detail < 1) {\n        detail = 1;\n      }\n      let tpl = getTemplateGeometry(detail)\n      ;['position', 'normal', 'uv'].forEach(attr => {\n        this.attributes[attr] = tpl.attributes[attr].clone();\n      });\n      this.setIndex(tpl.getIndex().clone());\n    }\n  }\n  get detail() {\n    return this._detail\n  }\n\n  set curveRadius(r) {\n    if (r !== this._curveRadius) {\n      this._curveRadius = r;\n      this._updateBounds();\n    }\n  }\n  get curveRadius() {\n    return this._curveRadius\n  }\n\n  /**\n   * Update the geometry for a new set of glyphs.\n   * @param {Float32Array} glyphBounds - An array holding the planar bounds for all glyphs\n   *        to be rendered, 4 entries for each glyph: x1,x2,y1,y1\n   * @param {Float32Array} glyphAtlasIndices - An array holding the index of each glyph within\n   *        the SDF atlas texture.\n   * @param {Array} blockBounds - An array holding the [minX, minY, maxX, maxY] across all glyphs\n   * @param {Array} [chunkedBounds] - An array of objects describing bounds for each chunk of N\n   *        consecutive glyphs: `{start:N, end:N, rect:[minX, minY, maxX, maxY]}`. This can be\n   *        used with `applyClipRect` to choose an optimized `instanceCount`.\n   * @param {Uint8Array} [glyphColors] - An array holding r,g,b values for each glyph.\n   */\n  updateGlyphs(glyphBounds, glyphAtlasIndices, blockBounds, chunkedBounds, glyphColors) {\n    // Update the instance attributes\n    this.updateAttributeData(glyphBoundsAttrName, glyphBounds, 4);\n    this.updateAttributeData(glyphIndexAttrName, glyphAtlasIndices, 1);\n    this.updateAttributeData(glyphColorAttrName, glyphColors, 3);\n    this._blockBounds = blockBounds;\n    this._chunkedBounds = chunkedBounds;\n    this.instanceCount = glyphAtlasIndices.length;\n    this._updateBounds();\n  }\n\n  _updateBounds() {\n    const bounds = this._blockBounds;\n    if (bounds) {\n      const { curveRadius, boundingBox: bbox } = this;\n      if (curveRadius) {\n        const { PI, floor, min, max, sin, cos } = Math;\n        const halfPi = PI / 2;\n        const twoPi = PI * 2;\n        const absR = Math.abs(curveRadius);\n        const leftAngle = bounds[0] / absR;\n        const rightAngle = bounds[2] / absR;\n        const minX = floor((leftAngle + halfPi) / twoPi) !== floor((rightAngle + halfPi) / twoPi)\n          ? -absR : min(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxX = floor((leftAngle - halfPi) / twoPi) !== floor((rightAngle - halfPi) / twoPi)\n          ? absR : max(sin(leftAngle) * absR, sin(rightAngle) * absR);\n        const maxZ = floor((leftAngle + PI) / twoPi) !== floor((rightAngle + PI) / twoPi)\n          ? absR * 2 : max(absR - cos(leftAngle) * absR, absR - cos(rightAngle) * absR);\n        bbox.min.set(minX, bounds[1], curveRadius < 0 ? -maxZ : 0);\n        bbox.max.set(maxX, bounds[3], curveRadius < 0 ? 0 : maxZ);\n      } else {\n        bbox.min.set(bounds[0], bounds[1], 0);\n        bbox.max.set(bounds[2], bounds[3], 0);\n      }\n      bbox.getBoundingSphere(this.boundingSphere);\n    }\n  }\n\n  /**\n   * Given a clipping rect, and the chunkedBounds from the last updateGlyphs call, choose the lowest\n   * `instanceCount` that will show all glyphs within the clipped view. This is an optimization\n   * for long blocks of text that are clipped, to skip vertex shader evaluation for glyphs that would\n   * be clipped anyway.\n   *\n   * Note that since `drawElementsInstanced[ANGLE]` only accepts an instance count and not a starting\n   * offset, this optimization becomes less effective as the clipRect moves closer to the end of the\n   * text block. We could fix that by switching from instancing to a full geometry with a drawRange,\n   * but at the expense of much larger attribute buffers (see classdoc above.)\n   *\n   * @param {Vector4} clipRect\n   */\n  applyClipRect(clipRect) {\n    let count = this.getAttribute(glyphIndexAttrName).count;\n    let chunks = this._chunkedBounds;\n    if (chunks) {\n      for (let i = chunks.length; i--;) {\n        count = chunks[i].end;\n        let rect = chunks[i].rect;\n        // note: both rects are l-b-r-t\n        if (rect[1] < clipRect.w && rect[3] > clipRect.y && rect[0] < clipRect.z && rect[2] > clipRect.x) {\n          break\n        }\n      }\n    }\n    this.instanceCount = count;\n  }\n\n  /**\n   * Utility for updating instance attributes with automatic resizing\n   */\n  updateAttributeData(attrName, newArray, itemSize) {\n    const attr = this.getAttribute(attrName);\n    if (newArray) {\n      // If length isn't changing, just update the attribute's array data\n      if (attr && attr.array.length === newArray.length) {\n        attr.array.set(newArray);\n        attr.needsUpdate = true;\n      } else {\n        this.setAttribute(attrName, new three__WEBPACK_IMPORTED_MODULE_3__.InstancedBufferAttribute(newArray, itemSize));\n        // If the new attribute has a different size, we also have to (as of r117) manually clear the\n        // internal cached max instance count. See https://github.com/mrdoob/three.js/issues/19706\n        // It's unclear if this is a threejs bug or a truly unsupported scenario; discussion in\n        // that ticket is ambiguous as to whether replacing a BufferAttribute with one of a\n        // different size is supported, but https://github.com/mrdoob/three.js/pull/17418 strongly\n        // implies it should be supported. It's possible we need to\n        delete this._maxInstanceCount; //for r117+, could be fragile\n        this.dispose(); //for r118+, more robust feeling, but more heavy-handed than I'd like\n      }\n    } else if (attr) {\n      this.deleteAttribute(attrName);\n    }\n  }\n}\n\n// language=GLSL\nconst VERTEX_DEFS = `\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform vec4 uTroikaTotalBounds;\nuniform vec4 uTroikaClipRect;\nuniform mat3 uTroikaOrient;\nuniform bool uTroikaUseGlyphColors;\nuniform float uTroikaEdgeOffset;\nuniform float uTroikaBlurRadius;\nuniform vec2 uTroikaPositionOffset;\nuniform float uTroikaCurveRadius;\nattribute vec4 aTroikaGlyphBounds;\nattribute float aTroikaGlyphIndex;\nattribute vec3 aTroikaGlyphColor;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec3 vTroikaGlyphColor;\nvarying vec2 vTroikaGlyphDimensions;\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst VERTEX_TRANSFORM = `\nvec4 bounds = aTroikaGlyphBounds;\nbounds.xz += uTroikaPositionOffset.x;\nbounds.yw -= uTroikaPositionOffset.y;\n\nvec4 outlineBounds = vec4(\n  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,\n  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius\n);\nvec4 clippedBounds = vec4(\n  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),\n  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)\n);\n\nvec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);\n\nposition.xy = mix(bounds.xy, bounds.zw, clippedXY);\n\nuv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);\n\nfloat rad = uTroikaCurveRadius;\nif (rad != 0.0) {\n  float angle = position.x / rad;\n  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);\n  normal.xz = vec2(sin(angle), cos(angle));\n}\n  \nposition = uTroikaOrient * position;\nnormal = uTroikaOrient * normal;\n\nvTroikaGlyphUV = clippedXY.xy;\nvTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);\n\n${''/* NOTE: it seems important to calculate the glyph's bounding texture UVs here in the\n  vertex shader, rather than in the fragment shader, as the latter gives strange artifacts\n  on some glyphs (those in the leftmost texture column) on some systems. The exact reason\n  isn't understood but doing this here, then mix()-ing in the fragment shader, seems to work. */}\nfloat txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;\nvec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;\nvec2 txStartUV = txUvPerSquare * vec2(\n  mod(floor(aTroikaGlyphIndex / 4.0), txCols),\n  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)\n);\nvTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);\nvTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);\n`;\n\n// language=GLSL\nconst FRAGMENT_DEFS = `\nuniform sampler2D uTroikaSDFTexture;\nuniform vec2 uTroikaSDFTextureSize;\nuniform float uTroikaSDFGlyphSize;\nuniform float uTroikaSDFExponent;\nuniform float uTroikaEdgeOffset;\nuniform float uTroikaFillOpacity;\nuniform float uTroikaBlurRadius;\nuniform vec3 uTroikaStrokeColor;\nuniform float uTroikaStrokeWidth;\nuniform float uTroikaStrokeOpacity;\nuniform bool uTroikaSDFDebug;\nvarying vec2 vTroikaGlyphUV;\nvarying vec4 vTroikaTextureUVBounds;\nvarying float vTroikaTextureChannel;\nvarying vec2 vTroikaGlyphDimensions;\n\nfloat troikaSdfValueToSignedDistance(float alpha) {\n  // Inverse of exponential encoding in webgl-sdf-generator\n  ${''/* TODO - there's some slight inaccuracy here when dealing with interpolated alpha values; those\n    are linearly interpolated where the encoding is exponential. Look into improving this by rounding\n    to nearest 2 whole texels, decoding those exponential values, and linearly interpolating the result.\n  */}\n  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);\n  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;\n  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);\n  return signedDist;\n}\n\nfloat troikaGlyphUvToSdfValue(vec2 glyphUV) {\n  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);\n  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);\n  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1\n  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;\n}\n\nfloat troikaGlyphUvToDistance(vec2 uv) {\n  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));\n}\n\nfloat troikaGetAADist() {\n  ${''/*\n    When the standard derivatives extension is available, we choose an antialiasing alpha threshold based\n    on the potential change in the SDF's alpha from this fragment to its neighbor. This strategy maximizes \n    readability and edge crispness at all sizes and screen resolutions.\n  */}\n  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300\n  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;\n  #else\n  return vTroikaGlyphDimensions.x / 64.0;\n  #endif\n}\n\nfloat troikaGetFragDistValue() {\n  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);\n  float distance = troikaGlyphUvToDistance(clampedGlyphUV);\n \n  // Extrapolate distance when outside bounds:\n  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : \n    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n\n  ${''/* \n  // TODO more refined extrapolated distance by adjusting for angle of gradient at edge...\n  // This has potential but currently gives very jagged extensions, maybe due to precision issues?\n  float uvStep = 1.0 / uTroikaSDFGlyphSize;\n  vec2 neighbor1UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  vec2 neighbor2UV = clampedGlyphUV + (\n    vTroikaGlyphUV.x != clampedGlyphUV.x ? vec2(0.0, uvStep * -sign(0.5 - vTroikaGlyphUV.y)) :\n    vTroikaGlyphUV.y != clampedGlyphUV.y ? vec2(uvStep * -sign(0.5 - vTroikaGlyphUV.x), 0.0) :\n    vec2(0.0)\n  );\n  float neighbor1Distance = troikaGlyphUvToDistance(neighbor1UV);\n  float neighbor2Distance = troikaGlyphUvToDistance(neighbor2UV);\n  float distToUnclamped = length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);\n  float distToNeighbor = length((clampedGlyphUV - neighbor1UV) * vTroikaGlyphDimensions);\n  float gradientAngle1 = min(asin(abs(neighbor1Distance - distance) / distToNeighbor), PI / 2.0);\n  float gradientAngle2 = min(asin(abs(neighbor2Distance - distance) / distToNeighbor), PI / 2.0);\n  distance += (cos(gradientAngle1) + cos(gradientAngle2)) / 2.0 * distToUnclamped;\n  */}\n\n  return distance;\n}\n\nfloat troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {\n  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)\n  float alpha = step(-distanceOffset, -distance);\n  #else\n\n  float alpha = smoothstep(\n    distanceOffset + aaDist,\n    distanceOffset - aaDist,\n    distance\n  );\n  #endif\n\n  return alpha;\n}\n`;\n\n// language=GLSL prefix=\"void main() {\" suffix=\"}\"\nconst FRAGMENT_TRANSFORM = `\nfloat aaDist = troikaGetAADist();\nfloat fragDistance = troikaGetFragDistValue();\nfloat edgeAlpha = uTroikaSDFDebug ?\n  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :\n  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));\n\n#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)\nvec4 fillRGBA = gl_FragColor;\nfillRGBA.a *= uTroikaFillOpacity;\nvec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);\nif (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;\ngl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(\n  -uTroikaStrokeWidth - aaDist,\n  -uTroikaStrokeWidth + aaDist,\n  fragDistance\n));\ngl_FragColor.a *= edgeAlpha;\n#endif\n\nif (edgeAlpha == 0.0) {\n  discard;\n}\n`;\n\n\n/**\n * Create a material for rendering text, derived from a baseMaterial\n */\nfunction createTextDerivedMaterial(baseMaterial) {\n  const textMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n    chained: true,\n    extensions: {\n      derivatives: true\n    },\n    uniforms: {\n      uTroikaSDFTexture: {value: null},\n      uTroikaSDFTextureSize: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaSDFGlyphSize: {value: 0},\n      uTroikaSDFExponent: {value: 0},\n      uTroikaTotalBounds: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaClipRect: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector4(0,0,0,0)},\n      uTroikaEdgeOffset: {value: 0},\n      uTroikaFillOpacity: {value: 1},\n      uTroikaPositionOffset: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()},\n      uTroikaCurveRadius: {value: 0},\n      uTroikaBlurRadius: {value: 0},\n      uTroikaStrokeWidth: {value: 0},\n      uTroikaStrokeColor: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Color()},\n      uTroikaStrokeOpacity: {value: 1},\n      uTroikaOrient: {value: new three__WEBPACK_IMPORTED_MODULE_3__.Matrix3()},\n      uTroikaUseGlyphColors: {value: true},\n      uTroikaSDFDebug: {value: false}\n    },\n    vertexDefs: VERTEX_DEFS,\n    vertexTransform: VERTEX_TRANSFORM,\n    fragmentDefs: FRAGMENT_DEFS,\n    fragmentColorTransform: FRAGMENT_TRANSFORM,\n    customRewriter({vertexShader, fragmentShader}) {\n      let uDiffuseRE = /\\buniform\\s+vec3\\s+diffuse\\b/;\n      if (uDiffuseRE.test(fragmentShader)) {\n        // Replace all instances of `diffuse` with our varying\n        fragmentShader = fragmentShader\n          .replace(uDiffuseRE, 'varying vec3 vTroikaGlyphColor')\n          .replace(/\\bdiffuse\\b/g, 'vTroikaGlyphColor');\n        // Make sure the vertex shader declares the uniform so we can grab it as a fallback\n        if (!uDiffuseRE.test(vertexShader)) {\n          vertexShader = vertexShader.replace(\n            troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.voidMainRegExp,\n            'uniform vec3 diffuse;\\n$&\\nvTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;\\n'\n          );\n        }\n      }\n      return { vertexShader, fragmentShader }\n    }\n  });\n\n  // Force transparency - TODO is this reasonable?\n  textMaterial.transparent = true;\n\n  // Force single draw call when double-sided\n  textMaterial.forceSinglePass = true;\n\n  Object.defineProperties(textMaterial, {\n    isTroikaTextMaterial: {value: true},\n\n    // WebGLShadowMap reverses the side of the shadow material by default, which fails\n    // for planes, so here we force the `shadowSide` to always match the main side.\n    shadowSide: {\n      get() {\n        return this.side\n      },\n      set() {\n        //no-op\n      }\n    }\n  });\n\n  return textMaterial\n}\n\nconst defaultMaterial = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.MeshBasicMaterial({\n  color: 0xffffff,\n  side: three__WEBPACK_IMPORTED_MODULE_3__.DoubleSide,\n  transparent: true\n});\nconst defaultStrokeColor = 0x808080;\n\nconst tempMat4 = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Matrix4();\nconst tempVec3a = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempVec3b = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst tempArray = [];\nconst origin = /*#__PURE__*/ new three__WEBPACK_IMPORTED_MODULE_3__.Vector3();\nconst defaultOrient = '+x+y';\n\nfunction first(o) {\n  return Array.isArray(o) ? o[0] : o\n}\n\nlet getFlatRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1),\n    defaultMaterial\n  );\n  getFlatRaycastMesh = () => mesh;\n  return mesh\n};\nlet getCurvedRaycastMesh = () => {\n  const mesh = new three__WEBPACK_IMPORTED_MODULE_3__.Mesh(\n    new three__WEBPACK_IMPORTED_MODULE_3__.PlaneGeometry(1, 1, 32, 1),\n    defaultMaterial\n  );\n  getCurvedRaycastMesh = () => mesh;\n  return mesh\n};\n\nconst syncStartEvent = { type: 'syncstart' };\nconst syncCompleteEvent = { type: 'synccomplete' };\n\nconst SYNCABLE_PROPS = [\n  'font',\n  'fontSize',\n  'fontStyle',\n  'fontWeight',\n  'lang',\n  'letterSpacing',\n  'lineHeight',\n  'maxWidth',\n  'overflowWrap',\n  'text',\n  'direction',\n  'textAlign',\n  'textIndent',\n  'whiteSpace',\n  'anchorX',\n  'anchorY',\n  'colorRanges',\n  'sdfGlyphSize'\n];\n\nconst COPYABLE_PROPS = SYNCABLE_PROPS.concat(\n  'material',\n  'color',\n  'depthOffset',\n  'clipRect',\n  'curveRadius',\n  'orientation',\n  'glyphGeometryDetail'\n);\n\n/**\n * @class Text\n *\n * A ThreeJS Mesh that renders a string of text on a plane in 3D space using signed distance\n * fields (SDF).\n */\nclass Text extends three__WEBPACK_IMPORTED_MODULE_3__.Mesh {\n  constructor() {\n    const geometry = new GlyphsGeometry();\n    super(geometry, null);\n\n    // === Text layout properties: === //\n\n    /**\n     * @member {string} text\n     * The string of text to be rendered.\n     */\n    this.text = '';\n\n    /**\n     * @member {number|string} anchorX\n     * Defines the horizontal position in the text block that should line up with the local origin.\n     * Can be specified as a numeric x position in local units, a string percentage of the total\n     * text block width e.g. `'25%'`, or one of the following keyword strings: 'left', 'center',\n     * or 'right'.\n     */\n    this.anchorX = 0;\n\n    /**\n     * @member {number|string} anchorY\n     * Defines the vertical position in the text block that should line up with the local origin.\n     * Can be specified as a numeric y position in local units (note: down is negative y), a string\n     * percentage of the total text block height e.g. `'25%'`, or one of the following keyword strings:\n     * 'top', 'top-baseline', 'top-cap', 'top-ex', 'middle', 'bottom-baseline', or 'bottom'.\n     */\n    this.anchorY = 0;\n\n    /**\n     * @member {number} curveRadius\n     * Defines a cylindrical radius along which the text's plane will be curved. Positive numbers put\n     * the cylinder's centerline (oriented vertically) that distance in front of the text, for a concave\n     * curvature, while negative numbers put it behind the text for a convex curvature. The centerline\n     * will be aligned with the text's local origin; you can use `anchorX` to offset it.\n     *\n     * Since each glyph is by default rendered with a simple quad, each glyph remains a flat plane\n     * internally. You can use `glyphGeometryDetail` to add more vertices for curvature inside glyphs.\n     */\n    this.curveRadius = 0;\n\n    /**\n     * @member {string} direction\n     * Sets the base direction for the text. The default value of \"auto\" will choose a direction based\n     * on the text's content according to the bidi spec. A value of \"ltr\" or \"rtl\" will force the direction.\n     */\n    this.direction = 'auto';\n\n    /**\n     * @member {string|null} font\n     * URL of a custom font to be used. Font files can be in .ttf, .otf, or .woff (not .woff2) formats.\n     * Defaults to Noto Sans.\n     */\n    this.font = null; //will use default from TextBuilder\n\n    this.unicodeFontsURL = null; //defaults to CDN\n\n    /**\n     * @member {number} fontSize\n     * The size at which to render the font in local units; corresponds to the em-box height\n     * of the chosen `font`.\n     */\n    this.fontSize = 0.1;\n\n    /**\n     * @member {number|'normal'|'bold'}\n     * The weight of the font. Currently only used for fallback Noto fonts.\n     */\n    this.fontWeight = 'normal';\n\n    /**\n     * @member {'normal'|'italic'}\n     * The style of the font. Currently only used for fallback Noto fonts.\n     */\n    this.fontStyle = 'normal';\n\n    /**\n     * @member {string|null} lang\n     * The language code of this text; can be used for explicitly selecting certain CJK fonts.\n     */\n    this.lang = null;\n\n      /**\n     * @member {number} letterSpacing\n     * Sets a uniform adjustment to spacing between letters after kerning is applied. Positive\n     * numbers increase spacing and negative numbers decrease it.\n     */\n    this.letterSpacing = 0;\n\n    /**\n     * @member {number|string} lineHeight\n     * Sets the height of each line of text, as a multiple of the `fontSize`. Defaults to 'normal'\n     * which chooses a reasonable height based on the chosen font's ascender/descender metrics.\n     */\n    this.lineHeight = 'normal';\n\n    /**\n     * @member {number} maxWidth\n     * The maximum width of the text block, above which text may start wrapping according to the\n     * `whiteSpace` and `overflowWrap` properties.\n     */\n    this.maxWidth = Infinity;\n\n    /**\n     * @member {string} overflowWrap\n     * Defines how text wraps if the `whiteSpace` property is `normal`. Can be either `'normal'`\n     * to break at whitespace characters, or `'break-word'` to allow breaking within words.\n     * Defaults to `'normal'`.\n     */\n    this.overflowWrap = 'normal';\n\n    /**\n     * @member {string} textAlign\n     * The horizontal alignment of each line of text within the overall text bounding box.\n     */\n    this.textAlign = 'left';\n\n    /**\n     * @member {number} textIndent\n     * Indentation for the first character of a line; see CSS `text-indent`.\n     */\n    this.textIndent = 0;\n\n    /**\n     * @member {string} whiteSpace\n     * Defines whether text should wrap when a line reaches the `maxWidth`. Can\n     * be either `'normal'` (the default), to allow wrapping according to the `overflowWrap` property,\n     * or `'nowrap'` to prevent wrapping. Note that `'normal'` here honors newline characters to\n     * manually break lines, making it behave more like `'pre-wrap'` does in CSS.\n     */\n    this.whiteSpace = 'normal';\n\n\n    // === Presentation properties: === //\n\n    /**\n     * @member {THREE.Material} material\n     * Defines a _base_ material to be used when rendering the text. This material will be\n     * automatically replaced with a material derived from it, that adds shader code to\n     * decrease the alpha for each fragment (pixel) outside the text glyphs, with antialiasing.\n     * By default it will derive from a simple white MeshBasicMaterial, but you can use any\n     * of the other mesh materials to gain other features like lighting, texture maps, etc.\n     *\n     * Also see the `color` shortcut property.\n     */\n    this.material = null;\n\n    /**\n     * @member {string|number|THREE.Color} color\n     * This is a shortcut for setting the `color` of the text's material. You can use this\n     * if you don't want to specify a whole custom `material`. Also, if you do use a custom\n     * `material`, this color will only be used for this particuar Text instance, even if\n     * that same material instance is shared across multiple Text objects.\n     */\n    this.color = null;\n\n    /**\n     * @member {object|null} colorRanges\n     * WARNING: This API is experimental and may change.\n     * This allows more fine-grained control of colors for individual or ranges of characters,\n     * taking precedence over the material's `color`. Its format is an Object whose keys each\n     * define a starting character index for a range, and whose values are the color for each\n     * range. The color value can be a numeric hex color value, a `THREE.Color` object, or\n     * any of the strings accepted by `THREE.Color`.\n     */\n    this.colorRanges = null;\n\n    /**\n     * @member {number|string} outlineWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an outline/halo to be drawn around each text glyph using the `outlineColor` and `outlineOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`, which means\n     * no outline will be drawn unless an `outlineOffsetX/Y` or `outlineBlur` is set.\n     */\n    this.outlineWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} outlineColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to black.\n     */\n    this.outlineColor = 0x000000;\n\n    /**\n     * @member {number} outlineOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the outline, if `outlineWidth`/`outlineBlur`/`outlineOffsetX/Y` are set.\n     * Defaults to `1`.\n     */\n    this.outlineOpacity = 1;\n\n    /**\n     * @member {number|string} outlineBlur\n     * WARNING: This API is experimental and may change.\n     * A blur radius applied to the outer edge of the text's outline. If the `outlineWidth` is\n     * zero, the blur will be applied at the glyph edge, like CSS's `text-shadow` blur radius.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g.\n     * `\"12%\"` which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineBlur = 0;\n\n    /**\n     * @member {number|string} outlineOffsetX\n     * WARNING: This API is experimental and may change.\n     * A horizontal offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetX = 0;\n\n    /**\n     * @member {number|string} outlineOffsetY\n     * WARNING: This API is experimental and may change.\n     * A vertical offset for the text outline.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.outlineOffsetY = 0;\n\n    /**\n     * @member {number|string} strokeWidth\n     * WARNING: This API is experimental and may change.\n     * The width of an inner stroke drawn inside each text glyph using the `strokeColor` and `strokeOpacity`.\n     * Can be specified as either an absolute number in local units, or as a percentage string e.g. `\"12%\"`\n     * which is treated as a percentage of the `fontSize`. Defaults to `0`.\n     */\n    this.strokeWidth = 0;\n\n    /**\n     * @member {string|number|THREE.Color} strokeColor\n     * WARNING: This API is experimental and may change.\n     * The color of the text stroke, if `strokeWidth` is greater than zero. Defaults to gray.\n     */\n    this.strokeColor = defaultStrokeColor;\n\n    /**\n     * @member {number} strokeOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the stroke, if `strokeWidth` is greater than zero. Defaults to `1`.\n     */\n    this.strokeOpacity = 1;\n\n    /**\n     * @member {number} fillOpacity\n     * WARNING: This API is experimental and may change.\n     * The opacity of the glyph's fill from 0 to 1. This behaves like the material's `opacity` but allows\n     * giving the fill a different opacity than the `strokeOpacity`. A fillOpacity of `0` makes the\n     * interior of the glyph invisible, leaving just the `strokeWidth`. Defaults to `1`.\n     */\n    this.fillOpacity = 1;\n\n    /**\n     * @member {number} depthOffset\n     * This is a shortcut for setting the material's `polygonOffset` and related properties,\n     * which can be useful in preventing z-fighting when this text is laid on top of another\n     * plane in the scene. Positive numbers are further from the camera, negatives closer.\n     */\n    this.depthOffset = 0;\n\n    /**\n     * @member {Array<number>} clipRect\n     * If specified, defines a `[minX, minY, maxX, maxY]` of a rectangle outside of which all\n     * pixels will be discarded. This can be used for example to clip overflowing text when\n     * `whiteSpace='nowrap'`.\n     */\n    this.clipRect = null;\n\n    /**\n     * @member {string} orientation\n     * Defines the axis plane on which the text should be laid out when the mesh has no extra\n     * rotation transform. It is specified as a string with two axes: the horizontal axis with\n     * positive pointing right, and the vertical axis with positive pointing up. By default this\n     * is '+x+y', meaning the text sits on the xy plane with the text's top toward positive y\n     * and facing positive z. A value of '+x-z' would place it on the xz plane with the text's\n     * top toward negative z and facing positive y.\n     */\n    this.orientation = defaultOrient;\n\n    /**\n     * @member {number} glyphGeometryDetail\n     * Controls number of vertical/horizontal segments that make up each glyph's rectangular\n     * plane. Defaults to 1. This can be increased to provide more geometrical detail for custom\n     * vertex shader effects, for example.\n     */\n    this.glyphGeometryDetail = 1;\n\n    /**\n     * @member {number|null} sdfGlyphSize\n     * The size of each glyph's SDF (signed distance field) used for rendering. This must be a\n     * power-of-two number. Defaults to 64 which is generally a good balance of size and quality\n     * for most fonts. Larger sizes can improve the quality of glyph rendering by increasing\n     * the sharpness of corners and preventing loss of very thin lines, at the expense of\n     * increased memory footprint and longer SDF generation time.\n     */\n    this.sdfGlyphSize = null;\n\n    /**\n     * @member {boolean} gpuAccelerateSDF\n     * When `true`, the SDF generation process will be GPU-accelerated with WebGL when possible,\n     * making it much faster especially for complex glyphs, and falling back to a JavaScript version\n     * executed in web workers when support isn't available. It should automatically detect support,\n     * but it's still somewhat experimental, so you can set it to `false` to force it to use the JS\n     * version if you encounter issues with it.\n     */\n    this.gpuAccelerateSDF = true;\n\n    this.debugSDF = false;\n  }\n\n  /**\n   * Updates the text rendering according to the current text-related configuration properties.\n   * This is an async process, so you can pass in a callback function to be executed when it\n   * finishes.\n   * @param {function} [callback]\n   */\n  sync(callback) {\n    if (this._needsSync) {\n      this._needsSync = false;\n\n      // If there's another sync still in progress, queue\n      if (this._isSyncing) {\n        (this._queuedSyncs || (this._queuedSyncs = [])).push(callback);\n      } else {\n        this._isSyncing = true;\n        this.dispatchEvent(syncStartEvent);\n\n        getTextRenderInfo({\n          text: this.text,\n          font: this.font,\n          lang: this.lang,\n          fontSize: this.fontSize || 0.1,\n          fontWeight: this.fontWeight || 'normal',\n          fontStyle: this.fontStyle || 'normal',\n          letterSpacing: this.letterSpacing || 0,\n          lineHeight: this.lineHeight || 'normal',\n          maxWidth: this.maxWidth,\n          direction: this.direction || 'auto',\n          textAlign: this.textAlign,\n          textIndent: this.textIndent,\n          whiteSpace: this.whiteSpace,\n          overflowWrap: this.overflowWrap,\n          anchorX: this.anchorX,\n          anchorY: this.anchorY,\n          colorRanges: this.colorRanges,\n          includeCaretPositions: true, //TODO parameterize\n          sdfGlyphSize: this.sdfGlyphSize,\n          gpuAccelerateSDF: this.gpuAccelerateSDF,\n          unicodeFontsURL: this.unicodeFontsURL,\n        }, textRenderInfo => {\n          this._isSyncing = false;\n\n          // Save result for later use in onBeforeRender\n          this._textRenderInfo = textRenderInfo;\n\n          // Update the geometry attributes\n          this.geometry.updateGlyphs(\n            textRenderInfo.glyphBounds,\n            textRenderInfo.glyphAtlasIndices,\n            textRenderInfo.blockBounds,\n            textRenderInfo.chunkedBounds,\n            textRenderInfo.glyphColors\n          );\n\n          // If we had extra sync requests queued up, kick it off\n          const queued = this._queuedSyncs;\n          if (queued) {\n            this._queuedSyncs = null;\n            this._needsSync = true;\n            this.sync(() => {\n              queued.forEach(fn => fn && fn());\n            });\n          }\n\n          this.dispatchEvent(syncCompleteEvent);\n          if (callback) {\n            callback();\n          }\n        });\n      }\n    }\n  }\n\n  /**\n   * Initiate a sync if needed - note it won't complete until next frame at the\n   * earliest so if possible it's a good idea to call sync() manually as soon as\n   * all the properties have been set.\n   * @override\n   */\n  onBeforeRender(renderer, scene, camera, geometry, material, group) {\n    this.sync();\n\n    // This may not always be a text material, e.g. if there's a scene.overrideMaterial present\n    if (material.isTroikaTextMaterial) {\n      this._prepareForRender(material);\n    }\n  }\n\n  /**\n   * Shortcut to dispose the geometry specific to this instance.\n   * Note: we don't also dispose the derived material here because if anything else is\n   * sharing the same base material it will result in a pause next frame as the program\n   * is recompiled. Instead users can dispose the base material manually, like normal,\n   * and we'll also dispose the derived material at that time.\n   */\n  dispose() {\n    this.geometry.dispose();\n  }\n\n  /**\n   * @property {TroikaTextRenderInfo|null} textRenderInfo\n   * @readonly\n   * The current processed rendering data for this TextMesh, returned by the TextBuilder after\n   * a `sync()` call. This will be `null` initially, and may be stale for a short period until\n   * the asynchrous `sync()` process completes.\n   */\n  get textRenderInfo() {\n    return this._textRenderInfo || null\n  }\n\n  /**\n   * Create the text derived material from the base material. Can be overridden to use a custom\n   * derived material.\n   */\n  createDerivedMaterial(baseMaterial) {\n    return createTextDerivedMaterial(baseMaterial)\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultMaterial.clone());\n    if (!derivedMaterial || !derivedMaterial.isDerivedFrom(baseMaterial)) {\n      derivedMaterial = this._derivedMaterial = this.createDerivedMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    // If text outline is configured, render it as a preliminary draw using Three's multi-material\n    // feature (see GlyphsGeometry which sets up `groups` for this purpose) Doing it with multi\n    // materials ensures the layers are always rendered consecutively in a consistent order.\n    // Each layer will trigger onBeforeRender with the appropriate material.\n    if (this.hasOutline()) {\n      let outlineMaterial = derivedMaterial._outlineMtl;\n      if (!outlineMaterial) {\n        outlineMaterial = derivedMaterial._outlineMtl = Object.create(derivedMaterial, {\n          id: {value: derivedMaterial.id + 0.1}\n        });\n        outlineMaterial.isTextOutlineMaterial = true;\n        outlineMaterial.depthWrite = false;\n        outlineMaterial.map = null; //???\n        derivedMaterial.addEventListener('dispose', function onDispose() {\n          derivedMaterial.removeEventListener('dispose', onDispose);\n          outlineMaterial.dispose();\n        });\n      }\n      return [\n        outlineMaterial,\n        derivedMaterial\n      ]\n    } else {\n      return derivedMaterial\n    }\n  }\n  set material(baseMaterial) {\n    if (baseMaterial && baseMaterial.isTroikaTextMaterial) { //prevent double-derivation\n      this._derivedMaterial = baseMaterial;\n      this._baseMaterial = baseMaterial.baseMaterial;\n    } else {\n      this._baseMaterial = baseMaterial;\n    }\n  }\n\n  hasOutline() {\n    return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY)\n  }\n\n  get glyphGeometryDetail() {\n    return this.geometry.detail\n  }\n  set glyphGeometryDetail(detail) {\n    this.geometry.detail = detail;\n  }\n\n  get curveRadius() {\n    return this.geometry.curveRadius\n  }\n  set curveRadius(r) {\n    this.geometry.curveRadius = r;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return first(this.material).getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return first(this.material).getDistanceMaterial()\n  }\n\n  _prepareForRender(material) {\n    const isOutline = material.isTextOutlineMaterial;\n    const uniforms = material.uniforms;\n    const textInfo = this.textRenderInfo;\n    if (textInfo) {\n      const {sdfTexture, blockBounds} = textInfo;\n      uniforms.uTroikaSDFTexture.value = sdfTexture;\n      uniforms.uTroikaSDFTextureSize.value.set(sdfTexture.image.width, sdfTexture.image.height);\n      uniforms.uTroikaSDFGlyphSize.value = textInfo.sdfGlyphSize;\n      uniforms.uTroikaSDFExponent.value = textInfo.sdfExponent;\n      uniforms.uTroikaTotalBounds.value.fromArray(blockBounds);\n      uniforms.uTroikaUseGlyphColors.value = !isOutline && !!textInfo.glyphColors;\n\n      let distanceOffset = 0;\n      let blurRadius = 0;\n      let strokeWidth = 0;\n      let fillOpacity;\n      let strokeOpacity;\n      let strokeColor;\n      let offsetX = 0;\n      let offsetY = 0;\n\n      if (isOutline) {\n        let {outlineWidth, outlineOffsetX, outlineOffsetY, outlineBlur, outlineOpacity} = this;\n        distanceOffset = this._parsePercent(outlineWidth) || 0;\n        blurRadius = Math.max(0, this._parsePercent(outlineBlur) || 0);\n        fillOpacity = outlineOpacity;\n        offsetX = this._parsePercent(outlineOffsetX) || 0;\n        offsetY = this._parsePercent(outlineOffsetY) || 0;\n      } else {\n        strokeWidth = Math.max(0, this._parsePercent(this.strokeWidth) || 0);\n        if (strokeWidth) {\n          strokeColor = this.strokeColor;\n          uniforms.uTroikaStrokeColor.value.set(strokeColor == null ? defaultStrokeColor : strokeColor);\n          strokeOpacity = this.strokeOpacity;\n          if (strokeOpacity == null) strokeOpacity = 1;\n        }\n        fillOpacity = this.fillOpacity;\n      }\n\n      uniforms.uTroikaEdgeOffset.value = distanceOffset;\n      uniforms.uTroikaPositionOffset.value.set(offsetX, offsetY);\n      uniforms.uTroikaBlurRadius.value = blurRadius;\n      uniforms.uTroikaStrokeWidth.value = strokeWidth;\n      uniforms.uTroikaStrokeOpacity.value = strokeOpacity;\n      uniforms.uTroikaFillOpacity.value = fillOpacity == null ? 1 : fillOpacity;\n      uniforms.uTroikaCurveRadius.value = this.curveRadius || 0;\n\n      let clipRect = this.clipRect;\n      if (clipRect && Array.isArray(clipRect) && clipRect.length === 4) {\n        uniforms.uTroikaClipRect.value.fromArray(clipRect);\n      } else {\n        // no clipping - choose a finite rect that shouldn't ever be reached by overflowing glyphs or outlines\n        const pad = (this.fontSize || 0.1) * 100;\n        uniforms.uTroikaClipRect.value.set(\n          blockBounds[0] - pad,\n          blockBounds[1] - pad,\n          blockBounds[2] + pad,\n          blockBounds[3] + pad\n        );\n      }\n      this.geometry.applyClipRect(uniforms.uTroikaClipRect.value);\n    }\n    uniforms.uTroikaSDFDebug.value = !!this.debugSDF;\n    material.polygonOffset = !!this.depthOffset;\n    material.polygonOffsetFactor = material.polygonOffsetUnits = this.depthOffset || 0;\n\n    // Shortcut for setting material color via `color` prop on the mesh; this is\n    // applied only to the derived material to avoid mutating a shared base material.\n    const color = isOutline ? (this.outlineColor || 0) : this.color;\n\n    if (color == null) {\n      delete material.color; //inherit from base\n    } else {\n      const colorObj = material.hasOwnProperty('color') ? material.color : (material.color = new three__WEBPACK_IMPORTED_MODULE_3__.Color());\n      if (color !== colorObj._input || typeof color === 'object') {\n        colorObj.set(colorObj._input = color);\n      }\n    }\n\n    // base orientation\n    let orient = this.orientation || defaultOrient;\n    if (orient !== material._orientation) {\n      let rotMat = uniforms.uTroikaOrient.value;\n      orient = orient.replace(/[^-+xyz]/g, '');\n      let match = orient !== defaultOrient && orient.match(/^([-+])([xyz])([-+])([xyz])$/);\n      if (match) {\n        let [, hSign, hAxis, vSign, vAxis] = match;\n        tempVec3a.set(0, 0, 0)[hAxis] = hSign === '-' ? 1 : -1;\n        tempVec3b.set(0, 0, 0)[vAxis] = vSign === '-' ? -1 : 1;\n        tempMat4.lookAt(origin, tempVec3a.cross(tempVec3b), tempVec3b);\n        rotMat.setFromMatrix4(tempMat4);\n      } else {\n        rotMat.identity();\n      }\n      material._orientation = orient;\n    }\n  }\n\n  _parsePercent(value) {\n    if (typeof value === 'string') {\n      let match = value.match(/^(-?[\\d.]+)%$/);\n      let pct = match ? parseFloat(match[1]) : NaN;\n      value = (isNaN(pct) ? 0 : pct / 100) * this.fontSize;\n    }\n    return value\n  }\n\n  /**\n   * Translate a point in local space to an x/y in the text plane.\n   */\n  localPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    target.copy(position); //simple non-curved case is 1:1\n    const r = this.curveRadius;\n    if (r) { //flatten the curve\n      target.x = Math.atan2(position.x, Math.abs(r) - Math.abs(position.z)) * Math.abs(r);\n    }\n    return target\n  }\n\n  /**\n   * Translate a point in world space to an x/y in the text plane.\n   */\n  worldPositionToTextCoords(position, target = new three__WEBPACK_IMPORTED_MODULE_3__.Vector2()) {\n    tempVec3a.copy(position);\n    return this.localPositionToTextCoords(this.worldToLocal(tempVec3a), target)\n  }\n\n  /**\n   * @override Custom raycasting to test against the whole text block's max rectangular bounds\n   * TODO is there any reason to make this more granular, like within individual line or glyph rects?\n   */\n  raycast(raycaster, intersects) {\n    const {textRenderInfo, curveRadius} = this;\n    if (textRenderInfo) {\n      const bounds = textRenderInfo.blockBounds;\n      const raycastMesh = curveRadius ? getCurvedRaycastMesh() : getFlatRaycastMesh();\n      const geom = raycastMesh.geometry;\n      const {position, uv} = geom.attributes;\n      for (let i = 0; i < uv.count; i++) {\n        let x = bounds[0] + (uv.getX(i) * (bounds[2] - bounds[0]));\n        const y = bounds[1] + (uv.getY(i) * (bounds[3] - bounds[1]));\n        let z = 0;\n        if (curveRadius) {\n          z = curveRadius - Math.cos(x / curveRadius) * curveRadius;\n          x = Math.sin(x / curveRadius) * curveRadius;\n        }\n        position.setXYZ(i, x, y, z);\n      }\n      geom.boundingSphere = this.geometry.boundingSphere;\n      geom.boundingBox = this.geometry.boundingBox;\n      raycastMesh.matrixWorld = this.matrixWorld;\n      raycastMesh.material.side = this.material.side;\n      tempArray.length = 0;\n      raycastMesh.raycast(raycaster, tempArray);\n      for (let i = 0; i < tempArray.length; i++) {\n        tempArray[i].object = this;\n        intersects.push(tempArray[i]);\n      }\n    }\n  }\n\n  copy(source) {\n    // Prevent copying the geometry reference so we don't end up sharing attributes between instances\n    const geom = this.geometry;\n    super.copy(source);\n    this.geometry = geom;\n\n    COPYABLE_PROPS.forEach(prop => {\n      this[prop] = source[prop];\n    });\n    return this\n  }\n\n  clone() {\n    return new this.constructor().copy(this)\n  }\n}\n\n\n// Create setters for properties that affect text layout:\nSYNCABLE_PROPS.forEach(prop => {\n  const privateKey = '_private_' + prop;\n  Object.defineProperty(Text.prototype, prop, {\n    get() {\n      return this[privateKey]\n    },\n    set(value) {\n      if (value !== this[privateKey]) {\n        this[privateKey] = value;\n        this._needsSync = true;\n      }\n    }\n  });\n});\n\nconst syncStartEvent$1 = { type: \"syncstart\" };\nconst syncCompleteEvent$1 = { type: \"synccomplete\" };\nconst memberIndexAttrName = \"aTroikaTextBatchMemberIndex\";\n\n\n/*\nData texture packing strategy:\n\n# Common:\n0-15: matrix\n16-19: uTroikaTotalBounds\n20-23: uTroikaClipRect\n24: diffuse (color/outlineColor)\n25: uTroikaFillOpacity (fillOpacity/outlineOpacity)\n26: uTroikaCurveRadius\n27: <blank>\n\n# Main:\n28: uTroikaStrokeWidth\n29: uTroikaStrokeColor\n30: uTroikaStrokeOpacity\n\n# Outline:\n28-29: uTroikaPositionOffset\n30: uTroikaEdgeOffset\n31: uTroikaBlurRadius\n*/\nconst floatsPerMember = 32;\n\nconst tempBox3 = new three__WEBPACK_IMPORTED_MODULE_3__.Box3();\nconst tempColor$1 = new three__WEBPACK_IMPORTED_MODULE_3__.Color();\n\n/**\n * @experimental\n *\n * A specialized `Text` implementation that accepts any number of `Text` children\n * and automatically batches them together to render in a single draw call.\n *\n * The `material` of each child `Text` will be ignored, and the `material` of the\n * `BatchedText` will be used for all of them instead.\n *\n * NOTE: This only works in WebGL2 or where the OES_texture_float extension is available.\n */\nclass BatchedText extends Text {\n  constructor () {\n    super();\n\n    /**\n     * @typedef {Object} PackingInfo\n     * @property {number} index - the packing order index when last packed, or -1\n     * @property {boolean} dirty - whether it has synced since last pack\n     */\n\n    /**\n     * @type {Map<Text, PackingInfo>}\n     */\n    this._members = new Map();\n    this._dataTextures = {};\n\n    this._onMemberSynced = (e) => {\n      this._members.get(e.target).dirty = true;\n    };\n  }\n\n  /**\n   * @override\n   * Batch any Text objects added as children\n   */\n  add (...objects) {\n    for (let i = 0; i < objects.length; i++) {\n      if (objects[i] instanceof Text) {\n        this.addText(objects[i]);\n      } else {\n        super.add(objects[i]);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * @override\n   */\n  remove (...objects) {\n    for (let i = 0; i < objects.length; i++) {\n      if (objects[i] instanceof Text) {\n        this.removeText(objects[i]);\n      } else {\n        super.remove(objects[i]);\n      }\n    }\n    return this;\n  }\n\n  /**\n   * @param {Text} text\n   */\n  addText (text) {\n    if (!this._members.has(text)) {\n      this._members.set(text, {\n        index: -1,\n        glyphCount: -1,\n        dirty: true\n      });\n      text.addEventListener(\"synccomplete\", this._onMemberSynced);\n    }\n  }\n\n  /**\n   * @param {Text} text\n   */\n  removeText (text) {\n    this._needsRepack = true;\n    text.removeEventListener(\"synccomplete\", this._onMemberSynced);\n    this._members.delete(text);\n  }\n\n  /**\n   * Use the custom derivation with extra batching logic\n   */\n  createDerivedMaterial (baseMaterial) {\n    return createBatchedTextMaterial(baseMaterial);\n  }\n\n  updateMatrixWorld (force) {\n    super.updateMatrixWorld(force);\n    this.updateBounds();\n  }\n\n  /**\n   * Update the batched geometry bounds to hold all members\n   */\n  updateBounds () {\n    // Update member local matrices and the overall bounds\n    const bbox = this.geometry.boundingBox.makeEmpty();\n    this._members.forEach((_, text) => {\n      if (text.matrixAutoUpdate) text.updateMatrix(); // ignore world matrix\n      tempBox3.copy(text.geometry.boundingBox).applyMatrix4(text.matrix);\n      bbox.union(tempBox3);\n    });\n    bbox.getBoundingSphere(this.geometry.boundingSphere);\n  }\n\n  /** @override */\n  hasOutline() {\n    // Iterator.some() not supported in Safari\n    for (let member of this._members.keys()) {\n      if (member.hasOutline()) return true;\n    }\n    return false;\n  }\n\n  /**\n   * @override\n   * Copy member matrices and uniform values into the data texture\n   */\n  _prepareForRender (material) {\n    const isOutline = material.isTextOutlineMaterial;\n    material.uniforms.uTroikaIsOutline.value = isOutline;\n\n    // Resize the texture to fit in powers of 2\n    let texture = this._dataTextures[isOutline ? 'outline' : 'main'];\n    const dataLength = Math.pow(2, Math.ceil(Math.log2(this._members.size * floatsPerMember)));\n    if (!texture || dataLength !== texture.image.data.length) {\n      // console.log(`resizing: ${dataLength}`);\n      if (texture) texture.dispose();\n      const width = Math.min(dataLength / 4, 1024);\n      texture = this._dataTextures[isOutline ? 'outline' : 'main'] = new three__WEBPACK_IMPORTED_MODULE_3__.DataTexture(\n        new Float32Array(dataLength),\n        width,\n        dataLength / 4 / width,\n        three__WEBPACK_IMPORTED_MODULE_3__.RGBAFormat,\n        three__WEBPACK_IMPORTED_MODULE_3__.FloatType\n      );\n    }\n\n    const texData = texture.image.data;\n    const setTexData = (index, value) => {\n      if (value !== texData[index]) {\n        texData[index] = value;\n        texture.needsUpdate = true;\n      }\n    };\n    this._members.forEach(({ index, dirty }, text) => {\n      if (index > -1) {\n        const startIndex = index * floatsPerMember;\n\n        // Matrix\n        const matrix = text.matrix.elements;\n        for (let i = 0; i < 16; i++) {\n          setTexData(startIndex + i, matrix[i]);\n        }\n\n        // Let the member populate the uniforms, since that does all the appropriate\n        // logic and handling of defaults, and we'll just grab the results from there\n        text._prepareForRender(material);\n        const {\n          uTroikaTotalBounds,\n          uTroikaClipRect,\n          uTroikaPositionOffset,\n          uTroikaEdgeOffset,\n          uTroikaBlurRadius,\n          uTroikaStrokeWidth,\n          uTroikaStrokeColor,\n          uTroikaStrokeOpacity,\n          uTroikaFillOpacity,\n          uTroikaCurveRadius,\n        } = material.uniforms;\n\n        // Total bounds for uv\n        for (let i = 0; i < 4; i++) {\n          setTexData(startIndex + 16 + i, uTroikaTotalBounds.value.getComponent(i));\n        }\n\n        // Clip rect\n        for (let i = 0; i < 4; i++) {\n          setTexData(startIndex + 20 + i, uTroikaClipRect.value.getComponent(i));\n        }\n\n        // Color\n        let color = isOutline ? (text.outlineColor || 0) : text.color;\n        if (color == null) color = this.color;\n        if (color == null) color = this.material.color;\n        if (color == null) color = 0xffffff;\n        setTexData(startIndex + 24, tempColor$1.set(color).getHex());\n\n        // Fill opacity / outline opacity\n        setTexData(startIndex + 25, uTroikaFillOpacity.value);\n\n        // Curve radius\n        setTexData(startIndex + 26, uTroikaCurveRadius.value);\n\n        if (isOutline) {\n          // Outline properties\n          setTexData(startIndex + 28, uTroikaPositionOffset.value.x);\n          setTexData(startIndex + 29, uTroikaPositionOffset.value.y);\n          setTexData(startIndex + 30, uTroikaEdgeOffset.value);\n          setTexData(startIndex + 31, uTroikaBlurRadius.value);\n        } else {\n          // Stroke properties\n          setTexData(startIndex + 28, uTroikaStrokeWidth.value);\n          setTexData(startIndex + 29, tempColor$1.set(uTroikaStrokeColor.value).getHex());\n          setTexData(startIndex + 30, uTroikaStrokeOpacity.value);\n        }\n      }\n    });\n    material.setMatrixTexture(texture);\n\n    // For the non-member-specific uniforms:\n    super._prepareForRender(material);\n  }\n\n  sync (callback) {\n    // TODO: skip members updating their geometries, just use textRenderInfo directly\n\n    // Trigger sync on all members that need it\n    let syncPromises = this._needsRepack ? [] : null;\n    this._needsRepack = false;\n    this._members.forEach((packingInfo, text) => {\n      if (packingInfo.dirty || text._needsSync) {\n        packingInfo.dirty = false;\n        (syncPromises || (syncPromises = [])).push(new Promise(resolve => {\n          if (text._needsSync) {\n            text.sync(resolve);\n          } else {\n            resolve();\n          }\n        }));\n      }\n    });\n\n    // If any needed syncing, wait for them and then repack the batched geometry\n    if (syncPromises) {\n      this.dispatchEvent(syncStartEvent$1);\n\n      Promise.all(syncPromises).then(() => {\n        const { geometry } = this;\n        const batchedAttributes = geometry.attributes;\n        let memberIndexes = batchedAttributes[memberIndexAttrName] && batchedAttributes[memberIndexAttrName].array || new Uint16Array(0);\n        let batchedGlyphIndexes = batchedAttributes[glyphIndexAttrName] && batchedAttributes[glyphIndexAttrName].array || new Float32Array(0);\n        let batchedGlyphBounds = batchedAttributes[glyphBoundsAttrName] && batchedAttributes[glyphBoundsAttrName].array || new Float32Array(0);\n\n        // Initial pass to collect total glyph count and resize the arrays if needed\n        let totalGlyphCount = 0;\n        this._members.forEach((packingInfo, { textRenderInfo }) => {\n          if (textRenderInfo) {\n            totalGlyphCount += textRenderInfo.glyphAtlasIndices.length;\n            this._textRenderInfo = textRenderInfo; // TODO - need this, but be smarter\n          }\n        });\n        if (totalGlyphCount !== memberIndexes.length) {\n          memberIndexes = cloneAndResize(memberIndexes, totalGlyphCount);\n          batchedGlyphIndexes = cloneAndResize(batchedGlyphIndexes, totalGlyphCount);\n          batchedGlyphBounds = cloneAndResize(batchedGlyphBounds, totalGlyphCount * 4);\n        }\n\n        // Populate batch arrays\n        let memberIndex = 0;\n        let glyphIndex = 0;\n        this._members.forEach((packingInfo, { textRenderInfo }) => {\n          if (textRenderInfo) {\n            const glyphCount = textRenderInfo.glyphAtlasIndices.length;\n            memberIndexes.fill(memberIndex, glyphIndex, glyphIndex + glyphCount);\n\n            // TODO can skip these for members that are not dirty or shifting overall position:\n            batchedGlyphIndexes.set(textRenderInfo.glyphAtlasIndices, glyphIndex, glyphIndex + glyphCount);\n            batchedGlyphBounds.set(textRenderInfo.glyphBounds, glyphIndex * 4, (glyphIndex + glyphCount) * 4);\n\n            glyphIndex += glyphCount;\n            packingInfo.index = memberIndex++;\n          }\n        });\n\n        // Update the geometry attributes\n        geometry.updateAttributeData(memberIndexAttrName, memberIndexes, 1);\n        geometry.getAttribute(memberIndexAttrName).setUsage(three__WEBPACK_IMPORTED_MODULE_3__.DynamicDrawUsage);\n        geometry.updateAttributeData(glyphIndexAttrName, batchedGlyphIndexes, 1);\n        geometry.updateAttributeData(glyphBoundsAttrName, batchedGlyphBounds, 4);\n\n        this.updateBounds();\n\n        this.dispatchEvent(syncCompleteEvent$1);\n        if (callback) {\n          callback();\n        }\n      });\n    }\n  }\n\n  copy (source) {\n    if (source instanceof BatchedText) {\n      super.copy(source);\n      this._members.forEach((_, text) => this.removeText(text));\n      source._members.forEach((_, text) => this.addText(text));\n    }\n    return this;\n  }\n\n  dispose () {\n    super.dispose();\n    Object.values(this._dataTextures).forEach(tex => tex.dispose());\n  }\n}\n\nfunction cloneAndResize (source, newLength) {\n  const copy = new source.constructor(newLength);\n  copy.set(source.subarray(0, newLength));\n  return copy;\n}\n\nfunction createBatchedTextMaterial (baseMaterial) {\n  const texUniformName = \"uTroikaMatricesTexture\";\n  const texSizeUniformName = \"uTroikaMatricesTextureSize\";\n\n  // Due to how vertexTransform gets injected, the matrix transforms must happen\n  // in the base material of TextDerivedMaterial, but other transforms to its\n  // shader must come after, so we sandwich it between two derivations.\n\n  // Transform the vertex position\n  let batchMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(baseMaterial, {\n    chained: true,\n    uniforms: {\n      [texSizeUniformName]: { value: new three__WEBPACK_IMPORTED_MODULE_3__.Vector2() },\n      [texUniformName]: { value: null }\n    },\n    // language=GLSL\n    vertexDefs: `\n      uniform highp sampler2D ${texUniformName};\n      uniform vec2 ${texSizeUniformName};\n      attribute float ${memberIndexAttrName};\n\n      vec4 troikaBatchTexel(float offset) {\n        offset += ${memberIndexAttrName} * ${floatsPerMember.toFixed(1)} / 4.0;\n        float w = ${texSizeUniformName}.x;\n        vec2 uv = (vec2(mod(offset, w), floor(offset / w)) + 0.5) / ${texSizeUniformName};\n        return texture2D(${texUniformName}, uv);\n      }\n    `,\n    // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n    vertexTransform: `\n      mat4 matrix = mat4(\n        troikaBatchTexel(0.0),\n        troikaBatchTexel(1.0),\n        troikaBatchTexel(2.0),\n        troikaBatchTexel(3.0)\n      );\n      position.xyz = (matrix * vec4(position, 1.0)).xyz;\n    `,\n  });\n\n  // Add the text shaders\n  batchMaterial = createTextDerivedMaterial(batchMaterial);\n\n  // Now make other changes to the derived text shader code\n  batchMaterial = (0,troika_three_utils__WEBPACK_IMPORTED_MODULE_4__.createDerivedMaterial)(batchMaterial, {\n    chained: true,\n    uniforms: {\n      uTroikaIsOutline: {value: false},\n    },\n    customRewriter(shaders) {\n      // Convert some text shader uniforms to varyings\n      const varyingUniforms = [\n        'uTroikaTotalBounds',\n        'uTroikaClipRect',\n        'uTroikaPositionOffset',\n        'uTroikaEdgeOffset',\n        'uTroikaBlurRadius',\n        'uTroikaStrokeWidth',\n        'uTroikaStrokeColor',\n        'uTroikaStrokeOpacity',\n        'uTroikaFillOpacity',\n        'uTroikaCurveRadius',\n        'diffuse'\n      ];\n      varyingUniforms.forEach(uniformName => {\n        shaders = uniformToVarying(shaders, uniformName);\n      });\n      return shaders\n    },\n    // language=GLSL\n    vertexDefs: `\n      uniform bool uTroikaIsOutline;\n      vec3 troikaFloatToColor(float v) {\n        return mod(floor(vec3(v / 65536.0, v / 256.0, v)), 256.0) / 256.0;\n      }\n    `,\n    // language=GLSL prefix=\"void main() {\" suffix=\"}\"\n    vertexTransform: `\n      uTroikaTotalBounds = troikaBatchTexel(4.0);\n      uTroikaClipRect = troikaBatchTexel(5.0);\n      \n      vec4 data = troikaBatchTexel(6.0);\n      diffuse = troikaFloatToColor(data.x);\n      uTroikaFillOpacity = data.y;\n      uTroikaCurveRadius = data.z;\n      \n      data = troikaBatchTexel(7.0);\n      if (uTroikaIsOutline) {\n        if (data == vec4(0.0)) { // degenerate if zero outline\n          position = vec3(0.0);\n        } else {\n          uTroikaPositionOffset = data.xy;\n          uTroikaEdgeOffset = data.z;\n          uTroikaBlurRadius = data.w;\n        }\n      } else {\n        uTroikaStrokeWidth = data.x;\n        uTroikaStrokeColor = troikaFloatToColor(data.y);\n        uTroikaStrokeOpacity = data.z;\n      }\n    `,\n  });\n\n  batchMaterial.setMatrixTexture = (texture) => {\n    batchMaterial.uniforms[texUniformName].value = texture;\n    batchMaterial.uniforms[texSizeUniformName].value.set(texture.image.width, texture.image.height);\n  };\n  return batchMaterial;\n}\n\n/**\n * Turn a uniform into a varying/writeable value.\n * - If the uniform was used in the fragment shader, it will become a varying in both shaders.\n * - If the uniform was only used in the vertex shader, it will become a writeable var.\n */\nfunction uniformToVarying({vertexShader, fragmentShader}, uniformName, varyingName = uniformName) {\n  const uniformRE = new RegExp(`uniform\\\\s+(bool|float|vec[234]|mat[34])\\\\s+${uniformName}\\\\b`);\n\n  let type;\n  let hadFragmentUniform = false;\n  fragmentShader = fragmentShader.replace(uniformRE, ($0, $1) => {\n    hadFragmentUniform = true;\n    return `varying ${type = $1} ${varyingName}`\n  });\n\n  let hadVertexUniform = false;\n  vertexShader = vertexShader.replace(uniformRE, (_, $1) => {\n    hadVertexUniform = true;\n    return `${hadFragmentUniform ? 'varying' : ''} ${type = $1} ${varyingName}`\n  });\n  if (!hadVertexUniform) {\n    vertexShader = `${hadFragmentUniform ? 'varying' : ''} ${type} ${varyingName};\\n${vertexShader}`;\n  }\n  return {vertexShader, fragmentShader}\n}\n\n//=== Utility functions for dealing with carets and selection ranges ===//\n\n/**\n * @typedef {object} TextCaret\n * @property {number} x - x position of the caret\n * @property {number} y - y position of the caret's bottom\n * @property {number} height - height of the caret\n * @property {number} charIndex - the index in the original input string of this caret's target\n *   character; the caret will be for the position _before_ that character.\n */\n\n/**\n * Given a local x/y coordinate in the text block plane, find the nearest caret position.\n * @param {TroikaTextRenderInfo} textRenderInfo - a result object from TextBuilder#getTextRenderInfo\n * @param {number} x\n * @param {number} y\n * @return {TextCaret | null}\n */\nfunction getCaretAtPoint(textRenderInfo, x, y) {\n  let closestCaret = null;\n  const rows = groupCaretsByRow(textRenderInfo);\n\n  // Find nearest row by y first\n  let closestRow = null;\n  rows.forEach(row => {\n    if (!closestRow || Math.abs(y - (row.top + row.bottom) / 2) < Math.abs(y - (closestRow.top + closestRow.bottom) / 2)) {\n      closestRow = row;\n    }\n  });\n\n  // Then find closest caret by x within that row\n  closestRow.carets.forEach(caret => {\n    if (!closestCaret || Math.abs(x - caret.x) < Math.abs(x - closestCaret.x)) {\n      closestCaret = caret;\n    }\n  });\n  return closestCaret\n}\n\n\nconst _rectsCache = new WeakMap();\n\n/**\n * Given start and end character indexes, return a list of rectangles covering all the\n * characters within that selection.\n * @param {TroikaTextRenderInfo} textRenderInfo\n * @param {number} start - index of the first char in the selection\n * @param {number} end - index of the first char after the selection\n * @return {Array<{left, top, right, bottom}> | null}\n */\nfunction getSelectionRects(textRenderInfo, start, end) {\n  let rects;\n  if (textRenderInfo) {\n    // Check cache - textRenderInfo is frozen so it's safe to cache based on it\n    let prevResult = _rectsCache.get(textRenderInfo);\n    if (prevResult && prevResult.start === start && prevResult.end === end) {\n      return prevResult.rects\n    }\n\n    const {caretPositions} = textRenderInfo;\n\n    // Normalize\n    if (end < start) {\n      const s = start;\n      start = end;\n      end = s;\n    }\n    start = Math.max(start, 0);\n    end = Math.min(end, caretPositions.length + 1);\n\n    // Build list of rects, expanding the current rect for all characters in a run and starting\n    // a new rect whenever reaching a new line or a new bidi direction\n    rects = [];\n    let currentRect = null;\n    for (let i = start; i < end; i++) {\n      const x1 = caretPositions[i * 4];\n      const x2 = caretPositions[i * 4 + 1];\n      const left = Math.min(x1, x2);\n      const right = Math.max(x1, x2);\n      const bottom = caretPositions[i * 4 + 2];\n      const top = caretPositions[i * 4 + 3];\n      if (!currentRect || bottom !== currentRect.bottom || top !== currentRect.top || left > currentRect.right || right < currentRect.left) {\n        currentRect = {\n          left: Infinity,\n          right: -Infinity,\n          bottom,\n          top,\n        };\n        rects.push(currentRect);\n      }\n      currentRect.left = Math.min(left, currentRect.left);\n      currentRect.right = Math.max(right, currentRect.right);\n    }\n\n    // Merge any overlapping rects, e.g. those formed by adjacent bidi runs\n    rects.sort((a, b) => b.bottom - a.bottom || a.left - b.left);\n    for (let i = rects.length - 1; i-- > 0;) {\n      const rectA = rects[i];\n      const rectB = rects[i + 1];\n      if (rectA.bottom === rectB.bottom && rectA.top === rectB.top && rectA.left <= rectB.right && rectA.right >= rectB.left) {\n        rectB.left = Math.min(rectB.left, rectA.left);\n        rectB.right = Math.max(rectB.right, rectA.right);\n        rects.splice(i, 1);\n      }\n    }\n\n    _rectsCache.set(textRenderInfo, {start, end, rects});\n  }\n  return rects\n}\n\nconst _caretsByRowCache = new WeakMap();\n\n/**\n * Group a set of carets by row of text, caching the result. A single row of text may contain carets of\n * differing positions/heights if it has multiple fonts, and they may overlap slightly across rows, so this\n * uses an assumption of \"at least overlapping by half\" to put them in the same row.\n * @return Array<{bottom: number, top: number, carets: TextCaret[]}>\n */\nfunction groupCaretsByRow(textRenderInfo) {\n  // textRenderInfo is frozen so it's safe to cache based on it\n  let rows = _caretsByRowCache.get(textRenderInfo);\n  if (!rows) {\n    rows = [];\n    const {caretPositions} = textRenderInfo;\n    let curRow;\n\n    const visitCaret = (x, bottom, top, charIndex) => {\n      // new row if not overlapping by at least half\n      if (!curRow || (top < (curRow.top + curRow.bottom) / 2)) {\n        rows.push(curRow = {bottom, top, carets: []});\n      }\n      // expand vertical limits if necessary\n      if (top > curRow.top) curRow.top = top;\n      if (bottom < curRow.bottom) curRow.bottom = bottom;\n      curRow.carets.push({\n        x,\n        y: bottom,\n        height: top - bottom,\n        charIndex,\n      });\n    };\n\n    let i = 0;\n    for (; i < caretPositions.length; i += 4) {\n      visitCaret(caretPositions[i], caretPositions[i + 2], caretPositions[i + 3], i / 4);\n    }\n    // Add one more caret after the final char\n    visitCaret(caretPositions[i - 3], caretPositions[i - 2], caretPositions[i - 1], i / 4);\n  }\n  _caretsByRowCache.set(textRenderInfo, rows);\n  return rows\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdGV4dC9kaXN0L3Ryb2lrYS10aHJlZS10ZXh0LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2UTtBQUNuTTtBQUNyQjtBQUNuQjtBQUN5Qzs7QUFFM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsa0VBQWtFLE9BQU8sa0JBQWtCLGlDQUFpQywrQkFBK0IsUUFBUSw4Q0FBOEMsc0JBQXNCLEtBQUssaUJBQWlCLElBQUksS0FBSyxzQkFBc0IsK0JBQStCLFNBQVMsMEJBQTBCLHlCQUF5QixpQkFBaUIsc0JBQXNCLHdCQUF3QiwwRUFBMEUsK0hBQStILGtCQUFrQixLQUFLLEtBQUssSUFBSSxLQUFLLHlCQUF5QiwwQkFBMEIsc0JBQXNCLEtBQUssc0JBQXNCLFdBQVcsb0JBQW9CLFFBQVEsV0FBVyxLQUFLLFdBQVcsb0VBQW9FLFNBQVMsNEJBQTRCLGtEQUFrRCxJQUFJLEtBQUsseUJBQXlCLDBCQUEwQixzQkFBc0IsMkNBQTJDLFdBQVcsUUFBUSx3QkFBd0IsaURBQWlELDJCQUEyQixtQ0FBbUMsdUJBQXVCLG1DQUFtQyx3QkFBd0Isa0NBQWtDLHlCQUF5QixtQ0FBbUMsMEJBQTBCLG9DQUFvQyw2QkFBNkIsaUJBQWlCLElBQUksdUNBQXVDLFNBQVMsd0JBQXdCLG9DQUFvQywwQkFBMEIsOERBQThELDJCQUEyQixpQkFBaUIsSUFBSSxtQ0FBbUMsU0FBUyw2QkFBNkIsaUJBQWlCLElBQUksS0FBSyx1QkFBdUIsMkJBQTJCLFNBQVMsMkdBQTJHLG1CQUFtQixnRUFBZ0UsMkJBQTJCLGlCQUFpQixJQUFJLG1CQUFtQixTQUFTLGdDQUFnQyxpQkFBaUIsSUFBSSx3Q0FBd0MsU0FBUyxtQkFBbUIsb0lBQW9JLFdBQVcsbUNBQW1DLGlCQUFpQixLQUFLLHNCQUFzQix3QkFBd0IsS0FBSyx3QkFBd0IsS0FBSyx3QkFBd0IsbUpBQW1KLHdDQUF3Qyww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QUFFQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLDJFQUEyRTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5RUFBeUU7QUFDekU7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QixNQUFNO0FBQ04saUdBQWlHLHdDQUFLO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDBDQUFPO0FBQzFELDJCQUEyQjtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsMENBQU87QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDZCQUE2QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRCwyQkFBMkI7QUFDM0IsOEJBQThCO0FBQzlCOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQix1Q0FBSTtBQUN6Qix3QkFBd0Isd0NBQUs7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsU0FBUztBQUMzQjs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBO0FBQ0EseUVBQXlFLDhDQUFXO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVU7QUFDbEIsUUFBUSw0Q0FBUztBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGNBQWM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSw0REFBNEQsbURBQWdCO0FBQzVFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLHlFQUFxQjtBQUMzQztBQUNBO0FBQ0EsOEJBQThCLFdBQVcsMENBQU8sSUFBSTtBQUNwRCwwQkFBMEI7QUFDMUIsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMscUJBQXFCO0FBQ3JCLHdCQUF3Qjs7QUFFeEI7QUFDQSxvQkFBb0IscUJBQXFCLElBQUksNEJBQTRCO0FBQ3pFLG9CQUFvQixtQkFBbUI7QUFDdkMsc0VBQXNFO0FBQ3RFLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQSwwQ0FBMEMsV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IseUVBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSx5QkFBeUIsYUFBYTtBQUN0QyxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hELDhFQUE4RSxZQUFZOztBQUUxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXLEVBQUUsWUFBWTtBQUMvQyxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWMscUNBQXFDLEVBQUUsV0FBVyxFQUFFLFlBQVk7QUFDOUUsR0FBRztBQUNIO0FBQ0Esc0JBQXNCLHFDQUFxQyxFQUFFLE1BQU0sRUFBRSxhQUFhLElBQUksYUFBYTtBQUNuRztBQUNBLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsZ0JBQWdCO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLE9BQU8seUJBQXlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLGdCQUFnQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFFBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsa0JBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBaUQ7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQSxXQUFXLDJCQUEyQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVxTyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHJvaWthLXRocmVlLXRleHQvZGlzdC90cm9pa2EtdGhyZWUtdGV4dC5lc20uanM/ZDA1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXh0dXJlLCBMaW5lYXJGaWx0ZXIsIENvbG9yLCBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSwgU3BoZXJlLCBCb3gzLCBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUsIFBsYW5lR2VvbWV0cnksIFZlY3RvcjIsIFZlY3RvcjQsIE1hdHJpeDMsIE1lc2gsIE1lc2hCYXNpY01hdGVyaWFsLCBEb3VibGVTaWRlLCBNYXRyaXg0LCBWZWN0b3IzLCBEYXRhVGV4dHVyZSwgUkdCQUZvcm1hdCwgRmxvYXRUeXBlLCBEeW5hbWljRHJhd1VzYWdlIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgZGVmaW5lV29ya2VyTW9kdWxlLCB0ZXJtaW5hdGVXb3JrZXIgfSBmcm9tICd0cm9pa2Etd29ya2VyLXV0aWxzJztcbmltcG9ydCBjcmVhdGVTREZHZW5lcmF0b3IgZnJvbSAnd2ViZ2wtc2RmLWdlbmVyYXRvcic7XG5pbXBvcnQgYmlkaUZhY3RvcnkgZnJvbSAnYmlkaS1qcyc7XG5pbXBvcnQgeyBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwsIHZvaWRNYWluUmVnRXhwIH0gZnJvbSAndHJvaWthLXRocmVlLXV0aWxzJztcblxuLyohXG5DdXN0b20gYnVpbGQgb2YgVHlwci50cyAoaHR0cHM6Ly9naXRodWIuY29tL2ZyZWRsaTc0L1R5cHIudHMpIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLlxuT3JpZ2luYWwgTUlUIGxpY2Vuc2UgYXBwbGllczogaHR0cHM6Ly9naXRodWIuY29tL2ZyZWRsaTc0L1R5cHIudHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuKi9cbmZ1bmN0aW9uIHR5cHJGYWN0b3J5KCl7cmV0dXJuIFwidW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3cmJihzZWxmLndpbmRvdz1zZWxmKSxmdW5jdGlvbihyKXt2YXIgZT17cGFyc2U6ZnVuY3Rpb24ocil7dmFyIHQ9ZS5fYmluLGE9bmV3IFVpbnQ4QXJyYXkocik7aWYoXCJ0dGNmXCI9PXQucmVhZEFTQ0lJKGEsMCw0KSl7dmFyIG49NDt0LnJlYWRVc2hvcnQoYSxuKSxuKz0yLHQucmVhZFVzaG9ydChhLG4pLG4rPTI7dmFyIG89dC5yZWFkVWludChhLG4pO24rPTQ7Zm9yKHZhciBzPVtdLGk9MDtpPG87aSsrKXt2YXIgaD10LnJlYWRVaW50KGEsbik7bis9NCxzLnB1c2goZS5fcmVhZEZvbnQoYSxoKSk7fXJldHVybiBzfXJldHVybiBbZS5fcmVhZEZvbnQoYSwwKV19LF9yZWFkRm9udDpmdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQ7YS5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixhLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTI7Zm9yKHZhciBzPVtcImNtYXBcIixcImhlYWRcIixcImhoZWFcIixcIm1heHBcIixcImhtdHhcIixcIm5hbWVcIixcIk9TLzJcIixcInBvc3RcIixcImxvY2FcIixcImdseWZcIixcImtlcm5cIixcIkNGRiBcIixcIkdERUZcIixcIkdQT1NcIixcIkdTVUJcIixcIlNWRyBcIl0saT17X2RhdGE6cixfb2Zmc2V0Om59LGg9e30sZD0wO2Q8bztkKyspe3ZhciBmPWEucmVhZEFTQ0lJKHIsdCw0KTt0Kz00LGEucmVhZFVpbnQocix0KSx0Kz00O3ZhciB1PWEucmVhZFVpbnQocix0KTt0Kz00O3ZhciBsPWEucmVhZFVpbnQocix0KTt0Kz00LGhbZl09e29mZnNldDp1LGxlbmd0aDpsfTt9Zm9yKGQ9MDtkPHMubGVuZ3RoO2QrKyl7dmFyIHY9c1tkXTtoW3ZdJiYoaVt2LnRyaW0oKV09ZVt2LnRyaW0oKV0ucGFyc2UocixoW3ZdLm9mZnNldCxoW3ZdLmxlbmd0aCxpKSk7fXJldHVybiBpfSxfdGFiT2Zmc2V0OmZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLG89bi5yZWFkVXNob3J0KHIsYSs0KSxzPWErMTIsaT0wO2k8bztpKyspe3ZhciBoPW4ucmVhZEFTQ0lJKHIscyw0KTtzKz00LG4ucmVhZFVpbnQocixzKSxzKz00O3ZhciBkPW4ucmVhZFVpbnQocixzKTtpZihzKz00LG4ucmVhZFVpbnQocixzKSxzKz00LGg9PXQpcmV0dXJuIGR9cmV0dXJuIDB9fTtlLl9iaW49e3JlYWRGaXhlZDpmdW5jdGlvbihyLGUpe3JldHVybiAocltlXTw8OHxyW2UrMV0pKyhyW2UrMl08PDh8cltlKzNdKS82NTU0MH0scmVhZEYyZG90MTQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLnJlYWRTaG9ydChyLHQpLzE2Mzg0fSxyZWFkSW50OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIGUuX2Jpbi5fdmlldyhyKS5nZXRJbnQzMih0KX0scmVhZEludDg6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldEludDgodCl9LHJlYWRTaG9ydDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0SW50MTYodCl9LHJlYWRVc2hvcnQ6ZnVuY3Rpb24ocix0KXtyZXR1cm4gZS5fYmluLl92aWV3KHIpLmdldFVpbnQxNih0KX0scmVhZFVzaG9ydHM6ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj1bXSxvPTA7bzxhO28rKyluLnB1c2goZS5fYmluLnJlYWRVc2hvcnQocix0KzIqbykpO3JldHVybiBufSxyZWFkVWludDpmdW5jdGlvbihyLHQpe3JldHVybiBlLl9iaW4uX3ZpZXcocikuZ2V0VWludDMyKHQpfSxyZWFkVWludDY0OmZ1bmN0aW9uKHIsdCl7cmV0dXJuIDQyOTQ5NjcyOTYqZS5fYmluLnJlYWRVaW50KHIsdCkrZS5fYmluLnJlYWRVaW50KHIsdCs0KX0scmVhZEFTQ0lJOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKylhKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRVbmljb2RlOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9XCJcIixuPTA7bjx0O24rKyl7dmFyIG89cltlKytdPDw4fHJbZSsrXTthKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pO31yZXR1cm4gYX0sX3RkZWM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93LlRleHREZWNvZGVyP25ldyB3aW5kb3cuVGV4dERlY29kZXI6bnVsbCxyZWFkVVRGODpmdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLl90ZGVjO3JldHVybiBuJiYwPT10JiZhPT1yLmxlbmd0aD9uLmRlY29kZShyKTplLl9iaW4ucmVhZEFTQ0lJKHIsdCxhKX0scmVhZEJ5dGVzOmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKHJbZStuXSk7cmV0dXJuIGF9LHJlYWRBU0NJSUFycmF5OmZ1bmN0aW9uKHIsZSx0KXtmb3IodmFyIGE9W10sbj0wO248dDtuKyspYS5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUocltlK25dKSk7cmV0dXJuIGF9LF92aWV3OmZ1bmN0aW9uKHIpe3JldHVybiByLl9kYXRhVmlld3x8KHIuX2RhdGFWaWV3PXIuYnVmZmVyP25ldyBEYXRhVmlldyhyLmJ1ZmZlcixyLmJ5dGVPZmZzZXQsci5ieXRlTGVuZ3RoKTpuZXcgRGF0YVZpZXcobmV3IFVpbnQ4QXJyYXkocikuYnVmZmVyKSl9fSxlLl9sY3RmPXt9LGUuX2xjdGYucGFyc2U9ZnVuY3Rpb24ocix0LGEsbixvKXt2YXIgcz1lLl9iaW4saT17fSxoPXQ7cy5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBkPXMucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9cy5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1zLnJlYWRVc2hvcnQocix0KTtyZXR1cm4gdCs9MixpLnNjcmlwdExpc3Q9ZS5fbGN0Zi5yZWFkU2NyaXB0TGlzdChyLGgrZCksaS5mZWF0dXJlTGlzdD1lLl9sY3RmLnJlYWRGZWF0dXJlTGlzdChyLGgrZiksaS5sb29rdXBMaXN0PWUuX2xjdGYucmVhZExvb2t1cExpc3QocixoK3UsbyksaX0sZS5fbGN0Zi5yZWFkTG9va3VwTGlzdD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89dCxzPVtdLGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPWUuX2xjdGYucmVhZExvb2t1cFRhYmxlKHIsbytkLGEpO3MucHVzaChmKTt9cmV0dXJuIHN9LGUuX2xjdGYucmVhZExvb2t1cFRhYmxlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz10LHM9e3RhYnM6W119O3MubHR5cGU9bi5yZWFkVXNob3J0KHIsdCksdCs9MixzLmZsYWc9bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgaT1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD1zLmx0eXBlLGQ9MDtkPGk7ZCsrKXt2YXIgZj1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB1PWEocixoLG8rZixzKTtzLnRhYnMucHVzaCh1KTt9cmV0dXJuIHN9LGUuX2xjdGYubnVtT2ZPbmVzPWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT0wLHQ9MDt0PDMyO3QrKykwIT0ocj4+PnQmMSkmJmUrKztyZXR1cm4gZX0sZS5fbGN0Zi5yZWFkQ2xhc3NEZWY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1bXSxvPWEucmVhZFVzaG9ydChyLHQpO2lmKHQrPTIsMT09byl7dmFyIHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaD0wO2g8aTtoKyspbi5wdXNoKHMraCksbi5wdXNoKHMraCksbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO31pZigyPT1vKXt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2ZvcihoPTA7aDxkO2grKyluLnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTIsbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yLG4ucHVzaChhLnJlYWRVc2hvcnQocix0KSksdCs9Mjt9cmV0dXJuIG59LGUuX2xjdGYuZ2V0SW50ZXJ2YWw9ZnVuY3Rpb24ocixlKXtmb3IodmFyIHQ9MDt0PHIubGVuZ3RoO3QrPTMpe3ZhciBhPXJbdF0sbj1yW3QrMV07aWYoclt0KzJdLGE8PWUmJmU8PW4pcmV0dXJuIHR9cmV0dXJuIC0xfSxlLl9sY3RmLnJlYWRDb3ZlcmFnZT1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm10PWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7cmV0dXJuIHQrPTIsMT09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCxvKSksMj09bi5mbXQmJihuLnRhYj1hLnJlYWRVc2hvcnRzKHIsdCwzKm8pKSxufSxlLl9sY3RmLmNvdmVyYWdlSW5kZXg9ZnVuY3Rpb24ocix0KXt2YXIgYT1yLnRhYjtpZigxPT1yLmZtdClyZXR1cm4gYS5pbmRleE9mKHQpO2lmKDI9PXIuZm10KXt2YXIgbj1lLl9sY3RmLmdldEludGVydmFsKGEsdCk7aWYoLTEhPW4pcmV0dXJuIGFbbisyXSsodC1hW25dKX1yZXR1cm4gLTF9LGUuX2xjdGYucmVhZEZlYXR1cmVMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPWUuX2xjdGYucmVhZEZlYXR1cmVUYWJsZShyLG4rZCk7Zi50YWc9aC50cmltKCksby5wdXNoKGYpO31yZXR1cm4gb30sZS5fbGN0Zi5yZWFkRmVhdHVyZVRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixzPjAmJihvLmZlYXR1cmVQYXJhbXM9bitzKTt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8udGFiPVtdO2Zvcih2YXIgaD0wO2g8aTtoKyspby50YWIucHVzaChhLnJlYWRVc2hvcnQocix0KzIqaCkpO3JldHVybiBvfSxlLl9sY3RmLnJlYWRTY3JpcHRMaXN0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG9baC50cmltKCldPWUuX2xjdGYucmVhZFNjcmlwdFRhYmxlKHIsbitkKTt9cmV0dXJuIG99LGUuX2xjdGYucmVhZFNjcmlwdFRhYmxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPXt9LHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9MixzPjAmJihvLmRlZmF1bHQ9ZS5fbGN0Zi5yZWFkTGFuZ1N5c1RhYmxlKHIsbitzKSk7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXt2YXIgZD1hLnJlYWRBU0NJSShyLHQsNCk7dCs9NDt2YXIgZj1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG9bZC50cmltKCldPWUuX2xjdGYucmVhZExhbmdTeXNUYWJsZShyLG4rZik7fXJldHVybiBvfSxlLl9sY3RmLnJlYWRMYW5nU3lzVGFibGU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTthLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVxRmVhdHVyZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLG4uZmVhdHVyZXM9YS5yZWFkVXNob3J0cyhyLHQsbyksbn0sZS5DRkY9e30sZS5DRkYucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2Jpbjsocj1uZXcgVWludDhBcnJheShyLmJ1ZmZlcix0LGEpKVt0PTBdLHJbKyt0XSxyWysrdF0sclsrK3RdLHQrKzt2YXIgbz1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsbyk7Zm9yKHZhciBzPVtdLGk9MDtpPG8ubGVuZ3RoLTE7aSsrKXMucHVzaChuLnJlYWRBU0NJSShyLHQrb1tpXSxvW2krMV0tb1tpXSkpO3QrPW9bby5sZW5ndGgtMV07dmFyIGg9W107dD1lLkNGRi5yZWFkSW5kZXgocix0LGgpO3ZhciBkPVtdO2ZvcihpPTA7aTxoLmxlbmd0aC0xO2krKylkLnB1c2goZS5DRkYucmVhZERpY3Qocix0K2hbaV0sdCtoW2krMV0pKTt0Kz1oW2gubGVuZ3RoLTFdO3ZhciBmPWRbMF0sdT1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsdSk7dmFyIGw9W107Zm9yKGk9MDtpPHUubGVuZ3RoLTE7aSsrKWwucHVzaChuLnJlYWRBU0NJSShyLHQrdVtpXSx1W2krMV0tdVtpXSkpO2lmKHQrPXVbdS5sZW5ndGgtMV0sZS5DRkYucmVhZFN1YnJzKHIsdCxmKSxmLkNoYXJTdHJpbmdzKXt0PWYuQ2hhclN0cmluZ3M7dT1bXTt0PWUuQ0ZGLnJlYWRJbmRleChyLHQsdSk7dmFyIHY9W107Zm9yKGk9MDtpPHUubGVuZ3RoLTE7aSsrKXYucHVzaChuLnJlYWRCeXRlcyhyLHQrdVtpXSx1W2krMV0tdVtpXSkpO2YuQ2hhclN0cmluZ3M9djt9aWYoZi5ST1Mpe3Q9Zi5GREFycmF5O3ZhciBjPVtdO3Q9ZS5DRkYucmVhZEluZGV4KHIsdCxjKSxmLkZEQXJyYXk9W107Zm9yKGk9MDtpPGMubGVuZ3RoLTE7aSsrKXt2YXIgcD1lLkNGRi5yZWFkRGljdChyLHQrY1tpXSx0K2NbaSsxXSk7ZS5DRkYuX3JlYWRGRGljdChyLHAsbCksZi5GREFycmF5LnB1c2gocCk7fXQrPWNbYy5sZW5ndGgtMV0sdD1mLkZEU2VsZWN0LGYuRkRTZWxlY3Q9W107dmFyIFU9clt0XTtpZih0KyssMyE9VSl0aHJvdyBVO3ZhciBnPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7Zm9yKGk9MDtpPGcrMTtpKyspZi5GRFNlbGVjdC5wdXNoKG4ucmVhZFVzaG9ydChyLHQpLHJbdCsyXSksdCs9Mzt9cmV0dXJuIGYuRW5jb2RpbmcmJihmLkVuY29kaW5nPWUuQ0ZGLnJlYWRFbmNvZGluZyhyLGYuRW5jb2RpbmcsZi5DaGFyU3RyaW5ncy5sZW5ndGgpKSxmLmNoYXJzZXQmJihmLmNoYXJzZXQ9ZS5DRkYucmVhZENoYXJzZXQocixmLmNoYXJzZXQsZi5DaGFyU3RyaW5ncy5sZW5ndGgpKSxlLkNGRi5fcmVhZEZEaWN0KHIsZixsKSxmfSxlLkNGRi5fcmVhZEZEaWN0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbjtmb3IodmFyIG8gaW4gdC5Qcml2YXRlJiYobj10LlByaXZhdGVbMV0sdC5Qcml2YXRlPWUuQ0ZGLnJlYWREaWN0KHIsbixuK3QuUHJpdmF0ZVswXSksdC5Qcml2YXRlLlN1YnJzJiZlLkNGRi5yZWFkU3VicnMocixuK3QuUHJpdmF0ZS5TdWJycyx0LlByaXZhdGUpKSx0KS0xIT1bXCJGYW1pbHlOYW1lXCIsXCJGb250TmFtZVwiLFwiRnVsbE5hbWVcIixcIk5vdGljZVwiLFwidmVyc2lvblwiLFwiQ29weXJpZ2h0XCJdLmluZGV4T2YobykmJih0W29dPWFbdFtvXS00MjYrMzVdKTt9LGUuQ0ZGLnJlYWRTdWJycz1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W107dD1lLkNGRi5yZWFkSW5kZXgocix0LG8pO3ZhciBzLGk9by5sZW5ndGg7cz1pPDEyNDA/MTA3Omk8MzM5MDA/MTEzMTozMjc2OCxhLkJpYXM9cyxhLlN1YnJzPVtdO2Zvcih2YXIgaD0wO2g8by5sZW5ndGgtMTtoKyspYS5TdWJycy5wdXNoKG4ucmVhZEJ5dGVzKHIsdCtvW2hdLG9baCsxXS1vW2hdKSk7fSxlLkNGRi50YWJsZVNFPVswLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMSwyLDMsNCw1LDYsNyw4LDksMTAsMTEsMTIsMTMsMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTQsNTUsNTYsNTcsNTgsNTksNjAsNjEsNjIsNjMsNjQsNjUsNjYsNjcsNjgsNjksNzAsNzEsNzIsNzMsNzQsNzUsNzYsNzcsNzgsNzksODAsODEsODIsODMsODQsODUsODYsODcsODgsODksOTAsOTEsOTIsOTMsOTQsOTUsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCw5Niw5Nyw5OCw5OSwxMDAsMTAxLDEwMiwxMDMsMTA0LDEwNSwxMDYsMTA3LDEwOCwxMDksMTEwLDAsMTExLDExMiwxMTMsMTE0LDAsMTE1LDExNiwxMTcsMTE4LDExOSwxMjAsMTIxLDEyMiwwLDEyMywwLDEyNCwxMjUsMTI2LDEyNywxMjgsMTI5LDEzMCwxMzEsMCwxMzIsMTMzLDAsMTM0LDEzNSwxMzYsMTM3LDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMTM4LDAsMTM5LDAsMCwwLDAsMTQwLDE0MSwxNDIsMTQzLDAsMCwwLDAsMCwxNDQsMCwwLDAsMTQ1LDAsMCwxNDYsMTQ3LDE0OCwxNDksMCwwLDAsMF0sZS5DRkYuZ2x5cGhCeVVuaWNvZGU9ZnVuY3Rpb24ocixlKXtmb3IodmFyIHQ9MDt0PHIuY2hhcnNldC5sZW5ndGg7dCsrKWlmKHIuY2hhcnNldFt0XT09ZSlyZXR1cm4gdDtyZXR1cm4gLTF9LGUuQ0ZGLmdseXBoQnlTRT1mdW5jdGlvbihyLHQpe3JldHVybiB0PDB8fHQ+MjU1Py0xOmUuQ0ZGLmdseXBoQnlVbmljb2RlKHIsZS5DRkYudGFibGVTRVt0XSl9LGUuQ0ZGLnJlYWRFbmNvZGluZz1mdW5jdGlvbihyLHQsYSl7ZS5fYmluO3ZhciBuPVtcIi5ub3RkZWZcIl0sbz1yW3RdO2lmKHQrKywwIT1vKXRocm93IFwiZXJyb3I6IHVua25vd24gZW5jb2RpbmcgZm9ybWF0OiBcIitvO3ZhciBzPXJbdF07dCsrO2Zvcih2YXIgaT0wO2k8cztpKyspbi5wdXNoKHJbdCtpXSk7cmV0dXJuIG59LGUuQ0ZGLnJlYWRDaGFyc2V0PWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1bXCIubm90ZGVmXCJdLHM9clt0XTtpZih0KyssMD09cylmb3IodmFyIGk9MDtpPGE7aSsrKXt2YXIgaD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChoKTt9ZWxzZSB7aWYoMSE9cyYmMiE9cyl0aHJvdyBcImVycm9yOiBmb3JtYXQ6IFwiK3M7Zm9yKDtvLmxlbmd0aDxhOyl7aD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBkPTA7MT09cz8oZD1yW3RdLHQrKyk6KGQ9bi5yZWFkVXNob3J0KHIsdCksdCs9Mik7Zm9yKGk9MDtpPD1kO2krKylvLnB1c2goaCksaCsrO319cmV0dXJuIG99LGUuQ0ZGLnJlYWRJbmRleD1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89bi5yZWFkVXNob3J0KHIsdCkrMSxzPXJbdCs9Ml07aWYodCsrLDE9PXMpZm9yKHZhciBpPTA7aTxvO2krKylhLnB1c2goclt0K2ldKTtlbHNlIGlmKDI9PXMpZm9yKGk9MDtpPG87aSsrKWEucHVzaChuLnJlYWRVc2hvcnQocix0KzIqaSkpO2Vsc2UgaWYoMz09cylmb3IoaT0wO2k8bztpKyspYS5wdXNoKDE2Nzc3MjE1Jm4ucmVhZFVpbnQocix0KzMqaS0xKSk7ZWxzZSBpZigxIT1vKXRocm93IFwidW5zdXBwb3J0ZWQgb2Zmc2V0IHNpemU6IFwiK3MrXCIsIGNvdW50OiBcIitvO3JldHVybiAodCs9bypzKS0xfSxlLkNGRi5nZXRDaGFyU3RyaW5nPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz1yW3RdLHM9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBpPTEsaD1udWxsLGQ9bnVsbDtvPD0yMCYmKGg9byxpPTEpLDEyPT1vJiYoaD0xMDAqbytzLGk9MiksMjE8PW8mJm88PTI3JiYoaD1vLGk9MSksMjg9PW8mJihkPW4ucmVhZFNob3J0KHIsdCsxKSxpPTMpLDI5PD1vJiZvPD0zMSYmKGg9byxpPTEpLDMyPD1vJiZvPD0yNDYmJihkPW8tMTM5LGk9MSksMjQ3PD1vJiZvPD0yNTAmJihkPTI1Niooby0yNDcpK3MrMTA4LGk9MiksMjUxPD1vJiZvPD0yNTQmJihkPTI1NiotKG8tMjUxKS1zLTEwOCxpPTIpLDI1NT09byYmKGQ9bi5yZWFkSW50KHIsdCsxKS82NTUzNSxpPTUpLGEudmFsPW51bGwhPWQ/ZDpcIm9cIitoLGEuc2l6ZT1pO30sZS5DRkYucmVhZENoYXJTdHJpbmc9ZnVuY3Rpb24ocix0LGEpe2Zvcih2YXIgbj10K2Esbz1lLl9iaW4scz1bXTt0PG47KXt2YXIgaT1yW3RdLGg9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBkPTEsZj1udWxsLHU9bnVsbDtpPD0yMCYmKGY9aSxkPTEpLDEyPT1pJiYoZj0xMDAqaStoLGQ9MiksMTkhPWkmJjIwIT1pfHwoZj1pLGQ9MiksMjE8PWkmJmk8PTI3JiYoZj1pLGQ9MSksMjg9PWkmJih1PW8ucmVhZFNob3J0KHIsdCsxKSxkPTMpLDI5PD1pJiZpPD0zMSYmKGY9aSxkPTEpLDMyPD1pJiZpPD0yNDYmJih1PWktMTM5LGQ9MSksMjQ3PD1pJiZpPD0yNTAmJih1PTI1NiooaS0yNDcpK2grMTA4LGQ9MiksMjUxPD1pJiZpPD0yNTQmJih1PTI1NiotKGktMjUxKS1oLTEwOCxkPTIpLDI1NT09aSYmKHU9by5yZWFkSW50KHIsdCsxKS82NTUzNSxkPTUpLHMucHVzaChudWxsIT11P3U6XCJvXCIrZiksdCs9ZDt9cmV0dXJuIHN9LGUuQ0ZGLnJlYWREaWN0PWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49ZS5fYmluLG89e30scz1bXTt0PGE7KXt2YXIgaT1yW3RdLGg9clt0KzFdO3JbdCsyXSxyW3QrM10sclt0KzRdO3ZhciBkPTEsZj1udWxsLHU9bnVsbDtpZigyOD09aSYmKHU9bi5yZWFkU2hvcnQocix0KzEpLGQ9MyksMjk9PWkmJih1PW4ucmVhZEludChyLHQrMSksZD01KSwzMjw9aSYmaTw9MjQ2JiYodT1pLTEzOSxkPTEpLDI0Nzw9aSYmaTw9MjUwJiYodT0yNTYqKGktMjQ3KStoKzEwOCxkPTIpLDI1MTw9aSYmaTw9MjU0JiYodT0yNTYqLShpLTI1MSktaC0xMDgsZD0yKSwyNTU9PWkpdGhyb3cgdT1uLnJlYWRJbnQocix0KzEpLzY1NTM1LGQ9NSxcInVua25vd24gbnVtYmVyXCI7aWYoMzA9PWkpe3ZhciBsPVtdO2ZvcihkPTE7Oyl7dmFyIHY9clt0K2RdO2QrKzt2YXIgYz12Pj40LHA9MTUmdjtpZigxNSE9YyYmbC5wdXNoKGMpLDE1IT1wJiZsLnB1c2gocCksMTU9PXApYnJlYWt9Zm9yKHZhciBVPVwiXCIsZz1bMCwxLDIsMyw0LDUsNiw3LDgsOSxcIi5cIixcImVcIixcImUtXCIsXCJyZXNlcnZlZFwiLFwiLVwiLFwiZW5kT2ZOdW1iZXJcIl0sUz0wO1M8bC5sZW5ndGg7UysrKVUrPWdbbFtTXV07dT1wYXJzZUZsb2F0KFUpO31pZihpPD0yMSlpZihmPVtcInZlcnNpb25cIixcIk5vdGljZVwiLFwiRnVsbE5hbWVcIixcIkZhbWlseU5hbWVcIixcIldlaWdodFwiLFwiRm9udEJCb3hcIixcIkJsdWVWYWx1ZXNcIixcIk90aGVyQmx1ZXNcIixcIkZhbWlseUJsdWVzXCIsXCJGYW1pbHlPdGhlckJsdWVzXCIsXCJTdGRIV1wiLFwiU3RkVldcIixcImVzY2FwZVwiLFwiVW5pcXVlSURcIixcIlhVSURcIixcImNoYXJzZXRcIixcIkVuY29kaW5nXCIsXCJDaGFyU3RyaW5nc1wiLFwiUHJpdmF0ZVwiLFwiU3VicnNcIixcImRlZmF1bHRXaWR0aFhcIixcIm5vbWluYWxXaWR0aFhcIl1baV0sZD0xLDEyPT1pKWY9W1wiQ29weXJpZ2h0XCIsXCJpc0ZpeGVkUGl0Y2hcIixcIkl0YWxpY0FuZ2xlXCIsXCJVbmRlcmxpbmVQb3NpdGlvblwiLFwiVW5kZXJsaW5lVGhpY2tuZXNzXCIsXCJQYWludFR5cGVcIixcIkNoYXJzdHJpbmdUeXBlXCIsXCJGb250TWF0cml4XCIsXCJTdHJva2VXaWR0aFwiLFwiQmx1ZVNjYWxlXCIsXCJCbHVlU2hpZnRcIixcIkJsdWVGdXp6XCIsXCJTdGVtU25hcEhcIixcIlN0ZW1TbmFwVlwiLFwiRm9yY2VCb2xkXCIsMCwwLFwiTGFuZ3VhZ2VHcm91cFwiLFwiRXhwYW5zaW9uRmFjdG9yXCIsXCJpbml0aWFsUmFuZG9tU2VlZFwiLFwiU3ludGhldGljQmFzZVwiLFwiUG9zdFNjcmlwdFwiLFwiQmFzZUZvbnROYW1lXCIsXCJCYXNlRm9udEJsZW5kXCIsMCwwLDAsMCwwLDAsXCJST1NcIixcIkNJREZvbnRWZXJzaW9uXCIsXCJDSURGb250UmV2aXNpb25cIixcIkNJREZvbnRUeXBlXCIsXCJDSURDb3VudFwiLFwiVUlEQmFzZVwiLFwiRkRBcnJheVwiLFwiRkRTZWxlY3RcIixcIkZvbnROYW1lXCJdW2hdLGQ9MjtudWxsIT1mPyhvW2ZdPTE9PXMubGVuZ3RoP3NbMF06cyxzPVtdKTpzLnB1c2godSksdCs9ZDt9cmV0dXJuIG99LGUuY21hcD17fSxlLmNtYXAucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3I9bmV3IFVpbnQ4QXJyYXkoci5idWZmZXIsdCxhKSx0PTA7dmFyIG49ZS5fYmluLG89e307bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBpPVtdO28udGFibGVzPVtdO2Zvcih2YXIgaD0wO2g8cztoKyspe3ZhciBkPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1uLnJlYWRVaW50KHIsdCk7dCs9NDt2YXIgbD1cInBcIitkK1wiZVwiK2Ysdj1pLmluZGV4T2YodSk7aWYoLTE9PXYpe3ZhciBjO3Y9by50YWJsZXMubGVuZ3RoLGkucHVzaCh1KTt2YXIgcD1uLnJlYWRVc2hvcnQocix1KTswPT1wP2M9ZS5jbWFwLnBhcnNlMChyLHUpOjQ9PXA/Yz1lLmNtYXAucGFyc2U0KHIsdSk6Nj09cD9jPWUuY21hcC5wYXJzZTYocix1KToxMj09cD9jPWUuY21hcC5wYXJzZTEyKHIsdSk6Y29uc29sZS5kZWJ1ZyhcInVua25vd24gZm9ybWF0OiBcIitwLGQsZix1KSxvLnRhYmxlcy5wdXNoKGMpO31pZihudWxsIT1vW2xdKXRocm93IFwibXVsdGlwbGUgdGFibGVzIGZvciBvbmUgcGxhdGZvcm0rZW5jb2RpbmdcIjtvW2xdPXY7fXJldHVybiBvfSxlLmNtYXAucGFyc2UwPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307bi5mb3JtYXQ9YS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgbz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsbi5tYXA9W107Zm9yKHZhciBzPTA7czxvLTY7cysrKW4ubWFwLnB1c2goclt0K3NdKTtyZXR1cm4gbn0sZS5jbWFwLnBhcnNlND1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXQsbz17fTtvLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBzPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgaT1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBoPWkvMjtvLnNlYXJjaFJhbmdlPWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5lbnRyeVNlbGVjdG9yPWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5yYW5nZVNoaWZ0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsby5lbmRDb3VudD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsdCs9MixvLnN0YXJ0Q291bnQ9YS5yZWFkVXNob3J0cyhyLHQsaCksdCs9MipoLG8uaWREZWx0YT1bXTtmb3IodmFyIGQ9MDtkPGg7ZCsrKW8uaWREZWx0YS5wdXNoKGEucmVhZFNob3J0KHIsdCkpLHQrPTI7Zm9yKG8uaWRSYW5nZU9mZnNldD1hLnJlYWRVc2hvcnRzKHIsdCxoKSx0Kz0yKmgsby5nbHlwaElkQXJyYXk9W107dDxuK3M7KW8uZ2x5cGhJZEFycmF5LnB1c2goYS5yZWFkVXNob3J0KHIsdCkpLHQrPTI7cmV0dXJuIG99LGUuY21hcC5wYXJzZTY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17fTtuLmZvcm1hdD1hLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5yZWFkVXNob3J0KHIsdCksdCs9MixuLmZpcnN0Q29kZT1hLnJlYWRVc2hvcnQocix0KSx0Kz0yO3ZhciBvPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5nbHlwaElkQXJyYXk9W107Zm9yKHZhciBzPTA7czxvO3MrKyluLmdseXBoSWRBcnJheS5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBufSxlLmNtYXAucGFyc2UxMj1mdW5jdGlvbihyLHQpe3ZhciBhPWUuX2JpbixuPXt9O24uZm9ybWF0PWEucmVhZFVzaG9ydChyLHQpLHQrPTIsdCs9MixhLnJlYWRVaW50KHIsdCksdCs9NCxhLnJlYWRVaW50KHIsdCksdCs9NDt2YXIgbz1hLnJlYWRVaW50KHIsdCk7dCs9NCxuLmdyb3Vwcz1bXTtmb3IodmFyIHM9MDtzPG87cysrKXt2YXIgaT10KzEyKnMsaD1hLnJlYWRVaW50KHIsaSswKSxkPWEucmVhZFVpbnQocixpKzQpLGY9YS5yZWFkVWludChyLGkrOCk7bi5ncm91cHMucHVzaChbaCxkLGZdKTt9cmV0dXJuIG59LGUuZ2x5Zj17fSxlLmdseWYucGFyc2U9ZnVuY3Rpb24ocixlLHQsYSl7Zm9yKHZhciBuPVtdLG89MDtvPGEubWF4cC5udW1HbHlwaHM7bysrKW4ucHVzaChudWxsKTtyZXR1cm4gbn0sZS5nbHlmLl9wYXJzZUdseWY9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1yLl9kYXRhLG89ZS5fdGFiT2Zmc2V0KG4sXCJnbHlmXCIsci5fb2Zmc2V0KStyLmxvY2FbdF07aWYoci5sb2NhW3RdPT1yLmxvY2FbdCsxXSlyZXR1cm4gbnVsbDt2YXIgcz17fTtpZihzLm5vYz1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy54TWluPWEucmVhZFNob3J0KG4sbyksbys9MixzLnlNaW49YS5yZWFkU2hvcnQobixvKSxvKz0yLHMueE1heD1hLnJlYWRTaG9ydChuLG8pLG8rPTIscy55TWF4PWEucmVhZFNob3J0KG4sbyksbys9MixzLnhNaW4+PXMueE1heHx8cy55TWluPj1zLnlNYXgpcmV0dXJuIG51bGw7aWYocy5ub2M+MCl7cy5lbmRQdHM9W107Zm9yKHZhciBpPTA7aTxzLm5vYztpKyspcy5lbmRQdHMucHVzaChhLnJlYWRVc2hvcnQobixvKSksbys9Mjt2YXIgaD1hLnJlYWRVc2hvcnQobixvKTtpZihvKz0yLG4ubGVuZ3RoLW88aClyZXR1cm4gbnVsbDtzLmluc3RydWN0aW9ucz1hLnJlYWRCeXRlcyhuLG8saCksbys9aDt2YXIgZD1zLmVuZFB0c1tzLm5vYy0xXSsxO3MuZmxhZ3M9W107Zm9yKGk9MDtpPGQ7aSsrKXt2YXIgZj1uW29dO2lmKG8rKyxzLmZsYWdzLnB1c2goZiksMCE9KDgmZikpe3ZhciB1PW5bb107bysrO2Zvcih2YXIgbD0wO2w8dTtsKyspcy5mbGFncy5wdXNoKGYpLGkrKzt9fXMueHM9W107Zm9yKGk9MDtpPGQ7aSsrKXt2YXIgdj0wIT0oMiZzLmZsYWdzW2ldKSxjPTAhPSgxNiZzLmZsYWdzW2ldKTt2PyhzLnhzLnB1c2goYz9uW29dOi1uW29dKSxvKyspOmM/cy54cy5wdXNoKDApOihzLnhzLnB1c2goYS5yZWFkU2hvcnQobixvKSksbys9Mik7fXMueXM9W107Zm9yKGk9MDtpPGQ7aSsrKXt2PTAhPSg0JnMuZmxhZ3NbaV0pLGM9MCE9KDMyJnMuZmxhZ3NbaV0pO3Y/KHMueXMucHVzaChjP25bb106LW5bb10pLG8rKyk6Yz9zLnlzLnB1c2goMCk6KHMueXMucHVzaChhLnJlYWRTaG9ydChuLG8pKSxvKz0yKTt9dmFyIHA9MCxVPTA7Zm9yKGk9MDtpPGQ7aSsrKXArPXMueHNbaV0sVSs9cy55c1tpXSxzLnhzW2ldPXAscy55c1tpXT1VO31lbHNlIHt2YXIgZztzLnBhcnRzPVtdO2Rve2c9YS5yZWFkVXNob3J0KG4sbyksbys9Mjt2YXIgUz17bTp7YToxLGI6MCxjOjAsZDoxLHR4OjAsdHk6MH0scDE6LTEscDI6LTF9O2lmKHMucGFydHMucHVzaChTKSxTLmdseXBoSW5kZXg9YS5yZWFkVXNob3J0KG4sbyksbys9MiwxJmcpe3ZhciBtPWEucmVhZFNob3J0KG4sbyk7bys9Mjt2YXIgYj1hLnJlYWRTaG9ydChuLG8pO28rPTI7fWVsc2Uge209YS5yZWFkSW50OChuLG8pO28rKztiPWEucmVhZEludDgobixvKTtvKys7fTImZz8oUy5tLnR4PW0sUy5tLnR5PWIpOihTLnAxPW0sUy5wMj1iKSw4Jmc/KFMubS5hPVMubS5kPWEucmVhZEYyZG90MTQobixvKSxvKz0yKTo2NCZnPyhTLm0uYT1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik6MTI4JmcmJihTLm0uYT1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uYj1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uYz1hLnJlYWRGMmRvdDE0KG4sbyksbys9MixTLm0uZD1hLnJlYWRGMmRvdDE0KG4sbyksbys9Mik7fXdoaWxlKDMyJmcpO2lmKDI1NiZnKXt2YXIgeT1hLnJlYWRVc2hvcnQobixvKTtvKz0yLHMuaW5zdHI9W107Zm9yKGk9MDtpPHk7aSsrKXMuaW5zdHIucHVzaChuW29dKSxvKys7fX1yZXR1cm4gc30sZS5HREVGPXt9LGUuR0RFRi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz10O3QrPTQ7dmFyIHM9ZS5fYmluLnJlYWRVc2hvcnQocix0KTtyZXR1cm4ge2dseXBoQ2xhc3NEZWY6MD09PXM/bnVsbDplLl9sY3RmLnJlYWRDbGFzc0RlZihyLG8rcyl9fSxlLkdQT1M9e30sZS5HUE9TLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HUE9TLnN1YnQpfSxlLkdQT1Muc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxPT10fHwyPT10fHwzPT10fHw3PT10fHw4PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIsaCtzKTt9aWYoMT09dCYmMT09aS5mbXQpe3ZhciBkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsMCE9ZCYmKGkucG9zPWUuR1BPUy5yZWFkVmFsdWVSZWNvcmQocixhLGQpKTt9ZWxzZSBpZigyPT10JiZpLmZtdD49MSYmaS5mbXQ8PTIpe2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgZj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB1PWUuX2xjdGYubnVtT2ZPbmVzKGQpLGw9ZS5fbGN0Zi5udW1PZk9uZXMoZik7aWYoMT09aS5mbXQpe2kucGFpcnNldHM9W107dmFyIHY9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGM9MDtjPHY7YysrKXt2YXIgcD1zK28ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIFU9by5yZWFkVXNob3J0KHIscCk7cCs9Mjtmb3IodmFyIGc9W10sUz0wO1M8VTtTKyspe3ZhciBtPW8ucmVhZFVzaG9ydChyLHApO3ArPTIsMCE9ZCYmKFA9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLHAsZCkscCs9Mip1KSwwIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIscCxmKSxwKz0yKmwpLGcucHVzaCh7Z2lkMjptLHZhbDE6UCx2YWwyOnh9KTt9aS5wYWlyc2V0cy5wdXNoKGcpO319aWYoMj09aS5mbXQpe3ZhciBiPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7dmFyIHk9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgRj1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciBDPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jbGFzc0RlZjE9ZS5fbGN0Zi5yZWFkQ2xhc3NEZWYocixzK2IpLGkuY2xhc3NEZWYyPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscyt5KSxpLm1hdHJpeD1bXTtmb3IoYz0wO2M8RjtjKyspe3ZhciBfPVtdO2ZvcihTPTA7UzxDO1MrKyl7dmFyIFA9bnVsbCx4PW51bGw7MCE9ZCYmKFA9ZS5HUE9TLnJlYWRWYWx1ZVJlY29yZChyLGEsZCksYSs9Mip1KSwwIT1mJiYoeD1lLkdQT1MucmVhZFZhbHVlUmVjb3JkKHIsYSxmKSxhKz0yKmwpLF8ucHVzaCh7dmFsMTpQLHZhbDI6eH0pO31pLm1hdHJpeC5wdXNoKF8pO319fWVsc2UgaWYoND09dCYmMT09aS5mbXQpaS5tYXJrQ292ZXJhZ2U9ZS5fbGN0Zi5yZWFkQ292ZXJhZ2UocixvLnJlYWRVc2hvcnQocixhKStzKSxpLmJhc2VDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGErMikrcyksaS5tYXJrQ2xhc3NDb3VudD1vLnJlYWRVc2hvcnQocixhKzQpLGkubWFya0FycmF5PWUuR1BPUy5yZWFkTWFya0FycmF5KHIsby5yZWFkVXNob3J0KHIsYSs2KStzKSxpLmJhc2VBcnJheT1lLkdQT1MucmVhZEJhc2VBcnJheShyLG8ucmVhZFVzaG9ydChyLGErOCkrcyxpLm1hcmtDbGFzc0NvdW50KTtlbHNlIGlmKDY9PXQmJjE9PWkuZm10KWkubWFyazFDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGEpK3MpLGkubWFyazJDb3ZlcmFnZT1lLl9sY3RmLnJlYWRDb3ZlcmFnZShyLG8ucmVhZFVzaG9ydChyLGErMikrcyksaS5tYXJrQ2xhc3NDb3VudD1vLnJlYWRVc2hvcnQocixhKzQpLGkubWFyazFBcnJheT1lLkdQT1MucmVhZE1hcmtBcnJheShyLG8ucmVhZFVzaG9ydChyLGErNikrcyksaS5tYXJrMkFycmF5PWUuR1BPUy5yZWFkQmFzZUFycmF5KHIsby5yZWFkVXNob3J0KHIsYSs4KStzLGkubWFya0NsYXNzQ291bnQpO2Vsc2Uge2lmKDk9PXQmJjE9PWkuZm10KXt2YXIgST1vLnJlYWRVc2hvcnQocixhKTthKz0yO3ZhciB3PW8ucmVhZFVpbnQocixhKTtpZihhKz00LDk9PW4ubHR5cGUpbi5sdHlwZT1JO2Vsc2UgaWYobi5sdHlwZSE9SSl0aHJvdyBcImludmFsaWQgZXh0ZW5zaW9uIHN1YnN0aXR1dGlvblwiO3JldHVybiBlLkdQT1Muc3VidChyLG4ubHR5cGUscyt3KX1jb25zb2xlLmRlYnVnKFwidW5zdXBwb3J0ZWQgR1BPUyB0YWJsZSBMb29rdXBUeXBlXCIsdCxcImZvcm1hdFwiLGkuZm10KTt9cmV0dXJuIGl9LGUuR1BPUy5yZWFkVmFsdWVSZWNvcmQ9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPVtdO3JldHVybiBvLnB1c2goMSZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MSZhPzI6MCxvLnB1c2goMiZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9MiZhPzI6MCxvLnB1c2goNCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9NCZhPzI6MCxvLnB1c2goOCZhP24ucmVhZFNob3J0KHIsdCk6MCksdCs9OCZhPzI6MCxvfSxlLkdQT1MucmVhZEJhc2VBcnJheT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89W10scz10LGk9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9MDtoPGk7aCsrKXtmb3IodmFyIGQ9W10sZj0wO2Y8YTtmKyspZC5wdXNoKGUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkKHIscytuLnJlYWRVc2hvcnQocix0KSkpLHQrPTI7by5wdXNoKGQpO31yZXR1cm4gb30sZS5HUE9TLnJlYWRNYXJrQXJyYXk9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj1bXSxvPXQscz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkKHIsYS5yZWFkVXNob3J0KHIsdCsyKStvKTtoLm1hcmtDbGFzcz1hLnJlYWRVc2hvcnQocix0KSxuLnB1c2goaCksdCs9NDt9cmV0dXJuIG59LGUuR1BPUy5yZWFkQW5jaG9yUmVjb3JkPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49e307cmV0dXJuIG4uZm10PWEucmVhZFVzaG9ydChyLHQpLG4ueD1hLnJlYWRTaG9ydChyLHQrMiksbi55PWEucmVhZFNob3J0KHIsdCs0KSxufSxlLkdTVUI9e30sZS5HU1VCLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3JldHVybiBlLl9sY3RmLnBhcnNlKHIsdCxhLG4sZS5HU1VCLnN1YnQpfSxlLkdTVUIuc3VidD1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1hLGk9e307aWYoaS5mbXQ9by5yZWFkVXNob3J0KHIsYSksYSs9MiwxIT10JiYyIT10JiY0IT10JiY1IT10JiY2IT10KXJldHVybiBudWxsO2lmKDE9PXR8fDI9PXR8fDQ9PXR8fDU9PXQmJmkuZm10PD0yfHw2PT10JiZpLmZtdDw9Mil7dmFyIGg9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmNvdmVyYWdlPWUuX2xjdGYucmVhZENvdmVyYWdlKHIscytoKTt9aWYoMT09dCYmaS5mbXQ+PTEmJmkuZm10PD0yKXtpZigxPT1pLmZtdClpLmRlbHRhPW8ucmVhZFNob3J0KHIsYSksYSs9MjtlbHNlIGlmKDI9PWkuZm10KXt2YXIgZD1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkubmV3Zz1vLnJlYWRVc2hvcnRzKHIsYSxkKSxhKz0yKmkubmV3Zy5sZW5ndGg7fX1lbHNlIGlmKDI9PXQmJjE9PWkuZm10KXtkPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5zZXFzPVtdO2Zvcih2YXIgZj0wO2Y8ZDtmKyspe3ZhciB1PW8ucmVhZFVzaG9ydChyLGEpK3M7YSs9Mjt2YXIgbD1vLnJlYWRVc2hvcnQocix1KTtpLnNlcXMucHVzaChvLnJlYWRVc2hvcnRzKHIsdSsyLGwpKTt9fWVsc2UgaWYoND09dCl7aS52YWxzPVtdO2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IoZj0wO2Y8ZDtmKyspe3ZhciB2PW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS52YWxzLnB1c2goZS5HU1VCLnJlYWRMaWdhdHVyZVNldChyLHMrdikpO319ZWxzZSBpZig1PT10JiYyPT1pLmZtdCl7aWYoMj09aS5mbXQpe3ZhciBjPW8ucmVhZFVzaG9ydChyLGEpO2ErPTIsaS5jRGVmPWUuX2xjdGYucmVhZENsYXNzRGVmKHIscytjKSxpLnNjc2V0PVtdO3ZhciBwPW8ucmVhZFVzaG9ydChyLGEpO2ErPTI7Zm9yKGY9MDtmPHA7ZisrKXt2YXIgVT1vLnJlYWRVc2hvcnQocixhKTthKz0yLGkuc2NzZXQucHVzaCgwPT1VP251bGw6ZS5HU1VCLnJlYWRTdWJDbGFzc1NldChyLHMrVSkpO319fWVsc2UgaWYoNj09dCYmMz09aS5mbXQpe2lmKDM9PWkuZm10KXtmb3IoZj0wO2Y8MztmKyspe2Q9by5yZWFkVXNob3J0KHIsYSk7YSs9Mjtmb3IodmFyIGc9W10sUz0wO1M8ZDtTKyspZy5wdXNoKGUuX2xjdGYucmVhZENvdmVyYWdlKHIscytvLnJlYWRVc2hvcnQocixhKzIqUykpKTthKz0yKmQsMD09ZiYmKGkuYmFja0N2Zz1nKSwxPT1mJiYoaS5pbnB0Q3ZnPWcpLDI9PWYmJihpLmFoZWRDdmc9Zyk7fWQ9by5yZWFkVXNob3J0KHIsYSk7YSs9MixpLmxvb2t1cFJlYz1lLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3JkcyhyLGEsZCk7fX1lbHNlIHtpZig3PT10JiYxPT1pLmZtdCl7dmFyIG09by5yZWFkVXNob3J0KHIsYSk7YSs9Mjt2YXIgYj1vLnJlYWRVaW50KHIsYSk7aWYoYSs9NCw5PT1uLmx0eXBlKW4ubHR5cGU9bTtlbHNlIGlmKG4ubHR5cGUhPW0pdGhyb3cgXCJpbnZhbGlkIGV4dGVuc2lvbiBzdWJzdGl0dXRpb25cIjtyZXR1cm4gZS5HU1VCLnN1YnQocixuLmx0eXBlLHMrYil9Y29uc29sZS5kZWJ1ZyhcInVuc3VwcG9ydGVkIEdTVUIgdGFibGUgTG9va3VwVHlwZVwiLHQsXCJmb3JtYXRcIixpLmZtdCk7fXJldHVybiBpfSxlLkdTVUIucmVhZFN1YkNsYXNzU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLnJlYWRVc2hvcnQsbj10LG89W10scz1hKHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hKHIsdCk7dCs9MixvLnB1c2goZS5HU1VCLnJlYWRTdWJDbGFzc1J1bGUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkU3ViQ2xhc3NSdWxlPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLnJlYWRVc2hvcnQsbj17fSxvPWEocix0KSxzPWEocix0Kz0yKTt0Kz0yLG4uaW5wdXQ9W107Zm9yKHZhciBpPTA7aTxvLTE7aSsrKW4uaW5wdXQucHVzaChhKHIsdCkpLHQrPTI7cmV0dXJuIG4uc3Vic3RMb29rdXBSZWNvcmRzPWUuR1NVQi5yZWFkU3Vic3RMb29rdXBSZWNvcmRzKHIsdCxzKSxufSxlLkdTVUIucmVhZFN1YnN0TG9va3VwUmVjb3Jkcz1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPWUuX2Jpbi5yZWFkVXNob3J0LG89W10scz0wO3M8YTtzKyspby5wdXNoKG4ocix0KSxuKHIsdCsyKSksdCs9NDtyZXR1cm4gb30sZS5HU1VCLnJlYWRDaGFpblN1YkNsYXNzU2V0PWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fYmluLG49dCxvPVtdLHM9YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGk9MDtpPHM7aSsrKXt2YXIgaD1hLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucHVzaChlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NSdWxlKHIsbitoKSk7fXJldHVybiBvfSxlLkdTVUIucmVhZENoYWluU3ViQ2xhc3NSdWxlPWZ1bmN0aW9uKHIsdCl7Zm9yKHZhciBhPWUuX2JpbixuPXt9LG89W1wiYmFja3RyYWNrXCIsXCJpbnB1dFwiLFwibG9va2FoZWFkXCJdLHM9MDtzPG8ubGVuZ3RoO3MrKyl7dmFyIGk9YS5yZWFkVXNob3J0KHIsdCk7dCs9MiwxPT1zJiZpLS0sbltvW3NdXT1hLnJlYWRVc2hvcnRzKHIsdCxpKSx0Kz0yKm5bb1tzXV0ubGVuZ3RoO31pPWEucmVhZFVzaG9ydChyLHQpO3JldHVybiB0Kz0yLG4uc3Vic3Q9YS5yZWFkVXNob3J0cyhyLHQsMippKSx0Kz0yKm4uc3Vic3QubGVuZ3RoLG59LGUuR1NVQi5yZWFkTGlnYXR1cmVTZXQ9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj10LG89W10scz1hLnJlYWRVc2hvcnQocix0KTt0Kz0yO2Zvcih2YXIgaT0wO2k8cztpKyspe3ZhciBoPWEucmVhZFVzaG9ydChyLHQpO3QrPTIsby5wdXNoKGUuR1NVQi5yZWFkTGlnYXR1cmUocixuK2gpKTt9cmV0dXJuIG99LGUuR1NVQi5yZWFkTGlnYXR1cmU9ZnVuY3Rpb24ocix0KXt2YXIgYT1lLl9iaW4sbj17Y2hhaW46W119O24ubmdseXBoPWEucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIG89YS5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIHM9MDtzPG8tMTtzKyspbi5jaGFpbi5wdXNoKGEucmVhZFVzaG9ydChyLHQpKSx0Kz0yO3JldHVybiBufSxlLmhlYWQ9e30sZS5oZWFkLnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gbi5yZWFkRml4ZWQocix0KSx0Kz00LG8uZm9udFJldmlzaW9uPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxuLnJlYWRVaW50KHIsdCksdCs9NCxuLnJlYWRVaW50KHIsdCksdCs9NCxvLmZsYWdzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby51bml0c1BlckVtPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5jcmVhdGVkPW4ucmVhZFVpbnQ2NChyLHQpLHQrPTgsby5tb2RpZmllZD1uLnJlYWRVaW50NjQocix0KSx0Kz04LG8ueE1pbj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby55TWluPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnhNYXg9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ueU1heD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5tYWNTdHlsZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubG93ZXN0UmVjUFBFTT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8uZm9udERpcmVjdGlvbkhpbnQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uaW5kZXhUb0xvY0Zvcm1hdD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5nbHlwaERhdGFGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG99LGUuaGhlYT17fSxlLmhoZWEucGFyc2U9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbixvPXt9O3JldHVybiBuLnJlYWRGaXhlZChyLHQpLHQrPTQsby5hc2NlbmRlcj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5kZXNjZW5kZXI9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubGluZUdhcD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5hZHZhbmNlV2lkdGhNYXg9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1pbkxlZnRTaWRlQmVhcmluZz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5taW5SaWdodFNpZGVCZWFyaW5nPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnhNYXhFeHRlbnQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRTbG9wZVJpc2U9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8uY2FyZXRTbG9wZVJ1bj1uLnJlYWRTaG9ydChyLHQpLHQrPTIsby5jYXJldE9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsdCs9OCxvLm1ldHJpY0RhdGFGb3JtYXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLG8ubnVtYmVyT2ZITWV0cmljcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG99LGUuaG10eD17fSxlLmhtdHgucGFyc2U9ZnVuY3Rpb24ocix0LGEsbil7Zm9yKHZhciBvPWUuX2JpbixzPXthV2lkdGg6W10sbHNCZWFyaW5nOltdfSxpPTAsaD0wLGQ9MDtkPG4ubWF4cC5udW1HbHlwaHM7ZCsrKWQ8bi5oaGVhLm51bWJlck9mSE1ldHJpY3MmJihpPW8ucmVhZFVzaG9ydChyLHQpLHQrPTIsaD1vLnJlYWRTaG9ydChyLHQpLHQrPTIpLHMuYVdpZHRoLnB1c2goaSkscy5sc0JlYXJpbmcucHVzaChoKTtyZXR1cm4gc30sZS5rZXJuPXt9LGUua2Vybi5wYXJzZT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW4scz1vLnJlYWRVc2hvcnQocix0KTtpZih0Kz0yLDE9PXMpcmV0dXJuIGUua2Vybi5wYXJzZVYxKHIsdC0yLGEsbik7dmFyIGk9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjtmb3IodmFyIGg9e2dseXBoMTpbXSxydmFsOltdfSxkPTA7ZDxpO2QrKyl7dCs9MjthPW8ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGY9by5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgdT1mPj4+ODtpZigwIT0odSY9MTUpKXRocm93IFwidW5rbm93biBrZXJuIHRhYmxlIGZvcm1hdDogXCIrdTt0PWUua2Vybi5yZWFkRm9ybWF0MChyLHQsaCk7fXJldHVybiBofSxlLmtlcm4ucGFyc2VWMT1mdW5jdGlvbihyLHQsYSxuKXt2YXIgbz1lLl9iaW47by5yZWFkRml4ZWQocix0KSx0Kz00O3ZhciBzPW8ucmVhZFVpbnQocix0KTt0Kz00O2Zvcih2YXIgaT17Z2x5cGgxOltdLHJ2YWw6W119LGg9MDtoPHM7aCsrKXtvLnJlYWRVaW50KHIsdCksdCs9NDt2YXIgZD1vLnJlYWRVc2hvcnQocix0KTt0Kz0yLG8ucmVhZFVzaG9ydChyLHQpLHQrPTI7dmFyIGY9ZD4+Pjg7aWYoMCE9KGYmPTE1KSl0aHJvdyBcInVua25vd24ga2VybiB0YWJsZSBmb3JtYXQ6IFwiK2Y7dD1lLmtlcm4ucmVhZEZvcm1hdDAocix0LGkpO31yZXR1cm4gaX0sZS5rZXJuLnJlYWRGb3JtYXQwPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz0tMSxzPW4ucmVhZFVzaG9ydChyLHQpO3QrPTIsbi5yZWFkVXNob3J0KHIsdCksdCs9MixuLnJlYWRVc2hvcnQocix0KSx0Kz0yLG4ucmVhZFVzaG9ydChyLHQpLHQrPTI7Zm9yKHZhciBpPTA7aTxzO2krKyl7dmFyIGg9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgZD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBmPW4ucmVhZFNob3J0KHIsdCk7dCs9MixoIT1vJiYoYS5nbHlwaDEucHVzaChoKSxhLnJ2YWwucHVzaCh7Z2x5cGgyOltdLHZhbHM6W119KSk7dmFyIHU9YS5ydmFsW2EucnZhbC5sZW5ndGgtMV07dS5nbHlwaDIucHVzaChkKSx1LnZhbHMucHVzaChmKSxvPWg7fXJldHVybiB0fSxlLmxvY2E9e30sZS5sb2NhLnBhcnNlPWZ1bmN0aW9uKHIsdCxhLG4pe3ZhciBvPWUuX2JpbixzPVtdLGk9bi5oZWFkLmluZGV4VG9Mb2NGb3JtYXQsaD1uLm1heHAubnVtR2x5cGhzKzE7aWYoMD09aSlmb3IodmFyIGQ9MDtkPGg7ZCsrKXMucHVzaChvLnJlYWRVc2hvcnQocix0KyhkPDwxKSk8PDEpO2lmKDE9PWkpZm9yKGQ9MDtkPGg7ZCsrKXMucHVzaChvLnJlYWRVaW50KHIsdCsoZDw8MikpKTtyZXR1cm4gc30sZS5tYXhwPXt9LGUubWF4cC5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e30scz1uLnJlYWRVaW50KHIsdCk7cmV0dXJuIHQrPTQsby5udW1HbHlwaHM9bi5yZWFkVXNob3J0KHIsdCksdCs9Miw2NTUzNj09cyYmKG8ubWF4UG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb250b3Vycz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9zaXRlUG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb3NpdGVDb250b3Vycz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Wm9uZXM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heFR3aWxpZ2h0UG9pbnRzPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhTdG9yYWdlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhGdW5jdGlvbkRlZnM9bi5yZWFkVXNob3J0KHIsdCksdCs9MixvLm1heEluc3RydWN0aW9uRGVmcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U3RhY2tFbGVtZW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4U2l6ZU9mSW5zdHJ1Y3Rpb25zPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsby5tYXhDb21wb25lbnRFbGVtZW50cz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLG8ubWF4Q29tcG9uZW50RGVwdGg9bi5yZWFkVXNob3J0KHIsdCksdCs9Miksb30sZS5uYW1lPXt9LGUubmFtZS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLG89e307bi5yZWFkVXNob3J0KHIsdCksdCs9Mjt2YXIgcz1uLnJlYWRVc2hvcnQocix0KTt0Kz0yLG4ucmVhZFVzaG9ydChyLHQpO2Zvcih2YXIgaSxoPVtcImNvcHlyaWdodFwiLFwiZm9udEZhbWlseVwiLFwiZm9udFN1YmZhbWlseVwiLFwiSURcIixcImZ1bGxOYW1lXCIsXCJ2ZXJzaW9uXCIsXCJwb3N0U2NyaXB0TmFtZVwiLFwidHJhZGVtYXJrXCIsXCJtYW51ZmFjdHVyZXJcIixcImRlc2lnbmVyXCIsXCJkZXNjcmlwdGlvblwiLFwidXJsVmVuZG9yXCIsXCJ1cmxEZXNpZ25lclwiLFwibGljZW5jZVwiLFwibGljZW5jZVVSTFwiLFwiLS0tXCIsXCJ0eXBvRmFtaWx5TmFtZVwiLFwidHlwb1N1YmZhbWlseU5hbWVcIixcImNvbXBhdGlibGVGdWxsXCIsXCJzYW1wbGVUZXh0XCIsXCJwb3N0U2NyaXB0Q0lEXCIsXCJ3d3NGYW1pbHlOYW1lXCIsXCJ3d3NTdWJmYW1pbHlOYW1lXCIsXCJsaWdodFBhbGV0dGVcIixcImRhcmtQYWxldHRlXCJdLGQ9dCs9MixmPTA7ZjxzO2YrKyl7dmFyIHU9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgbD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciB2PW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGM9bi5yZWFkVXNob3J0KHIsdCk7dCs9Mjt2YXIgcD1uLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBVPW4ucmVhZFVzaG9ydChyLHQpO3QrPTI7dmFyIGcsUz1oW2NdLG09ZCsxMipzK1U7aWYoMD09dSlnPW4ucmVhZFVuaWNvZGUocixtLHAvMik7ZWxzZSBpZigzPT11JiYwPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDA9PWwpZz1uLnJlYWRBU0NJSShyLG0scCk7ZWxzZSBpZigxPT1sKWc9bi5yZWFkVW5pY29kZShyLG0scC8yKTtlbHNlIGlmKDM9PWwpZz1uLnJlYWRVbmljb2RlKHIsbSxwLzIpO2Vsc2Uge2lmKDEhPXUpdGhyb3cgXCJ1bmtub3duIGVuY29kaW5nIFwiK2wrXCIsIHBsYXRmb3JtSUQ6IFwiK3U7Zz1uLnJlYWRBU0NJSShyLG0scCksY29uc29sZS5kZWJ1ZyhcInJlYWRpbmcgdW5rbm93biBNQUMgZW5jb2RpbmcgXCIrbCtcIiBhcyBBU0NJSVwiKTt9dmFyIGI9XCJwXCIrdStcIixcIit2LnRvU3RyaW5nKDE2KTtudWxsPT1vW2JdJiYob1tiXT17fSksb1tiXVt2b2lkIDAhPT1TP1M6Y109ZyxvW2JdLl9sYW5nPXY7fWZvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUmJjEwMzM9PW9beV0uX2xhbmcpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8paWYobnVsbCE9b1t5XS5wb3N0U2NyaXB0TmFtZSYmMD09b1t5XS5fbGFuZylyZXR1cm4gb1t5XTtmb3IodmFyIHkgaW4gbylpZihudWxsIT1vW3ldLnBvc3RTY3JpcHROYW1lJiYzMDg0PT1vW3ldLl9sYW5nKXJldHVybiBvW3ldO2Zvcih2YXIgeSBpbiBvKWlmKG51bGwhPW9beV0ucG9zdFNjcmlwdE5hbWUpcmV0dXJuIG9beV07Zm9yKHZhciB5IGluIG8pe2k9eTticmVha31yZXR1cm4gY29uc29sZS5kZWJ1ZyhcInJldHVybmluZyBuYW1lIHRhYmxlIHdpdGggbGFuZ3VhZ2VJRCBcIitvW2ldLl9sYW5nKSxvW2ldfSxlW1wiT1MvMlwiXT17fSxlW1wiT1MvMlwiXS5wYXJzZT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluLnJlYWRVc2hvcnQocix0KTt0Kz0yO3ZhciBvPXt9O2lmKDA9PW4pZVtcIk9TLzJcIl0udmVyc2lvbjAocix0LG8pO2Vsc2UgaWYoMT09billW1wiT1MvMlwiXS52ZXJzaW9uMShyLHQsbyk7ZWxzZSBpZigyPT1ufHwzPT1ufHw0PT1uKWVbXCJPUy8yXCJdLnZlcnNpb24yKHIsdCxvKTtlbHNlIHtpZig1IT1uKXRocm93IFwidW5rbm93biBPUy8yIHRhYmxlIHZlcnNpb246IFwiK247ZVtcIk9TLzJcIl0udmVyc2lvbjUocix0LG8pO31yZXR1cm4gb30sZVtcIk9TLzJcIl0udmVyc2lvbjA9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPWUuX2JpbjtyZXR1cm4gYS54QXZnQ2hhcldpZHRoPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnVzV2VpZ2h0Q2xhc3M9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzV2lkdGhDbGFzcz1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEuZnNUeXBlPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS55U3Vic2NyaXB0WFNpemU9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1YnNjcmlwdFlTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRYT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdWJzY3JpcHRZT2Zmc2V0PW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFhTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFlTaXplPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnlTdXBlcnNjcmlwdFhPZmZzZXQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEueVN1cGVyc2NyaXB0WU9mZnNldD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3RyaWtlb3V0U2l6ZT1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS55U3RyaWtlb3V0UG9zaXRpb249bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc0ZhbWlseUNsYXNzPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnBhbm9zZT1uLnJlYWRCeXRlcyhyLHQsMTApLHQrPTEwLGEudWxVbmljb2RlUmFuZ2UxPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2UyPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2UzPW4ucmVhZFVpbnQocix0KSx0Kz00LGEudWxVbmljb2RlUmFuZ2U0PW4ucmVhZFVpbnQocix0KSx0Kz00LGEuYWNoVmVuZElEPVtuLnJlYWRJbnQ4KHIsdCksbi5yZWFkSW50OChyLHQrMSksbi5yZWFkSW50OChyLHQrMiksbi5yZWFkSW50OChyLHQrMyldLHQrPTQsYS5mc1NlbGVjdGlvbj1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNGaXJzdENoYXJJbmRleD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNMYXN0Q2hhckluZGV4PW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS5zVHlwb0FzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNUeXBvRGVzY2VuZGVyPW4ucmVhZFNob3J0KHIsdCksdCs9MixhLnNUeXBvTGluZUdhcD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c1dpbkFzY2VudD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yLGEudXNXaW5EZXNjZW50PW4ucmVhZFVzaG9ydChyLHQpLHQrPTJ9LGVbXCJPUy8yXCJdLnZlcnNpb24xPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjAocix0LGEpLGEudWxDb2RlUGFnZVJhbmdlMT1uLnJlYWRVaW50KHIsdCksdCs9NCxhLnVsQ29kZVBhZ2VSYW5nZTI9bi5yZWFkVWludChyLHQpLHQrPTR9LGVbXCJPUy8yXCJdLnZlcnNpb24yPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW47cmV0dXJuIHQ9ZVtcIk9TLzJcIl0udmVyc2lvbjEocix0LGEpLGEuc3hIZWlnaHQ9bi5yZWFkU2hvcnQocix0KSx0Kz0yLGEuc0NhcEhlaWdodD1uLnJlYWRTaG9ydChyLHQpLHQrPTIsYS51c0RlZmF1bHQ9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzQnJlYWs9bi5yZWFkVXNob3J0KHIsdCksdCs9MixhLnVzTWF4Q29udGV4dD1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlW1wiT1MvMlwiXS52ZXJzaW9uNT1mdW5jdGlvbihyLHQsYSl7dmFyIG49ZS5fYmluO3JldHVybiB0PWVbXCJPUy8yXCJdLnZlcnNpb24yKHIsdCxhKSxhLnVzTG93ZXJPcHRpY2FsUG9pbnRTaXplPW4ucmVhZFVzaG9ydChyLHQpLHQrPTIsYS51c1VwcGVyT3B0aWNhbFBvaW50U2l6ZT1uLnJlYWRVc2hvcnQocix0KSx0Kz0yfSxlLnBvc3Q9e30sZS5wb3N0LnBhcnNlPWZ1bmN0aW9uKHIsdCxhKXt2YXIgbj1lLl9iaW4sbz17fTtyZXR1cm4gby52ZXJzaW9uPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLml0YWxpY0FuZ2xlPW4ucmVhZEZpeGVkKHIsdCksdCs9NCxvLnVuZGVybGluZVBvc2l0aW9uPW4ucmVhZFNob3J0KHIsdCksdCs9MixvLnVuZGVybGluZVRoaWNrbmVzcz1uLnJlYWRTaG9ydChyLHQpLHQrPTIsb30sbnVsbD09ZSYmKGU9e30pLG51bGw9PWUuVSYmKGUuVT17fSksZS5VLmNvZGVUb0dseXBoPWZ1bmN0aW9uKHIsZSl7dmFyIHQ9ci5jbWFwLGE9LTE7aWYobnVsbCE9dC5wMGU0P2E9dC5wMGU0Om51bGwhPXQucDNlMT9hPXQucDNlMTpudWxsIT10LnAxZTA/YT10LnAxZTA6bnVsbCE9dC5wMGUzJiYoYT10LnAwZTMpLC0xPT1hKXRocm93IFwibm8gZmFtaWxpYXIgcGxhdGZvcm0gYW5kIGVuY29kaW5nIVwiO3ZhciBuPXQudGFibGVzW2FdO2lmKDA9PW4uZm9ybWF0KXJldHVybiBlPj1uLm1hcC5sZW5ndGg/MDpuLm1hcFtlXTtpZig0PT1uLmZvcm1hdCl7Zm9yKHZhciBvPS0xLHM9MDtzPG4uZW5kQ291bnQubGVuZ3RoO3MrKylpZihlPD1uLmVuZENvdW50W3NdKXtvPXM7YnJlYWt9aWYoLTE9PW8pcmV0dXJuIDA7aWYobi5zdGFydENvdW50W29dPmUpcmV0dXJuIDA7cmV0dXJuIDY1NTM1JigwIT1uLmlkUmFuZ2VPZmZzZXRbb10/bi5nbHlwaElkQXJyYXlbZS1uLnN0YXJ0Q291bnRbb10rKG4uaWRSYW5nZU9mZnNldFtvXT4+MSktKG4uaWRSYW5nZU9mZnNldC5sZW5ndGgtbyldOmUrbi5pZERlbHRhW29dKX1pZigxMj09bi5mb3JtYXQpe2lmKGU+bi5ncm91cHNbbi5ncm91cHMubGVuZ3RoLTFdWzFdKXJldHVybiAwO2ZvcihzPTA7czxuLmdyb3Vwcy5sZW5ndGg7cysrKXt2YXIgaT1uLmdyb3Vwc1tzXTtpZihpWzBdPD1lJiZlPD1pWzFdKXJldHVybiBpWzJdKyhlLWlbMF0pfXJldHVybiAwfXRocm93IFwidW5rbm93biBjbWFwIHRhYmxlIGZvcm1hdCBcIituLmZvcm1hdH0sZS5VLmdseXBoVG9QYXRoPWZ1bmN0aW9uKHIsdCl7dmFyIGE9e2NtZHM6W10sY3JkczpbXX07aWYoci5TVkcmJnIuU1ZHLmVudHJpZXNbdF0pe3ZhciBuPXIuU1ZHLmVudHJpZXNbdF07cmV0dXJuIG51bGw9PW4/YTooXCJzdHJpbmdcIj09dHlwZW9mIG4mJihuPWUuU1ZHLnRvUGF0aChuKSxyLlNWRy5lbnRyaWVzW3RdPW4pLG4pfWlmKHIuQ0ZGKXt2YXIgbz17eDowLHk6MCxzdGFjazpbXSxuU3RlbXM6MCxoYXZlV2lkdGg6ITEsd2lkdGg6ci5DRkYuUHJpdmF0ZT9yLkNGRi5Qcml2YXRlLmRlZmF1bHRXaWR0aFg6MCxvcGVuOiExfSxzPXIuQ0ZGLGk9ci5DRkYuUHJpdmF0ZTtpZihzLlJPUyl7Zm9yKHZhciBoPTA7cy5GRFNlbGVjdFtoKzJdPD10OyloKz0yO2k9cy5GREFycmF5W3MuRkRTZWxlY3RbaCsxXV0uUHJpdmF0ZTt9ZS5VLl9kcmF3Q0ZGKHIuQ0ZGLkNoYXJTdHJpbmdzW3RdLG8scyxpLGEpO31lbHNlIHIuZ2x5ZiYmZS5VLl9kcmF3R2x5Zih0LHIsYSk7cmV0dXJuIGF9LGUuVS5fZHJhd0dseWY9ZnVuY3Rpb24ocix0LGEpe3ZhciBuPXQuZ2x5ZltyXTtudWxsPT1uJiYobj10LmdseWZbcl09ZS5nbHlmLl9wYXJzZUdseWYodCxyKSksbnVsbCE9biYmKG4ubm9jPi0xP2UuVS5fc2ltcGxlR2x5cGgobixhKTplLlUuX2NvbXBvR2x5cGgobix0LGEpKTt9LGUuVS5fc2ltcGxlR2x5cGg9ZnVuY3Rpb24ocix0KXtmb3IodmFyIGE9MDthPHIubm9jO2ErKyl7Zm9yKHZhciBuPTA9PWE/MDpyLmVuZFB0c1thLTFdKzEsbz1yLmVuZFB0c1thXSxzPW47czw9bztzKyspe3ZhciBpPXM9PW4/bzpzLTEsaD1zPT1vP246cysxLGQ9MSZyLmZsYWdzW3NdLGY9MSZyLmZsYWdzW2ldLHU9MSZyLmZsYWdzW2hdLGw9ci54c1tzXSx2PXIueXNbc107aWYocz09bilpZihkKXtpZighZil7ZS5VLlAubW92ZVRvKHQsbCx2KTtjb250aW51ZX1lLlUuUC5tb3ZlVG8odCxyLnhzW2ldLHIueXNbaV0pO31lbHNlIGY/ZS5VLlAubW92ZVRvKHQsci54c1tpXSxyLnlzW2ldKTplLlUuUC5tb3ZlVG8odCwoci54c1tpXStsKS8yLChyLnlzW2ldK3YpLzIpO2Q/ZiYmZS5VLlAubGluZVRvKHQsbCx2KTp1P2UuVS5QLnFjdXJ2ZVRvKHQsbCx2LHIueHNbaF0sci55c1toXSk6ZS5VLlAucWN1cnZlVG8odCxsLHYsKGwrci54c1toXSkvMiwodityLnlzW2hdKS8yKTt9ZS5VLlAuY2xvc2VQYXRoKHQpO319LGUuVS5fY29tcG9HbHlwaD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPTA7bjxyLnBhcnRzLmxlbmd0aDtuKyspe3ZhciBvPXtjbWRzOltdLGNyZHM6W119LHM9ci5wYXJ0c1tuXTtlLlUuX2RyYXdHbHlmKHMuZ2x5cGhJbmRleCx0LG8pO2Zvcih2YXIgaT1zLm0saD0wO2g8by5jcmRzLmxlbmd0aDtoKz0yKXt2YXIgZD1vLmNyZHNbaF0sZj1vLmNyZHNbaCsxXTthLmNyZHMucHVzaChkKmkuYStmKmkuYitpLnR4KSxhLmNyZHMucHVzaChkKmkuYytmKmkuZCtpLnR5KTt9Zm9yKGg9MDtoPG8uY21kcy5sZW5ndGg7aCsrKWEuY21kcy5wdXNoKG8uY21kc1toXSk7fX0sZS5VLl9nZXRHbHlwaENsYXNzPWZ1bmN0aW9uKHIsdCl7dmFyIGE9ZS5fbGN0Zi5nZXRJbnRlcnZhbCh0LHIpO3JldHVybiAtMT09YT8wOnRbYSsyXX0sZS5VLl9hcHBseVN1YnM9ZnVuY3Rpb24ocix0LGEsbil7Zm9yKHZhciBvPXIubGVuZ3RoLXQtMSxzPTA7czxhLnRhYnMubGVuZ3RoO3MrKylpZihudWxsIT1hLnRhYnNbc10pe3ZhciBpLGg9YS50YWJzW3NdO2lmKCFoLmNvdmVyYWdlfHwtMSE9KGk9ZS5fbGN0Zi5jb3ZlcmFnZUluZGV4KGguY292ZXJhZ2Usclt0XSkpKWlmKDE9PWEubHR5cGUpclt0XSwxPT1oLmZtdD9yW3RdPXJbdF0raC5kZWx0YTpyW3RdPWgubmV3Z1tpXTtlbHNlIGlmKDQ9PWEubHR5cGUpZm9yKHZhciBkPWgudmFsc1tpXSxmPTA7ZjxkLmxlbmd0aDtmKyspe3ZhciB1PWRbZl0sbD11LmNoYWluLmxlbmd0aDtpZighKGw+bykpe2Zvcih2YXIgdj0hMCxjPTAscD0wO3A8bDtwKyspe2Zvcig7LTE9PXJbdCtjKygxK3ApXTspYysrO3UuY2hhaW5bcF0hPXJbdCtjKygxK3ApXSYmKHY9ITEpO31pZih2KXtyW3RdPXUubmdseXBoO2ZvcihwPTA7cDxsK2M7cCsrKXJbdCtwKzFdPS0xO2JyZWFrfX19ZWxzZSBpZig1PT1hLmx0eXBlJiYyPT1oLmZtdClmb3IodmFyIFU9ZS5fbGN0Zi5nZXRJbnRlcnZhbChoLmNEZWYsclt0XSksZz1oLmNEZWZbVSsyXSxTPWguc2NzZXRbZ10sbT0wO208Uy5sZW5ndGg7bSsrKXt2YXIgYj1TW21dLHk9Yi5pbnB1dDtpZighKHkubGVuZ3RoPm8pKXtmb3Iodj0hMCxwPTA7cDx5Lmxlbmd0aDtwKyspe3ZhciBGPWUuX2xjdGYuZ2V0SW50ZXJ2YWwoaC5jRGVmLHJbdCsxK3BdKTtpZigtMT09VSYmaC5jRGVmW0YrMl0hPXlbcF0pe3Y9ITE7YnJlYWt9fWlmKHYpe3ZhciBDPWIuc3Vic3RMb29rdXBSZWNvcmRzO2ZvcihmPTA7ZjxDLmxlbmd0aDtmKz0yKUNbZl0sQ1tmKzFdO319fWVsc2UgaWYoNj09YS5sdHlwZSYmMz09aC5mbXQpe2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmJhY2tDdmcsdC1oLmJhY2tDdmcubGVuZ3RoKSljb250aW51ZTtpZighZS5VLl9nbHNDb3ZlcmVkKHIsaC5pbnB0Q3ZnLHQpKWNvbnRpbnVlO2lmKCFlLlUuX2dsc0NvdmVyZWQocixoLmFoZWRDdmcsdCtoLmlucHRDdmcubGVuZ3RoKSljb250aW51ZTt2YXIgXz1oLmxvb2t1cFJlYztmb3IobT0wO208Xy5sZW5ndGg7bSs9Mil7VT1fW21dO3ZhciBQPW5bX1ttKzFdXTtlLlUuX2FwcGx5U3VicyhyLHQrVSxQLG4pO319fX0sZS5VLl9nbHNDb3ZlcmVkPWZ1bmN0aW9uKHIsdCxhKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7aWYoLTE9PWUuX2xjdGYuY292ZXJhZ2VJbmRleCh0W25dLHJbYStuXSkpcmV0dXJuICExfXJldHVybiAhMH0sZS5VLmdseXBoc1RvUGF0aD1mdW5jdGlvbihyLHQsYSl7Zm9yKHZhciBuPXtjbWRzOltdLGNyZHM6W119LG89MCxzPTA7czx0Lmxlbmd0aDtzKyspe3ZhciBpPXRbc107aWYoLTEhPWkpe2Zvcih2YXIgaD1zPHQubGVuZ3RoLTEmJi0xIT10W3MrMV0/dFtzKzFdOjAsZD1lLlUuZ2x5cGhUb1BhdGgocixpKSxmPTA7ZjxkLmNyZHMubGVuZ3RoO2YrPTIpbi5jcmRzLnB1c2goZC5jcmRzW2ZdK28pLG4uY3Jkcy5wdXNoKGQuY3Jkc1tmKzFdKTthJiZuLmNtZHMucHVzaChhKTtmb3IoZj0wO2Y8ZC5jbWRzLmxlbmd0aDtmKyspbi5jbWRzLnB1c2goZC5jbWRzW2ZdKTthJiZuLmNtZHMucHVzaChcIlhcIiksbys9ci5obXR4LmFXaWR0aFtpXSxzPHQubGVuZ3RoLTEmJihvKz1lLlUuZ2V0UGFpckFkanVzdG1lbnQocixpLGgpKTt9fXJldHVybiBufSxlLlUuUD17fSxlLlUuUC5tb3ZlVG89ZnVuY3Rpb24ocixlLHQpe3IuY21kcy5wdXNoKFwiTVwiKSxyLmNyZHMucHVzaChlLHQpO30sZS5VLlAubGluZVRvPWZ1bmN0aW9uKHIsZSx0KXtyLmNtZHMucHVzaChcIkxcIiksci5jcmRzLnB1c2goZSx0KTt9LGUuVS5QLmN1cnZlVG89ZnVuY3Rpb24ocixlLHQsYSxuLG8scyl7ci5jbWRzLnB1c2goXCJDXCIpLHIuY3Jkcy5wdXNoKGUsdCxhLG4sbyxzKTt9LGUuVS5QLnFjdXJ2ZVRvPWZ1bmN0aW9uKHIsZSx0LGEsbil7ci5jbWRzLnB1c2goXCJRXCIpLHIuY3Jkcy5wdXNoKGUsdCxhLG4pO30sZS5VLlAuY2xvc2VQYXRoPWZ1bmN0aW9uKHIpe3IuY21kcy5wdXNoKFwiWlwiKTt9LGUuVS5fZHJhd0NGRj1mdW5jdGlvbihyLHQsYSxuLG8pe2Zvcih2YXIgcz10LnN0YWNrLGk9dC5uU3RlbXMsaD10LmhhdmVXaWR0aCxkPXQud2lkdGgsZj10Lm9wZW4sdT0wLGw9dC54LHY9dC55LGM9MCxwPTAsVT0wLGc9MCxTPTAsbT0wLGI9MCx5PTAsRj0wLEM9MCxfPXt2YWw6MCxzaXplOjB9O3U8ci5sZW5ndGg7KXtlLkNGRi5nZXRDaGFyU3RyaW5nKHIsdSxfKTt2YXIgUD1fLnZhbDtpZih1Kz1fLnNpemUsXCJvMVwiPT1QfHxcIm8xOFwiPT1QKXMubGVuZ3RoJTIhPTAmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITA7ZWxzZSBpZihcIm8zXCI9PVB8fFwibzIzXCI9PVApe3MubGVuZ3RoJTIhPTAmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYKSxpKz1zLmxlbmd0aD4+MSxzLmxlbmd0aD0wLGg9ITA7fWVsc2UgaWYoXCJvNFwiPT1QKXMubGVuZ3RoPjEmJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLGYmJmUuVS5QLmNsb3NlUGF0aChvKSx2Kz1zLnBvcCgpLGUuVS5QLm1vdmVUbyhvLGwsdiksZj0hMDtlbHNlIGlmKFwibzVcIj09UClmb3IoO3MubGVuZ3RoPjA7KWwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KTtlbHNlIGlmKFwibzZcIj09UHx8XCJvN1wiPT1QKWZvcih2YXIgeD1zLmxlbmd0aCxJPVwibzZcIj09UCx3PTA7dzx4O3crKyl7dmFyIGs9cy5zaGlmdCgpO0k/bCs9azp2Kz1rLEk9IUksZS5VLlAubGluZVRvKG8sbCx2KTt9ZWxzZSBpZihcIm84XCI9PVB8fFwibzI0XCI9PVApe3g9cy5sZW5ndGg7Zm9yKHZhciBHPTA7Rys2PD14OyljPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpLEcrPTY7XCJvMjRcIj09UCYmKGwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KSk7fWVsc2Uge2lmKFwibzExXCI9PVApYnJlYWs7aWYoXCJvMTIzNFwiPT1QfHxcIm8xMjM1XCI9PVB8fFwibzEyMzZcIj09UHx8XCJvMTIzN1wiPT1QKVwibzEyMzRcIj09UCYmKHA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksQz1nPXArcy5zaGlmdCgpLG09Zyx5PXYsbD0oYj0oUz0oRj1VK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCkpK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLEMpLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzVcIj09UCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLGc9cCtzLnNoaWZ0KCksRj1VK3Muc2hpZnQoKSxDPWcrcy5zaGlmdCgpLFM9RitzLnNoaWZ0KCksbT1DK3Muc2hpZnQoKSxiPVMrcy5zaGlmdCgpLHk9bStzLnNoaWZ0KCksbD1iK3Muc2hpZnQoKSx2PXkrcy5zaGlmdCgpLHMuc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxGLEMpLGUuVS5QLmN1cnZlVG8obyxTLG0sYix5LGwsdikpLFwibzEyMzZcIj09UCYmKGM9bCtzLnNoaWZ0KCkscD12K3Muc2hpZnQoKSxVPWMrcy5zaGlmdCgpLEM9Zz1wK3Muc2hpZnQoKSxtPWcsYj0oUz0oRj1VK3Muc2hpZnQoKSkrcy5zaGlmdCgpKStzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxsPWIrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSksXCJvMTIzN1wiPT1QJiYoYz1sK3Muc2hpZnQoKSxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxGPVUrcy5zaGlmdCgpLEM9ZytzLnNoaWZ0KCksUz1GK3Muc2hpZnQoKSxtPUMrcy5zaGlmdCgpLGI9UytzLnNoaWZ0KCkseT1tK3Muc2hpZnQoKSxNYXRoLmFicyhiLWwpPk1hdGguYWJzKHktdik/bD1iK3Muc2hpZnQoKTp2PXkrcy5zaGlmdCgpLGUuVS5QLmN1cnZlVG8obyxjLHAsVSxnLEYsQyksZS5VLlAuY3VydmVUbyhvLFMsbSxiLHksbCx2KSk7ZWxzZSBpZihcIm8xNFwiPT1QKXtpZihzLmxlbmd0aD4wJiYhaCYmKGQ9cy5zaGlmdCgpK2Eubm9taW5hbFdpZHRoWCxoPSEwKSw0PT1zLmxlbmd0aCl7dmFyIE89cy5zaGlmdCgpLFQ9cy5zaGlmdCgpLEQ9cy5zaGlmdCgpLEI9cy5zaGlmdCgpLEE9ZS5DRkYuZ2x5cGhCeVNFKGEsRCksUj1lLkNGRi5nbHlwaEJ5U0UoYSxCKTtlLlUuX2RyYXdDRkYoYS5DaGFyU3RyaW5nc1tBXSx0LGEsbixvKSx0Lng9Tyx0Lnk9VCxlLlUuX2RyYXdDRkYoYS5DaGFyU3RyaW5nc1tSXSx0LGEsbixvKTt9ZiYmKGUuVS5QLmNsb3NlUGF0aChvKSxmPSExKTt9ZWxzZSBpZihcIm8xOVwiPT1QfHxcIm8yMFwiPT1QKXtzLmxlbmd0aCUyIT0wJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCksaSs9cy5sZW5ndGg+PjEscy5sZW5ndGg9MCxoPSEwLHUrPWkrNz4+Mzt9ZWxzZSBpZihcIm8yMVwiPT1QKXMubGVuZ3RoPjImJiFoJiYoZD1zLnNoaWZ0KCkrbi5ub21pbmFsV2lkdGhYLGg9ITApLHYrPXMucG9wKCksbCs9cy5wb3AoKSxmJiZlLlUuUC5jbG9zZVBhdGgobyksZS5VLlAubW92ZVRvKG8sbCx2KSxmPSEwO2Vsc2UgaWYoXCJvMjJcIj09UClzLmxlbmd0aD4xJiYhaCYmKGQ9cy5zaGlmdCgpK24ubm9taW5hbFdpZHRoWCxoPSEwKSxsKz1zLnBvcCgpLGYmJmUuVS5QLmNsb3NlUGF0aChvKSxlLlUuUC5tb3ZlVG8obyxsLHYpLGY9ITA7ZWxzZSBpZihcIm8yNVwiPT1QKXtmb3IoO3MubGVuZ3RoPjY7KWwrPXMuc2hpZnQoKSx2Kz1zLnNoaWZ0KCksZS5VLlAubGluZVRvKG8sbCx2KTtjPWwrcy5zaGlmdCgpLHA9ditzLnNoaWZ0KCksVT1jK3Muc2hpZnQoKSxnPXArcy5zaGlmdCgpLGw9VStzLnNoaWZ0KCksdj1nK3Muc2hpZnQoKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO31lbHNlIGlmKFwibzI2XCI9PVApZm9yKHMubGVuZ3RoJTImJihsKz1zLnNoaWZ0KCkpO3MubGVuZ3RoPjA7KWM9bCxwPXYrcy5zaGlmdCgpLGw9VT1jK3Muc2hpZnQoKSx2PShnPXArcy5zaGlmdCgpKStzLnNoaWZ0KCksZS5VLlAuY3VydmVUbyhvLGMscCxVLGcsbCx2KTtlbHNlIGlmKFwibzI3XCI9PVApZm9yKHMubGVuZ3RoJTImJih2Kz1zLnNoaWZ0KCkpO3MubGVuZ3RoPjA7KXA9dixVPShjPWwrcy5zaGlmdCgpKStzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHY9ZyxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpO2Vsc2UgaWYoXCJvMTBcIj09UHx8XCJvMjlcIj09UCl7dmFyIEw9XCJvMTBcIj09UD9uOmE7aWYoMD09cy5sZW5ndGgpY29uc29sZS5kZWJ1ZyhcImVycm9yOiBlbXB0eSBzdGFja1wiKTtlbHNlIHt2YXIgVz1zLnBvcCgpLE09TC5TdWJyc1tXK0wuQmlhc107dC54PWwsdC55PXYsdC5uU3RlbXM9aSx0LmhhdmVXaWR0aD1oLHQud2lkdGg9ZCx0Lm9wZW49ZixlLlUuX2RyYXdDRkYoTSx0LGEsbixvKSxsPXQueCx2PXQueSxpPXQublN0ZW1zLGg9dC5oYXZlV2lkdGgsZD10LndpZHRoLGY9dC5vcGVuO319ZWxzZSBpZihcIm8zMFwiPT1QfHxcIm8zMVwiPT1QKXt2YXIgVj1zLmxlbmd0aCxFPShHPTAsXCJvMzFcIj09UCk7Zm9yKEcrPVYtKHg9LTMmVik7Rzx4OylFPyhwPXYsVT0oYz1sK3Muc2hpZnQoKSkrcy5zaGlmdCgpLHY9KGc9cCtzLnNoaWZ0KCkpK3Muc2hpZnQoKSx4LUc9PTU/KGw9VStzLnNoaWZ0KCksRysrKTpsPVUsRT0hMSk6KGM9bCxwPXYrcy5zaGlmdCgpLFU9YytzLnNoaWZ0KCksZz1wK3Muc2hpZnQoKSxsPVUrcy5zaGlmdCgpLHgtRz09NT8odj1nK3Muc2hpZnQoKSxHKyspOnY9ZyxFPSEwKSxlLlUuUC5jdXJ2ZVRvKG8sYyxwLFUsZyxsLHYpLEcrPTQ7fWVsc2Uge2lmKFwib1wiPT0oUCtcIlwiKS5jaGFyQXQoMCkpdGhyb3cgY29uc29sZS5kZWJ1ZyhcIlVua25vd24gb3BlcmF0aW9uOiBcIitQLHIpLFA7cy5wdXNoKFApO319fXQueD1sLHQueT12LHQublN0ZW1zPWksdC5oYXZlV2lkdGg9aCx0LndpZHRoPWQsdC5vcGVuPWY7fTt2YXIgdD1lLGE9e1R5cHI6dH07cmV0dXJuIHIuVHlwcj10LHIuZGVmYXVsdD1hLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHJ9KHt9KS5UeXByfVxuXG4vKiFcbkN1c3RvbSBidW5kbGUgb2Ygd29mZjJvdGYgKGh0dHBzOi8vZ2l0aHViLmNvbS9hcnR5LW5hbWUvd29mZjJvdGYpIHdpdGggZmZsYXRlXG4oaHR0cHM6Ly9naXRodWIuY29tLzEwMWFycm93ei9mZmxhdGUpIGZvciB1c2UgaW4gVHJvaWthIHRleHQgcmVuZGVyaW5nLiBcbk9yaWdpbmFsIGxpY2Vuc2VzIGFwcGx5OiBcbi0gZmZsYXRlOiBodHRwczovL2dpdGh1Yi5jb20vMTAxYXJyb3d6L2ZmbGF0ZS9ibG9iL21hc3Rlci9MSUNFTlNFIChNSVQpXG4tIHdvZmYyb3RmLmpzOiBodHRwczovL2dpdGh1Yi5jb20vYXJ0eS1uYW1lL3dvZmYyb3RmL2Jsb2IvbWFzdGVyL3dvZmYyb3RmLmpzIChBcGFjaGUyKVxuKi9cbmZ1bmN0aW9uIHdvZmYyb3RmRmFjdG9yeSgpe3JldHVybiBmdW5jdGlvbihyKXt2YXIgZT1VaW50OEFycmF5LG49VWludDE2QXJyYXksdD1VaW50MzJBcnJheSxhPW5ldyBlKFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdKSxpPW5ldyBlKFswLDAsMCwwLDEsMSwyLDIsMywzLDQsNCw1LDUsNiw2LDcsNyw4LDgsOSw5LDEwLDEwLDExLDExLDEyLDEyLDEzLDEzLDAsMF0pLG89bmV3IGUoWzE2LDE3LDE4LDAsOCw3LDksNiwxMCw1LDExLDQsMTIsMywxMywyLDE0LDEsMTVdKSxmPWZ1bmN0aW9uKHIsZSl7Zm9yKHZhciBhPW5ldyBuKDMxKSxpPTA7aTwzMTsrK2kpYVtpXT1lKz0xPDxyW2ktMV07dmFyIG89bmV3IHQoYVszMF0pO2ZvcihpPTE7aTwzMDsrK2kpZm9yKHZhciBmPWFbaV07ZjxhW2krMV07KytmKW9bZl09Zi1hW2ldPDw1fGk7cmV0dXJuIFthLG9dfSx1PWYoYSwyKSx2PXVbMF0scz11WzFdO3ZbMjhdPTI1OCxzWzI1OF09Mjg7Zm9yKHZhciBsPWYoaSwwKVswXSxjPW5ldyBuKDMyNzY4KSxnPTA7ZzwzMjc2ODsrK2cpe3ZhciBoPSg0MzY5MCZnKT4+PjF8KDIxODQ1JmcpPDwxO2g9KDYxNjgwJihoPSg1MjQyOCZoKT4+PjJ8KDEzMTA3JmgpPDwyKSk+Pj40fCgzODU1JmgpPDw0LGNbZ109KCg2NTI4MCZoKT4+Pjh8KDI1NSZoKTw8OCk+Pj4xO312YXIgdz1mdW5jdGlvbihyLGUsdCl7Zm9yKHZhciBhPXIubGVuZ3RoLGk9MCxvPW5ldyBuKGUpO2k8YTsrK2kpKytvW3JbaV0tMV07dmFyIGYsdT1uZXcgbihlKTtmb3IoaT0wO2k8ZTsrK2kpdVtpXT11W2ktMV0rb1tpLTFdPDwxO2lmKHQpe2Y9bmV3IG4oMTw8ZSk7dmFyIHY9MTUtZTtmb3IoaT0wO2k8YTsrK2kpaWYocltpXSlmb3IodmFyIHM9aTw8NHxyW2ldLGw9ZS1yW2ldLGc9dVtyW2ldLTFdKys8PGwsaD1nfCgxPDxsKS0xO2c8PWg7KytnKWZbY1tnXT4+PnZdPXM7fWVsc2UgZm9yKGY9bmV3IG4oYSksaT0wO2k8YTsrK2kpcltpXSYmKGZbaV09Y1t1W3JbaV0tMV0rK10+Pj4xNS1yW2ldKTtyZXR1cm4gZn0sZD1uZXcgZSgyODgpO2ZvcihnPTA7ZzwxNDQ7KytnKWRbZ109ODtmb3IoZz0xNDQ7ZzwyNTY7KytnKWRbZ109OTtmb3IoZz0yNTY7ZzwyODA7KytnKWRbZ109Nztmb3IoZz0yODA7ZzwyODg7KytnKWRbZ109ODt2YXIgbT1uZXcgZSgzMik7Zm9yKGc9MDtnPDMyOysrZyltW2ddPTU7dmFyIGI9dyhkLDksMSkscD13KG0sNSwxKSx5PWZ1bmN0aW9uKHIpe2Zvcih2YXIgZT1yWzBdLG49MTtuPHIubGVuZ3RoOysrbilyW25dPmUmJihlPXJbbl0pO3JldHVybiBlfSxMPWZ1bmN0aW9uKHIsZSxuKXt2YXIgdD1lLzh8MDtyZXR1cm4gKHJbdF18clt0KzFdPDw4KT4+KDcmZSkmbn0sVT1mdW5jdGlvbihyLGUpe3ZhciBuPWUvOHwwO3JldHVybiAocltuXXxyW24rMV08PDh8cltuKzJdPDwxNik+Pig3JmUpfSxrPVtcInVuZXhwZWN0ZWQgRU9GXCIsXCJpbnZhbGlkIGJsb2NrIHR5cGVcIixcImludmFsaWQgbGVuZ3RoL2xpdGVyYWxcIixcImludmFsaWQgZGlzdGFuY2VcIixcInN0cmVhbSBmaW5pc2hlZFwiLFwibm8gc3RyZWFtIGhhbmRsZXJcIiwsXCJubyBjYWxsYmFja1wiLFwiaW52YWxpZCBVVEYtOCBkYXRhXCIsXCJleHRyYSBmaWVsZCB0b28gbG9uZ1wiLFwiZGF0ZSBub3QgaW4gcmFuZ2UgMTk4MC0yMDk5XCIsXCJmaWxlbmFtZSB0b28gbG9uZ1wiLFwic3RyZWFtIGZpbmlzaGluZ1wiLFwiaW52YWxpZCB6aXAgZGF0YVwiXSxUPWZ1bmN0aW9uKHIsZSxuKXt2YXIgdD1uZXcgRXJyb3IoZXx8a1tyXSk7aWYodC5jb2RlPXIsRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UmJkVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHQsVCksIW4pdGhyb3cgdDtyZXR1cm4gdH0sTz1mdW5jdGlvbihyLGYsdSl7dmFyIHM9ci5sZW5ndGg7aWYoIXN8fHUmJiF1LmwmJnM8NSlyZXR1cm4gZnx8bmV3IGUoMCk7dmFyIGM9IWZ8fHUsZz0hdXx8dS5pO3V8fCh1PXt9KSxmfHwoZj1uZXcgZSgzKnMpKTt2YXIgaCxkPWZ1bmN0aW9uKHIpe3ZhciBuPWYubGVuZ3RoO2lmKHI+bil7dmFyIHQ9bmV3IGUoTWF0aC5tYXgoMipuLHIpKTt0LnNldChmKSxmPXQ7fX0sbT11LmZ8fDAsaz11LnB8fDAsTz11LmJ8fDAsQT11LmwseD11LmQsRT11Lm0sRD11Lm4sTT04KnM7ZG97aWYoIUEpe3UuZj1tPUwocixrLDEpO3ZhciBTPUwocixrKzEsMyk7aWYoays9MywhUyl7dmFyIFY9clsoST0oKGg9aykvOHwwKSsoNyZoJiYxKSs0KS00XXxyW0ktM108PDgsXz1JK1Y7aWYoXz5zKXtnJiZUKDApO2JyZWFrfWMmJmQoTytWKSxmLnNldChyLnN1YmFycmF5KEksXyksTyksdS5iPU8rPVYsdS5wPWs9OCpfO2NvbnRpbnVlfWlmKDE9PVMpQT1iLHg9cCxFPTksRD01O2Vsc2UgaWYoMj09Uyl7dmFyIGo9TChyLGssMzEpKzI1Nyx6PUwocixrKzEwLDE1KSs0LEM9aitMKHIsays1LDMxKSsxO2srPTE0O2Zvcih2YXIgRj1uZXcgZShDKSxQPW5ldyBlKDE5KSxxPTA7cTx6OysrcSlQW29bcV1dPUwocixrKzMqcSw3KTtrKz0zKno7dmFyIEI9eShQKSxHPSgxPDxCKS0xLEg9dyhQLEIsMSk7Zm9yKHE9MDtxPEM7KXt2YXIgSSxKPUhbTChyLGssRyldO2lmKGsrPTE1JkosKEk9Sj4+PjQpPDE2KUZbcSsrXT1JO2Vsc2Uge3ZhciBLPTAsTj0wO2ZvcigxNj09ST8oTj0zK0wocixrLDMpLGsrPTIsSz1GW3EtMV0pOjE3PT1JPyhOPTMrTChyLGssNyksays9Myk6MTg9PUkmJihOPTExK0wocixrLDEyNyksays9Nyk7Ti0tOylGW3ErK109Szt9fXZhciBRPUYuc3ViYXJyYXkoMCxqKSxSPUYuc3ViYXJyYXkoaik7RT15KFEpLEQ9eShSKSxBPXcoUSxFLDEpLHg9dyhSLEQsMSk7fWVsc2UgVCgxKTtpZihrPk0pe2cmJlQoMCk7YnJlYWt9fWMmJmQoTysxMzEwNzIpO2Zvcih2YXIgVz0oMTw8RSktMSxYPSgxPDxEKS0xLFk9azs7WT1rKXt2YXIgWj0oSz1BW1UocixrKSZXXSk+Pj40O2lmKChrKz0xNSZLKT5NKXtnJiZUKDApO2JyZWFrfWlmKEt8fFQoMiksWjwyNTYpZltPKytdPVo7ZWxzZSB7aWYoMjU2PT1aKXtZPWssQT1udWxsO2JyZWFrfXZhciAkPVotMjU0O2lmKFo+MjY0KXt2YXIgcnI9YVtxPVotMjU3XTskPUwocixrLCgxPDxyciktMSkrdltxXSxrKz1ycjt9dmFyIGVyPXhbVShyLGspJlhdLG5yPWVyPj4+NDtlcnx8VCgzKSxrKz0xNSZlcjtSPWxbbnJdO2lmKG5yPjMpe3JyPWlbbnJdO1IrPVUocixrKSYoMTw8cnIpLTEsays9cnI7fWlmKGs+TSl7ZyYmVCgwKTticmVha31jJiZkKE8rMTMxMDcyKTtmb3IodmFyIHRyPU8rJDtPPHRyO08rPTQpZltPXT1mW08tUl0sZltPKzFdPWZbTysxLVJdLGZbTysyXT1mW08rMi1SXSxmW08rM109ZltPKzMtUl07Tz10cjt9fXUubD1BLHUucD1ZLHUuYj1PLEEmJihtPTEsdS5tPUUsdS5kPXgsdS5uPUQpO313aGlsZSghbSk7cmV0dXJuIE89PWYubGVuZ3RoP2Y6ZnVuY3Rpb24ocixhLGkpeyhudWxsPT1hfHxhPDApJiYoYT0wKSwobnVsbD09aXx8aT5yLmxlbmd0aCkmJihpPXIubGVuZ3RoKTt2YXIgbz1uZXcociBpbnN0YW5jZW9mIG4/bjpyIGluc3RhbmNlb2YgdD90OmUpKGktYSk7cmV0dXJuIG8uc2V0KHIuc3ViYXJyYXkoYSxpKSksb30oZiwwLE8pfSxBPW5ldyBlKDApO3ZhciB4PVwidW5kZWZpbmVkXCIhPXR5cGVvZiBUZXh0RGVjb2RlciYmbmV3IFRleHREZWNvZGVyO3RyeXt4LmRlY29kZShBLHtzdHJlYW06ITB9KSwxO31jYXRjaChyKXt9cmV0dXJuIHIuY29udmVydF9zdHJlYW1zPWZ1bmN0aW9uKHIpe3ZhciBlPW5ldyBEYXRhVmlldyhyKSxuPTA7ZnVuY3Rpb24gdCgpe3ZhciByPWUuZ2V0VWludDE2KG4pO3JldHVybiBuKz0yLHJ9ZnVuY3Rpb24gYSgpe3ZhciByPWUuZ2V0VWludDMyKG4pO3JldHVybiBuKz00LHJ9ZnVuY3Rpb24gaShyKXttLnNldFVpbnQxNihiLHIpLGIrPTI7fWZ1bmN0aW9uIG8ocil7bS5zZXRVaW50MzIoYixyKSxiKz00O31mb3IodmFyIGY9e3NpZ25hdHVyZTphKCksZmxhdm9yOmEoKSxsZW5ndGg6YSgpLG51bVRhYmxlczp0KCkscmVzZXJ2ZWQ6dCgpLHRvdGFsU2ZudFNpemU6YSgpLG1ham9yVmVyc2lvbjp0KCksbWlub3JWZXJzaW9uOnQoKSxtZXRhT2Zmc2V0OmEoKSxtZXRhTGVuZ3RoOmEoKSxtZXRhT3JpZ0xlbmd0aDphKCkscHJpdk9mZnNldDphKCkscHJpdkxlbmd0aDphKCl9LHU9MDtNYXRoLnBvdygyLHUpPD1mLm51bVRhYmxlczspdSsrO3UtLTtmb3IodmFyIHY9MTYqTWF0aC5wb3coMix1KSxzPTE2KmYubnVtVGFibGVzLXYsbD0xMixjPVtdLGc9MDtnPGYubnVtVGFibGVzO2crKyljLnB1c2goe3RhZzphKCksb2Zmc2V0OmEoKSxjb21wTGVuZ3RoOmEoKSxvcmlnTGVuZ3RoOmEoKSxvcmlnQ2hlY2tzdW06YSgpfSksbCs9MTY7dmFyIGgsdz1uZXcgVWludDhBcnJheSgxMisxNipjLmxlbmd0aCtjLnJlZHVjZSgoZnVuY3Rpb24ocixlKXtyZXR1cm4gcitlLm9yaWdMZW5ndGgrNH0pLDApKSxkPXcuYnVmZmVyLG09bmV3IERhdGFWaWV3KGQpLGI9MDtyZXR1cm4gbyhmLmZsYXZvciksaShmLm51bVRhYmxlcyksaSh2KSxpKHUpLGkocyksYy5mb3JFYWNoKChmdW5jdGlvbihyKXtvKHIudGFnKSxvKHIub3JpZ0NoZWNrc3VtKSxvKGwpLG8oci5vcmlnTGVuZ3RoKSxyLm91dE9mZnNldD1sLChsKz1yLm9yaWdMZW5ndGgpJTQhPTAmJihsKz00LWwlNCk7fSkpLGMuZm9yRWFjaCgoZnVuY3Rpb24oZSl7dmFyIG4sdD1yLnNsaWNlKGUub2Zmc2V0LGUub2Zmc2V0K2UuY29tcExlbmd0aCk7aWYoZS5jb21wTGVuZ3RoIT1lLm9yaWdMZW5ndGgpe3ZhciBhPW5ldyBVaW50OEFycmF5KGUub3JpZ0xlbmd0aCk7bj1uZXcgVWludDhBcnJheSh0LDIpLE8obixhKTt9ZWxzZSBhPW5ldyBVaW50OEFycmF5KHQpO3cuc2V0KGEsZS5vdXRPZmZzZXQpO3ZhciBpPTA7KGw9ZS5vdXRPZmZzZXQrZS5vcmlnTGVuZ3RoKSU0IT0wJiYoaT00LWwlNCksdy5zZXQobmV3IFVpbnQ4QXJyYXkoaSkuYnVmZmVyLGUub3V0T2Zmc2V0K2Uub3JpZ0xlbmd0aCksaD1sK2k7fSkpLGQuc2xpY2UoMCxoKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscn0oe30pLmNvbnZlcnRfc3RyZWFtc31cblxuLyoqXG4gKiBBIGZhY3Rvcnkgd3JhcHBlciBwYXJzaW5nIGEgZm9udCBmaWxlIHVzaW5nIFR5cHIuXG4gKiBBbHNvIGFkZHMgc3VwcG9ydCBmb3IgV09GRiBmaWxlcyAobm90IFdPRkYyKS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIFBhcnNlZEZvbnRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBhc2NlbmRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRlc2NlbmRlclxuICogQHByb3BlcnR5IHtudW1iZXJ9IHhIZWlnaHRcbiAqIEBwcm9wZXJ0eSB7KG51bWJlcikgPT4gYm9vbGVhbn0gc3VwcG9ydHNDb2RlUG9pbnRcbiAqIEBwcm9wZXJ0eSB7KHRleHQ6c3RyaW5nLCBmb250U2l6ZTpudW1iZXIsIGxldHRlclNwYWNpbmc6bnVtYmVyLCBjYWxsYmFjaykgPT4gbnVtYmVyfSBmb3JFYWNoR2x5cGhcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lR2FwXG4gKiBAcHJvcGVydHkge251bWJlcn0gY2FwSGVpZ2h0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5pdHNQZXJFbVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgeyhidWZmZXI6IEFycmF5QnVmZmVyKSA9PiBQYXJzZWRGb250fSBGb250UGFyc2VyXG4gKi9cblxuLyoqXG4gKiBAcmV0dXJucyB7Rm9udFBhcnNlcn1cbiAqL1xuZnVuY3Rpb24gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90Zikge1xuICBjb25zdCBjbWRBcmdMZW5ndGhzID0ge1xuICAgIE06IDIsXG4gICAgTDogMixcbiAgICBROiA0LFxuICAgIEM6IDYsXG4gICAgWjogMFxuICB9O1xuXG4gIC8vIHtqb2luVHlwZTogXCJza2lwK3N0ZXAsLi4uXCJ9XG4gIGNvbnN0IGpvaW5pbmdUeXBlUmF3RGF0YSA9IHtcIkNcIjpcIjE4ZyxjYSwzNjgsMWt6XCIsXCJEXCI6XCIxN2ssNiwyLDIrNCw1K2MsMis2LDIrMSwxMCsxLDkrZixqKzExLDIrMSxhLDIsMisxLDE1KzIsMyxqKzIsNiszLDIrOCwyLDIsMisxLHcrYSw0K2UsMyszLDIsMysyLDMrNSwyMyt3LDJmKzQsMywyKzksMixiLDIrMywzLDFrKzksNisxLDMrMSwyKzIsMitkLDMwZyxwK3ksMSwxKzFnLGYreCwyLHNkMisxZCxqZjMrNCxmKzMsMis0LDIrMixiKzMsNDIsMiw0KzIsMisxLDIsMyx0KzEsOWYrdywyLGVsKzIsMitnLGQrMiwybCwyKzEsNSwzKzEsMisxLDIsMyw2LDE2d20rMXZcIixcIlJcIjpcIjE3bSszLDIsMiw2KzMsbSwxNSsyLDIrMixoK2gsMTMsMys4LDIsMiwzKzEsMixwKzEseCw1KzQsNSxhLDIsMiwzLHUsYysyLGcrMSw1LDIrMSw0KzEsNWosNisxLDIsYiwyKzIsZiwyKzEsMXMrMiwyLDMrMSw3LDFlejAsMiwyKzEsNCs0LGIsNCwzLGIsNDIsMisyLDQsMywyKzEsMixvKzMsYWUsZXAseCwybysyLDMrMSwzLDUrMSw2XCIsXCJMXCI6XCJ4OXUsamZmLGEsZmQsanZcIixcIlRcIjpcIjR0LGdqKzMzLDdvKzQsMSsxLDdjKzE4LDIsMisxLDIrMSwyLDIxK2EsMiwxYitrLGgsMnUrNiwzKzUsMysxLDIrMyx5LDIsditxLDJrK2EsMW4rOCxhLHArMywyKzgsMisyLDIrNCwxOCsyLDNjK2UsMit2LDFrLDIsNSs3LDUsNCs2LGIrMSx1LDFuLDUrMyw5LGwrMSxyLDMrMSwxbSw1KzEsNSsxLDMrMiw0LHYrMSw0LGMrMSwxbSw1KzQsMisxLDUsbCsxLG4rNSwyLDFuLDMsMiszLDksOCsxLGMrMSx2LDFxLGQsMWYsNCwxbSsyLDYrMiwyKzMsOCsxLGMrMSx1LDFuLDMsNyw2KzEsbCsxLHQrMSwxbSsxLDUrMyw5LGwrMSx1LDIxLDgrMiwyLDJqLDMrNixkKzcsMnIsMys4LGMrNSwyMysxLHMsMiwyLDFrK2QsMis0LDIrMSw2K2EsMit6LGEsMnYrMywyKzUsMisxLDMrMSxxKzEsNSsyLGgrMyxlLDMrMSw3LGcsamsrMixxYisyLHUrMix1KzEsdisxLDF0KzEsMis2LDksMythLGEsMWErMiwzYysxLHosM2IrMiw1KzEsYSw3KzIsNjQrMSwzLDFuLDIrNiwyLDIsMys3LDcrOSwzLDFkK2QsMSwxKzEsMXMrMywxZCwyKzQsMiw2LDE1KzgsZCsxLHgrMywzKzEsMisyLDFsLDIrMSw0LDIrMiwxbis3LDMrMSw0OSsyLDIrYywyKzYsNSw3LDQrMSw1aisxbCwyKzQsZWssMysxLHIrNCwxZSs0LDYrNSwycCtjLDErMywxLDErMiwxK2IsMmRiKzIsM3ksMnArdixmZiszLDMwKzEsbjl4LDErMiwyKzkseCsxLDI5KzEsN2wsNCw1LHErMSw2LDQ4KzEscitoLGUsMTMrNyxxK2EsMWIrMiwxZCwzKzMsMysxLDE0LDF3KzUsMysxLDMrMSxkLDksMWMsMWcsMisyLDMrMSw2KzEsMiwxNysxLDksNm4sMyw1LGZuNSxraStmLGgrZiw1cyw2eSsyLGVhLDZiLDQ2KzQsMWFmKzIsMisxLDYrMywxNSsyLDUsNG0rMSxmeSszLGFzKzEsNGErYSw0eCwxaitlLDFsKzIsMWUrMywzKzEsMXkrMiwxMSs0LDIrNywxcixkKzEsMWgrOCxiKzMsMywybysyLDMsMisxLDcsNGgsNCs3LG0rMSwxbSsxLDQsMTIrNiw0KzQsNWcrNywzKzIsMixvLDJkKzUsMiw1KzEsMisxLDZuKzMsNysxLDIrMSxzKzEsMmUrNywzLDIrMSwyeiwyLDMrNSwyLDJ1KzIsMyszLDIrNCw3OCs4LDIrMSw3NSsxLDIsNSw0MSszLDMrMSw1LHgrOSwxNSs1LDMrMyw5LGErNSwzKzIsMWIrYywyKzEsYmIrNiwyKzUsMiwyYitsLDMrNiwyKzEsMisxLDNmKzUsNCwyKzEsMis2LDIsMjErMSw0LDIsOW8rMSw0NzArOCxhdDQrNCwxbys2LHQ1LDFzKzMsMmEsZjVsKzEsMiszLDQzbysyLGErNywxKzcsMys2LHYrMyw0NSsyLDFqMCsxaSw1KzFkLDksZixuKzQsMitlLDExdCs2LDIrZywzKzYsMisxLDIrNCw3YSs2LGM2KzMsMTV0KzYsMzIrNiwxLGd6YXUsdisybiwzbCs2blwifTtcblxuICBjb25zdCBKVF9MRUZUID0gMSwgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBqb2lucyB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3Rlci5cbiAgICBKVF9SSUdIVCA9IDIsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciwgYnV0IGRvZXMgbm90IGpvaW4gd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgSlRfRFVBTCA9IDQsIC8vaW5kaWNhdGVzIHRoYXQgYSBjaGFyYWN0ZXIgam9pbnMgd2l0aCB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBhbmQgam9pbnMgd2l0aCB0aGUgc3Vic2VxdWVudCBjaGFyYWN0ZXIuXG4gICAgSlRfVFJBTlNQQVJFTlQgPSA4LCAvL2luZGljYXRlcyB0aGF0IHRoZSBjaGFyYWN0ZXIgZG9lcyBub3Qgam9pbiB3aXRoIGFkamFjZW50IGNoYXJhY3RlcnMgYW5kIHRoYXQgdGhlIGNoYXJhY3RlciBtdXN0IGJlIHNraXBwZWQgb3ZlciB3aGVuIHRoZSBzaGFwaW5nIGVuZ2luZSBpcyBldmFsdWF0aW5nIHRoZSBqb2luaW5nIHBvc2l0aW9ucyBpbiBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuIFdoZW4gYSBKVF9UUkFOU1BBUkVOVCBjaGFyYWN0ZXIgaXMgZW5jb3VudGVyZWQgaW4gYSBzZXF1ZW5jZSwgdGhlIEpPSU5JTkdfVFlQRSBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBwYXNzZXMgdGhyb3VnaC4gRGlhY3JpdGljYWwgbWFya3MgYXJlIGZyZXF1ZW50bHkgYXNzaWduZWQgdGhpcyB2YWx1ZS5cbiAgICBKVF9KT0lOX0NBVVNJTkcgPSAxNiwgLy9pbmRpY2F0ZXMgdGhhdCB0aGUgY2hhcmFjdGVyIGZvcmNlcyB0aGUgdXNlIG9mIGpvaW5pbmcgZm9ybXMgd2l0aCB0aGUgcHJlY2VkaW5nIGFuZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMuIEthc2hpZGFzIGFuZCB0aGUgWmVybyBXaWR0aCBKb2luZXIgKFUrMjAwRCkgYXJlIGJvdGggSk9JTl9DQVVTSU5HIGNoYXJhY3RlcnMuXG4gICAgSlRfTk9OX0pPSU5JTkcgPSAzMjsgLy9pbmRpY2F0ZXMgdGhhdCBhIGNoYXJhY3RlciBkb2VzIG5vdCBqb2luIHdpdGggdGhlIHByZWNlZGluZyBvciB3aXRoIHRoZSBzdWJzZXF1ZW50IGNoYXJhY3Rlci4sXG5cbiAgbGV0IGpvaW5pbmdUeXBlTWFwO1xuICBmdW5jdGlvbiBnZXRDaGFySm9pbmluZ1R5cGUoY2gpIHtcbiAgICBpZiAoIWpvaW5pbmdUeXBlTWFwKSB7XG4gICAgICBjb25zdCBtID0ge1xuICAgICAgICBSOiBKVF9SSUdIVCxcbiAgICAgICAgTDogSlRfTEVGVCxcbiAgICAgICAgRDogSlRfRFVBTCxcbiAgICAgICAgQzogSlRfSk9JTl9DQVVTSU5HLFxuICAgICAgICBVOiBKVF9OT05fSk9JTklORyxcbiAgICAgICAgVDogSlRfVFJBTlNQQVJFTlRcbiAgICAgIH07XG4gICAgICBqb2luaW5nVHlwZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgIGZvciAobGV0IHR5cGUgaW4gam9pbmluZ1R5cGVSYXdEYXRhKSB7XG4gICAgICAgIGxldCBsYXN0Q29kZSA9IDA7XG4gICAgICAgIGpvaW5pbmdUeXBlUmF3RGF0YVt0eXBlXS5zcGxpdCgnLCcpLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgIGxldCBbc2tpcCwgc3RlcF0gPSByYW5nZS5zcGxpdCgnKycpO1xuICAgICAgICAgIHNraXAgPSBwYXJzZUludChza2lwLDM2KTtcbiAgICAgICAgICBzdGVwID0gc3RlcCA/IHBhcnNlSW50KHN0ZXAsIDM2KSA6IDA7XG4gICAgICAgICAgam9pbmluZ1R5cGVNYXAuc2V0KGxhc3RDb2RlICs9IHNraXAsIG1bdHlwZV0pO1xuICAgICAgICAgIGZvciAobGV0IGkgPSBzdGVwOyBpLS07KSB7XG4gICAgICAgICAgICBqb2luaW5nVHlwZU1hcC5zZXQoKytsYXN0Q29kZSwgbVt0eXBlXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGpvaW5pbmdUeXBlTWFwLmdldChjaCkgfHwgSlRfTk9OX0pPSU5JTkdcbiAgfVxuXG4gIGNvbnN0IElTT0wgPSAxLCBJTklUID0gMiwgRklOQSA9IDMsIE1FREkgPSA0O1xuICBjb25zdCBmb3Jtc1RvRmVhdHVyZXMgPSBbbnVsbCwgJ2lzb2wnLCAnaW5pdCcsICdmaW5hJywgJ21lZGknXTtcblxuICBmdW5jdGlvbiBkZXRlY3RKb2luaW5nRm9ybXMoc3RyKSB7XG4gICAgLy8gVGhpcyBpbXBsZW1lbnRzIHRoZSBhbGdvcml0aG0gZGVzY3JpYmVkIGhlcmU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL244d2lsbGlzL29wZW50eXBlLXNoYXBpbmctZG9jdW1lbnRzL2Jsb2IvbWFzdGVyL29wZW50eXBlLXNoYXBpbmctYXJhYmljLWdlbmVyYWwubWRcbiAgICBjb25zdCBqb2luaW5nRm9ybXMgPSBuZXcgVWludDhBcnJheShzdHIubGVuZ3RoKTtcbiAgICBsZXQgcHJldkpvaW5pbmdUeXBlID0gSlRfTk9OX0pPSU5JTkc7XG4gICAgbGV0IHByZXZGb3JtID0gSVNPTDtcbiAgICBsZXQgcHJldkluZGV4ID0gLTE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBsZXQgam9pbmluZ1R5cGUgPSBnZXRDaGFySm9pbmluZ1R5cGUoY29kZSkgfCAwO1xuICAgICAgbGV0IGZvcm0gPSBJU09MO1xuICAgICAgaWYgKGpvaW5pbmdUeXBlICYgSlRfVFJBTlNQQVJFTlQpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgIGlmIChqb2luaW5nVHlwZSAmIChKVF9SSUdIVCB8IEpUX0RVQUwgfCBKVF9KT0lOX0NBVVNJTkcpKSB7XG4gICAgICAgICAgZm9ybSA9IEZJTkE7XG4gICAgICAgICAgLy8gaXNvbC0+aW5pdCwgZmluYS0+bWVkaVxuICAgICAgICAgIGlmIChwcmV2Rm9ybSA9PT0gSVNPTCB8fCBwcmV2Rm9ybSA9PT0gRklOQSkge1xuICAgICAgICAgICAgam9pbmluZ0Zvcm1zW3ByZXZJbmRleF0rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoam9pbmluZ1R5cGUgJiAoSlRfTEVGVCB8IEpUX05PTl9KT0lOSU5HKSkge1xuICAgICAgICAgIC8vIG1lZGktPmZpbmEsIGluaXQtPmlzb2xcbiAgICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICAgIGpvaW5pbmdGb3Jtc1twcmV2SW5kZXhdLS07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChwcmV2Sm9pbmluZ1R5cGUgJiAoSlRfUklHSFQgfCBKVF9OT05fSk9JTklORykpIHtcbiAgICAgICAgLy8gbWVkaS0+ZmluYSwgaW5pdC0+aXNvbFxuICAgICAgICBpZiAocHJldkZvcm0gPT09IElOSVQgfHwgcHJldkZvcm0gPT09IE1FREkpIHtcbiAgICAgICAgICBqb2luaW5nRm9ybXNbcHJldkluZGV4XS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwcmV2Rm9ybSA9IGpvaW5pbmdGb3Jtc1tpXSA9IGZvcm07XG4gICAgICBwcmV2Sm9pbmluZ1R5cGUgPSBqb2luaW5nVHlwZTtcbiAgICAgIHByZXZJbmRleCA9IGk7XG4gICAgICBpZiAoY29kZSA+IDB4ZmZmZikgaSsrO1xuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZyhzdHIuc3BsaXQoJycpLm1hcChjaCA9PiBjaC5jb2RlUG9pbnRBdCgwKS50b1N0cmluZygxNikpKVxuICAgIC8vIGNvbnNvbGUubG9nKHN0ci5zcGxpdCgnJykubWFwKGNoID0+IGdldENoYXJKb2luaW5nVHlwZShjaC5jb2RlUG9pbnRBdCgwKSkpKVxuICAgIC8vIGNvbnNvbGUubG9nKEFycmF5LmZyb20oam9pbmluZ0Zvcm1zKS5tYXAoZiA9PiBmb3Jtc1RvRmVhdHVyZXNbZl0gfHwgJ25vbmUnKSlcbiAgICByZXR1cm4gam9pbmluZ0Zvcm1zXG4gIH1cblxuICBmdW5jdGlvbiBzdHJpbmdUb0dseXBocyAoZm9udCwgc3RyKSB7XG4gICAgY29uc3QgZ2x5cGhJZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2MgPSBzdHIuY29kZVBvaW50QXQoaSk7XG4gICAgICBpZiAoY2MgPiAweGZmZmYpIGkrKztcbiAgICAgIGdseXBoSWRzLnB1c2goVHlwci5VLmNvZGVUb0dseXBoKGZvbnQsIGNjKSk7XG4gICAgfVxuXG4gICAgY29uc3QgZ3N1YiA9IGZvbnRbJ0dTVUInXTtcbiAgICBpZiAoZ3N1Yikge1xuICAgICAgY29uc3Qge2xvb2t1cExpc3QsIGZlYXR1cmVMaXN0fSA9IGdzdWI7XG4gICAgICBsZXQgam9pbmluZ0Zvcm1zO1xuICAgICAgY29uc3Qgc3VwcG9ydGVkRmVhdHVyZXMgPSAvXihybGlnfGxpZ2F8bXNldHxpc29sfGluaXR8ZmluYXxtZWRpfGhhbGZ8cHJlc3xibHdzfGNjbXApJC87XG4gICAgICBjb25zdCB1c2VkTG9va3VwcyA9IFtdO1xuICAgICAgZmVhdHVyZUxpc3QuZm9yRWFjaChmZWF0dXJlID0+IHtcbiAgICAgICAgaWYgKHN1cHBvcnRlZEZlYXR1cmVzLnRlc3QoZmVhdHVyZS50YWcpKSB7XG4gICAgICAgICAgZm9yIChsZXQgdGkgPSAwOyB0aSA8IGZlYXR1cmUudGFiLmxlbmd0aDsgdGkrKykge1xuICAgICAgICAgICAgaWYgKHVzZWRMb29rdXBzW2ZlYXR1cmUudGFiW3RpXV0pIGNvbnRpbnVlXG4gICAgICAgICAgICB1c2VkTG9va3Vwc1tmZWF0dXJlLnRhYlt0aV1dID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRhYiA9IGxvb2t1cExpc3RbZmVhdHVyZS50YWJbdGldXTtcbiAgICAgICAgICAgIGNvbnN0IGlzSm9pbmluZ0ZlYXR1cmUgPSAvXihpc29sfGluaXR8ZmluYXxtZWRpKSQvLnRlc3QoZmVhdHVyZS50YWcpO1xuICAgICAgICAgICAgaWYgKGlzSm9pbmluZ0ZlYXR1cmUgJiYgIWpvaW5pbmdGb3JtcykgeyAvL2xhenlcbiAgICAgICAgICAgICAgam9pbmluZ0Zvcm1zID0gZGV0ZWN0Sm9pbmluZ0Zvcm1zKHN0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBjaSA9IDA7IGNpIDwgZ2x5cGhJZHMubGVuZ3RoOyBjaSsrKSB7XG4gICAgICAgICAgICAgIGlmICgham9pbmluZ0Zvcm1zIHx8ICFpc0pvaW5pbmdGZWF0dXJlIHx8IGZvcm1zVG9GZWF0dXJlc1tqb2luaW5nRm9ybXNbY2ldXSA9PT0gZmVhdHVyZS50YWcpIHtcbiAgICAgICAgICAgICAgICBUeXByLlUuX2FwcGx5U3VicyhnbHlwaElkcywgY2ksIHRhYiwgbG9va3VwTGlzdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBnbHlwaElkc1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGFkdmFuY2VzIGFuZCB4L3kgb2Zmc2V0cyBmb3IgZWFjaCBnbHlwaCwgZS5nLiBrZXJuaW5nIGFuZCBtYXJrXG4gIC8vIGF0dGFjaG1lbnRzLiBUaGlzIGlzIGEgbW9yZSBjb21wbGV0ZSB2ZXJzaW9uIG9mIFR5cHIuVS5nZXRQYWlyQWRqdXN0bWVudFxuICAvLyBhbmQgc2hvdWxkIGJlY29tZSBhbiB1cHN0cmVhbSByZXBsYWNlbWVudCBldmVudHVhbGx5LlxuICBmdW5jdGlvbiBjYWxjR2x5cGhQb3NpdGlvbnMoZm9udCwgZ2x5cGhJZHMpIHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBuZXcgSW50MTZBcnJheShnbHlwaElkcy5sZW5ndGggKiAzKTsgLy8gW29mZnNldFgsIG9mZnNldFksIGFkdmFuY2VYLCAuLi5dXG4gICAgbGV0IGdseXBoSW5kZXggPSAwO1xuICAgIGZvciAoOyBnbHlwaEluZGV4IDwgZ2x5cGhJZHMubGVuZ3RoOyBnbHlwaEluZGV4KyspIHtcbiAgICAgIGNvbnN0IGdseXBoSWQgPSBnbHlwaElkc1tnbHlwaEluZGV4XTtcbiAgICAgIGlmIChnbHlwaElkID09PSAtMSkgY29udGludWU7XG5cbiAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogMyArIDJdID0gZm9udC5obXR4LmFXaWR0aFtnbHlwaElkXTsgLy8gcG9wdWxhdGUgYWR2YW5jZVggaW4uLi5hZHZhbmNlLlxuXG4gICAgICBjb25zdCBncG9zID0gZm9udC5HUE9TO1xuICAgICAgaWYgKGdwb3MpIHtcbiAgICAgICAgY29uc3QgbGxpc3QgPSBncG9zLmxvb2t1cExpc3Q7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsb29rdXAgPSBsbGlzdFtpXTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvb2t1cC50YWJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCB0YWIgPSBsb29rdXAudGFic1tqXTtcbiAgICAgICAgICAgIC8vIFNpbmdsZSBjaGFyIHBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKGxvb2t1cC5sdHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBpbmQgPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLmNvdmVyYWdlLCBnbHlwaElkKTtcbiAgICAgICAgICAgICAgaWYgKGluZCAhPT0gLTEgJiYgdGFiLnBvcykge1xuICAgICAgICAgICAgICAgIGFwcGx5VmFsdWVSZWNvcmQodGFiLnBvcywgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFpcnMgKGtlcm5pbmcpXG4gICAgICAgICAgICBlbHNlIGlmIChsb29rdXAubHR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgbGV0IGFkaiA9IG51bGw7XG4gICAgICAgICAgICAgIGxldCBwcmV2R2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KCk7XG4gICAgICAgICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb3ZlcmFnZUluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5jb3ZlcmFnZSwgZ2x5cGhJZHNbcHJldkdseXBoSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoY292ZXJhZ2VJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YWIuZm10ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gdGFiLnBhaXJzZXRzW2NvdmVyYWdlSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJpZ2h0Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0W2tdLmdpZDIgPT09IGdseXBoSWQpIGFkaiA9IHJpZ2h0W2tdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhYi5mbXQgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYzEgPSBUeXByLlUuX2dldEdseXBoQ2xhc3MoZ2x5cGhJZHNbcHJldkdseXBoSW5kZXhdLCB0YWIuY2xhc3NEZWYxKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYzIgPSBUeXByLlUuX2dldEdseXBoQ2xhc3MoZ2x5cGhJZCwgdGFiLmNsYXNzRGVmMik7XG4gICAgICAgICAgICAgICAgICAgIGFkaiA9IHRhYi5tYXRyaXhbYzFdW2MyXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChhZGopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkai52YWwxKSBhcHBseVZhbHVlUmVjb3JkKGFkai52YWwxLCBwcmV2R2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhZGoudmFsMikgYXBwbHlWYWx1ZVJlY29yZChhZGoudmFsMiwgZ2x5cGhJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYXJrIHRvIGJhc2VcbiAgICAgICAgICAgIGVsc2UgaWYgKGxvb2t1cC5sdHlwZSA9PT0gNCkge1xuICAgICAgICAgICAgICBjb25zdCBtYXJrQXJySW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLm1hcmtDb3ZlcmFnZSwgZ2x5cGhJZCk7XG4gICAgICAgICAgICAgIGlmIChtYXJrQXJySW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUdseXBoSW5kZXggPSBnZXRQcmV2R2x5cGhJbmRleChpc0Jhc2VHbHlwaCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZUFyckluZGV4ID0gYmFzZUdseXBoSW5kZXggPT09IC0xID8gLTEgOiBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLmJhc2VDb3ZlcmFnZSwgZ2x5cGhJZHNbYmFzZUdseXBoSW5kZXhdKTtcbiAgICAgICAgICAgICAgICBpZiAoYmFzZUFyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgbWFya1JlY29yZCA9IHRhYi5tYXJrQXJyYXlbbWFya0FyckluZGV4XTtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VBbmNob3IgPSB0YWIuYmFzZUFycmF5W2Jhc2VBcnJJbmRleF1bbWFya1JlY29yZC5tYXJrQ2xhc3NdO1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzXSA9IGJhc2VBbmNob3IueCAtIG1hcmtSZWNvcmQueCArIHBvc2l0aW9uc1tiYXNlR2x5cGhJbmRleCAqIDNdIC0gcG9zaXRpb25zW2Jhc2VHbHlwaEluZGV4ICogMyArIDJdO1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb25zW2dseXBoSW5kZXggKiAzICsgMV0gPSBiYXNlQW5jaG9yLnkgLSBtYXJrUmVjb3JkLnkgKyBwb3NpdGlvbnNbYmFzZUdseXBoSW5kZXggKiAzICsgMV07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hcmsgdG8gbWFya1xuICAgICAgICAgICAgZWxzZSBpZiAobG9va3VwLmx0eXBlID09PSA2KSB7XG4gICAgICAgICAgICAgIGNvbnN0IG1hcmsxQXJySW5kZXggPSBUeXByLl9sY3RmLmNvdmVyYWdlSW5kZXgodGFiLm1hcmsxQ292ZXJhZ2UsIGdseXBoSWQpO1xuICAgICAgICAgICAgICBpZiAobWFyazFBcnJJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2R2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZHbHlwaEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHJldkdseXBoSWQgPSBnbHlwaElkc1twcmV2R2x5cGhJbmRleF07XG4gICAgICAgICAgICAgICAgICBpZiAoZ2V0R2x5cGhDbGFzcyhmb250LCBwcmV2R2x5cGhJZCkgPT09IDMpIHsgLy8gb25seSBjaGVjayBtYXJrIGdseXBoc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrMkFyckluZGV4ID0gVHlwci5fbGN0Zi5jb3ZlcmFnZUluZGV4KHRhYi5tYXJrMkNvdmVyYWdlLCBwcmV2R2x5cGhJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXJrMkFyckluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hcmsxUmVjb3JkID0gdGFiLm1hcmsxQXJyYXlbbWFyazFBcnJJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWFyazJBbmNob3IgPSB0YWIubWFyazJBcnJheVttYXJrMkFyckluZGV4XVttYXJrMVJlY29yZC5tYXJrQ2xhc3NdO1xuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogM10gPSBtYXJrMkFuY2hvci54IC0gbWFyazFSZWNvcmQueCArIHBvc2l0aW9uc1twcmV2R2x5cGhJbmRleCAqIDNdIC0gcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogMyArIDJdO1xuICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uc1tnbHlwaEluZGV4ICogMyArIDFdID0gbWFyazJBbmNob3IueSAtIG1hcmsxUmVjb3JkLnkgKyBwb3NpdGlvbnNbcHJldkdseXBoSW5kZXggKiAzICsgMV07XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGtlcm4gdGFibGUgaWYgbm8gR1BPU1xuICAgICAgZWxzZSBpZiAoZm9udC5rZXJuICYmICFmb250LmNmZikge1xuICAgICAgICBjb25zdCBwcmV2R2x5cGhJbmRleCA9IGdldFByZXZHbHlwaEluZGV4KCk7XG4gICAgICAgIGlmIChwcmV2R2x5cGhJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCBpbmQxID0gZm9udC5rZXJuLmdseXBoMS5pbmRleE9mKGdseXBoSWRzW3ByZXZHbHlwaEluZGV4XSk7XG4gICAgICAgICAgaWYgKGluZDEgIT09IC0xKSB7XG4gICAgICAgICAgICBjb25zdCBpbmQyID0gZm9udC5rZXJuLnJ2YWxbaW5kMV0uZ2x5cGgyLmluZGV4T2YoZ2x5cGhJZCk7XG4gICAgICAgICAgICBpZiAoaW5kMiAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgcG9zaXRpb25zW3ByZXZHbHlwaEluZGV4ICogMyArIDJdICs9IGZvbnQua2Vybi5ydmFsW2luZDFdLnZhbHNbaW5kMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcblxuICAgIGZ1bmN0aW9uIGdldFByZXZHbHlwaEluZGV4KGZpbHRlcikge1xuICAgICAgZm9yIChsZXQgaSA9IGdseXBoSW5kZXggLSAxOyBpID49MDsgaS0tKSB7XG4gICAgICAgIGlmIChnbHlwaElkc1tpXSAhPT0gLTEgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKGdseXBoSWRzW2ldKSkpIHtcbiAgICAgICAgICByZXR1cm4gaVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNCYXNlR2x5cGgoZ2x5cGhJZCkge1xuICAgICAgcmV0dXJuIGdldEdseXBoQ2xhc3MoZm9udCwgZ2x5cGhJZCkgPT09IDE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlWYWx1ZVJlY29yZChzb3VyY2UsIGdpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBwb3NpdGlvbnNbZ2kgKiAzICsgaV0gKz0gc291cmNlW2ldIHx8IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0R2x5cGhDbGFzcyhmb250LCBnbHlwaElkKSB7XG4gICAgY29uc3QgY2xhc3NEZWYgPSBmb250LkdERUYgJiYgZm9udC5HREVGLmdseXBoQ2xhc3NEZWY7XG4gICAgcmV0dXJuIGNsYXNzRGVmID8gVHlwci5VLl9nZXRHbHlwaENsYXNzKGdseXBoSWQsIGNsYXNzRGVmKSA6IDA7XG4gIH1cblxuICBmdW5jdGlvbiBmaXJzdE51bSguLi5hcmdzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIFBhcnNlZEZvbnRcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXBGb250T2JqKHR5cHJGb250KSB7XG4gICAgY29uc3QgZ2x5cGhNYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgY29uc3Qgb3MyID0gdHlwckZvbnRbJ09TLzInXTtcbiAgICBjb25zdCBoaGVhID0gdHlwckZvbnQuaGhlYTtcbiAgICBjb25zdCB1bml0c1BlckVtID0gdHlwckZvbnQuaGVhZC51bml0c1BlckVtO1xuICAgIGNvbnN0IGFzY2VuZGVyID0gZmlyc3ROdW0ob3MyICYmIG9zMi5zVHlwb0FzY2VuZGVyLCBoaGVhICYmIGhoZWEuYXNjZW5kZXIsIHVuaXRzUGVyRW0pO1xuXG4gICAgLyoqIEB0eXBlIFBhcnNlZEZvbnQgKi9cbiAgICBjb25zdCBmb250T2JqID0ge1xuICAgICAgdW5pdHNQZXJFbSxcbiAgICAgIGFzY2VuZGVyLFxuICAgICAgZGVzY2VuZGVyOiBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvRGVzY2VuZGVyLCBoaGVhICYmIGhoZWEuZGVzY2VuZGVyLCAwKSxcbiAgICAgIGNhcEhlaWdodDogZmlyc3ROdW0ob3MyICYmIG9zMi5zQ2FwSGVpZ2h0LCBhc2NlbmRlciksXG4gICAgICB4SGVpZ2h0OiBmaXJzdE51bShvczIgJiYgb3MyLnN4SGVpZ2h0LCBhc2NlbmRlciksXG4gICAgICBsaW5lR2FwOiBmaXJzdE51bShvczIgJiYgb3MyLnNUeXBvTGluZUdhcCwgaGhlYSAmJiBoaGVhLmxpbmVHYXApLFxuICAgICAgc3VwcG9ydHNDb2RlUG9pbnQoY29kZSkge1xuICAgICAgICByZXR1cm4gVHlwci5VLmNvZGVUb0dseXBoKHR5cHJGb250LCBjb2RlKSA+IDBcbiAgICAgIH0sXG4gICAgICBmb3JFYWNoR2x5cGgodGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBwZW5YID0gMDtcbiAgICAgICAgY29uc3QgZm9udFNjYWxlID0gMSAvIGZvbnRPYmoudW5pdHNQZXJFbSAqIGZvbnRTaXplO1xuXG4gICAgICAgIGNvbnN0IGdseXBoSWRzID0gc3RyaW5nVG9HbHlwaHModHlwckZvbnQsIHRleHQpO1xuICAgICAgICBsZXQgY2hhckluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgcG9zaXRpb25zID0gY2FsY0dseXBoUG9zaXRpb25zKHR5cHJGb250LCBnbHlwaElkcyk7XG5cbiAgICAgICAgZ2x5cGhJZHMuZm9yRWFjaCgoZ2x5cGhJZCwgaSkgPT4ge1xuICAgICAgICAgIC8vIFR5cHIgcmV0dXJucyBhIGdseXBoIGluZGV4IHBlciBzdHJpbmcgY29kZXBvaW50LCB3aXRoIC0xcyBpbiBwbGFjZSBvZiB0aG9zZSB0aGF0XG4gICAgICAgICAgLy8gd2VyZSBvbWl0dGVkIGR1ZSB0byBsaWdhdHVyZSBzdWJzdGl0dXRpb24uIFNvIHdlIGNhbiB0cmFjayBvcmlnaW5hbCBpbmRleCBpbiB0aGVcbiAgICAgICAgICAvLyBzdHJpbmcgdmlhIHNpbXBsZSBpbmNyZW1lbnQsIGFuZCBza2lwIGV2ZXJ5dGhpbmcgZWxzZSB3aGVuIHNlZWluZyBhIC0xLlxuICAgICAgICAgIGlmIChnbHlwaElkICE9PSAtMSkge1xuICAgICAgICAgICAgbGV0IGdseXBoT2JqID0gZ2x5cGhNYXBbZ2x5cGhJZF07XG4gICAgICAgICAgICBpZiAoIWdseXBoT2JqKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtjbWRzLCBjcmRzfSA9IFR5cHIuVS5nbHlwaFRvUGF0aCh0eXByRm9udCwgZ2x5cGhJZCk7XG5cbiAgICAgICAgICAgICAgLy8gQnVpbGQgcGF0aCBzdHJpbmdcbiAgICAgICAgICAgICAgbGV0IHBhdGggPSAnJztcbiAgICAgICAgICAgICAgbGV0IGNyZHNJZHggPSAwO1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY21kcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG51bUFyZ3MgPSBjbWRBcmdMZW5ndGhzW2NtZHNbaV1dO1xuICAgICAgICAgICAgICAgIHBhdGggKz0gY21kc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8PSBudW1BcmdzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgIHBhdGggKz0gKGogPiAxID8gJywnIDogJycpICsgY3Jkc1tjcmRzSWR4KytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEZpbmQgZXh0ZW50cyAtIEdseWYgZ2l2ZXMgdGhpcyBpbiBtZXRhZGF0YSBidXQgbm90IENGRiwgYW5kIFR5cHIgZG9lc24ndFxuICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdGhlIHR3bywgc28gaXQncyBzaW1wbGVzdCBqdXN0IHRvIGl0ZXJhdGUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICBsZXQgeE1pbiwgeU1pbiwgeE1heCwgeU1heDtcbiAgICAgICAgICAgICAgaWYgKGNyZHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgeE1pbiA9IHlNaW4gPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB4TWF4ID0geU1heCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgICAgICAgICAgICAgbGV0IHggPSBjcmRzW2ldO1xuICAgICAgICAgICAgICAgICAgbGV0IHkgPSBjcmRzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgIGlmICh4IDwgeE1pbikgeE1pbiA9IHg7XG4gICAgICAgICAgICAgICAgICBpZiAoeSA8IHlNaW4pIHlNaW4gPSB5O1xuICAgICAgICAgICAgICAgICAgaWYgKHggPiB4TWF4KSB4TWF4ID0geDtcbiAgICAgICAgICAgICAgICAgIGlmICh5ID4geU1heCkgeU1heCA9IHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhNaW4gPSB4TWF4ID0geU1pbiA9IHlNYXggPSAwO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZ2x5cGhPYmogPSBnbHlwaE1hcFtnbHlwaElkXSA9IHtcbiAgICAgICAgICAgICAgICBpbmRleDogZ2x5cGhJZCxcbiAgICAgICAgICAgICAgICBhZHZhbmNlV2lkdGg6IHR5cHJGb250LmhtdHguYVdpZHRoW2dseXBoSWRdLFxuICAgICAgICAgICAgICAgIHhNaW4sXG4gICAgICAgICAgICAgICAgeU1pbixcbiAgICAgICAgICAgICAgICB4TWF4LFxuICAgICAgICAgICAgICAgIHlNYXgsXG4gICAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChcbiAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgZ2x5cGhPYmosXG4gICAgICAgICAgICAgIHBlblggKyBwb3NpdGlvbnNbaSAqIDNdICogZm9udFNjYWxlLFxuICAgICAgICAgICAgICBwb3NpdGlvbnNbaSAqIDMgKyAxXSAqIGZvbnRTY2FsZSxcbiAgICAgICAgICAgICAgY2hhckluZGV4XG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBwZW5YICs9IHBvc2l0aW9uc1tpICogMyArIDJdICogZm9udFNjYWxlO1xuICAgICAgICAgICAgaWYgKGxldHRlclNwYWNpbmcpIHtcbiAgICAgICAgICAgICAgcGVuWCArPSBsZXR0ZXJTcGFjaW5nICogZm9udFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNoYXJJbmRleCArPSAodGV4dC5jb2RlUG9pbnRBdChjaGFySW5kZXgpID4gMHhmZmZmID8gMiA6IDEpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcGVuWFxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gZm9udE9ialxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIEZvbnRQYXJzZXJcbiAgICovXG4gIHJldHVybiBmdW5jdGlvbiBwYXJzZShidWZmZXIpIHtcbiAgICAvLyBMb29rIHRvIHNlZSBpZiB3ZSBoYXZlIGEgV09GRiBmaWxlIGFuZCBjb252ZXJ0IGl0IGlmIHNvOlxuICAgIGNvbnN0IHBlZWsgPSBuZXcgVWludDhBcnJheShidWZmZXIsIDAsIDQpO1xuICAgIGNvbnN0IHRhZyA9IFR5cHIuX2Jpbi5yZWFkQVNDSUkocGVlaywgMCwgNCk7XG4gICAgaWYgKHRhZyA9PT0gJ3dPRkYnKSB7XG4gICAgICBidWZmZXIgPSB3b2ZmMm90ZihidWZmZXIpO1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnd09GMicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd29mZjIgZm9udHMgbm90IHN1cHBvcnRlZCcpXG4gICAgfVxuICAgIHJldHVybiB3cmFwRm9udE9iaihUeXByLnBhcnNlKGJ1ZmZlcilbMF0pXG4gIH1cbn1cblxuXG5jb25zdCB3b3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgbmFtZTogJ1R5cHIgRm9udCBQYXJzZXInLFxuICBkZXBlbmRlbmNpZXM6IFt0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5XSxcbiAgaW5pdCh0eXByRmFjdG9yeSwgd29mZjJvdGZGYWN0b3J5LCBwYXJzZXJGYWN0b3J5KSB7XG4gICAgY29uc3QgVHlwciA9IHR5cHJGYWN0b3J5KCk7XG4gICAgY29uc3Qgd29mZjJvdGYgPSB3b2ZmMm90ZkZhY3RvcnkoKTtcbiAgICByZXR1cm4gcGFyc2VyRmFjdG9yeShUeXByLCB3b2ZmMm90ZilcbiAgfVxufSk7XG5cbi8qIVxuQ3VzdG9tIGJ1bmRsZSBvZiBAdW5pY29kZS1mb250LXJlc29sdmVyL2NsaWVudCB2MS4wLjIgKGh0dHBzOi8vZ2l0aHViLmNvbS9sb2pqaWMvdW5pY29kZS1mb250LXJlc29sdmVyKVxuZm9yIHVzZSBpbiBUcm9pa2EgdGV4dCByZW5kZXJpbmcuIFxuT3JpZ2luYWwgTUlUIGxpY2Vuc2UgYXBwbGllc1xuKi9cbmZ1bmN0aW9uIHVuaWNvZGVGb250UmVzb2x2ZXJDbGllbnRGYWN0b3J5KCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBuPWZ1bmN0aW9uKCl7dGhpcy5idWNrZXRzPW5ldyBNYXA7fTtuLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7dmFyIG49dD4+NTt0aGlzLmJ1Y2tldHMuc2V0KG4sKHRoaXMuYnVja2V0cy5nZXQobil8fDApfDE8PCgzMSZ0KSk7fSxuLnByb3RvdHlwZS5oYXM9ZnVuY3Rpb24odCl7dmFyIG49dGhpcy5idWNrZXRzLmdldCh0Pj41KTtyZXR1cm4gdm9pZCAwIT09biYmMCE9KG4mMTw8KDMxJnQpKX0sbi5wcm90b3R5cGUuc2VyaWFsaXplPWZ1bmN0aW9uKCl7dmFyIHQ9W107cmV0dXJuIHRoaXMuYnVja2V0cy5mb3JFYWNoKChmdW5jdGlvbihuLHIpe3QucHVzaCgoK3IpLnRvU3RyaW5nKDM2KStcIjpcIituLnRvU3RyaW5nKDM2KSk7fSkpLHQuam9pbihcIixcIil9LG4ucHJvdG90eXBlLmRlc2VyaWFsaXplPWZ1bmN0aW9uKHQpe3ZhciBuPXRoaXM7dGhpcy5idWNrZXRzLmNsZWFyKCksdC5zcGxpdChcIixcIikuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIHI9dC5zcGxpdChcIjpcIik7bi5idWNrZXRzLnNldChwYXJzZUludChyWzBdLDM2KSxwYXJzZUludChyWzFdLDM2KSk7fSkpO307dmFyIHI9TWF0aC5wb3coMiw4KSxlPXItMSxvPX5lO2Z1bmN0aW9uIGEodCl7dmFyIG49ZnVuY3Rpb24odCl7cmV0dXJuIHQmb30odCkudG9TdHJpbmcoMTYpLGU9ZnVuY3Rpb24odCl7cmV0dXJuICh0Jm8pK3ItMX0odCkudG9TdHJpbmcoMTYpO3JldHVybiBcImNvZGVwb2ludC1pbmRleC9wbGFuZVwiKyh0Pj4xNikrXCIvXCIrbitcIi1cIitlK1wiLmpzb25cIn1mdW5jdGlvbiBpKHQsbil7dmFyIHI9dCZlLG89bi5jb2RlUG9pbnRBdChyLzZ8MCk7cmV0dXJuIDAhPSgobz0ob3x8NDgpLTQ4KSYxPDxyJTYpfWZ1bmN0aW9uIHUodCxuKXt2YXIgcjsocj10LHIucmVwbGFjZSgvVVxcKy9naSxcIlwiKS5yZXBsYWNlKC9eLCt8LCskL2csXCJcIikuc3BsaXQoLywrLykubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5zcGxpdChcIi1cIikubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gcGFyc2VJbnQodC50cmltKCksMTYpfSkpfSkpKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgcj10WzBdLGU9dFsxXTt2b2lkIDA9PT1lJiYoZT1yKSxuKHIsZSk7fSkpO31mdW5jdGlvbiBjKHQsbil7dSh0LChmdW5jdGlvbih0LHIpe2Zvcih2YXIgZT10O2U8PXI7ZSsrKW4oZSk7fSkpO312YXIgcz17fSxmPXt9LGw9bmV3IFdlYWtNYXAsdj1cImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9naC9sb2pqaWMvdW5pY29kZS1mb250LXJlc29sdmVyQHYxLjAuMS9wYWNrYWdlcy9kYXRhXCI7ZnVuY3Rpb24gZCh0KXt2YXIgcj1sLmdldCh0KTtyZXR1cm4gcnx8KHI9bmV3IG4sYyh0LnJhbmdlcywoZnVuY3Rpb24odCl7cmV0dXJuIHIuYWRkKHQpfSkpLGwuc2V0KHQscikpLHJ9dmFyIGgscD1uZXcgTWFwO2Z1bmN0aW9uIGcodCxuLHIpe3JldHVybiB0W25dP246dFtyXT9yOmZ1bmN0aW9uKHQpe2Zvcih2YXIgbiBpbiB0KXJldHVybiBufSh0KX1mdW5jdGlvbiB3KHQsbil7dmFyIHI9bjtpZighdC5pbmNsdWRlcyhyKSl7cj0xLzA7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspTWF0aC5hYnModFtlXS1uKTxNYXRoLmFicyhyLW4pJiYocj10W2VdKTt9cmV0dXJuIHJ9ZnVuY3Rpb24gayh0KXtyZXR1cm4gaHx8KGg9bmV3IFNldCxjKFwiOS1ELDIwLDg1LEEwLDE2ODAsMjAwMC0yMDBBLDIwMjgtMjAyRiwyMDVGLDMwMDBcIiwoZnVuY3Rpb24odCl7aC5hZGQodCk7fSkpKSxoLmhhcyh0KX1yZXR1cm4gdC5Db2RlUG9pbnRTZXQ9bix0LmNsZWFyQ2FjaGU9ZnVuY3Rpb24oKXtzPXt9LGY9e307fSx0LmdldEZvbnRzRm9yU3RyaW5nPWZ1bmN0aW9uKHQsbil7dm9pZCAwPT09biYmKG49e30pO3ZhciByLGU9bi5sYW5nO3ZvaWQgMD09PWUmJihlPS9cXHB7U2NyaXB0PUhhbmd1bH0vdS50ZXN0KHI9dCk/XCJrb1wiOi9cXHB7U2NyaXB0PUhpcmFnYW5hfXxcXHB7U2NyaXB0PUthdGFrYW5hfS91LnRlc3Qocik/XCJqYVwiOlwiZW5cIik7dmFyIG89bi5jYXRlZ29yeTt2b2lkIDA9PT1vJiYobz1cInNhbnMtc2VyaWZcIik7dmFyIHU9bi5zdHlsZTt2b2lkIDA9PT11JiYodT1cIm5vcm1hbFwiKTt2YXIgYz1uLndlaWdodDt2b2lkIDA9PT1jJiYoYz00MDApO3ZhciBsPShuLmRhdGFVcmx8fHYpLnJlcGxhY2UoL1xcLyQvZyxcIlwiKSxoPW5ldyBNYXAseT1uZXcgVWludDhBcnJheSh0Lmxlbmd0aCksYj17fSxtPXt9LEE9bmV3IEFycmF5KHQubGVuZ3RoKSxTPW5ldyBNYXAsaj0hMTtmdW5jdGlvbiBNKHQpe3ZhciBuPXAuZ2V0KHQpO3JldHVybiBufHwobj1mZXRjaChsK1wiL1wiK3QpLnRoZW4oKGZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXRocm93IG5ldyBFcnJvcih0LnN0YXR1c1RleHQpO3JldHVybiB0Lmpzb24oKS50aGVuKChmdW5jdGlvbih0KXtpZighQXJyYXkuaXNBcnJheSh0KXx8MSE9PXRbMF0pdGhyb3cgbmV3IEVycm9yKFwiSW5jb3JyZWN0IHNjaGVtYSB2ZXJzaW9uOyBuZWVkIDEsIGdvdCBcIit0WzBdKTtyZXR1cm4gdFsxXX0pKX0pKS5jYXRjaCgoZnVuY3Rpb24obil7aWYobCE9PXYpcmV0dXJuIGp8fChjb25zb2xlLmVycm9yKCd1bmljb2RlLWZvbnQtcmVzb2x2ZXI6IEZhaWxlZCBsb2FkaW5nIGZyb20gZGF0YVVybCBcIicrbCsnXCIsIHRyeWluZyBkZWZhdWx0IENETi4gJytuLm1lc3NhZ2UpLGo9ITApLGw9dixwLmRlbGV0ZSh0KSxNKHQpO3Rocm93IG59KSkscC5zZXQodCxuKSksbn1mb3IodmFyIFA9ZnVuY3Rpb24obil7dmFyIHI9dC5jb2RlUG9pbnRBdChuKSxlPWEocik7QVtuXT1lLHNbZV18fFMuaGFzKGUpfHxTLnNldChlLE0oZSkudGhlbigoZnVuY3Rpb24odCl7c1tlXT10O30pKSkscj42NTUzNSYmKG4rKyxFPW4pO30sRT0wO0U8dC5sZW5ndGg7RSsrKVAoRSk7cmV0dXJuIFByb21pc2UuYWxsKFMudmFsdWVzKCkpLnRoZW4oKGZ1bmN0aW9uKCl7Uy5jbGVhcigpO2Zvcih2YXIgbj1mdW5jdGlvbihuKXt2YXIgbz10LmNvZGVQb2ludEF0KG4pLGE9bnVsbCx1PXNbQVtuXV0sYz12b2lkIDA7Zm9yKHZhciBsIGluIHUpe3ZhciB2PW1bbF07aWYodm9pZCAwPT09diYmKHY9bVtsXT1uZXcgUmVnRXhwKGwpLnRlc3QoZXx8XCJlblwiKSksdil7Zm9yKHZhciBkIGluIGM9bCx1W2xdKWlmKGkobyx1W2xdW2RdKSl7YT1kO2JyZWFrfWJyZWFrfX1pZighYSl0OmZvcih2YXIgaCBpbiB1KWlmKGghPT1jKWZvcih2YXIgcCBpbiB1W2hdKWlmKGkobyx1W2hdW3BdKSl7YT1wO2JyZWFrIHR9YXx8KGNvbnNvbGUuZGVidWcoXCJObyBmb250IGNvdmVyYWdlIGZvciBVK1wiK28udG9TdHJpbmcoMTYpKSxhPVwibGF0aW5cIiksQVtuXT1hLGZbYV18fFMuaGFzKGEpfHxTLnNldChhLE0oXCJmb250LW1ldGEvXCIrYStcIi5qc29uXCIpLnRoZW4oKGZ1bmN0aW9uKHQpe2ZbYV09dDt9KSkpLG8+NjU1MzUmJihuKysscj1uKTt9LHI9MDtyPHQubGVuZ3RoO3IrKyluKHIpO3JldHVybiBQcm9taXNlLmFsbChTLnZhbHVlcygpKX0pKS50aGVuKChmdW5jdGlvbigpe2Zvcih2YXIgbixyPW51bGwsZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgYT10LmNvZGVQb2ludEF0KGUpO2lmKHImJihrKGEpfHxkKHIpLmhhcyhhKSkpeVtlXT15W2UtMV07ZWxzZSB7cj1mW0FbZV1dO3ZhciBpPWJbci5pZF07aWYoIWkpe3ZhciBzPXIudHlwZWZvcm1zLHY9ZyhzLG8sXCJzYW5zLXNlcmlmXCIpLHA9ZyhzW3ZdLHUsXCJub3JtYWxcIiksbT13KG51bGw9PT0obj1zW3ZdKXx8dm9pZCAwPT09bj92b2lkIDA6bltwXSxjKTtpPWJbci5pZF09bCtcIi9mb250LWZpbGVzL1wiK3IuaWQrXCIvXCIrditcIi5cIitwK1wiLlwiK20rXCIud29mZlwiO312YXIgUz1oLmdldChpKTtudWxsPT1TJiYoUz1oLnNpemUsaC5zZXQoaSxTKSkseVtlXT1TO31hPjY1NTM1JiYoZSsrLHlbZV09eVtlLTFdKTt9cmV0dXJuIHtmb250VXJsczpBcnJheS5mcm9tKGgua2V5cygpKSxjaGFyczp5fX0pKX0sT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdH0oe30pfVxuXG4vKipcbiAqIEB0eXBlZGVmIHtzdHJpbmcgfCB7c3JjOnN0cmluZywgbGFiZWw/OnN0cmluZywgdW5pY29kZVJhbmdlPzpzdHJpbmcsIGxhbmc/OnN0cmluZ319IFVzZXJGb250XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7Q2xpZW50T3B0aW9uc30gRm9udFJlc29sdmVyT3B0aW9uc1xuICogQHByb3BlcnR5IHtBcnJheTxVc2VyRm9udD58VXNlckZvbnR9IFtmb250c11cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2l0YWxpYyd9IFtzdHlsZV1cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J2JvbGQnfG51bWJlcn0gW3N0eWxlXVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt1bmljb2RlRm9udHNVUkxdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBGb250UmVzb2x2ZXJSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gY2hhcnNcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8UGFyc2VkRm9udCAmIHtzcmM6c3RyaW5nfT59IGZvbnRzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7ZnVuY3Rpb259IEZvbnRSZXNvbHZlclxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7KEZvbnRSZXNvbHZlclJlc3VsdCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Rm9udFJlc29sdmVyT3B0aW9uc30gW29wdGlvbnNdXG4gKi9cblxuLyoqXG4gKiBGYWN0b3J5IGZvciB0aGUgRm9udFJlc29sdmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtGb250UGFyc2VyfSBmb250UGFyc2VyXG4gKiBAcGFyYW0ge3tnZXRGb250c0ZvclN0cmluZzogZnVuY3Rpb24sIENvZGVQb2ludFNldDogZnVuY3Rpb259fSB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50XG4gKiBAcmV0dXJuIHtGb250UmVzb2x2ZXJ9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZvbnRSZXNvbHZlcihmb250UGFyc2VyLCB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50KSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgUGFyc2VkRm9udD59XG4gICAqL1xuICBjb25zdCBwYXJzZWRGb250cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBBcnJheTwoUGFyc2VkRm9udCkgPT4gdm9pZD4+fVxuICAgKi9cbiAgY29uc3QgbG9hZGluZ0ZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvKipcbiAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsXG4gICAqL1xuICBmdW5jdGlvbiBkb0xvYWRGb250KHVybCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWx1cmUgbG9hZGluZyBmb250ICR7dXJsfWAsIGVycik7XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgcmVxdWVzdC5vcGVuKCdnZXQnLCB1cmwsIHRydWUpO1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgcmVxdWVzdC5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA+PSA0MDApIHtcbiAgICAgICAgICBvbkVycm9yKG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA+IDApIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZm9udE9iaiA9IGZvbnRQYXJzZXIocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICBmb250T2JqLnNyYyA9IHVybDtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZvbnRPYmopO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVxdWVzdC5vbmVycm9yID0gb25FcnJvcjtcbiAgICAgIHJlcXVlc3Quc2VuZCgpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBvbkVycm9yKGVycik7XG4gICAgfVxuICB9XG5cblxuICAvKipcbiAgICogTG9hZCBhIGdpdmVuIGZvbnQgdXJsIGlmIG5lZWRlZCwgaW52b2tpbmcgYSBjYWxsYmFjayB3aGVuIGl0J3MgbG9hZGVkLiBJZiBhbHJlYWR5XG4gICAqIGxvYWRlZCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb250VXJsXG4gICAqIEBwYXJhbSB7KGZvbnQ6IFBhcnNlZEZvbnQpID0+IHZvaWR9IGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkRm9udChmb250VXJsLCBjYWxsYmFjaykge1xuICAgIGxldCBmb250ID0gcGFyc2VkRm9udHNbZm9udFVybF07XG4gICAgaWYgKGZvbnQpIHtcbiAgICAgIGNhbGxiYWNrKGZvbnQpO1xuICAgIH0gZWxzZSBpZiAobG9hZGluZ0ZvbnRzW2ZvbnRVcmxdKSB7XG4gICAgICBsb2FkaW5nRm9udHNbZm9udFVybF0ucHVzaChjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvYWRpbmdGb250c1tmb250VXJsXSA9IFtjYWxsYmFja107XG4gICAgICBkb0xvYWRGb250KGZvbnRVcmwsIGZvbnRPYmogPT4ge1xuICAgICAgICBmb250T2JqLnNyYyA9IGZvbnRVcmw7XG4gICAgICAgIHBhcnNlZEZvbnRzW2ZvbnRVcmxdID0gZm9udE9iajtcbiAgICAgICAgbG9hZGluZ0ZvbnRzW2ZvbnRVcmxdLmZvckVhY2goY2IgPT4gY2IoZm9udE9iaikpO1xuICAgICAgICBkZWxldGUgbG9hZGluZ0ZvbnRzW2ZvbnRVcmxdO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIHN0cmluZyBvZiB0ZXh0LCBkZXRlcm1pbmUgd2hpY2ggZm9udHMgYXJlIHJlcXVpcmVkIHRvIGZ1bGx5IHJlbmRlciBpdCBhbmRcbiAgICogZW5zdXJlIHRob3NlIGZvbnRzIGFyZSBsb2FkZWQuXG4gICAqL1xuICByZXR1cm4gZnVuY3Rpb24gKHRleHQsIGNhbGxiYWNrLCB7XG4gICAgbGFuZyxcbiAgICBmb250czogdXNlckZvbnRzID0gW10sXG4gICAgc3R5bGUgPSAnbm9ybWFsJyxcbiAgICB3ZWlnaHQgPSAnbm9ybWFsJyxcbiAgICB1bmljb2RlRm9udHNVUkxcbiAgfSA9IHt9KSB7XG4gICAgY29uc3QgY2hhclJlc29sdXRpb25zID0gbmV3IFVpbnQ4QXJyYXkodGV4dC5sZW5ndGgpO1xuICAgIGNvbnN0IGZvbnRSZXNvbHV0aW9ucyA9IFtdO1xuICAgIGlmICghdGV4dC5sZW5ndGgpIHtcbiAgICAgIGFsbERvbmUoKTtcbiAgICB9XG5cbiAgICBjb25zdCBmb250SW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBmYWxsYmFja1JhbmdlcyA9IFtdOyAvLyBbW3N0YXJ0LCBlbmRdLCAuLi5dXG5cbiAgICBpZiAoc3R5bGUgIT09ICdpdGFsaWMnKSBzdHlsZSA9ICdub3JtYWwnO1xuICAgIGlmICh0eXBlb2Ygd2VpZ2h0ICE9PSAnbnVtYmVyJykge1xuICAgICAgd2VpZ2h0ID0gd2VpZ2h0ID09PSAnYm9sZCcgPyA3MDAgOiA0MDA7XG4gICAgfVxuXG4gICAgaWYgKHVzZXJGb250cyAmJiAhQXJyYXkuaXNBcnJheSh1c2VyRm9udHMpKSB7XG4gICAgICB1c2VyRm9udHMgPSBbdXNlckZvbnRzXTtcbiAgICB9XG4gICAgdXNlckZvbnRzID0gdXNlckZvbnRzLnNsaWNlKClcbiAgICAgIC8vIGZpbHRlciBieSBsYW5ndWFnZVxuICAgICAgLmZpbHRlcihkZWYgPT4gIWRlZi5sYW5nIHx8IGRlZi5sYW5nLnRlc3QobGFuZykpXG4gICAgICAvLyBzd2l0Y2ggb3JkZXIgZm9yIGVhc2llciBpdGVyYXRpb25cbiAgICAgIC5yZXZlcnNlKCk7XG4gICAgaWYgKHVzZXJGb250cy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFVOS05PV04gPSAwO1xuICAgICAgY29uc3QgUkVTT0xWRUQgPSAxO1xuICAgICAgY29uc3QgTkVFRFNfRkFMTEJBQ0sgPSAyO1xuICAgICAgbGV0IHByZXZDaGFyUmVzdWx0ID0gVU5LTk9XTlxuXG4gICAgICA7KGZ1bmN0aW9uIHJlc29sdmVVc2VyRm9udHMgKHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4LCBpTGVuID0gdGV4dC5sZW5ndGg7IGkgPCBpTGVuOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjb2RlUG9pbnQgPSB0ZXh0LmNvZGVQb2ludEF0KGkpO1xuICAgICAgICAgIC8vIENhcnJ5IHByZXZpb3VzIGNoYXJhY3RlcidzIHJlc3VsdCBmb3J3YXJkIGlmOlxuICAgICAgICAgIC8vIC0gaXQgcmVzb2x2ZWQgdG8gYSBmb250IHRoYXQgYWxzbyBjb3ZlcnMgdGhpcyBjaGFyYWN0ZXJcbiAgICAgICAgICAvLyAtIHRoaXMgY2hhcmFjdGVyIGlzIHdoaXRlc3BhY2VcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAocHJldkNoYXJSZXN1bHQgPT09IFJFU09MVkVEICYmIGZvbnRSZXNvbHV0aW9uc1tjaGFyUmVzb2x1dGlvbnNbaSAtIDFdXS5zdXBwb3J0c0NvZGVQb2ludChjb2RlUG9pbnQpKSB8fFxuICAgICAgICAgICAgKGkgPiAwICYmIC9cXHMvLnRlc3QodGV4dFtpXSkpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbaV0gPSBjaGFyUmVzb2x1dGlvbnNbaSAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZDaGFyUmVzdWx0ID09PSBORUVEU19GQUxMQkFDSykge1xuICAgICAgICAgICAgICBmYWxsYmFja1Jhbmdlc1tmYWxsYmFja1Jhbmdlcy5sZW5ndGggLSAxXVsxXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBjaGFyUmVzb2x1dGlvbnNbaV0sIGpMZW4gPSB1c2VyRm9udHMubGVuZ3RoOyBqIDw9IGpMZW47IGorKykge1xuICAgICAgICAgICAgICBpZiAoaiA9PT0gakxlbikge1xuICAgICAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIHVzZXIgZm9udHMgbWF0Y2hlZDsgbmVlZHMgZmFsbGJhY2tcbiAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHByZXZDaGFyUmVzdWx0ID09PSBORUVEU19GQUxMQkFDSyA/XG4gICAgICAgICAgICAgICAgICBmYWxsYmFja1Jhbmdlc1tmYWxsYmFja1Jhbmdlcy5sZW5ndGggLSAxXSA6XG4gICAgICAgICAgICAgICAgICAoZmFsbGJhY2tSYW5nZXNbZmFsbGJhY2tSYW5nZXMubGVuZ3RoXSA9IFtpLCBpXSk7XG4gICAgICAgICAgICAgICAgcmFuZ2VbMV0gPSBpO1xuICAgICAgICAgICAgICAgIHByZXZDaGFyUmVzdWx0ID0gTkVFRFNfRkFMTEJBQ0s7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhclJlc29sdXRpb25zW2ldID0gajtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNyYywgdW5pY29kZVJhbmdlIH0gPSB1c2VyRm9udHNbal07XG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGJ5IG9wdGlvbmFsIGV4cGxpY2l0IHVuaWNvZGUgcmFuZ2VzXG4gICAgICAgICAgICAgICAgaWYgKCF1bmljb2RlUmFuZ2UgfHwgaXNDb2RlSW5SYW5nZXMoY29kZVBvaW50LCB1bmljb2RlUmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBmb250T2JqID0gcGFyc2VkRm9udHNbc3JjXTtcbiAgICAgICAgICAgICAgICAgIC8vIGZvbnQgbm90IHlldCBsb2FkZWQsIGxvYWQgaXQgYW5kIHJlc3VtZVxuICAgICAgICAgICAgICAgICAgaWYgKCFmb250T2JqKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRGb250KHNyYywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVVc2VyRm9udHMoaSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZm9udCBhY3R1YWxseSBjb250YWlucyBhIGdseXBoIGZvciB0aGlzIGNoYXIsIGxvY2sgaXQgaW5cbiAgICAgICAgICAgICAgICAgIGlmIChmb250T2JqLnN1cHBvcnRzQ29kZVBvaW50KGNvZGVQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvbnRJbmRleCA9IGZvbnRJbmRpY2VzLmdldChmb250T2JqKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmb250SW5kZXggIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZm9udEluZGV4ID0gZm9udFJlc29sdXRpb25zLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICBmb250UmVzb2x1dGlvbnMucHVzaChmb250T2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICBmb250SW5kaWNlcy5zZXQoZm9udE9iaiwgZm9udEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbaV0gPSBmb250SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHByZXZDaGFyUmVzdWx0ID0gUkVTT0xWRUQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjb2RlUG9pbnQgPiAweGZmZmYgJiYgaSArIDEgPCBpTGVuKSB7XG4gICAgICAgICAgICBjaGFyUmVzb2x1dGlvbnNbaSArIDFdID0gY2hhclJlc29sdXRpb25zW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKHByZXZDaGFyUmVzdWx0ID09PSBORUVEU19GQUxMQkFDSykge1xuICAgICAgICAgICAgICBmYWxsYmFja1Jhbmdlc1tmYWxsYmFja1Jhbmdlcy5sZW5ndGggLSAxXVsxXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVGYWxsYmFja3MoKTtcbiAgICAgIH0pKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZhbGxiYWNrUmFuZ2VzLnB1c2goWzAsIHRleHQubGVuZ3RoIC0gMV0pO1xuICAgICAgcmVzb2x2ZUZhbGxiYWNrcygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVGYWxsYmFja3MoKSB7XG4gICAgICBpZiAoZmFsbGJhY2tSYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIENvbWJpbmUgYWxsIGZhbGxiYWNrIHN1YnN0cmluZ3MgaW50byBhIHNpbmdsZSBzdHJpbmcgZm9yIHF1ZXJ5aW5nXG4gICAgICAgIGNvbnN0IGZhbGxiYWNrU3RyaW5nID0gZmFsbGJhY2tSYW5nZXMubWFwKHJhbmdlID0+IHRleHQuc3Vic3RyaW5nKHJhbmdlWzBdLCByYW5nZVsxXSArIDEpKS5qb2luKCdcXG4nKTtcbiAgICAgICAgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudC5nZXRGb250c0ZvclN0cmluZyhmYWxsYmFja1N0cmluZywge1xuICAgICAgICAgIGxhbmc6IGxhbmcgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHN0eWxlLFxuICAgICAgICAgIHdlaWdodCxcbiAgICAgICAgICBkYXRhVXJsOiB1bmljb2RlRm9udHNVUkxcbiAgICAgICAgfSkudGhlbigoe2ZvbnRVcmxzLCBjaGFyc30pID0+IHtcbiAgICAgICAgICAvLyBFeHRyYWN0IHJlc3VsdHMgYW5kIHB1dCB0aGVtIGJhY2sgaW4gdGhlIG1haW4gYXJyYXlcbiAgICAgICAgICBjb25zdCBmb250SW5kZXhPZmZzZXQgPSBmb250UmVzb2x1dGlvbnMubGVuZ3RoO1xuICAgICAgICAgIGxldCBjaGFySWR4ID0gMDtcbiAgICAgICAgICBmYWxsYmFja1Jhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBlbmRJZHggPSByYW5nZVsxXSAtIHJhbmdlWzBdOyBpIDw9IGVuZElkeDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNoYXJSZXNvbHV0aW9uc1tyYW5nZVswXSArIGldID0gY2hhcnNbY2hhcklkeCsrXSArIGZvbnRJbmRleE9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYXJJZHgrKzsgLy9za2lwIHNlZ21lbnQgc2VwYXJhdG9yXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBMb2FkIGFuZCBwYXJzZSB0aGUgZmFsbGJhY2sgZm9udHMgLSBhdm9pZGluZyBQcm9taXNlIGhlcmUgdG8gcHJldmVudCBwb2x5ZmlsbHMgaW4gdGhlIHdvcmtlclxuICAgICAgICAgIGxldCBsb2FkZWRDb3VudCA9IDA7XG4gICAgICAgICAgZm9udFVybHMuZm9yRWFjaCgodXJsLCBpKSA9PiB7XG4gICAgICAgICAgICBsb2FkRm9udCh1cmwsIGZvbnRPYmogPT4ge1xuICAgICAgICAgICAgICBmb250UmVzb2x1dGlvbnNbaSArIGZvbnRJbmRleE9mZnNldF0gPSBmb250T2JqO1xuICAgICAgICAgICAgICBpZiAoKytsb2FkZWRDb3VudCA9PT0gZm9udFVybHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYWxsRG9uZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxEb25lKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsRG9uZSgpIHtcbiAgICAgIGNhbGxiYWNrKHtcbiAgICAgICAgY2hhcnM6IGNoYXJSZXNvbHV0aW9ucyxcbiAgICAgICAgZm9udHM6IGZvbnRSZXNvbHV0aW9uc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNDb2RlSW5SYW5nZXMoY29kZSwgcmFuZ2VzKSB7XG4gICAgICAvLyB0b2RvIG9wdGltaXplIHNlYXJjaCAtIENvZGVQb2ludFNldCBmcm9tIHVuaWNvZGUtZm9udC1yZXNvbHZlcj9cbiAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgcmFuZ2VzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIGNvbnN0IFtzdGFydCwgZW5kID0gc3RhcnRdID0gcmFuZ2VzW2tdO1xuICAgICAgICBpZiAoc3RhcnQgPD0gY29kZSAmJiBjb2RlIDw9IGVuZCkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBmb250UmVzb2x2ZXJXb3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgbmFtZTogJ0ZvbnRSZXNvbHZlcicsXG4gIGRlcGVuZGVuY2llczogW1xuICAgIGNyZWF0ZUZvbnRSZXNvbHZlcixcbiAgICB3b3JrZXJNb2R1bGUsXG4gICAgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnksXG4gIF0sXG4gIGluaXQoY3JlYXRlRm9udFJlc29sdmVyLCBmb250UGFyc2VyLCB1bmljb2RlRm9udFJlc29sdmVyQ2xpZW50RmFjdG9yeSkge1xuICAgIHJldHVybiBjcmVhdGVGb250UmVzb2x2ZXIoZm9udFBhcnNlciwgdW5pY29kZUZvbnRSZXNvbHZlckNsaWVudEZhY3RvcnkoKSk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtudW1iZXJ8J2xlZnQnfCdjZW50ZXInfCdyaWdodCd9IEFuY2hvclhWYWx1ZVxuICovXG4vKipcbiAqIEB0eXBlZGVmIHtudW1iZXJ8J3RvcCd8J3RvcC1iYXNlbGluZSd8J3RvcC1jYXAnfCd0b3AtZXgnfCdtaWRkbGUnfCdib3R0b20tYmFzZWxpbmUnfCdib3R0b20nfSBBbmNob3JZVmFsdWVcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFR5cGVzZXRQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0ZXh0XG4gKiBAcHJvcGVydHkge1VzZXJGb250fFVzZXJGb250W119IFtmb250XVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtsYW5nXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzZGZHbHlwaFNpemU9NjRdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW2ZvbnRTaXplPTFdXG4gKiBAcHJvcGVydHkge251bWJlcnwnbm9ybWFsJ3wnYm9sZCd9IFtmb250V2VpZ2h0PSdub3JtYWwnXVxuICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnaXRhbGljJ30gW2ZvbnRTdHlsZT0nbm9ybWFsJ11cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbGV0dGVyU3BhY2luZz0wXVxuICogQHByb3BlcnR5IHsnbm9ybWFsJ3xudW1iZXJ9IFtsaW5lSGVpZ2h0PSdub3JtYWwnXVxuICogQHByb3BlcnR5IHtudW1iZXJ9IFttYXhXaWR0aF1cbiAqIEBwcm9wZXJ0eSB7J2x0cid8J3J0bCd9IFtkaXJlY3Rpb249J2x0ciddXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RleHRBbGlnbj0nbGVmdCddXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3RleHRJbmRlbnQ9MF1cbiAqIEBwcm9wZXJ0eSB7J25vcm1hbCd8J25vd3JhcCd9IFt3aGl0ZVNwYWNlPSdub3JtYWwnXVxuICogQHByb3BlcnR5IHsnbm9ybWFsJ3wnYnJlYWstd29yZCd9IFtvdmVyZmxvd1dyYXA9J25vcm1hbCddXG4gKiBAcHJvcGVydHkge0FuY2hvclhWYWx1ZX0gW2FuY2hvclg9MF1cbiAqIEBwcm9wZXJ0eSB7QW5jaG9yWVZhbHVlfSBbYW5jaG9yWT0wXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbbWV0cmljc09ubHk9ZmFsc2VdXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VuaWNvZGVGb250c1VSTF1cbiAqIEBwcm9wZXJ0eSB7Rm9udFJlc29sdmVyUmVzdWx0fSBbcHJlUmVzb2x2ZWRGb250c11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2luY2x1ZGVDYXJldFBvc2l0aW9ucz1mYWxzZV1cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbY2h1bmtlZEJvdW5kc1NpemU9ODE5Ml1cbiAqIEBwcm9wZXJ0eSB7e1tyYW5nZVN0YXJ0SW5kZXhdOiBudW1iZXJ9fSBbY29sb3JSYW5nZXNdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUeXBlc2V0UmVzdWx0XG4gKiBAcHJvcGVydHkge1VpbnQxNkFycmF5fSBnbHlwaElkcyBpZCBmb3IgZWFjaCBnbHlwaCwgc3BlY2lmaWMgdG8gdGhhdCBnbHlwaCdzIGZvbnRcbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gZ2x5cGhGb250SW5kaWNlcyBpbmRleCBpbnRvIGZvbnREYXRhIGZvciBlYWNoIGdseXBoXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhQb3NpdGlvbnMgeCx5IG9mIGVhY2ggZ2x5cGgncyBvcmlnaW4gaW4gbGF5b3V0XG4gKiBAcHJvcGVydHkge3tbZm9udF06IHtbZ2x5cGhJZF06IHtwYXRoOiBzdHJpbmcsIHBhdGhCb3VuZHM6IG51bWJlcltdfX19fSBnbHlwaERhdGEgZGF0YSBhYm91dCBlYWNoIGdseXBoIGFwcGVhcmluZyBpbiB0aGUgdGV4dFxuICogQHByb3BlcnR5IHtUeXBlc2V0Rm9udERhdGFbXX0gZm9udERhdGEgZGF0YSBhYm91dCBlYWNoIGZvbnQgdXNlZCBpbiB0aGUgdGV4dFxuICogQHByb3BlcnR5IHtGbG9hdDMyQXJyYXl9IFtjYXJldFBvc2l0aW9uc10gc3RhcnRYLGVuZFgsYm90dG9tWSBjYXJldCBwb3NpdGlvbnMgZm9yIGVhY2ggY2hhclxuICogQHByb3BlcnR5IHtVaW50OEFycmF5fSBbZ2x5cGhDb2xvcnNdIGNvbG9yIGZvciBlYWNoIGdseXBoLCBpZiBjb2xvciByYW5nZXMgc3VwcGxpZWRcbiAqICAgICAgICAgY2h1bmtlZEJvdW5kcywgLy90b3RhbCByZWN0cyBwZXIgKG49Y2h1bmtlZEJvdW5kc1NpemUpIGNvbnNlY3V0aXZlIGdseXBoc1xuICogICAgICAgICBmb250U2l6ZSwgLy9jYWxjdWxhdGVkIGVtIGhlaWdodFxuICogICAgICAgICB0b3BCYXNlbGluZTogYW5jaG9yWU9mZnNldCArIGxpbmVzWzBdLmJhc2VsaW5lLCAvL3kgY29vcmRpbmF0ZSBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZVxuICogICAgICAgICBibG9ja0JvdW5kczogWyAvL2JvdW5kcyBmb3IgdGhlIHdob2xlIGJsb2NrIG9mIHRleHQsIGluY2x1ZGluZyB2ZXJ0aWNhbCBwYWRkaW5nIGZvciBsaW5lSGVpZ2h0XG4gKiAgICAgICAgICAgYW5jaG9yWE9mZnNldCxcbiAqICAgICAgICAgICBhbmNob3JZT2Zmc2V0IC0gdG90YWxIZWlnaHQsXG4gKiAgICAgICAgICAgYW5jaG9yWE9mZnNldCArIG1heExpbmVXaWR0aCxcbiAqICAgICAgICAgICBhbmNob3JZT2Zmc2V0XG4gKiAgICAgICAgIF0sXG4gKiAgICAgICAgIHZpc2libGVCb3VuZHMsIC8vdG90YWwgYm91bmRzIG9mIHZpc2libGUgdGV4dCBwYXRocywgbWF5IGJlIGxhcmdlciBvciBzbWFsbGVyIHRoYW4gYmxvY2tCb3VuZHNcbiAqICAgICAgICAgdGltaW5nc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHlwZXNldEZvbnREYXRhXG4gKiBAcHJvcGVydHkgc3JjXG4gKiBAcHJvcGVydHkgdW5pdHNQZXJFbVxuICogQHByb3BlcnR5IGFzY2VuZGVyXG4gKiBAcHJvcGVydHkgZGVzY2VuZGVyXG4gKiBAcHJvcGVydHkgbGluZUhlaWdodFxuICogQHByb3BlcnR5IGNhcEhlaWdodFxuICogQHByb3BlcnR5IHhIZWlnaHRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtmdW5jdGlvbn0gVHlwZXNldHRlclR5cGVzZXRGdW5jdGlvbiAtIGNvbXB1dGUgZm9udHMgYW5kIGxheW91dCBmb3Igc29tZSB0ZXh0LlxuICogQHBhcmFtIHtUeXBlc2V0UGFyYW1zfSBwYXJhbXNcbiAqIEBwYXJhbSB7KFR5cGVzZXRSZXN1bHQpID0+IHZvaWR9IGNhbGxiYWNrIC0gZnVuY3Rpb24gY2FsbGVkIHdoZW4gdHlwZXNldHRpbmcgaXMgY29tcGxldGUuXG4gKiAgICBJZiB0aGUgcGFyYW1zIGluY2x1ZGVkIGBwcmVSZXNvbHZlZEZvbnRzYCwgdGhpcyB3aWxsIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9ufSBUeXBlc2V0dGVyTWVhc3VyZUZ1bmN0aW9uIC0gY29tcHV0ZSB3aWR0aC9oZWlnaHQgZm9yIHNvbWUgdGV4dC5cbiAqIEBwYXJhbSB7VHlwZXNldFBhcmFtc30gcGFyYW1zXG4gKiBAcGFyYW0geyh3aWR0aDpudW1iZXIsIGhlaWdodDpudW1iZXIpID0+IHZvaWR9IGNhbGxiYWNrIC0gZnVuY3Rpb24gY2FsbGVkIHdoZW4gbWVhc3VyZW1lbnQgaXMgY29tcGxldGUuXG4gKiAgICBJZiB0aGUgcGFyYW1zIGluY2x1ZGVkIGBwcmVSZXNvbHZlZEZvbnRzYCwgdGhpcyB3aWxsIGJlIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICovXG5cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyBhIHNlbGYtY29udGFpbmVkIGVudmlyb25tZW50IGZvciBwcm9jZXNzaW5nIHRleHQgdHlwZXNldHRpbmcgcmVxdWVzdHMuXG4gKlxuICogSXQgaXMgaW1wb3J0YW50IHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgbm8gY2xvc3VyZSBkZXBlbmRlbmNpZXMsIHNvIHRoYXQgaXQgY2FuIGJlIGVhc2lseSBpbmplY3RlZFxuICogaW50byB0aGUgc291cmNlIGZvciBhIFdvcmtlciB3aXRob3V0IHJlcXVpcmluZyBhIGJ1aWxkIHN0ZXAgb3IgY29tcGxleCBkZXBlbmRlbmN5IGxvYWRpbmcuIEFsbCBpdHNcbiAqIGRlcGVuZGVuY2llcyBtdXN0IGJlIHBhc3NlZCBpbiBhdCBpbml0aWFsaXphdGlvbi5cbiAqXG4gKiBAcGFyYW0ge0ZvbnRSZXNvbHZlcn0gcmVzb2x2ZUZvbnRzIC0gZnVuY3Rpb24gdG8gcmVzb2x2ZSBhIHN0cmluZyB0byBwYXJzZWQgZm9udHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBiaWRpIC0gdGhlIGJpZGkuanMgaW1wbGVtZW50YXRpb24gb2JqZWN0XG4gKiBAcmV0dXJuIHt7dHlwZXNldDogVHlwZXNldHRlclR5cGVzZXRGdW5jdGlvbiwgbWVhc3VyZTogVHlwZXNldHRlck1lYXN1cmVGdW5jdGlvbn19XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVR5cGVzZXR0ZXIocmVzb2x2ZUZvbnRzLCBiaWRpKSB7XG4gIGNvbnN0IElORiA9IEluZmluaXR5O1xuXG4gIC8vIFNldCBvZiBVbmljb2RlIERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQgY2hhcmFjdGVycywgdGhlc2Ugd2lsbCBub3QgcHJvZHVjZSB2aXNpYmxlIGdseXBoc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbWlzbGVhZGluZy1jaGFyYWN0ZXItY2xhc3NcbiAgY29uc3QgREVGQVVMVF9JR05PUkFCTEVfQ0hBUlMgPSAvW1xcdTAwQURcXHUwMzRGXFx1MDYxQ1xcdTExNUYtXFx1MTE2MFxcdTE3QjQtXFx1MTdCNVxcdTE4MEItXFx1MTgwRVxcdTIwMEItXFx1MjAwRlxcdTIwMkEtXFx1MjAyRVxcdTIwNjAtXFx1MjA2RlxcdTMxNjRcXHVGRTAwLVxcdUZFMEZcXHVGRUZGXFx1RkZBMFxcdUZGRjAtXFx1RkZGOF0vO1xuXG4gIC8vIFRoaXMgcmVnZXggKGluc3RlYWQgb2YgL1xccy8pIGFsbG93cyB1cyB0byBzZWxlY3QgYWxsIHdoaXRlc3BhY2UgRVhDRVBUIGZvciBub24tYnJlYWtpbmcgd2hpdGUgc3BhY2VzXG4gIGNvbnN0IGxpbmVCcmVha2luZ1doaXRlU3BhY2UgPSBgW15cXFxcU1xcXFx1MDBBMF1gO1xuXG4gIC8vIEluY29tcGxldGUgc2V0IG9mIGNoYXJhY3RlcnMgdGhhdCBhbGxvdyBsaW5lIGJyZWFraW5nIGFmdGVyIHRoZW1cbiAgLy8gSW4gdGhlIGZ1dHVyZSB3ZSBtYXkgY29uc2lkZXIgYSBmdWxsIFVuaWNvZGUgbGluZSBicmVha2luZyBhbGdvcml0aG0gaW1wbDogaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjE0XG4gIGNvbnN0IEJSRUFLX0FGVEVSX0NIQVJTID0gbmV3IFJlZ0V4cChgJHtsaW5lQnJlYWtpbmdXaGl0ZVNwYWNlfXxbXFxcXC1cXFxcdTAwN0NcXFxcdTAwQURcXFxcdTIwMTBcXFxcdTIwMTItXFxcXHUyMDE0XFxcXHUyMDI3XFxcXHUyMDU2XFxcXHUyRTE3XFxcXHUyRTQwXWApO1xuXG4gIC8qKlxuICAgKiBMb2FkIGFuZCBwYXJzZSBhbGwgdGhlIG5lY2Vzc2FyeSBmb250cyB0byByZW5kZXIgYSBnaXZlbiBzdHJpbmcgb2YgdGV4dCwgdGhlbiBncm91cFxuICAgKiB0aGVtIGludG8gY29uc2VjdXRpdmUgcnVucyBvZiBjaGFyYWN0ZXJzIHNoYXJpbmcgYSBmb250LlxuICAgKi9cbiAgZnVuY3Rpb24gY2FsY3VsYXRlRm9udFJ1bnMoe3RleHQsIGxhbmcsIGZvbnRzLCBzdHlsZSwgd2VpZ2h0LCBwcmVSZXNvbHZlZEZvbnRzLCB1bmljb2RlRm9udHNVUkx9LCBvbkRvbmUpIHtcbiAgICBjb25zdCBvblJlc29sdmVkID0gKHtjaGFycywgZm9udHM6IHBhcnNlZEZvbnRzfSkgPT4ge1xuICAgICAgbGV0IGN1clJ1biwgcHJldlZhbDtcbiAgICAgIGNvbnN0IHJ1bnMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGNoYXJzW2ldICE9PSBwcmV2VmFsKSB7XG4gICAgICAgICAgcHJldlZhbCA9IGNoYXJzW2ldO1xuICAgICAgICAgIHJ1bnMucHVzaChjdXJSdW4gPSB7IHN0YXJ0OiBpLCBlbmQ6IGksIGZvbnRPYmo6IHBhcnNlZEZvbnRzW2NoYXJzW2ldXX0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1clJ1bi5lbmQgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkRvbmUocnVucyk7XG4gICAgfTtcbiAgICBpZiAocHJlUmVzb2x2ZWRGb250cykge1xuICAgICAgb25SZXNvbHZlZChwcmVSZXNvbHZlZEZvbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZUZvbnRzKFxuICAgICAgICB0ZXh0LFxuICAgICAgICBvblJlc29sdmVkLFxuICAgICAgICB7IGxhbmcsIGZvbnRzLCBzdHlsZSwgd2VpZ2h0LCB1bmljb2RlRm9udHNVUkwgfVxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFpbiBlbnRyeSBwb2ludC5cbiAgICogUHJvY2VzcyBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBhbmQgZm9ybWF0dGluZyBwYXJhbWV0ZXJzLCBhbmQgcmV0dXJuIGFsbCBpbmZvXG4gICAqIG5lY2Vzc2FyeSB0byByZW5kZXIgYWxsIGl0cyBnbHlwaHMuXG4gICAqIEB0eXBlIFR5cGVzZXR0ZXJUeXBlc2V0RnVuY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIHR5cGVzZXQoXG4gICAge1xuICAgICAgdGV4dD0nJyxcbiAgICAgIGZvbnQsXG4gICAgICBsYW5nLFxuICAgICAgc2RmR2x5cGhTaXplPTY0LFxuICAgICAgZm9udFNpemU9NDAwLFxuICAgICAgZm9udFdlaWdodD0xLFxuICAgICAgZm9udFN0eWxlPSdub3JtYWwnLFxuICAgICAgbGV0dGVyU3BhY2luZz0wLFxuICAgICAgbGluZUhlaWdodD0nbm9ybWFsJyxcbiAgICAgIG1heFdpZHRoPUlORixcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIHRleHRBbGlnbj0nbGVmdCcsXG4gICAgICB0ZXh0SW5kZW50PTAsXG4gICAgICB3aGl0ZVNwYWNlPSdub3JtYWwnLFxuICAgICAgb3ZlcmZsb3dXcmFwPSdub3JtYWwnLFxuICAgICAgYW5jaG9yWCA9IDAsXG4gICAgICBhbmNob3JZID0gMCxcbiAgICAgIG1ldHJpY3NPbmx5PWZhbHNlLFxuICAgICAgdW5pY29kZUZvbnRzVVJMLFxuICAgICAgcHJlUmVzb2x2ZWRGb250cz1udWxsLFxuICAgICAgaW5jbHVkZUNhcmV0UG9zaXRpb25zPWZhbHNlLFxuICAgICAgY2h1bmtlZEJvdW5kc1NpemU9ODE5MixcbiAgICAgIGNvbG9yUmFuZ2VzPW51bGxcbiAgICB9LFxuICAgIGNhbGxiYWNrXG4gICkge1xuICAgIGNvbnN0IG1haW5TdGFydCA9IG5vdygpO1xuICAgIGNvbnN0IHRpbWluZ3MgPSB7Zm9udExvYWQ6IDAsIHR5cGVzZXR0aW5nOiAwfTtcblxuICAgIC8vIEVuc3VyZSBuZXdsaW5lcyBhcmUgbm9ybWFsaXplZFxuICAgIGlmICh0ZXh0LmluZGV4T2YoJ1xccicpID4gLTEpIHtcbiAgICAgIGNvbnNvbGUuaW5mbygnVHlwZXNldHRlcjogZ290IHRleHQgd2l0aCBcXFxcciBjaGFyczsgbm9ybWFsaXppbmcgdG8gXFxcXG4nKTtcbiAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoL1xcclxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxyL2csICdcXG4nKTtcbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgd2UndmUgZ290IG51bWJlcnMgbm90IHN0cmluZ3NcbiAgICBmb250U2l6ZSA9ICtmb250U2l6ZTtcbiAgICBsZXR0ZXJTcGFjaW5nID0gK2xldHRlclNwYWNpbmc7XG4gICAgbWF4V2lkdGggPSArbWF4V2lkdGg7XG4gICAgbGluZUhlaWdodCA9IGxpbmVIZWlnaHQgfHwgJ25vcm1hbCc7XG4gICAgdGV4dEluZGVudCA9ICt0ZXh0SW5kZW50O1xuXG4gICAgY2FsY3VsYXRlRm9udFJ1bnMoe1xuICAgICAgdGV4dCxcbiAgICAgIGxhbmcsXG4gICAgICBzdHlsZTogZm9udFN0eWxlLFxuICAgICAgd2VpZ2h0OiBmb250V2VpZ2h0LFxuICAgICAgZm9udHM6IHR5cGVvZiBmb250ID09PSAnc3RyaW5nJyA/IFt7c3JjOiBmb250fV0gOiBmb250LFxuICAgICAgdW5pY29kZUZvbnRzVVJMLFxuICAgICAgcHJlUmVzb2x2ZWRGb250c1xuICAgIH0sIHJ1bnMgPT4ge1xuICAgICAgdGltaW5ncy5mb250TG9hZCA9IG5vdygpIC0gbWFpblN0YXJ0O1xuICAgICAgY29uc3QgaGFzTWF4V2lkdGggPSBpc0Zpbml0ZShtYXhXaWR0aCk7XG4gICAgICBsZXQgZ2x5cGhJZHMgPSBudWxsO1xuICAgICAgbGV0IGdseXBoRm9udEluZGljZXMgPSBudWxsO1xuICAgICAgbGV0IGdseXBoUG9zaXRpb25zID0gbnVsbDtcbiAgICAgIGxldCBnbHlwaERhdGEgPSBudWxsO1xuICAgICAgbGV0IGdseXBoQ29sb3JzID0gbnVsbDtcbiAgICAgIGxldCBjYXJldFBvc2l0aW9ucyA9IG51bGw7XG4gICAgICBsZXQgdmlzaWJsZUJvdW5kcyA9IG51bGw7XG4gICAgICBsZXQgY2h1bmtlZEJvdW5kcyA9IG51bGw7XG4gICAgICBsZXQgbWF4TGluZVdpZHRoID0gMDtcbiAgICAgIGxldCByZW5kZXJhYmxlR2x5cGhDb3VudCA9IDA7XG4gICAgICBsZXQgY2FuV3JhcCA9IHdoaXRlU3BhY2UgIT09ICdub3dyYXAnO1xuICAgICAgY29uc3QgbWV0cmljc0J5Rm9udCA9IG5ldyBNYXAoKTsgLy8gZm9udE9iaiAtPiBtZXRyaWNzXG4gICAgICBjb25zdCB0eXBlc2V0U3RhcnQgPSBub3coKTtcblxuICAgICAgLy8gRGlzdHJpYnV0ZSBnbHlwaHMgaW50byBsaW5lcyBiYXNlZCBvbiB3cmFwcGluZ1xuICAgICAgbGV0IGxpbmVYT2Zmc2V0ID0gdGV4dEluZGVudDtcbiAgICAgIGxldCBwcmV2UnVuRW5kWCA9IDA7XG4gICAgICBsZXQgY3VycmVudExpbmUgPSBuZXcgVGV4dExpbmUoKTtcbiAgICAgIGNvbnN0IGxpbmVzID0gW2N1cnJlbnRMaW5lXTtcbiAgICAgIHJ1bnMuZm9yRWFjaChydW4gPT4ge1xuICAgICAgICBjb25zdCB7IGZvbnRPYmogfSA9IHJ1bjtcbiAgICAgICAgY29uc3QgeyBhc2NlbmRlciwgZGVzY2VuZGVyLCB1bml0c1BlckVtLCBsaW5lR2FwLCBjYXBIZWlnaHQsIHhIZWlnaHQgfSA9IGZvbnRPYmo7XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIG1ldHJpY3MgZm9yIGVhY2ggZm9udCB1c2VkXG4gICAgICAgIGxldCBmb250RGF0YSA9IG1ldHJpY3NCeUZvbnQuZ2V0KGZvbnRPYmopO1xuICAgICAgICBpZiAoIWZvbnREYXRhKSB7XG4gICAgICAgICAgLy8gRmluZCBjb252ZXJzaW9uIGJldHdlZW4gbmF0aXZlIGZvbnQgdW5pdHMgYW5kIGZvbnRTaXplIHVuaXRzXG4gICAgICAgICAgY29uc3QgZm9udFNpemVNdWx0ID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGFwcHJvcHJpYXRlIHZhbHVlIGZvciAnbm9ybWFsJyBsaW5lIGhlaWdodCBiYXNlZCBvbiB0aGUgZm9udCdzIGFjdHVhbCBtZXRyaWNzXG4gICAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBndWFyYW50ZWUgaW5kaXZpZHVhbCBnbHlwaHMgd29uJ3QgZXhjZWVkIHRoZSBsaW5lIGhlaWdodCwgZS5nLiBSb2JvdG87IHNob3VsZCB3ZSB1c2UgeU1pbi9NYXggaW5zdGVhZD9cbiAgICAgICAgICBjb25zdCBjYWxjTGluZUhlaWdodCA9IGxpbmVIZWlnaHQgPT09ICdub3JtYWwnID9cbiAgICAgICAgICAgIChhc2NlbmRlciAtIGRlc2NlbmRlciArIGxpbmVHYXApICogZm9udFNpemVNdWx0IDogbGluZUhlaWdodCAqIGZvbnRTaXplO1xuXG4gICAgICAgICAgLy8gRGV0ZXJtaW5lIGxpbmUgaGVpZ2h0IGFuZCBsZWFkaW5nIGFkanVzdG1lbnRzXG4gICAgICAgICAgY29uc3QgaGFsZkxlYWRpbmcgPSAoY2FsY0xpbmVIZWlnaHQgLSAoYXNjZW5kZXIgLSBkZXNjZW5kZXIpICogZm9udFNpemVNdWx0KSAvIDI7XG4gICAgICAgICAgY29uc3QgY2FyZXRIZWlnaHQgPSBNYXRoLm1pbihjYWxjTGluZUhlaWdodCwgKGFzY2VuZGVyIC0gZGVzY2VuZGVyKSAqIGZvbnRTaXplTXVsdCk7XG4gICAgICAgICAgY29uc3QgY2FyZXRUb3AgPSAoYXNjZW5kZXIgKyBkZXNjZW5kZXIpIC8gMiAqIGZvbnRTaXplTXVsdCArIGNhcmV0SGVpZ2h0IC8gMjtcbiAgICAgICAgICBmb250RGF0YSA9IHtcbiAgICAgICAgICAgIGluZGV4OiBtZXRyaWNzQnlGb250LnNpemUsXG4gICAgICAgICAgICBzcmM6IGZvbnRPYmouc3JjLFxuICAgICAgICAgICAgZm9udE9iaixcbiAgICAgICAgICAgIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgIHVuaXRzUGVyRW0sXG4gICAgICAgICAgICBhc2NlbmRlcjogYXNjZW5kZXIgKiBmb250U2l6ZU11bHQsXG4gICAgICAgICAgICBkZXNjZW5kZXI6IGRlc2NlbmRlciAqIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgIGNhcEhlaWdodDogY2FwSGVpZ2h0ICogZm9udFNpemVNdWx0LFxuICAgICAgICAgICAgeEhlaWdodDogeEhlaWdodCAqIGZvbnRTaXplTXVsdCxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IGNhbGNMaW5lSGVpZ2h0LFxuICAgICAgICAgICAgYmFzZWxpbmU6IC1oYWxmTGVhZGluZyAtIGFzY2VuZGVyICogZm9udFNpemVNdWx0LCAvLyBiYXNlbGluZSBvZmZzZXQgZnJvbSB0b3Agb2YgbGluZSBoZWlnaHRcbiAgICAgICAgICAgIC8vIGNhcDogLWhhbGZMZWFkaW5nIC0gY2FwSGVpZ2h0ICogZm9udFNpemVNdWx0LCAvLyBjYXAgZnJvbSB0b3Agb2YgbGluZSBoZWlnaHRcbiAgICAgICAgICAgIC8vIGV4OiAtaGFsZkxlYWRpbmcgLSB4SGVpZ2h0ICogZm9udFNpemVNdWx0LCAvLyBleCBmcm9tIHRvcCBvZiBsaW5lIGhlaWdodFxuICAgICAgICAgICAgY2FyZXRUb3AsXG4gICAgICAgICAgICBjYXJldEJvdHRvbTogY2FyZXRUb3AgLSBjYXJldEhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgICAgbWV0cmljc0J5Rm9udC5zZXQoZm9udE9iaiwgZm9udERhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZm9udFNpemVNdWx0IH0gPSBmb250RGF0YTtcblxuICAgICAgICBjb25zdCBydW5UZXh0ID0gdGV4dC5zbGljZShydW4uc3RhcnQsIHJ1bi5lbmQgKyAxKTtcbiAgICAgICAgbGV0IHByZXZHbHlwaFgsIHByZXZHbHlwaE9iajtcbiAgICAgICAgZm9udE9iai5mb3JFYWNoR2x5cGgocnVuVGV4dCwgZm9udFNpemUsIGxldHRlclNwYWNpbmcsIChnbHlwaE9iaiwgZ2x5cGhYLCBnbHlwaFksIGNoYXJJbmRleCkgPT4ge1xuICAgICAgICAgIGdseXBoWCArPSBwcmV2UnVuRW5kWDtcbiAgICAgICAgICBjaGFySW5kZXggKz0gcnVuLnN0YXJ0O1xuICAgICAgICAgIHByZXZHbHlwaFggPSBnbHlwaFg7XG4gICAgICAgICAgcHJldkdseXBoT2JqID0gZ2x5cGhPYmo7XG4gICAgICAgICAgY29uc3QgY2hhciA9IHRleHQuY2hhckF0KGNoYXJJbmRleCk7XG4gICAgICAgICAgY29uc3QgZ2x5cGhXaWR0aCA9IGdseXBoT2JqLmFkdmFuY2VXaWR0aCAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICBjb25zdCBjdXJMaW5lQ291bnQgPSBjdXJyZW50TGluZS5jb3VudDtcbiAgICAgICAgICBsZXQgbmV4dExpbmU7XG5cbiAgICAgICAgICAvLyBDYWxjIGlzV2hpdGVzcGFjZSBhbmQgaXNFbXB0eSBvbmNlIHBlciBnbHlwaE9ialxuICAgICAgICAgIGlmICghKCdpc0VtcHR5JyBpbiBnbHlwaE9iaikpIHtcbiAgICAgICAgICAgIGdseXBoT2JqLmlzV2hpdGVzcGFjZSA9ICEhY2hhciAmJiBuZXcgUmVnRXhwKGxpbmVCcmVha2luZ1doaXRlU3BhY2UpLnRlc3QoY2hhcik7XG4gICAgICAgICAgICBnbHlwaE9iai5jYW5CcmVha0FmdGVyID0gISFjaGFyICYmIEJSRUFLX0FGVEVSX0NIQVJTLnRlc3QoY2hhcik7XG4gICAgICAgICAgICBnbHlwaE9iai5pc0VtcHR5ID0gZ2x5cGhPYmoueE1pbiA9PT0gZ2x5cGhPYmoueE1heCB8fCBnbHlwaE9iai55TWluID09PSBnbHlwaE9iai55TWF4IHx8IERFRkFVTFRfSUdOT1JBQkxFX0NIQVJTLnRlc3QoY2hhcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZ2x5cGhPYmouaXNXaGl0ZXNwYWNlICYmICFnbHlwaE9iai5pc0VtcHR5KSB7XG4gICAgICAgICAgICByZW5kZXJhYmxlR2x5cGhDb3VudCsrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIGEgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyIG92ZXJmbG93cyB0aGUgbWF4IHdpZHRoLCB3ZSBuZWVkIHRvIHNvZnQtd3JhcFxuICAgICAgICAgIGlmIChjYW5XcmFwICYmIGhhc01heFdpZHRoICYmICFnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgZ2x5cGhYICsgZ2x5cGhXaWR0aCArIGxpbmVYT2Zmc2V0ID4gbWF4V2lkdGggJiYgY3VyTGluZUNvdW50KSB7XG4gICAgICAgICAgICAvLyBJZiBpdCdzIHRoZSBmaXJzdCBjaGFyIGFmdGVyIGEgd2hpdGVzcGFjZSwgc3RhcnQgYSBuZXcgbGluZVxuICAgICAgICAgICAgaWYgKGN1cnJlbnRMaW5lLmdseXBoQXQoY3VyTGluZUNvdW50IC0gMSkuZ2x5cGhPYmouY2FuQnJlYWtBZnRlcikge1xuICAgICAgICAgICAgICBuZXh0TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBCYWNrIHVwIGxvb2tpbmcgZm9yIGEgd2hpdGVzcGFjZSBjaGFyYWN0ZXIgdG8gd3JhcCBhdFxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY3VyTGluZUNvdW50OyBpLS07KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZ290IHRoZSBzdGFydCBvZiB0aGUgbGluZSB0aGVyZSdzIG5vIHNvZnQgYnJlYWsgcG9pbnQ7IG1ha2UgaGFyZCBicmVhayBpZiBvdmVyZmxvd1dyYXA9J2JyZWFrLXdvcmQnXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDAgJiYgb3ZlcmZsb3dXcmFwID09PSAnYnJlYWstd29yZCcpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICAgICAgICBsaW5lWE9mZnNldCA9IC1nbHlwaFg7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBGb3VuZCBhIHNvZnQgYnJlYWsgcG9pbnQ7IG1vdmUgYWxsIGNoYXJzIHNpbmNlIGl0IHRvIGEgbmV3IGxpbmVcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50TGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmNhbkJyZWFrQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgIG5leHRMaW5lID0gY3VycmVudExpbmUuc3BsaXRBdChpICsgMSk7XG4gICAgICAgICAgICAgICAgICBjb25zdCBhZGp1c3RYID0gbmV4dExpbmUuZ2x5cGhBdCgwKS54O1xuICAgICAgICAgICAgICAgICAgbGluZVhPZmZzZXQgLT0gYWRqdXN0WDtcbiAgICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBuZXh0TGluZS5jb3VudDsgai0tOykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0TGluZS5nbHlwaEF0KGopLnggLT0gYWRqdXN0WDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dExpbmUpIHtcbiAgICAgICAgICAgICAgY3VycmVudExpbmUuaXNTb2Z0V3JhcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV4dExpbmU7XG4gICAgICAgICAgICAgIGxpbmVzLnB1c2goY3VycmVudExpbmUpO1xuICAgICAgICAgICAgICBtYXhMaW5lV2lkdGggPSBtYXhXaWR0aDsgLy9hZnRlciBzb2Z0IHdyYXBwaW5nIHVzZSBtYXhXaWR0aCBhcyBjYWxjdWxhdGVkIHdpZHRoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IGZseSA9IGN1cnJlbnRMaW5lLmdseXBoQXQoY3VycmVudExpbmUuY291bnQpO1xuICAgICAgICAgIGZseS5nbHlwaE9iaiA9IGdseXBoT2JqO1xuICAgICAgICAgIGZseS54ID0gZ2x5cGhYICsgbGluZVhPZmZzZXQ7XG4gICAgICAgICAgZmx5LnkgPSBnbHlwaFk7XG4gICAgICAgICAgZmx5LndpZHRoID0gZ2x5cGhXaWR0aDtcbiAgICAgICAgICBmbHkuY2hhckluZGV4ID0gY2hhckluZGV4O1xuICAgICAgICAgIGZseS5mb250RGF0YSA9IGZvbnREYXRhO1xuXG4gICAgICAgICAgLy8gSGFuZGxlIGhhcmQgbGluZSBicmVha3NcbiAgICAgICAgICBpZiAoY2hhciA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMaW5lID0gbmV3IFRleHRMaW5lKCk7XG4gICAgICAgICAgICBsaW5lcy5wdXNoKGN1cnJlbnRMaW5lKTtcbiAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gLShnbHlwaFggKyBnbHlwaFdpZHRoICsgKGxldHRlclNwYWNpbmcgKiBmb250U2l6ZSkpICsgdGV4dEluZGVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBdCB0aGUgZW5kIG9mIGEgcnVuIHdlIG11c3QgY2FwdHVyZSB0aGUgeCBwb3NpdGlvbiBhcyB0aGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBuZXh0IHJ1blxuICAgICAgICBwcmV2UnVuRW5kWCA9IHByZXZHbHlwaFggKyBwcmV2R2x5cGhPYmouYWR2YW5jZVdpZHRoICogZm9udFNpemVNdWx0ICsgbGV0dGVyU3BhY2luZyAqIGZvbnRTaXplO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB3aWR0aC9oZWlnaHQvYmFzZWxpbmUgb2YgZWFjaCBsaW5lIChleGNsdWRpbmcgdHJhaWxpbmcgd2hpdGVzcGFjZSkgYW5kIG1heGltdW0gYmxvY2sgd2lkdGhcbiAgICAgIGxldCB0b3RhbEhlaWdodCA9IDA7XG4gICAgICBsaW5lcy5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgICBsZXQgaXNUcmFpbGluZ1doaXRlc3BhY2UgPSB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gbGluZS5jb3VudDsgaS0tOykge1xuICAgICAgICAgIGNvbnN0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICAvLyBvbWl0IHRyYWlsaW5nIHdoaXRlc3BhY2UgZnJvbSB3aWR0aCBjYWxjdWxhdGlvblxuICAgICAgICAgIGlmIChpc1RyYWlsaW5nV2hpdGVzcGFjZSAmJiAhZ2x5cGhJbmZvLmdseXBoT2JqLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgbGluZS53aWR0aCA9IGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoO1xuICAgICAgICAgICAgaWYgKGxpbmUud2lkdGggPiBtYXhMaW5lV2lkdGgpIHtcbiAgICAgICAgICAgICAgbWF4TGluZVdpZHRoID0gbGluZS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzVHJhaWxpbmdXaGl0ZXNwYWNlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHVzZSB0aGUgdGFsbGVzdCBsaW5lIGhlaWdodCwgbG93ZXN0IGJhc2VsaW5lLCBhbmQgaGlnaGVzdCBjYXAvZXhcbiAgICAgICAgICBsZXQge2xpbmVIZWlnaHQsIGNhcEhlaWdodCwgeEhlaWdodCwgYmFzZWxpbmV9ID0gZ2x5cGhJbmZvLmZvbnREYXRhO1xuICAgICAgICAgIGlmIChsaW5lSGVpZ2h0ID4gbGluZS5saW5lSGVpZ2h0KSBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgIGNvbnN0IGJhc2VsaW5lRGlmZiA9IGJhc2VsaW5lIC0gbGluZS5iYXNlbGluZTtcbiAgICAgICAgICBpZiAoYmFzZWxpbmVEaWZmIDwgMCkgeyAvL3NoaWZ0IGFsbCBtZXRyaWNzIGRvd25cbiAgICAgICAgICAgIGxpbmUuYmFzZWxpbmUgKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgICAgbGluZS5jYXAgKz0gYmFzZWxpbmVEaWZmO1xuICAgICAgICAgICAgbGluZS5leCArPSBiYXNlbGluZURpZmY7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGNvbXBhcmUgY2FwL2V4IGJhc2VkIG9uIG5ldyBsb3dlc3QgYmFzZWxpbmVcbiAgICAgICAgICBsaW5lLmNhcCA9IE1hdGgubWF4KGxpbmUuY2FwLCBsaW5lLmJhc2VsaW5lICsgY2FwSGVpZ2h0KTtcbiAgICAgICAgICBsaW5lLmV4ID0gTWF0aC5tYXgobGluZS5leCwgbGluZS5iYXNlbGluZSArIHhIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUuYmFzZWxpbmUgLT0gdG90YWxIZWlnaHQ7XG4gICAgICAgIGxpbmUuY2FwIC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICBsaW5lLmV4IC09IHRvdGFsSGVpZ2h0O1xuICAgICAgICB0b3RhbEhlaWdodCArPSBsaW5lLmxpbmVIZWlnaHQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gRmluZCBvdmVyYWxsIHBvc2l0aW9uIGFkanVzdG1lbnRzIGZvciBhbmNob3JpbmdcbiAgICAgIGxldCBhbmNob3JYT2Zmc2V0ID0gMDtcbiAgICAgIGxldCBhbmNob3JZT2Zmc2V0ID0gMDtcbiAgICAgIGlmIChhbmNob3JYKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0ID0gLWFuY2hvclg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYW5jaG9yWE9mZnNldCA9IC1tYXhMaW5lV2lkdGggKiAoXG4gICAgICAgICAgICBhbmNob3JYID09PSAnbGVmdCcgPyAwIDpcbiAgICAgICAgICAgIGFuY2hvclggPT09ICdjZW50ZXInID8gMC41IDpcbiAgICAgICAgICAgIGFuY2hvclggPT09ICdyaWdodCcgPyAxIDpcbiAgICAgICAgICAgIHBhcnNlUGVyY2VudChhbmNob3JYKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbmNob3JZKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYW5jaG9yWSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBhbmNob3JZT2Zmc2V0ID0gLWFuY2hvclk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFuY2hvclkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgYW5jaG9yWU9mZnNldCA9IGFuY2hvclkgPT09ICd0b3AnID8gMCA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWJhc2VsaW5lJyA/IC1saW5lc1swXS5iYXNlbGluZSA6XG4gICAgICAgICAgICBhbmNob3JZID09PSAndG9wLWNhcCcgPyAtbGluZXNbMF0uY2FwIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICd0b3AtZXgnID8gLWxpbmVzWzBdLmV4IDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdtaWRkbGUnID8gdG90YWxIZWlnaHQgLyAyIDpcbiAgICAgICAgICAgIGFuY2hvclkgPT09ICdib3R0b20nID8gdG90YWxIZWlnaHQgOlxuICAgICAgICAgICAgYW5jaG9yWSA9PT0gJ2JvdHRvbS1iYXNlbGluZScgPyAtbGluZXNbbGluZXMubGVuZ3RoIC0gMV0uYmFzZWxpbmUgOlxuICAgICAgICAgICAgcGFyc2VQZXJjZW50KGFuY2hvclkpICogdG90YWxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFtZXRyaWNzT25seSkge1xuICAgICAgICAvLyBSZXNvbHZlIGJpZGkgbGV2ZWxzXG4gICAgICAgIGNvbnN0IGJpZGlMZXZlbHNSZXN1bHQgPSBiaWRpLmdldEVtYmVkZGluZ0xldmVscyh0ZXh0LCBkaXJlY3Rpb24pO1xuXG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBsaW5lLCBhcHBseWluZyBhbGlnbm1lbnQgb2Zmc2V0cywgYWRkaW5nIGVhY2ggZ2x5cGggdG8gdGhlIGF0bGFzLCBhbmRcbiAgICAgICAgLy8gY29sbGVjdGluZyBhbGwgcmVuZGVyYWJsZSBnbHlwaHMgaW50byBhIHNpbmdsZSBjb2xsZWN0aW9uLlxuICAgICAgICBnbHlwaElkcyA9IG5ldyBVaW50MTZBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCk7XG4gICAgICAgIGdseXBoRm9udEluZGljZXMgPSBuZXcgVWludDhBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCk7XG4gICAgICAgIGdseXBoUG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheShyZW5kZXJhYmxlR2x5cGhDb3VudCAqIDIpO1xuICAgICAgICBnbHlwaERhdGEgPSB7fTtcbiAgICAgICAgdmlzaWJsZUJvdW5kcyA9IFtJTkYsIElORiwgLUlORiwgLUlORl07XG4gICAgICAgIGNodW5rZWRCb3VuZHMgPSBbXTtcbiAgICAgICAgaWYgKGluY2x1ZGVDYXJldFBvc2l0aW9ucykge1xuICAgICAgICAgIGNhcmV0UG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSh0ZXh0Lmxlbmd0aCAqIDQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvclJhbmdlcykge1xuICAgICAgICAgIGdseXBoQ29sb3JzID0gbmV3IFVpbnQ4QXJyYXkocmVuZGVyYWJsZUdseXBoQ291bnQgKiAzKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVuZGVyYWJsZUdseXBoSW5kZXggPSAwO1xuICAgICAgICBsZXQgcHJldkNoYXJJbmRleCA9IC0xO1xuICAgICAgICBsZXQgY29sb3JDaGFySW5kZXggPSAtMTtcbiAgICAgICAgbGV0IGNodW5rO1xuICAgICAgICBsZXQgY3VycmVudENvbG9yO1xuICAgICAgICBsaW5lcy5mb3JFYWNoKChsaW5lLCBsaW5lSW5kZXgpID0+IHtcbiAgICAgICAgICBsZXQge2NvdW50OmxpbmVHbHlwaENvdW50LCB3aWR0aDpsaW5lV2lkdGh9ID0gbGluZTtcblxuICAgICAgICAgIC8vIElnbm9yZSBlbXB0eSBsaW5lc1xuICAgICAgICAgIGlmIChsaW5lR2x5cGhDb3VudCA+IDApIHtcbiAgICAgICAgICAgIC8vIENvdW50IHRyYWlsaW5nIHdoaXRlc3BhY2VzLCB3ZSB3YW50IHRvIGlnbm9yZSB0aGVzZSBmb3IgY2VydGFpbiB0aGluZ3NcbiAgICAgICAgICAgIGxldCB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGluZUdseXBoQ291bnQ7IGktLSAmJiBsaW5lLmdseXBoQXQoaSkuZ2x5cGhPYmouaXNXaGl0ZXNwYWNlOykge1xuICAgICAgICAgICAgICB0cmFpbGluZ1doaXRlc3BhY2VDb3VudCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBcHBseSBob3Jpem9udGFsIGFsaWdubWVudCBhZGp1c3RtZW50c1xuICAgICAgICAgICAgbGV0IGxpbmVYT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIGxldCBqdXN0aWZ5QWRqdXN0ID0gMDtcbiAgICAgICAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgIGxpbmVYT2Zmc2V0ID0gKG1heExpbmVXaWR0aCAtIGxpbmVXaWR0aCkgLyAyO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgICAgbGluZVhPZmZzZXQgPSBtYXhMaW5lV2lkdGggLSBsaW5lV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2p1c3RpZnknICYmIGxpbmUuaXNTb2Z0V3JhcHBlZCkge1xuICAgICAgICAgICAgICAvLyBjb3VudCBub24tdHJhaWxpbmcgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBhbmQgd2UnbGwgYWRqdXN0IHRoZSBvZmZzZXRzIHBlciBjaGFyYWN0ZXIgaW4gdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgICBsZXQgd2hpdGVzcGFjZUNvdW50ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQ7IGktLTspIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5nbHlwaEF0KGkpLmdseXBoT2JqLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgd2hpdGVzcGFjZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGp1c3RpZnlBZGp1c3QgPSAobWF4TGluZVdpZHRoIC0gbGluZVdpZHRoKSAvIHdoaXRlc3BhY2VDb3VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqdXN0aWZ5QWRqdXN0IHx8IGxpbmVYT2Zmc2V0KSB7XG4gICAgICAgICAgICAgIGxldCBqdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGdseXBoSW5mbyA9IGxpbmUuZ2x5cGhBdChpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBnbHlwaE9iaiA9IGdseXBoSW5mby5nbHlwaE9iajtcbiAgICAgICAgICAgICAgICBnbHlwaEluZm8ueCArPSBsaW5lWE9mZnNldCArIGp1c3RpZnlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgLy8gRXhwYW5kIG5vbi10cmFpbGluZyB3aGl0ZXNwYWNlcyBmb3IganVzdGlmeSBhbGlnbm1lbnRcbiAgICAgICAgICAgICAgICBpZiAoanVzdGlmeUFkanVzdCAhPT0gMCAmJiBnbHlwaE9iai5pc1doaXRlc3BhY2UgJiYgaSA8IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgIGp1c3RpZnlPZmZzZXQgKz0ganVzdGlmeUFkanVzdDtcbiAgICAgICAgICAgICAgICAgIGdseXBoSW5mby53aWR0aCArPSBqdXN0aWZ5QWRqdXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQZXJmb3JtIGJpZGkgcmFuZ2UgZmxpcHBpbmdcbiAgICAgICAgICAgIGNvbnN0IGZsaXBzID0gYmlkaS5nZXRSZW9yZGVyU2VnbWVudHMoXG4gICAgICAgICAgICAgIHRleHQsIGJpZGlMZXZlbHNSZXN1bHQsIGxpbmUuZ2x5cGhBdCgwKS5jaGFySW5kZXgsIGxpbmUuZ2x5cGhBdChsaW5lLmNvdW50IC0gMSkuY2hhckluZGV4XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZm9yIChsZXQgZmkgPSAwOyBmaSA8IGZsaXBzLmxlbmd0aDsgZmkrKykge1xuICAgICAgICAgICAgICBjb25zdCBbc3RhcnQsIGVuZF0gPSBmbGlwc1tmaV07XG4gICAgICAgICAgICAgIC8vIE1hcCBzdGFydC9lbmQgc3RyaW5nIGluZGljZXMgdG8gaW5kaWNlcyBpbiB0aGUgbGluZVxuICAgICAgICAgICAgICBsZXQgbGVmdCA9IEluZmluaXR5LCByaWdodCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lR2x5cGhDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuZ2x5cGhBdChpKS5jaGFySW5kZXggPj0gc3RhcnQpIHsgLy8gZ3RlIHRvIGhhbmRsZSByZW1vdmVkIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgIGxldCBzdGFydEluTGluZSA9IGksIGVuZEluTGluZSA9IGk7XG4gICAgICAgICAgICAgICAgICBmb3IgKDsgZW5kSW5MaW5lIDwgbGluZUdseXBoQ291bnQ7IGVuZEluTGluZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmZvID0gbGluZS5nbHlwaEF0KGVuZEluTGluZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmZvLmNoYXJJbmRleCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGVuZEluTGluZSA8IGxpbmVHbHlwaENvdW50IC0gdHJhaWxpbmdXaGl0ZXNwYWNlQ291bnQpIHsgLy9kb24ndCBpbmNsdWRlIHRyYWlsaW5nIHdzIGluIGZsaXAgd2lkdGhcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4obGVmdCwgaW5mby54KTtcbiAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBpbmZvLnggKyBpbmZvLndpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0SW5MaW5lOyBqIDwgZW5kSW5MaW5lOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhJbmZvID0gbGluZS5nbHlwaEF0KGopO1xuICAgICAgICAgICAgICAgICAgICBnbHlwaEluZm8ueCA9IHJpZ2h0IC0gKGdseXBoSW5mby54ICsgZ2x5cGhJbmZvLndpZHRoIC0gbGVmdCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBc3NlbWJsZSBmaW5hbCBkYXRhIGFycmF5c1xuICAgICAgICAgICAgbGV0IGdseXBoT2JqO1xuICAgICAgICAgICAgY29uc3Qgc2V0R2x5cGhPYmogPSBnID0+IGdseXBoT2JqID0gZztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZUdseXBoQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICBjb25zdCBnbHlwaEluZm8gPSBsaW5lLmdseXBoQXQoaSk7XG4gICAgICAgICAgICAgIGdseXBoT2JqID0gZ2x5cGhJbmZvLmdseXBoT2JqO1xuICAgICAgICAgICAgICBjb25zdCBnbHlwaElkID0gZ2x5cGhPYmouaW5kZXg7XG5cbiAgICAgICAgICAgICAgLy8gUmVwbGFjZSBtaXJyb3JlZCBjaGFyYWN0ZXJzIGluIHJ0bFxuICAgICAgICAgICAgICBjb25zdCBydGwgPSBiaWRpTGV2ZWxzUmVzdWx0LmxldmVsc1tnbHlwaEluZm8uY2hhckluZGV4XSAmIDE7IC8vb2RkIGxldmVsIG1lYW5zIHJ0bFxuICAgICAgICAgICAgICBpZiAocnRsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWlycm9yZWQgPSBiaWRpLmdldE1pcnJvcmVkQ2hhcmFjdGVyKHRleHRbZ2x5cGhJbmZvLmNoYXJJbmRleF0pO1xuICAgICAgICAgICAgICAgIGlmIChtaXJyb3JlZCkge1xuICAgICAgICAgICAgICAgICAgZ2x5cGhJbmZvLmZvbnREYXRhLmZvbnRPYmouZm9yRWFjaEdseXBoKG1pcnJvcmVkLCAwLCAwLCBzZXRHbHlwaE9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gQWRkIGNhcmV0IHBvc2l0aW9uc1xuICAgICAgICAgICAgICBpZiAoaW5jbHVkZUNhcmV0UG9zaXRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qge2NoYXJJbmRleCwgZm9udERhdGF9ID0gZ2x5cGhJbmZvO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhcmV0TGVmdCA9IGdseXBoSW5mby54ICsgYW5jaG9yWE9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjYXJldFJpZ2h0ID0gZ2x5cGhJbmZvLnggKyBnbHlwaEluZm8ud2lkdGggKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDRdID0gcnRsID8gY2FyZXRSaWdodCA6IGNhcmV0TGVmdDsgLy9zdGFydCBlZGdlIHhcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiA0ICsgMV0gPSBydGwgPyBjYXJldExlZnQgOiBjYXJldFJpZ2h0OyAvL2VuZCBlZGdlIHhcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uc1tjaGFySW5kZXggKiA0ICsgMl0gPSBsaW5lLmJhc2VsaW5lICsgZm9udERhdGEuY2FyZXRCb3R0b20gKyBhbmNob3JZT2Zmc2V0OyAvL2NvbW1vbiBib3R0b20geVxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25zW2NoYXJJbmRleCAqIDQgKyAzXSA9IGxpbmUuYmFzZWxpbmUgKyBmb250RGF0YS5jYXJldFRvcCArIGFuY2hvcllPZmZzZXQ7IC8vY29tbW9uIHRvcCB5XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBza2lwcGVkIGFueSBjaGFycyBmcm9tIHRoZSBwcmV2aW91cyBnbHlwaCAoZHVlIHRvIGxpZ2F0dXJlIHN1YnMpLCBmaWxsIGluIGNhcmV0XG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGZvciB0aG9zZSBtaXNzaW5nIGNoYXIgaW5kaWNlczsgY3VycmVudGx5IHRoaXMgdXNlcyBhIGJlc3QtZ3Vlc3MgYnkgZGl2aWRpbmdcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGlnYXR1cmUncyB3aWR0aCBldmVubHkuIEluIHRoZSBmdXR1cmUgd2UgbWF5IHRyeSB0byB1c2UgdGhlIGZvbnQncyBMaWdhdHVyZUNhcmV0TGlzdFxuICAgICAgICAgICAgICAgIC8vIHRhYmxlIHRvIGdldCBiZXR0ZXIgaW50ZXJpb3IgY2FyZXQgcG9zaXRpb25zLlxuICAgICAgICAgICAgICAgIGNvbnN0IGxpZ0NvdW50ID0gY2hhckluZGV4IC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAobGlnQ291bnQgPiAxKSB7XG4gICAgICAgICAgICAgICAgICBmaWxsTGlnYXR1cmVDYXJldFBvc2l0aW9ucyhjYXJldFBvc2l0aW9ucywgcHJldkNoYXJJbmRleCwgbGlnQ291bnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcmV2Q2hhckluZGV4ID0gY2hhckluZGV4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gVHJhY2sgY3VycmVudCBjb2xvciByYW5nZVxuICAgICAgICAgICAgICBpZiAoY29sb3JSYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7Y2hhckluZGV4fSA9IGdseXBoSW5mbztcbiAgICAgICAgICAgICAgICB3aGlsZShjaGFySW5kZXggPiBjb2xvckNoYXJJbmRleCkge1xuICAgICAgICAgICAgICAgICAgY29sb3JDaGFySW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIGlmIChjb2xvclJhbmdlcy5oYXNPd25Qcm9wZXJ0eShjb2xvckNoYXJJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENvbG9yID0gY29sb3JSYW5nZXNbY29sb3JDaGFySW5kZXhdO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEdldCBhdGxhcyBkYXRhIGZvciByZW5kZXJhYmxlIGdseXBoc1xuICAgICAgICAgICAgICBpZiAoIWdseXBoT2JqLmlzV2hpdGVzcGFjZSAmJiAhZ2x5cGhPYmouaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IHJlbmRlcmFibGVHbHlwaEluZGV4Kys7XG4gICAgICAgICAgICAgICAgY29uc3Qge2ZvbnRTaXplTXVsdCwgc3JjOiBmb250U3JjLCBpbmRleDogZm9udEluZGV4fSA9IGdseXBoSW5mby5mb250RGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGlzIGdseXBoJ3MgcGF0aCBkYXRhXG4gICAgICAgICAgICAgICAgY29uc3QgZm9udEdseXBoRGF0YSA9IGdseXBoRGF0YVtmb250U3JjXSB8fCAoZ2x5cGhEYXRhW2ZvbnRTcmNdID0ge30pO1xuICAgICAgICAgICAgICAgIGlmICghZm9udEdseXBoRGF0YVtnbHlwaElkXSkge1xuICAgICAgICAgICAgICAgICAgZm9udEdseXBoRGF0YVtnbHlwaElkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogZ2x5cGhPYmoucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aEJvdW5kczogW2dseXBoT2JqLnhNaW4sIGdseXBoT2JqLnlNaW4sIGdseXBoT2JqLnhNYXgsIGdseXBoT2JqLnlNYXhdXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBmaW5hbCBnbHlwaCBwb3NpdGlvbiBhbmQgYWRkIHRvIGdseXBoUG9zaXRpb25zIGFycmF5XG4gICAgICAgICAgICAgICAgY29uc3QgZ2x5cGhYID0gZ2x5cGhJbmZvLnggKyBhbmNob3JYT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IGdseXBoWSA9IGdseXBoSW5mby55ICsgbGluZS5iYXNlbGluZSArIGFuY2hvcllPZmZzZXQ7XG4gICAgICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnNbaWR4ICogMl0gPSBnbHlwaFg7XG4gICAgICAgICAgICAgICAgZ2x5cGhQb3NpdGlvbnNbaWR4ICogMiArIDFdID0gZ2x5cGhZO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgdG90YWwgdmlzaWJsZSBib3VuZHNcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNYMCA9IGdseXBoWCArIGdseXBoT2JqLnhNaW4gKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgdmlzWTAgPSBnbHlwaFkgKyBnbHlwaE9iai55TWluICogZm9udFNpemVNdWx0O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpc1gxID0gZ2x5cGhYICsgZ2x5cGhPYmoueE1heCAqIGZvbnRTaXplTXVsdDtcbiAgICAgICAgICAgICAgICBjb25zdCB2aXNZMSA9IGdseXBoWSArIGdseXBoT2JqLnlNYXggKiBmb250U2l6ZU11bHQ7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gwIDwgdmlzaWJsZUJvdW5kc1swXSkgdmlzaWJsZUJvdW5kc1swXSA9IHZpc1gwO1xuICAgICAgICAgICAgICAgIGlmICh2aXNZMCA8IHZpc2libGVCb3VuZHNbMV0pIHZpc2libGVCb3VuZHNbMV0gPSB2aXNZMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWDEgPiB2aXNpYmxlQm91bmRzWzJdKSB2aXNpYmxlQm91bmRzWzJdID0gdmlzWDE7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kxID4gdmlzaWJsZUJvdW5kc1szXSkgdmlzaWJsZUJvdW5kc1szXSA9IHZpc1kxO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJhY2sgYm91bmRpbmcgcmVjdHMgZm9yIGVhY2ggY2h1bmsgb2YgTiBnbHlwaHNcbiAgICAgICAgICAgICAgICBpZiAoaWR4ICUgY2h1bmtlZEJvdW5kc1NpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNodW5rID0ge3N0YXJ0OiBpZHgsIGVuZDogaWR4LCByZWN0OiBbSU5GLCBJTkYsIC1JTkYsIC1JTkZdfTtcbiAgICAgICAgICAgICAgICAgIGNodW5rZWRCb3VuZHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNodW5rLmVuZCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rUmVjdCA9IGNodW5rLnJlY3Q7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1gwIDwgY2h1bmtSZWN0WzBdKSBjaHVua1JlY3RbMF0gPSB2aXNYMDtcbiAgICAgICAgICAgICAgICBpZiAodmlzWTAgPCBjaHVua1JlY3RbMV0pIGNodW5rUmVjdFsxXSA9IHZpc1kwO1xuICAgICAgICAgICAgICAgIGlmICh2aXNYMSA+IGNodW5rUmVjdFsyXSkgY2h1bmtSZWN0WzJdID0gdmlzWDE7XG4gICAgICAgICAgICAgICAgaWYgKHZpc1kxID4gY2h1bmtSZWN0WzNdKSBjaHVua1JlY3RbM10gPSB2aXNZMTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCB0byBnbHlwaCBpZHMgYW5kIGZvbnQgaW5kaWNlcyBhcnJheXNcbiAgICAgICAgICAgICAgICBnbHlwaElkc1tpZHhdID0gZ2x5cGhJZDtcbiAgICAgICAgICAgICAgICBnbHlwaEZvbnRJbmRpY2VzW2lkeF0gPSBmb250SW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgY29sb3JzXG4gICAgICAgICAgICAgICAgaWYgKGNvbG9yUmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBzdGFydCA9IGlkeCAqIDM7XG4gICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydF0gPSBjdXJyZW50Q29sb3IgPj4gMTYgJiAyNTU7XG4gICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydCArIDFdID0gY3VycmVudENvbG9yID4+IDggJiAyNTU7XG4gICAgICAgICAgICAgICAgICBnbHlwaENvbG9yc1tzdGFydCArIDJdID0gY3VycmVudENvbG9yICYgMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gRmlsbCBpbiByZW1haW5pbmcgY2FyZXQgcG9zaXRpb25zIGluIGNhc2UgdGhlIGZpbmFsIGNoYXJhY3RlciB3YXMgYSBsaWdhdHVyZVxuICAgICAgICBpZiAoY2FyZXRQb3NpdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBsaWdDb3VudCA9IHRleHQubGVuZ3RoIC0gcHJldkNoYXJJbmRleDtcbiAgICAgICAgICBpZiAobGlnQ291bnQgPiAxKSB7XG4gICAgICAgICAgICBmaWxsTGlnYXR1cmVDYXJldFBvc2l0aW9ucyhjYXJldFBvc2l0aW9ucywgcHJldkNoYXJJbmRleCwgbGlnQ291bnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBBc3NlbWJsZSBmaW5hbCBkYXRhIGFib3V0IGVhY2ggZm9udCB1c2VkXG4gICAgICBjb25zdCBmb250RGF0YSA9IFtdO1xuICAgICAgbWV0cmljc0J5Rm9udC5mb3JFYWNoKCh7aW5kZXgsIHNyYywgdW5pdHNQZXJFbSwgYXNjZW5kZXIsIGRlc2NlbmRlciwgbGluZUhlaWdodCwgY2FwSGVpZ2h0LCB4SGVpZ2h0fSkgPT4ge1xuICAgICAgICBmb250RGF0YVtpbmRleF0gPSB7c3JjLCB1bml0c1BlckVtLCBhc2NlbmRlciwgZGVzY2VuZGVyLCBsaW5lSGVpZ2h0LCBjYXBIZWlnaHQsIHhIZWlnaHR9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFRpbWluZyBzdGF0c1xuICAgICAgdGltaW5ncy50eXBlc2V0dGluZyA9IG5vdygpIC0gdHlwZXNldFN0YXJ0O1xuXG4gICAgICBjYWxsYmFjayh7XG4gICAgICAgIGdseXBoSWRzLCAvL2lkIGZvciBlYWNoIGdseXBoLCBzcGVjaWZpYyB0byB0aGF0IGdseXBoJ3MgZm9udFxuICAgICAgICBnbHlwaEZvbnRJbmRpY2VzLCAvL2luZGV4IGludG8gZm9udERhdGEgZm9yIGVhY2ggZ2x5cGhcbiAgICAgICAgZ2x5cGhQb3NpdGlvbnMsIC8veCx5IG9mIGVhY2ggZ2x5cGgncyBvcmlnaW4gaW4gbGF5b3V0XG4gICAgICAgIGdseXBoRGF0YSwgLy9kaWN0IGhvbGRpbmcgZGF0YSBhYm91dCBlYWNoIGdseXBoIGFwcGVhcmluZyBpbiB0aGUgdGV4dFxuICAgICAgICBmb250RGF0YSwgLy9kYXRhIGFib3V0IGVhY2ggZm9udCB1c2VkIGluIHRoZSB0ZXh0XG4gICAgICAgIGNhcmV0UG9zaXRpb25zLCAvL3N0YXJ0WCxlbmRYLGJvdHRvbVkgY2FyZXQgcG9zaXRpb25zIGZvciBlYWNoIGNoYXJcbiAgICAgICAgLy8gY2FyZXRIZWlnaHQsIC8vaGVpZ2h0IG9mIGN1cnNvciBmcm9tIGJvdHRvbSB0byB0b3AgLSB0b2RvIHBlciBnbHlwaD9cbiAgICAgICAgZ2x5cGhDb2xvcnMsIC8vY29sb3IgZm9yIGVhY2ggZ2x5cGgsIGlmIGNvbG9yIHJhbmdlcyBzdXBwbGllZFxuICAgICAgICBjaHVua2VkQm91bmRzLCAvL3RvdGFsIHJlY3RzIHBlciAobj1jaHVua2VkQm91bmRzU2l6ZSkgY29uc2VjdXRpdmUgZ2x5cGhzXG4gICAgICAgIGZvbnRTaXplLCAvL2NhbGN1bGF0ZWQgZW0gaGVpZ2h0XG4gICAgICAgIHRvcEJhc2VsaW5lOiBhbmNob3JZT2Zmc2V0ICsgbGluZXNbMF0uYmFzZWxpbmUsIC8veSBjb29yZGluYXRlIG9mIHRoZSB0b3AgbGluZSdzIGJhc2VsaW5lXG4gICAgICAgIGJsb2NrQm91bmRzOiBbIC8vYm91bmRzIGZvciB0aGUgd2hvbGUgYmxvY2sgb2YgdGV4dCwgaW5jbHVkaW5nIHZlcnRpY2FsIHBhZGRpbmcgZm9yIGxpbmVIZWlnaHRcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0LFxuICAgICAgICAgIGFuY2hvcllPZmZzZXQgLSB0b3RhbEhlaWdodCxcbiAgICAgICAgICBhbmNob3JYT2Zmc2V0ICsgbWF4TGluZVdpZHRoLFxuICAgICAgICAgIGFuY2hvcllPZmZzZXRcbiAgICAgICAgXSxcbiAgICAgICAgdmlzaWJsZUJvdW5kcywgLy90b3RhbCBib3VuZHMgb2YgdmlzaWJsZSB0ZXh0IHBhdGhzLCBtYXkgYmUgbGFyZ2VyIG9yIHNtYWxsZXIgdGhhbiBibG9ja0JvdW5kc1xuICAgICAgICB0aW1pbmdzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIEZvciBhIGdpdmVuIHRleHQgc3RyaW5nIGFuZCBmb250IHBhcmFtZXRlcnMsIGRldGVybWluZSB0aGUgcmVzdWx0aW5nIGJsb2NrIGRpbWVuc2lvbnNcbiAgICogYWZ0ZXIgd3JhcHBpbmcgZm9yIHRoZSBnaXZlbiBtYXhXaWR0aC5cbiAgICogQHBhcmFtIGFyZ3NcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICBmdW5jdGlvbiBtZWFzdXJlKGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgdHlwZXNldCh7Li4uYXJncywgbWV0cmljc09ubHk6IHRydWV9LCAocmVzdWx0KSA9PiB7XG4gICAgICBjb25zdCBbeDAsIHkwLCB4MSwgeTFdID0gcmVzdWx0LmJsb2NrQm91bmRzO1xuICAgICAgY2FsbGJhY2soe1xuICAgICAgICB3aWR0aDogeDEgLSB4MCxcbiAgICAgICAgaGVpZ2h0OiB5MSAtIHkwXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUGVyY2VudChzdHIpIHtcbiAgICBsZXQgbWF0Y2ggPSBzdHIubWF0Y2goL14oW1xcZC5dKyklJC8pO1xuICAgIGxldCBwY3QgPSBtYXRjaCA/IHBhcnNlRmxvYXQobWF0Y2hbMV0pIDogTmFOO1xuICAgIHJldHVybiBpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMFxuICB9XG5cbiAgZnVuY3Rpb24gZmlsbExpZ2F0dXJlQ2FyZXRQb3NpdGlvbnMoY2FyZXRQb3NpdGlvbnMsIGxpZ1N0YXJ0SW5kZXgsIGxpZ0NvdW50KSB7XG4gICAgY29uc3QgbGlnU3RhcnRYID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDRdO1xuICAgIGNvbnN0IGxpZ0VuZFggPSBjYXJldFBvc2l0aW9uc1tsaWdTdGFydEluZGV4ICogNCArIDFdO1xuICAgIGNvbnN0IGxpZ0JvdHRvbSA9IGNhcmV0UG9zaXRpb25zW2xpZ1N0YXJ0SW5kZXggKiA0ICsgMl07XG4gICAgY29uc3QgbGlnVG9wID0gY2FyZXRQb3NpdGlvbnNbbGlnU3RhcnRJbmRleCAqIDQgKyAzXTtcbiAgICBjb25zdCBndWVzc2VkQWR2YW5jZVggPSAobGlnRW5kWCAtIGxpZ1N0YXJ0WCkgLyBsaWdDb3VudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpZ0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSAobGlnU3RhcnRJbmRleCArIGkpICogNDtcbiAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXhdID0gbGlnU3RhcnRYICsgZ3Vlc3NlZEFkdmFuY2VYICogaTtcbiAgICAgIGNhcmV0UG9zaXRpb25zW3N0YXJ0SW5kZXggKyAxXSA9IGxpZ1N0YXJ0WCArIGd1ZXNzZWRBZHZhbmNlWCAqIChpICsgMSk7XG4gICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4ICsgMl0gPSBsaWdCb3R0b207XG4gICAgICBjYXJldFBvc2l0aW9uc1tzdGFydEluZGV4ICsgM10gPSBsaWdUb3A7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm93KCkge1xuICAgIHJldHVybiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKVxuICB9XG5cbiAgLy8gQXJyYXktYmFja2VkIHN0cnVjdHVyZSBmb3IgYSBzaW5nbGUgbGluZSdzIGdseXBocyBkYXRhXG4gIGZ1bmN0aW9uIFRleHRMaW5lKCkge1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG4gIGNvbnN0IHRleHRMaW5lUHJvcHMgPSBbJ2dseXBoT2JqJywgJ3gnLCAneScsICd3aWR0aCcsICdjaGFySW5kZXgnLCAnZm9udERhdGEnXTtcbiAgVGV4dExpbmUucHJvdG90eXBlID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGxpbmVIZWlnaHQ6IDAsXG4gICAgYmFzZWxpbmU6IDAsXG4gICAgY2FwOiAwLFxuICAgIGV4OiAwLFxuICAgIGlzU29mdFdyYXBwZWQ6IGZhbHNlLFxuICAgIGdldCBjb3VudCgpIHtcbiAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5kYXRhLmxlbmd0aCAvIHRleHRMaW5lUHJvcHMubGVuZ3RoKVxuICAgIH0sXG4gICAgZ2x5cGhBdChpKSB7XG4gICAgICBsZXQgZmx5ID0gVGV4dExpbmUuZmx5d2VpZ2h0O1xuICAgICAgZmx5LmRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICBmbHkuaW5kZXggPSBpO1xuICAgICAgcmV0dXJuIGZseVxuICAgIH0sXG4gICAgc3BsaXRBdChpKSB7XG4gICAgICBsZXQgbmV3TGluZSA9IG5ldyBUZXh0TGluZSgpO1xuICAgICAgbmV3TGluZS5kYXRhID0gdGhpcy5kYXRhLnNwbGljZShpICogdGV4dExpbmVQcm9wcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ld0xpbmVcbiAgICB9XG4gIH07XG4gIFRleHRMaW5lLmZseXdlaWdodCA9IHRleHRMaW5lUHJvcHMucmVkdWNlKChvYmosIHByb3AsIGksIGFsbCkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLmluZGV4ICogdGV4dExpbmVQcm9wcy5sZW5ndGggKyBpXVxuICAgICAgfSxcbiAgICAgIHNldCh2YWwpIHtcbiAgICAgICAgdGhpcy5kYXRhW3RoaXMuaW5kZXggKiB0ZXh0TGluZVByb3BzLmxlbmd0aCArIGldID0gdmFsO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpcbiAgfSwge2RhdGE6IG51bGwsIGluZGV4OiAwfSk7XG5cblxuICByZXR1cm4ge1xuICAgIHR5cGVzZXQsXG4gICAgbWVhc3VyZSxcbiAgfVxufVxuXG5jb25zdCBub3cgPSAoKSA9PiAoc2VsZi5wZXJmb3JtYW5jZSB8fCBEYXRlKS5ub3coKTtcblxuY29uc3QgbWFpblRocmVhZEdlbmVyYXRvciA9IC8qI19fUFVSRV9fKi8gY3JlYXRlU0RGR2VuZXJhdG9yKCk7XG5cbmxldCB3YXJuZWQ7XG5cbi8qKlxuICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgc2luZ2xlIGdseXBoIHBhdGgsIHBsYWNpbmcgdGhlIHJlc3VsdCBpbnRvIGEgd2ViZ2wgY2FudmFzIGF0IGFcbiAqIGdpdmVuIGxvY2F0aW9uIGFuZCBjaGFubmVsLiBVdGlsaXplcyB0aGUgd2ViZ2wtc2RmLWdlbmVyYXRvciBleHRlcm5hbCBwYWNrYWdlIGZvciBHUFUtYWNjZWxlcmF0ZWQgU0RGXG4gKiBnZW5lcmF0aW9uIHdoZW4gc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVNERih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCwgdXNlV2ViR0wgPSB0cnVlKSB7XG4gIC8vIEFsbG93IG9wdC1vdXRcbiAgaWYgKCF1c2VXZWJHTCkge1xuICAgIHJldHVybiBnZW5lcmF0ZVNERl9KU19Xb3JrZXIod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50LCBjYW52YXMsIHgsIHksIGNoYW5uZWwpXG4gIH1cblxuICAvLyBBdHRlbXB0IEdQVS1hY2NlbGVyYXRlZCBnZW5lcmF0aW9uIGZpcnN0XG4gIHJldHVybiBnZW5lcmF0ZVNERl9HTCh3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkudGhlbihcbiAgICBudWxsLFxuICAgIGVyciA9PiB7XG4gICAgICAvLyBXZWJHTCBmYWlsZWQgZWl0aGVyIGR1ZSB0byBhIGhhcmQgZXJyb3Igb3IgdW5leHBlY3RlZCByZXN1bHRzOyBmYWxsIGJhY2sgdG8gSlMgaW4gd29ya2Vyc1xuICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKU2AsIGVycik7XG4gICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2VuZXJhdGVTREZfSlNfV29ya2VyKHdpZHRoLCBoZWlnaHQsIHBhdGgsIHZpZXdCb3gsIGRpc3RhbmNlLCBleHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKVxuICAgIH1cbiAgKVxufVxuXG5jb25zdCBxdWV1ZSA9IFtdO1xuY29uc3QgY2h1bmtUaW1lQnVkZ2V0ID0gNTsgLy8gbXNcbmxldCB0aW1lciA9IDA7XG5cbmZ1bmN0aW9uIG5leHRDaHVuaygpIHtcbiAgY29uc3Qgc3RhcnQgPSBub3coKTtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAmJiBub3coKSAtIHN0YXJ0IDwgY2h1bmtUaW1lQnVkZ2V0KSB7XG4gICAgcXVldWUuc2hpZnQoKSgpO1xuICB9XG4gIHRpbWVyID0gcXVldWUubGVuZ3RoID8gc2V0VGltZW91dChuZXh0Q2h1bmssIDApIDogMDtcbn1cblxuLyoqXG4gKiBXZWJHTC1iYXNlZCBpbXBsZW1lbnRhdGlvbiBleGVjdXRlZCBvbiB0aGUgbWFpbiB0aHJlYWQuIFJlcXVlc3RzIGFyZSBleGVjdXRlZCBpbiB0aW1lLWJvdW5kZWRcbiAqIG1hY3JvdGFzayBjaHVua3MgdG8gYWxsb3cgcmVuZGVyIGZyYW1lcyB0byBleGVjdXRlIGluIGJldHdlZW4uXG4gKi9cbmNvbnN0IGdlbmVyYXRlU0RGX0dMID0gKC4uLmFyZ3MpID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBxdWV1ZS5wdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICB0cnkge1xuICAgICAgICBtYWluVGhyZWFkR2VuZXJhdG9yLndlYmdsLmdlbmVyYXRlSW50b0NhbnZhcyguLi5hcmdzKTtcbiAgICAgICAgcmVzb2x2ZSh7IHRpbWluZzogbm93KCkgLSBzdGFydCB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIXRpbWVyKSB7XG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQobmV4dENodW5rLCAwKTtcbiAgICB9XG4gIH0pXG59O1xuXG5jb25zdCB0aHJlYWRDb3VudCA9IDQ7IC8vIGhvdyBtYW55IHdvcmtlcnMgdG8gc3Bhd25cbmNvbnN0IGlkbGVUaW1lb3V0ID0gMjAwMDsgLy8gd29ya2VycyB3aWxsIGJlIHRlcm1pbmF0ZWQgYWZ0ZXIgYmVpbmcgaWRsZSB0aGlzIG1hbnkgbWlsbGlzZWNvbmRzXG5jb25zdCB0aHJlYWRzID0ge307XG5sZXQgY2FsbE51bSA9IDA7XG5cbi8qKlxuICogRmFsbGJhY2sgSlMtYmFzZWQgaW1wbGVtZW50YXRpb24sIGZhbm5lZCBvdXQgdG8gYSBudW1iZXIgb2Ygd29ya2VyIHRocmVhZHMgZm9yIHBhcmFsbGVsaXNtXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlU0RGX0pTX1dvcmtlcih3aWR0aCwgaGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBkaXN0YW5jZSwgZXhwb25lbnQsIGNhbnZhcywgeCwgeSwgY2hhbm5lbCkge1xuICBjb25zdCB3b3JrZXJJZCA9ICdUcm9pa2FUZXh0U0RGR2VuZXJhdG9yX0pTXycgKyAoKGNhbGxOdW0rKykgJSB0aHJlYWRDb3VudCk7XG4gIGxldCB0aHJlYWQgPSB0aHJlYWRzW3dvcmtlcklkXTtcbiAgaWYgKCF0aHJlYWQpIHtcbiAgICB0aHJlYWQgPSB0aHJlYWRzW3dvcmtlcklkXSA9IHtcbiAgICAgIHdvcmtlck1vZHVsZTogZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgICAgICAgbmFtZTogd29ya2VySWQsXG4gICAgICAgIHdvcmtlcklkLFxuICAgICAgICBkZXBlbmRlbmNpZXM6IFtcbiAgICAgICAgICBjcmVhdGVTREZHZW5lcmF0b3IsXG4gICAgICAgICAgbm93XG4gICAgICAgIF0sXG4gICAgICAgIGluaXQoX2NyZWF0ZVNERkdlbmVyYXRvciwgbm93KSB7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGUgPSBfY3JlYXRlU0RGR2VuZXJhdG9yKCkuamF2YXNjcmlwdC5nZW5lcmF0ZTtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0dXJlRGF0YSA9IGdlbmVyYXRlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdGV4dHVyZURhdGEsXG4gICAgICAgICAgICAgIHRpbWluZzogbm93KCkgLSBzdGFydFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gW3Jlc3VsdC50ZXh0dXJlRGF0YS5idWZmZXJdXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcmVxdWVzdHM6IDAsXG4gICAgICBpZGxlVGltZXI6IG51bGxcbiAgICB9O1xuICB9XG5cbiAgdGhyZWFkLnJlcXVlc3RzKys7XG4gIGNsZWFyVGltZW91dCh0aHJlYWQuaWRsZVRpbWVyKTtcbiAgcmV0dXJuIHRocmVhZC53b3JrZXJNb2R1bGUod2lkdGgsIGhlaWdodCwgcGF0aCwgdmlld0JveCwgZGlzdGFuY2UsIGV4cG9uZW50KVxuICAgIC50aGVuKCh7IHRleHR1cmVEYXRhLCB0aW1pbmcgfSkgPT4ge1xuICAgICAgLy8gY29weSByZXN1bHQgZGF0YSBpbnRvIHRoZSBjYW52YXNcbiAgICAgIGNvbnN0IHN0YXJ0ID0gbm93KCk7XG4gICAgICAvLyBleHBhbmQgc2luZ2xlLWNoYW5uZWwgZGF0YSBpbnRvIHJnYmFcbiAgICAgIGNvbnN0IGltYWdlRGF0YSA9IG5ldyBVaW50OEFycmF5KHRleHR1cmVEYXRhLmxlbmd0aCAqIDQpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0dXJlRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbWFnZURhdGFbaSAqIDQgKyBjaGFubmVsXSA9IHRleHR1cmVEYXRhW2ldO1xuICAgICAgfVxuICAgICAgbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlbmRlckltYWdlRGF0YShjYW52YXMsIGltYWdlRGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSA8PCAoMyAtIGNoYW5uZWwpKTtcbiAgICAgIHRpbWluZyArPSBub3coKSAtIHN0YXJ0O1xuXG4gICAgICAvLyBjbGVhbiB1cCB3b3JrZXJzIGFmdGVyIGEgd2hpbGVcbiAgICAgIGlmICgtLXRocmVhZC5yZXF1ZXN0cyA9PT0gMCkge1xuICAgICAgICB0aHJlYWQuaWRsZVRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7IHRlcm1pbmF0ZVdvcmtlcih3b3JrZXJJZCk7IH0sIGlkbGVUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHRpbWluZyB9XG4gICAgfSlcbn1cblxuZnVuY3Rpb24gd2FybVVwU0RGQ2FudmFzKGNhbnZhcykge1xuICBpZiAoIWNhbnZhcy5fd2FybSkge1xuICAgIG1haW5UaHJlYWRHZW5lcmF0b3Iud2ViZ2wuaXNTdXBwb3J0ZWQoY2FudmFzKTtcbiAgICBjYW52YXMuX3dhcm0gPSB0cnVlO1xuICB9XG59XG5cbmNvbnN0IHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nID0gbWFpblRocmVhZEdlbmVyYXRvci53ZWJnbFV0aWxzLnJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nO1xuXG5jb25zdCBDT05GSUcgPSB7XG4gIGRlZmF1bHRGb250VVJMOiBudWxsLFxuICB1bmljb2RlRm9udHNVUkw6IG51bGwsXG4gIHNkZkdseXBoU2l6ZTogNjQsXG4gIHNkZk1hcmdpbjogMSAvIDE2LFxuICBzZGZFeHBvbmVudDogOSxcbiAgdGV4dHVyZVdpZHRoOiAyMDQ4LFxuICB1c2VXb3JrZXI6IHRydWUsXG59O1xuY29uc3QgdGVtcENvbG9yID0gLyojX19QVVJFX18qL25ldyBDb2xvcigpO1xubGV0IGhhc1JlcXVlc3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBub3ckMSgpIHtcbiAgcmV0dXJuIChzZWxmLnBlcmZvcm1hbmNlIHx8IERhdGUpLm5vdygpXG59XG5cbi8qKlxuICogQ3VzdG9taXplcyB0aGUgdGV4dCBidWlsZGVyIGNvbmZpZ3VyYXRpb24uIFRoaXMgbXVzdCBiZSBjYWxsZWQgcHJpb3IgdG8gdGhlIGZpcnN0IGZvbnQgcHJvY2Vzc2luZ1xuICogcmVxdWVzdCwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb25maWcuZGVmYXVsdEZvbnRVUkwgLSBUaGUgVVJMIG9mIHRoZSBkZWZhdWx0IGZvbnQgdG8gdXNlIGZvciB0ZXh0IHByb2Nlc3NpbmdcbiAqICAgICAgICAgICAgICAgICByZXF1ZXN0cywgaW4gY2FzZSBub25lIGlzIHNwZWNpZmllZCBvciB0aGUgc3BlY2lmaWVkZSBmb250IGZhaWxzIHRvIGxvYWQgb3IgcGFyc2UuXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gXCJSb2JvdG8gUmVndWxhclwiIGZyb20gR29vZ2xlIEZvbnRzLlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbmZpZy51bmljb2RlRm9udHNVUkwgLSBBIGN1c3RvbSBsb2NhdGlvbiBmb3IgdGhlIGZhbGxiYWNrIHVuaWNvZGUtZm9udC1yZXNvbHZlclxuICogICAgICAgICAgICAgICAgIGRhdGEgYW5kIGZvbnQgZmlsZXMsIGlmIHlvdSBkb24ndCB3YW50IHRvIHVzZSB0aGUgZGVmYXVsdCBDRE4uIFNlZVxuICogICAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2pqaWMvdW5pY29kZS1mb250LXJlc29sdmVyIGZvciBkZXRhaWxzLiBJdCBjYW4gYWxzbyBiZVxuICogICAgICAgICAgICAgICAgIGNvbmZpZ3VyZWQgcGVyIHRleHQgaW5zdGFuY2UsIGJ1dCB0aGlzIGxldHMgeW91IGRvIGl0IG9uY2UgZ2xvYmFsbHkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZkdseXBoU2l6ZSAtIFRoZSBkZWZhdWx0IHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKVxuICogICAgICAgICAgICAgICAgIHRleHR1cmUgdXNlZCBmb3IgcmVuZGVyaW5nLiBNdXN0IGJlIGEgcG93ZXItb2YtdHdvIG51bWJlciwgYW5kIGFwcGxpZXMgdG8gYWxsIGZvbnRzLFxuICogICAgICAgICAgICAgICAgIGJ1dCBub3RlIHRoYXQgdGhpcyBjYW4gYWxzbyBiZSBvdmVycmlkZGVuIHBlciBjYWxsIHRvIGBnZXRUZXh0UmVuZGVySW5mbygpYC5cbiAqICAgICAgICAgICAgICAgICBMYXJnZXIgc2l6ZXMgY2FuIGltcHJvdmUgdGhlIHF1YWxpdHkgb2YgZ2x5cGggcmVuZGVyaW5nIGJ5IGluY3JlYXNpbmcgdGhlIHNoYXJwbmVzc1xuICogICAgICAgICAgICAgICAgIG9mIGNvcm5lcnMgYW5kIHByZXZlbnRpbmcgbG9zcyBvZiB2ZXJ5IHRoaW4gbGluZXMsIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeS4gRGVmYXVsdHNcbiAqICAgICAgICAgICAgICAgICB0byA2NCB3aGljaCBpcyBnZW5lcmFsbHkgYSBnb29kIGJhbGFuY2Ugb2Ygc2l6ZSBhbmQgcXVhbGl0eS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBjb25maWcuc2RmRXhwb25lbnQgLSBUaGUgZXhwb25lbnQgdXNlZCB3aGVuIGVuY29kaW5nIHRoZSBTREYgdmFsdWVzLiBBIGhpZ2hlciBleHBvbmVudFxuICogICAgICAgICAgICAgICAgIHNoaWZ0cyB0aGUgZW5jb2RlZCA4LWJpdCB2YWx1ZXMgdG8gYWNoaWV2ZSBoaWdoZXIgcHJlY2lzaW9uL2FjY3VyYWN5IGF0IHRleGVscyBuZWFyZXJcbiAqICAgICAgICAgICAgICAgICB0aGUgZ2x5cGgncyBwYXRoLCB3aXRoIGxvd2VyIHByZWNpc2lvbiBmdXJ0aGVyIGF3YXkuIERlZmF1bHRzIHRvIDkuXG4gKiBAcGFyYW0ge051bWJlcn0gY29uZmlnLnNkZk1hcmdpbiAtIEhvdyBtdWNoIHNwYWNlIHRvIHJlc2VydmUgaW4gdGhlIFNERiBhcyBtYXJnaW4gb3V0c2lkZSB0aGUgZ2x5cGgnc1xuICogICAgICAgICAgICAgICAgIHBhdGgsIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgU0RGIHdpZHRoLiBBIGxhcmdlciBtYXJnaW4gaW5jcmVhc2VzIHRoZSBxdWFsaXR5IG9mXG4gKiAgICAgICAgICAgICAgICAgZXh0cnVkZWQgZ2x5cGggb3V0bGluZXMsIGJ1dCBkZWNyZWFzZXMgdGhlIHByZWNpc2lvbiBhdmFpbGFibGUgZm9yIHRoZSBnbHlwaCBpdHNlbGYuXG4gKiAgICAgICAgICAgICAgICAgRGVmYXVsdHMgdG8gMS8xNnRoIG9mIHRoZSBnbHlwaCBzaXplLlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbmZpZy50ZXh0dXJlV2lkdGggLSBUaGUgd2lkdGggb2YgdGhlIFNERiB0ZXh0dXJlOyBtdXN0IGJlIGEgcG93ZXIgb2YgMi4gRGVmYXVsdHMgdG9cbiAqICAgICAgICAgICAgICAgICAyMDQ4IHdoaWNoIGlzIGEgc2FmZSBtYXhpbXVtIHRleHR1cmUgZGltZW5zaW9uIGFjY29yZGluZyB0byB0aGUgc3RhdHMgYXRcbiAqICAgICAgICAgICAgICAgICBodHRwczovL3dlYmdsc3RhdHMuY29tL3dlYmdsL3BhcmFtZXRlci9NQVhfVEVYVFVSRV9TSVpFIGFuZCBzaG91bGQgYWxsb3cgZm9yIGFcbiAqICAgICAgICAgICAgICAgICByZWFzb25hYmx5IGxhcmdlIG51bWJlciBvZiBnbHlwaHMgKGRlZmF1bHQgZ2x5cGggc2l6ZSBvZiA2NF4yIGFuZCBzYWZlIHRleHR1cmUgc2l6ZSBvZlxuICogICAgICAgICAgICAgICAgIDIwNDheMiwgdGltZXMgNCBjaGFubmVscywgYWxsb3dzIGZvciA0MDk2IGdseXBocy4pIFRoaXMgY2FuIGJlIGluY3JlYXNlZCBpZiB5b3UgbmVlZCB0b1xuICogICAgICAgICAgICAgICAgIGluY3JlYXNlIHRoZSBnbHlwaCBzaXplIGFuZC9vciBoYXZlIGFuIGV4dHJhb3JkaW5hcnkgbnVtYmVyIG9mIGdseXBocy5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY29uZmlnLnVzZVdvcmtlciAtIFdoZXRoZXIgdG8gcnVuIHR5cGVzZXR0aW5nIGluIGEgd2ViIHdvcmtlci4gRGVmYXVsdHMgdG8gdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlVGV4dEJ1aWxkZXIoY29uZmlnKSB7XG4gIGlmIChoYXNSZXF1ZXN0ZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ2NvbmZpZ3VyZVRleHRCdWlsZGVyIGNhbGxlZCBhZnRlciBmaXJzdCBmb250IHJlcXVlc3Q7IHdpbGwgYmUgaWdub3JlZC4nKTtcbiAgfSBlbHNlIHtcbiAgICBhc3NpZ24oQ09ORklHLCBjb25maWcpO1xuICB9XG59XG5cbi8qKlxuICogUmVwb3NpdG9yeSBmb3IgYWxsIGZvbnQgU0RGIGF0bGFzIHRleHR1cmVzIGFuZCB0aGVpciBnbHlwaCBtYXBwaW5ncy4gVGhlcmUgaXMgYSBzZXBhcmF0ZSBhdGxhcyBmb3JcbiAqIGVhY2ggc2RmR2x5cGhTaXplLiBFYWNoIGF0bGFzIGhhcyBhIHNpbmdsZSBUZXh0dXJlIHRoYXQgaG9sZHMgYWxsIGdseXBocyBmb3IgYWxsIGZvbnRzLlxuICpcbiAqICAge1xuICogICAgIFtzZGZHbHlwaFNpemVdOiB7XG4gKiAgICAgICBnbHlwaENvdW50OiBudW1iZXIsXG4gKiAgICAgICBzZGZHbHlwaFNpemU6IG51bWJlcixcbiAqICAgICAgIHNkZlRleHR1cmU6IFRleHR1cmUsXG4gKiAgICAgICBzZGZDYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LFxuICogICAgICAgY29udGV4dExvc3Q6IGJvb2xlYW4sXG4gKiAgICAgICBnbHlwaHNCeUZvbnQ6IE1hcDxmb250VVJMLCBNYXA8Z2x5cGhJRCwge3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9Pj5cbiAqICAgICB9XG4gKiAgIH1cbiAqL1xuY29uc3QgYXRsYXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gVHJvaWthVGV4dFJlbmRlckluZm8gLSBGb3JtYXQgb2YgdGhlIHJlc3VsdCBmcm9tIGBnZXRUZXh0UmVuZGVySW5mb2AuXG4gKiBAcHJvcGVydHkge1R5cGVzZXRQYXJhbXN9IHBhcmFtZXRlcnMgLSBUaGUgbm9ybWFsaXplZCBpbnB1dCBhcmd1bWVudHMgdG8gdGhlIHJlbmRlciBjYWxsLlxuICogQHByb3BlcnR5IHtUZXh0dXJlfSBzZGZUZXh0dXJlIC0gVGhlIFNERiBhdGxhcyB0ZXh0dXJlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkdseXBoU2l6ZSAtIFRoZSBzaXplIG9mIGVhY2ggZ2x5cGgncyBTREY7IHNlZSBgY29uZmlndXJlVGV4dEJ1aWxkZXJgLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNkZkV4cG9uZW50IC0gVGhlIGV4cG9uZW50IHVzZWQgaW4gZW5jb2RpbmcgdGhlIFNERidzIHZhbHVlczsgc2VlIGBjb25maWd1cmVUZXh0QnVpbGRlcmAuXG4gKiBAcHJvcGVydHkge0Zsb2F0MzJBcnJheX0gZ2x5cGhCb3VuZHMgLSBMaXN0IG9mIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBxdWFkIGJvdW5kcyBmb3IgZWFjaCBnbHlwaC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBnbHlwaEF0bGFzSW5kaWNlcyAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgaW5kZXggaW4gdGhlIFNERiBhdGxhcy5cbiAqIEBwcm9wZXJ0eSB7VWludDhBcnJheX0gW2dseXBoQ29sb3JzXSAtIExpc3QgaG9sZGluZyBlYWNoIGdseXBoJ3MgW3IsIGcsIGJdIGNvbG9yLCBpZiBgY29sb3JSYW5nZXNgIHdhcyBzdXBwbGllZC5cbiAqIEBwcm9wZXJ0eSB7RmxvYXQzMkFycmF5fSBbY2FyZXRQb3NpdGlvbnNdIC0gQSBsaXN0IG9mIGNhcmV0IHBvc2l0aW9ucyBmb3IgYWxsIGNoYXJhY3RlcnMgaW4gdGhlIHN0cmluZzsgZWFjaCBpc1xuICogICAgICAgICAgIGZvdXIgZWxlbWVudHM6IHRoZSBzdGFydGluZyBYLCB0aGUgZW5kaW5nIFgsIHRoZSBib3R0b20gWSwgYW5kIHRoZSB0b3AgWSBmb3IgdGhlIGNhcmV0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtjYXJldEhlaWdodF0gLSBBbiBhcHByb3ByaWF0ZSBoZWlnaHQgZm9yIGFsbCBzZWxlY3Rpb24gY2FyZXRzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGFzY2VuZGVyIC0gVGhlIGZvbnQncyBhc2NlbmRlciBtZXRyaWMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGVzY2VuZGVyIC0gVGhlIGZvbnQncyBkZXNjZW5kZXIgbWV0cmljLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGNhcEhlaWdodCAtIFRoZSBmb250J3MgY2FwIGhlaWdodCBtZXRyaWMsIGJhc2VkIG9uIHRoZSBoZWlnaHQgb2YgTGF0aW4gY2FwaXRhbCBsZXR0ZXJzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHhIZWlnaHQgLSBUaGUgZm9udCdzIHggaGVpZ2h0IG1ldHJpYywgYmFzZWQgb24gdGhlIGhlaWdodCBvZiBMYXRpbiBsb3dlcmNhc2UgbGV0dGVycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBsaW5lSGVpZ2h0IC0gVGhlIGZpbmFsIGNvbXB1dGVkIGxpbmVIZWlnaHQgbWVhc3VyZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdG9wQmFzZWxpbmUgLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgdG9wIGxpbmUncyBiYXNlbGluZS5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gYmxvY2tCb3VuZHMgLSBUaGUgdG90YWwgW21pblgsIG1pblksIG1heFgsIG1heFldIHJlY3Qgb2YgdGhlIHdob2xlIHRleHQgYmxvY2s7XG4gKiAgICAgICAgICAgdGhpcyBjYW4gaW5jbHVkZSBleHRyYSB2ZXJ0aWNhbCBzcGFjZSBiZXlvbmQgdGhlIHZpc2libGUgZ2x5cGhzIGR1ZSB0byBsaW5lSGVpZ2h0LCBhbmQgaXNcbiAqICAgICAgICAgICBlcXVpdmFsZW50IHRvIHRoZSBkaW1lbnNpb25zIG9mIGEgYmxvY2stbGV2ZWwgdGV4dCBlbGVtZW50IGluIENTUy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8bnVtYmVyPn0gdmlzaWJsZUJvdW5kcyAtIFRoZSB0b3RhbCBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gcmVjdCBvZiB0aGUgd2hvbGUgdGV4dCBibG9jaztcbiAqICAgICAgICAgICB1bmxpa2UgYGJsb2NrQm91bmRzYCB0aGlzIGlzIHRpZ2h0bHkgd3JhcHBlZCB0byB0aGUgdmlzaWJsZSBnbHlwaCBwYXRocy5cbiAqIEBwcm9wZXJ0eSB7QXJyYXk8b2JqZWN0Pn0gY2h1bmtlZEJvdW5kcyAtIExpc3Qgb2YgYm91bmRpbmcgcmVjdHMgZm9yIGVhY2ggY29uc2VjdXRpdmUgc2V0IG9mIE4gZ2x5cGhzLFxuICogICAgICAgICAgIGluIHRoZSBmb3JtYXQgYHtzdGFydDpOLCBlbmQ6TiwgcmVjdDpbbWluWCwgbWluWSwgbWF4WCwgbWF4WV19YC5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aW1pbmdzIC0gVGltaW5nIGluZm8gZm9yIHZhcmlvdXMgcGFydHMgb2YgdGhlIHJlbmRlcmluZyBsb2dpYyBpbmNsdWRpbmcgU0RGXG4gKiAgICAgICAgICAgZ2VuZXJhdGlvbiwgdHlwZXNldHRpbmcsIGV0Yy5cbiAqIEBmcm96ZW5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBnZXRUZXh0UmVuZGVySW5mb35jYWxsYmFja1xuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAqL1xuXG4vKipcbiAqIE1haW4gZW50cnkgcG9pbnQgZm9yIHJlcXVlc3RpbmcgdGhlIGRhdGEgbmVlZGVkIHRvIHJlbmRlciBhIHRleHQgc3RyaW5nIHdpdGggZ2l2ZW4gZm9udCBwYXJhbWV0ZXJzLlxuICogVGhpcyBpcyBhbiBhc3luY2hyb25vdXMgY2FsbCwgcGVyZm9ybWluZyBtb3N0IG9mIHRoZSBsb2dpYyBpbiBhIHdlYiB3b3JrZXIgdGhyZWFkLlxuICogQHBhcmFtIHtUeXBlc2V0UGFyYW1zfSBhcmdzXG4gKiBAcGFyYW0ge2dldFRleHRSZW5kZXJJbmZvfmNhbGxiYWNrfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBnZXRUZXh0UmVuZGVySW5mbyhhcmdzLCBjYWxsYmFjaykge1xuICBoYXNSZXF1ZXN0ZWQgPSB0cnVlO1xuICBhcmdzID0gYXNzaWduKHt9LCBhcmdzKTtcbiAgY29uc3QgdG90YWxTdGFydCA9IG5vdyQxKCk7XG5cbiAgLy8gQ29udmVydCByZWxhdGl2ZSBVUkwgdG8gYWJzb2x1dGUgc28gaXQgY2FuIGJlIHJlc29sdmVkIGluIHRoZSB3b3JrZXIsIGFuZCBhZGQgZmFsbGJhY2tzLlxuICAvLyBJbiB0aGUgZnV0dXJlIHdlJ2xsIGFsbG93IGFyZ3MuZm9udCB0byBiZSBhIGxpc3Qgd2l0aCB1bmljb2RlIHJhbmdlcyB0b28uXG4gIGNvbnN0IHsgZGVmYXVsdEZvbnRVUkwgfSA9IENPTkZJRztcbiAgY29uc3QgZm9udHMgPSBbXTtcbiAgaWYgKGRlZmF1bHRGb250VVJMKSB7XG4gICAgZm9udHMucHVzaCh7bGFiZWw6ICdkZWZhdWx0Jywgc3JjOiB0b0Fic29sdXRlVVJMKGRlZmF1bHRGb250VVJMKX0pO1xuICB9XG4gIGlmIChhcmdzLmZvbnQpIHtcbiAgICBmb250cy5wdXNoKHtsYWJlbDogJ3VzZXInLCBzcmM6IHRvQWJzb2x1dGVVUkwoYXJncy5mb250KX0pO1xuICB9XG4gIGFyZ3MuZm9udCA9IGZvbnRzO1xuXG4gIC8vIE5vcm1hbGl6ZSB0ZXh0IHRvIGEgc3RyaW5nXG4gIGFyZ3MudGV4dCA9ICcnICsgYXJncy50ZXh0O1xuXG4gIGFyZ3Muc2RmR2x5cGhTaXplID0gYXJncy5zZGZHbHlwaFNpemUgfHwgQ09ORklHLnNkZkdseXBoU2l6ZTtcbiAgYXJncy51bmljb2RlRm9udHNVUkwgPSBhcmdzLnVuaWNvZGVGb250c1VSTCB8fCBDT05GSUcudW5pY29kZUZvbnRzVVJMO1xuXG4gIC8vIE5vcm1hbGl6ZSBjb2xvcnNcbiAgaWYgKGFyZ3MuY29sb3JSYW5nZXMgIT0gbnVsbCkge1xuICAgIGxldCBjb2xvcnMgPSB7fTtcbiAgICBmb3IgKGxldCBrZXkgaW4gYXJncy5jb2xvclJhbmdlcykge1xuICAgICAgaWYgKGFyZ3MuY29sb3JSYW5nZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBsZXQgdmFsID0gYXJncy5jb2xvclJhbmdlc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB2YWwgPSB0ZW1wQ29sb3Iuc2V0KHZhbCkuZ2V0SGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3JzW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfVxuICAgIGFyZ3MuY29sb3JSYW5nZXMgPSBjb2xvcnM7XG4gIH1cblxuICBPYmplY3QuZnJlZXplKGFyZ3MpO1xuXG4gIC8vIEluaXQgdGhlIGF0bGFzIGlmIG5lZWRlZFxuICBjb25zdCB7dGV4dHVyZVdpZHRoLCBzZGZFeHBvbmVudH0gPSBDT05GSUc7XG4gIGNvbnN0IHtzZGZHbHlwaFNpemV9ID0gYXJncztcbiAgY29uc3QgZ2x5cGhzUGVyUm93ID0gKHRleHR1cmVXaWR0aCAvIHNkZkdseXBoU2l6ZSAqIDQpO1xuICBsZXQgYXRsYXMgPSBhdGxhc2VzW3NkZkdseXBoU2l6ZV07XG4gIGlmICghYXRsYXMpIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSB0ZXh0dXJlV2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IHNkZkdseXBoU2l6ZSAqIDI1NiAvIGdseXBoc1BlclJvdzsgLy8gc3RhcnQgdGFsbCBlbm91Z2ggdG8gZml0IDI1NiBnbHlwaHNcbiAgICBhdGxhcyA9IGF0bGFzZXNbc2RmR2x5cGhTaXplXSA9IHtcbiAgICAgIGdseXBoQ291bnQ6IDAsXG4gICAgICBzZGZHbHlwaFNpemUsXG4gICAgICBzZGZDYW52YXM6IGNhbnZhcyxcbiAgICAgIHNkZlRleHR1cmU6IG5ldyBUZXh0dXJlKFxuICAgICAgICBjYW52YXMsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgIExpbmVhckZpbHRlcixcbiAgICAgICAgTGluZWFyRmlsdGVyXG4gICAgICApLFxuICAgICAgY29udGV4dExvc3Q6IGZhbHNlLFxuICAgICAgZ2x5cGhzQnlGb250OiBuZXcgTWFwKClcbiAgICB9O1xuICAgIGF0bGFzLnNkZlRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XG4gICAgaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpO1xuICB9XG5cbiAgY29uc3Qge3NkZlRleHR1cmUsIHNkZkNhbnZhc30gPSBhdGxhcztcblxuICAvLyBJc3N1ZSByZXF1ZXN0IHRvIHRoZSB0eXBlc2V0dGluZyBlbmdpbmUgaW4gdGhlIHdvcmtlclxuICBjb25zdCB0eXBlc2V0ID0gQ09ORklHLnVzZVdvcmtlciA/IHR5cGVzZXRJbldvcmtlciA6IHR5cGVzZXRPbk1haW5UaHJlYWQ7XG4gIHR5cGVzZXQoYXJncykudGhlbihyZXN1bHQgPT4ge1xuICAgIGNvbnN0IHtnbHlwaElkcywgZ2x5cGhGb250SW5kaWNlcywgZm9udERhdGEsIGdseXBoUG9zaXRpb25zLCBmb250U2l6ZSwgdGltaW5nc30gPSByZXN1bHQ7XG4gICAgY29uc3QgbmVlZGVkU0RGcyA9IFtdO1xuICAgIGNvbnN0IGdseXBoQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheShnbHlwaElkcy5sZW5ndGggKiA0KTtcbiAgICBsZXQgYm91bmRzSWR4ID0gMDtcbiAgICBsZXQgcG9zaXRpb25zSWR4ID0gMDtcbiAgICBjb25zdCBxdWFkc1N0YXJ0ID0gbm93JDEoKTtcblxuICAgIGNvbnN0IGZvbnRHbHlwaE1hcHMgPSBmb250RGF0YS5tYXAoZm9udCA9PiB7XG4gICAgICBsZXQgbWFwID0gYXRsYXMuZ2x5cGhzQnlGb250LmdldChmb250LnNyYyk7XG4gICAgICBpZiAoIW1hcCkge1xuICAgICAgICBhdGxhcy5nbHlwaHNCeUZvbnQuc2V0KGZvbnQuc3JjLCBtYXAgPSBuZXcgTWFwKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcFxuICAgIH0pO1xuXG4gICAgZ2x5cGhJZHMuZm9yRWFjaCgoZ2x5cGhJZCwgaSkgPT4ge1xuICAgICAgY29uc3QgZm9udEluZGV4ID0gZ2x5cGhGb250SW5kaWNlc1tpXTtcbiAgICAgIGNvbnN0IHtzcmM6IGZvbnRTcmMsIHVuaXRzUGVyRW19ID0gZm9udERhdGFbZm9udEluZGV4XTtcbiAgICAgIGxldCBnbHlwaEluZm8gPSBmb250R2x5cGhNYXBzW2ZvbnRJbmRleF0uZ2V0KGdseXBoSWQpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZ2x5cGhJZCBub3Qgc2VlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgYXRsYXNcbiAgICAgIGlmICghZ2x5cGhJbmZvKSB7XG4gICAgICAgIGNvbnN0IHtwYXRoLCBwYXRoQm91bmRzfSA9IHJlc3VsdC5nbHlwaERhdGFbZm9udFNyY11bZ2x5cGhJZF07XG5cbiAgICAgICAgLy8gTWFyZ2luIGFyb3VuZCBwYXRoIGVkZ2VzIGluIFNERiwgYmFzZWQgb24gYSBwZXJjZW50YWdlIG9mIHRoZSBnbHlwaCdzIG1heCBkaW1lbnNpb24uXG4gICAgICAgIC8vIE5vdGUgd2UgYWRkIGFuIGV4dHJhIDAuNSBweCBvdmVyIHRoZSBjb25maWd1cmVkIHZhbHVlIGJlY2F1c2UgdGhlIG91dGVyIDAuNSBkb2Vzbid0IGNvbnRhaW5cbiAgICAgICAgLy8gdXNlZnVsIGludGVycG9sYXRlZCB2YWx1ZXMgYW5kIHdpbGwgYmUgaWdub3JlZCBhbnl3YXkuXG4gICAgICAgIGNvbnN0IGZvbnRVbml0c01hcmdpbiA9IE1hdGgubWF4KHBhdGhCb3VuZHNbMl0gLSBwYXRoQm91bmRzWzBdLCBwYXRoQm91bmRzWzNdIC0gcGF0aEJvdW5kc1sxXSlcbiAgICAgICAgICAvIHNkZkdseXBoU2l6ZSAqIChDT05GSUcuc2RmTWFyZ2luICogc2RmR2x5cGhTaXplICsgMC41KTtcblxuICAgICAgICBjb25zdCBhdGxhc0luZGV4ID0gYXRsYXMuZ2x5cGhDb3VudCsrO1xuICAgICAgICBjb25zdCBzZGZWaWV3Qm94ID0gW1xuICAgICAgICAgIHBhdGhCb3VuZHNbMF0gLSBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgICAgcGF0aEJvdW5kc1sxXSAtIGZvbnRVbml0c01hcmdpbixcbiAgICAgICAgICBwYXRoQm91bmRzWzJdICsgZm9udFVuaXRzTWFyZ2luLFxuICAgICAgICAgIHBhdGhCb3VuZHNbM10gKyBmb250VW5pdHNNYXJnaW4sXG4gICAgICAgIF07XG4gICAgICAgIGZvbnRHbHlwaE1hcHNbZm9udEluZGV4XS5zZXQoZ2x5cGhJZCwgKGdseXBoSW5mbyA9IHsgcGF0aCwgYXRsYXNJbmRleCwgc2RmVmlld0JveCB9KSk7XG5cbiAgICAgICAgLy8gQ29sbGVjdCB0aG9zZSB0aGF0IG5lZWQgU0RGIGdlbmVyYXRpb25cbiAgICAgICAgbmVlZGVkU0RGcy5wdXNoKGdseXBoSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBib3VuZHMgZm9yIHJlbmRlcmFibGUgcXVhZHNcbiAgICAgIC8vIFRPRE8gY2FuIHdlIGdldCB0aGlzIGJhY2sgb2ZmIHRoZSBtYWluIHRocmVhZD9cbiAgICAgIGNvbnN0IHtzZGZWaWV3Qm94fSA9IGdseXBoSW5mbztcbiAgICAgIGNvbnN0IHBvc1ggPSBnbHlwaFBvc2l0aW9uc1twb3NpdGlvbnNJZHgrK107XG4gICAgICBjb25zdCBwb3NZID0gZ2x5cGhQb3NpdGlvbnNbcG9zaXRpb25zSWR4KytdO1xuICAgICAgY29uc3QgZm9udFNpemVNdWx0ID0gZm9udFNpemUgLyB1bml0c1BlckVtO1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWCArIHNkZlZpZXdCb3hbMF0gKiBmb250U2l6ZU11bHQ7XG4gICAgICBnbHlwaEJvdW5kc1tib3VuZHNJZHgrK10gPSBwb3NZICsgc2RmVmlld0JveFsxXSAqIGZvbnRTaXplTXVsdDtcbiAgICAgIGdseXBoQm91bmRzW2JvdW5kc0lkeCsrXSA9IHBvc1ggKyBzZGZWaWV3Qm94WzJdICogZm9udFNpemVNdWx0O1xuICAgICAgZ2x5cGhCb3VuZHNbYm91bmRzSWR4KytdID0gcG9zWSArIHNkZlZpZXdCb3hbM10gKiBmb250U2l6ZU11bHQ7XG5cbiAgICAgIC8vIENvbnZlcnQgZ2x5cGhJZCB0byBTREYgaW5kZXggZm9yIHRoZSBzaGFkZXJcbiAgICAgIGdseXBoSWRzW2ldID0gZ2x5cGhJbmZvLmF0bGFzSW5kZXg7XG4gICAgfSk7XG4gICAgdGltaW5ncy5xdWFkcyA9ICh0aW1pbmdzLnF1YWRzIHx8IDApICsgKG5vdyQxKCkgLSBxdWFkc1N0YXJ0KTtcblxuICAgIGNvbnN0IHNkZlN0YXJ0ID0gbm93JDEoKTtcbiAgICB0aW1pbmdzLnNkZiA9IHt9O1xuXG4gICAgLy8gR3JvdyB0aGUgdGV4dHVyZSBoZWlnaHQgYnkgcG93ZXIgb2YgMiBpZiBuZWVkZWRcbiAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gc2RmQ2FudmFzLmhlaWdodDtcbiAgICBjb25zdCBuZWVkZWRSb3dzID0gTWF0aC5jZWlsKGF0bGFzLmdseXBoQ291bnQgLyBnbHlwaHNQZXJSb3cpO1xuICAgIGNvbnN0IG5lZWRlZEhlaWdodCA9IE1hdGgucG93KDIsIE1hdGguY2VpbChNYXRoLmxvZzIobmVlZGVkUm93cyAqIHNkZkdseXBoU2l6ZSkpKTtcbiAgICBpZiAobmVlZGVkSGVpZ2h0ID4gY3VycmVudEhlaWdodCkge1xuICAgICAgLy8gU2luY2UgcmVzaXppbmcgdGhlIGNhbnZhcyBjbGVhcnMgaXRzIHJlbmRlciBidWZmZXIsIGl0IG5lZWRzIHNwZWNpYWwgaGFuZGxpbmcgdG8gY29weSB0aGUgb2xkIGNvbnRlbnRzIG92ZXJcbiAgICAgIGNvbnNvbGUuaW5mbyhgSW5jcmVhc2luZyBTREYgdGV4dHVyZSBzaXplICR7Y3VycmVudEhlaWdodH0tPiR7bmVlZGVkSGVpZ2h0fWApO1xuICAgICAgcmVzaXplV2ViR0xDYW52YXNXaXRob3V0Q2xlYXJpbmcoc2RmQ2FudmFzLCB0ZXh0dXJlV2lkdGgsIG5lZWRlZEhlaWdodCk7XG4gICAgICAvLyBBcyBvZiBUaHJlZSByMTM2IHRleHR1cmVzIGNhbm5vdCBiZSByZXNpemVkIG9uY2UgdGhleSdyZSBhbGxvY2F0ZWQgb24gdGhlIEdQVSwgd2UgbXVzdCBkaXNwb3NlIHRvIHJlYWxsb2NhdGUgaXRcbiAgICAgIHNkZlRleHR1cmUuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIFByb21pc2UuYWxsKG5lZWRlZFNERnMubWFwKGdseXBoSW5mbyA9PlxuICAgICAgZ2VuZXJhdGVHbHlwaFNERihnbHlwaEluZm8sIGF0bGFzLCBhcmdzLmdwdUFjY2VsZXJhdGVTREYpLnRoZW4oKHt0aW1pbmd9KSA9PiB7XG4gICAgICAgIHRpbWluZ3Muc2RmW2dseXBoSW5mby5hdGxhc0luZGV4XSA9IHRpbWluZztcbiAgICAgIH0pXG4gICAgKSkudGhlbigoKSA9PiB7XG4gICAgICBpZiAobmVlZGVkU0RGcy5sZW5ndGggJiYgIWF0bGFzLmNvbnRleHRMb3N0KSB7XG4gICAgICAgIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcyk7XG4gICAgICAgIHNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGltaW5ncy5zZGZUb3RhbCA9IG5vdyQxKCkgLSBzZGZTdGFydDtcbiAgICAgIHRpbWluZ3MudG90YWwgPSBub3ckMSgpIC0gdG90YWxTdGFydDtcbiAgICAgIC8vIGNvbnNvbGUubG9nKGBTREYgLSAke3RpbWluZ3Muc2RmVG90YWx9LCBUb3RhbCAtICR7dGltaW5ncy50b3RhbCAtIHRpbWluZ3MuZm9udExvYWR9YClcblxuICAgICAgLy8gSW52b2tlIGNhbGxiYWNrIHdpdGggdGhlIHRleHQgbGF5b3V0IGFycmF5cyBhbmQgdXBkYXRlZCB0ZXh0dXJlXG4gICAgICBjYWxsYmFjayhPYmplY3QuZnJlZXplKHtcbiAgICAgICAgcGFyYW1ldGVyczogYXJncyxcbiAgICAgICAgc2RmVGV4dHVyZSxcbiAgICAgICAgc2RmR2x5cGhTaXplLFxuICAgICAgICBzZGZFeHBvbmVudCxcbiAgICAgICAgZ2x5cGhCb3VuZHMsXG4gICAgICAgIGdseXBoQXRsYXNJbmRpY2VzOiBnbHlwaElkcyxcbiAgICAgICAgZ2x5cGhDb2xvcnM6IHJlc3VsdC5nbHlwaENvbG9ycyxcbiAgICAgICAgY2FyZXRQb3NpdGlvbnM6IHJlc3VsdC5jYXJldFBvc2l0aW9ucyxcbiAgICAgICAgY2h1bmtlZEJvdW5kczogcmVzdWx0LmNodW5rZWRCb3VuZHMsXG4gICAgICAgIGFzY2VuZGVyOiByZXN1bHQuYXNjZW5kZXIsXG4gICAgICAgIGRlc2NlbmRlcjogcmVzdWx0LmRlc2NlbmRlcixcbiAgICAgICAgbGluZUhlaWdodDogcmVzdWx0LmxpbmVIZWlnaHQsXG4gICAgICAgIGNhcEhlaWdodDogcmVzdWx0LmNhcEhlaWdodCxcbiAgICAgICAgeEhlaWdodDogcmVzdWx0LnhIZWlnaHQsXG4gICAgICAgIHRvcEJhc2VsaW5lOiByZXN1bHQudG9wQmFzZWxpbmUsXG4gICAgICAgIGJsb2NrQm91bmRzOiByZXN1bHQuYmxvY2tCb3VuZHMsXG4gICAgICAgIHZpc2libGVCb3VuZHM6IHJlc3VsdC52aXNpYmxlQm91bmRzLFxuICAgICAgICB0aW1pbmdzOiByZXN1bHQudGltaW5ncyxcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gV2hpbGUgdGhlIHR5cGVzZXR0aW5nIHJlcXVlc3QgaXMgYmVpbmcgaGFuZGxlZCwgZ28gYWhlYWQgYW5kIG1ha2Ugc3VyZSB0aGUgYXRsYXMgY2FudmFzIGNvbnRleHQgaXNcbiAgLy8gXCJ3YXJtZWQgdXBcIjsgdGhlIGZpcnN0IHJlcXVlc3Qgd2lsbCBiZSB0aGUgbG9uZ2VzdCBkdWUgdG8gc2hhZGVyIHByb2dyYW0gY29tcGlsYXRpb24gc28gdGhpcyBnZXRzXG4gIC8vIGEgaGVhZCBzdGFydCBvbiB0aGF0IHByb2Nlc3MgYmVmb3JlIFNERnMgYWN0dWFsbHkgc3RhcnQgZ2V0dGluZyBwcm9jZXNzZWQuXG4gIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgIGlmICghYXRsYXMuY29udGV4dExvc3QpIHtcbiAgICAgIHdhcm1VcFNERkNhbnZhcyhzZGZDYW52YXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlR2x5cGhTREYoe3BhdGgsIGF0bGFzSW5kZXgsIHNkZlZpZXdCb3h9LCB7c2RmR2x5cGhTaXplLCBzZGZDYW52YXMsIGNvbnRleHRMb3N0fSwgdXNlR1BVKSB7XG4gIGlmIChjb250ZXh0TG9zdCkge1xuICAgIC8vIElmIHRoZSBjb250ZXh0IGlzIGxvc3QgdGhlcmUncyBub3RoaW5nIHdlIGNhbiBkbywganVzdCBxdWl0IHNpbGVudGx5IGFuZCBsZXQgaXRcbiAgICAvLyBnZXQgcmVnZW5lcmF0ZWQgd2hlbiB0aGUgY29udGV4dCBpcyByZXN0b3JlZFxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe3RpbWluZzogLTF9KVxuICB9XG4gIGNvbnN0IHt0ZXh0dXJlV2lkdGgsIHNkZkV4cG9uZW50fSA9IENPTkZJRztcbiAgY29uc3QgbWF4RGlzdCA9IE1hdGgubWF4KHNkZlZpZXdCb3hbMl0gLSBzZGZWaWV3Qm94WzBdLCBzZGZWaWV3Qm94WzNdIC0gc2RmVmlld0JveFsxXSk7XG4gIGNvbnN0IHNxdWFyZUluZGV4ID0gTWF0aC5mbG9vcihhdGxhc0luZGV4IC8gNCk7XG4gIGNvbnN0IHggPSBzcXVhcmVJbmRleCAlICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpICogc2RmR2x5cGhTaXplO1xuICBjb25zdCB5ID0gTWF0aC5mbG9vcihzcXVhcmVJbmRleCAvICh0ZXh0dXJlV2lkdGggLyBzZGZHbHlwaFNpemUpKSAqIHNkZkdseXBoU2l6ZTtcbiAgY29uc3QgY2hhbm5lbCA9IGF0bGFzSW5kZXggJSA0O1xuICByZXR1cm4gZ2VuZXJhdGVTREYoc2RmR2x5cGhTaXplLCBzZGZHbHlwaFNpemUsIHBhdGgsIHNkZlZpZXdCb3gsIG1heERpc3QsIHNkZkV4cG9uZW50LCBzZGZDYW52YXMsIHgsIHksIGNoYW5uZWwsIHVzZUdQVSlcbn1cblxuZnVuY3Rpb24gaW5pdENvbnRleHRMb3NzSGFuZGxpbmcoYXRsYXMpIHtcbiAgY29uc3QgY2FudmFzID0gYXRsYXMuc2RmQ2FudmFzO1xuXG4gIC8qXG4gIC8vIEJlZ2luIGNvbnRleHQgbG9zcyBzaW11bGF0aW9uXG4gIGlmICghd2luZG93LldlYkdMRGVidWdVdGlscykge1xuICAgIGxldCBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnV2ViR0xEZWJ1Z1V0aWxzU2NyaXB0JylcbiAgICBpZiAoIXNjcmlwdCkge1xuICAgICAgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JylcbiAgICAgIHNjcmlwdC5pZCA9ICdXZWJHTERlYnVnVXRpbHMnXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcbiAgICAgIHNjcmlwdC5zcmMgPSAnaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL0tocm9ub3NHcm91cC9XZWJHTERldmVsb3BlclRvb2xzQGI0MmU3MDIvc3JjL2RlYnVnL3dlYmdsLWRlYnVnLmpzJ1xuICAgIH1cbiAgICBzY3JpcHQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGluaXRDb250ZXh0TG9zc0hhbmRsaW5nKGF0bGFzKVxuICAgIH0pXG4gICAgcmV0dXJuXG4gIH1cbiAgd2luZG93LldlYkdMRGVidWdVdGlscy5tYWtlTG9zdENvbnRleHRTaW11bGF0aW5nQ2FudmFzKGNhbnZhcylcbiAgY2FudmFzLmxvc2VDb250ZXh0SW5OQ2FsbHMoNTAwKVxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICBjYW52YXMubG9zZUNvbnRleHRJbk5DYWxscyg1MDAwKVxuICB9KVxuICAvLyBFbmQgY29udGV4dCBsb3NzIHNpbXVsYXRpb25cbiAgKi9cblxuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIChldmVudCkgPT4ge1xuICAgIGNvbnNvbGUubG9nKCdDb250ZXh0IExvc3QnLCBldmVudCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBhdGxhcy5jb250ZXh0TG9zdCA9IHRydWU7XG4gIH0pO1xuICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCAoZXZlbnQpID0+IHtcbiAgICBjb25zb2xlLmxvZygnQ29udGV4dCBSZXN0b3JlZCcsIGV2ZW50KTtcbiAgICBhdGxhcy5jb250ZXh0TG9zdCA9IGZhbHNlO1xuICAgIC8vIFJlZ2VuZXJhdGUgYWxsIGdseXBocyBpbnRvIHRoZSByZXN0b3JlZCBjYW52YXM6XG4gICAgY29uc3QgcHJvbWlzZXMgPSBbXTtcbiAgICBhdGxhcy5nbHlwaHNCeUZvbnQuZm9yRWFjaChnbHlwaE1hcCA9PiB7XG4gICAgICBnbHlwaE1hcC5mb3JFYWNoKGdseXBoID0+IHtcbiAgICAgICAgcHJvbWlzZXMucHVzaChnZW5lcmF0ZUdseXBoU0RGKGdseXBoLCBhdGxhcywgdHJ1ZSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgc2FmYXJpUHJlMTVXb3JrYXJvdW5kKGF0bGFzKTtcbiAgICAgIGF0bGFzLnNkZlRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQcmVsb2FkIGEgZ2l2ZW4gZm9udCBhbmQgb3B0aW9uYWxseSBwcmUtZ2VuZXJhdGUgZ2x5cGggU0RGcyBmb3Igb25lIG9yIG1vcmUgY2hhcmFjdGVyIHNlcXVlbmNlcy5cbiAqIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBhdm9pZCBsb25nIHBhdXNlcyB3aGVuIGZpcnN0IHNob3dpbmcgdGV4dCBpbiBhIHNjZW5lLCBieSBwcmVsb2FkaW5nIHRoZVxuICogbmVlZGVkIGZvbnRzIGFuZCBnbHlwaHMgdXAgZnJvbnQgYWxvbmcgd2l0aCBvdGhlciBhc3NldHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZvbnQgLSBVUkwgb2YgdGhlIGZvbnQgZmlsZSB0byBwcmVsb2FkLiBJZiBub3QgZ2l2ZW4sIHRoZSBkZWZhdWx0IGZvbnQgd2lsbFxuICogICAgICAgIGJlIGxvYWRlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBvcHRpb25zLmNoYXJhY3RlcnMgLSBPbmUgb3IgbW9yZSBjaGFyYWN0ZXIgc2VxdWVuY2VzIGZvciB3aGljaCB0byBwcmUtXG4gKiAgICAgICAgZ2VuZXJhdGUgZ2x5cGggU0RGcy4gTm90ZSB0aGF0IHRoaXMgd2lsbCBob25vciBsaWdhdHVyZSBzdWJzdGl0dXRpb24sIHNvIHlvdSBtYXkgbmVlZFxuICogICAgICAgIHRvIHNwZWNpZnkgbGlnYXR1cmUgc2VxdWVuY2VzIGluIGFkZGl0aW9uIHRvIHRoZWlyIGluZGl2aWR1YWwgY2hhcmFjdGVycyB0byBnZXQgYWxsXG4gKiAgICAgICAgcG9zc2libGUgZ2x5cGhzLCBlLmcuIGBbXCJ0XCIsIFwiaFwiLCBcInRoXCJdYCB0byBnZXQgdGhlIFwidFwiIGFuZCBcImhcIiBnbHlwaHMgcGx1cyB0aGUgXCJ0aFwiIGxpZ2F0dXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuc2RmR2x5cGhTaXplIC0gVGhlIHNpemUgYXQgd2hpY2ggdG8gcHJlcmVuZGVyIHRoZSBTREYgdGV4dHVyZXMgZm9yIHRoZVxuICogICAgICAgIHNwZWNpZmllZCBgY2hhcmFjdGVyc2AuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBwcmVsb2FkaW5nIGlzIGNvbXBsZXRlLlxuICovXG5mdW5jdGlvbiBwcmVsb2FkRm9udCh7Zm9udCwgY2hhcmFjdGVycywgc2RmR2x5cGhTaXplfSwgY2FsbGJhY2spIHtcbiAgbGV0IHRleHQgPSBBcnJheS5pc0FycmF5KGNoYXJhY3RlcnMpID8gY2hhcmFjdGVycy5qb2luKCdcXG4nKSA6ICcnICsgY2hhcmFjdGVycztcbiAgZ2V0VGV4dFJlbmRlckluZm8oeyBmb250LCBzZGZHbHlwaFNpemUsIHRleHQgfSwgY2FsbGJhY2spO1xufVxuXG5cbi8vIExvY2FsIGFzc2lnbiBpbXBsIHNvIHdlIGRvbid0IGhhdmUgdG8gaW1wb3J0IHRyb2lrYS1jb3JlXG5mdW5jdGlvbiBhc3NpZ24odG9PYmosIGZyb21PYmopIHtcbiAgZm9yIChsZXQga2V5IGluIGZyb21PYmopIHtcbiAgICBpZiAoZnJvbU9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICB0b09ialtrZXldID0gZnJvbU9ialtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9PYmpcbn1cblxuLy8gVXRpbGl0eSBmb3IgbWFraW5nIFVSTHMgYWJzb2x1dGVcbmxldCBsaW5rRWw7XG5mdW5jdGlvbiB0b0Fic29sdXRlVVJMKHBhdGgpIHtcbiAgaWYgKCFsaW5rRWwpIHtcbiAgICBsaW5rRWwgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnID8ge30gOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIH1cbiAgbGlua0VsLmhyZWYgPSBwYXRoO1xuICByZXR1cm4gbGlua0VsLmhyZWZcbn1cblxuLyoqXG4gKiBTYWZhcmkgPCB2MTUgc2VlbXMgdW5hYmxlIHRvIHVzZSB0aGUgU0RGIHdlYmdsIGNhbnZhcyBhcyBhIHRleHR1cmUuIFRoaXMgYXBwbGllcyBhIHdvcmthcm91bmRcbiAqIHdoZXJlIGl0IHJlYWRzIHRoZSBwaXhlbHMgb3V0IG9mIHRoYXQgY2FudmFzIGFuZCB1cGxvYWRzIHRoZW0gYXMgYSBkYXRhIHRleHR1cmUgaW5zdGVhZCwgYXRcbiAqIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGNvc3QuXG4gKi9cbmZ1bmN0aW9uIHNhZmFyaVByZTE1V29ya2Fyb3VuZChhdGxhcykge1xuICAvLyBVc2UgY3JlYXRlSW1hZ2VCaXRtYXAgc3VwcG9ydCBhcyBhIHByb3h5IGZvciBTYWZhcmk8MTUsIGFsbCBvdGhlciBtYWluc3RyZWFtIGJyb3dzZXJzXG4gIC8vIGhhdmUgc3VwcG9ydGVkIGl0IGZvciBhIGxvbmcgd2hpbGUgc28gYW55IGZhbHNlIHBvc2l0aXZlcyBzaG91bGQgYmUgbWluaW1hbC5cbiAgaWYgKHR5cGVvZiBjcmVhdGVJbWFnZUJpdG1hcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuaW5mbygnU2FmYXJpPDE1OiBhcHBseWluZyBTREYgY2FudmFzIHdvcmthcm91bmQnKTtcbiAgICBjb25zdCB7c2RmQ2FudmFzLCBzZGZUZXh0dXJlfSA9IGF0bGFzO1xuICAgIGNvbnN0IHt3aWR0aCwgaGVpZ2h0fSA9IHNkZkNhbnZhcztcbiAgICBjb25zdCBnbCA9IGF0bGFzLnNkZkNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICAgIGxldCBwaXhlbHMgPSBzZGZUZXh0dXJlLmltYWdlLmRhdGE7XG4gICAgaWYgKCFwaXhlbHMgfHwgcGl4ZWxzLmxlbmd0aCAhPT0gd2lkdGggKiBoZWlnaHQgKiA0KSB7XG4gICAgICBwaXhlbHMgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDQpO1xuICAgICAgc2RmVGV4dHVyZS5pbWFnZSA9IHt3aWR0aCwgaGVpZ2h0LCBkYXRhOiBwaXhlbHN9O1xuICAgICAgc2RmVGV4dHVyZS5mbGlwWSA9IGZhbHNlO1xuICAgICAgc2RmVGV4dHVyZS5pc0RhdGFUZXh0dXJlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2wucmVhZFBpeGVscygwLCAwLCB3aWR0aCwgaGVpZ2h0LCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbHMpO1xuICB9XG59XG5cbmNvbnN0IHR5cGVzZXR0ZXJXb3JrZXJNb2R1bGUgPSAvKiNfX1BVUkVfXyovZGVmaW5lV29ya2VyTW9kdWxlKHtcbiAgbmFtZTogJ1R5cGVzZXR0ZXInLFxuICBkZXBlbmRlbmNpZXM6IFtcbiAgICBjcmVhdGVUeXBlc2V0dGVyLFxuICAgIGZvbnRSZXNvbHZlcldvcmtlck1vZHVsZSxcbiAgICBiaWRpRmFjdG9yeSxcbiAgXSxcbiAgaW5pdChjcmVhdGVUeXBlc2V0dGVyLCBmb250UmVzb2x2ZXIsIGJpZGlGYWN0b3J5KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVR5cGVzZXR0ZXIoZm9udFJlc29sdmVyLCBiaWRpRmFjdG9yeSgpKVxuICB9XG59KTtcblxuY29uc3QgdHlwZXNldEluV29ya2VyID0gLyojX19QVVJFX18qL2RlZmluZVdvcmtlck1vZHVsZSh7XG4gIG5hbWU6ICdUeXBlc2V0dGVyJyxcbiAgZGVwZW5kZW5jaWVzOiBbXG4gICAgdHlwZXNldHRlcldvcmtlck1vZHVsZSxcbiAgXSxcbiAgaW5pdCh0eXBlc2V0dGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdHlwZXNldHRlci50eXBlc2V0KGFyZ3MsIHJlc29sdmUpO1xuICAgICAgfSlcbiAgICB9XG4gIH0sXG4gIGdldFRyYW5zZmVyYWJsZXMocmVzdWx0KSB7XG4gICAgLy8gTWFyayBhcnJheSBidWZmZXJzIGFzIHRyYW5zZmVyYWJsZSB0byBhdm9pZCBjbG9uaW5nIGR1cmluZyBwb3N0TWVzc2FnZVxuICAgIGNvbnN0IHRyYW5zZmVyYWJsZXMgPSBbXTtcbiAgICBmb3IgKGxldCBwIGluIHJlc3VsdCkge1xuICAgICAgaWYgKHJlc3VsdFtwXSAmJiByZXN1bHRbcF0uYnVmZmVyKSB7XG4gICAgICAgIHRyYW5zZmVyYWJsZXMucHVzaChyZXN1bHRbcF0uYnVmZmVyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYW5zZmVyYWJsZXNcbiAgfVxufSk7XG5cbmNvbnN0IHR5cGVzZXRPbk1haW5UaHJlYWQgPSB0eXBlc2V0SW5Xb3JrZXIub25NYWluVGhyZWFkO1xuXG5mdW5jdGlvbiBkdW1wU0RGVGV4dHVyZXMoKSB7XG4gIE9iamVjdC5rZXlzKGF0bGFzZXMpLmZvckVhY2goc2l6ZSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gYXRsYXNlc1tzaXplXS5zZGZDYW52YXM7XG4gICAgY29uc3Qge3dpZHRoLCBoZWlnaHR9ID0gY2FudmFzO1xuICAgIGNvbnNvbGUubG9nKFwiJWMuXCIsIGBcbiAgICAgIGJhY2tncm91bmQ6IHVybCgke2NhbnZhcy50b0RhdGFVUkwoKX0pO1xuICAgICAgYmFja2dyb3VuZC1zaXplOiAke3dpZHRofXB4ICR7aGVpZ2h0fXB4O1xuICAgICAgY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgZm9udC1zaXplOiAwO1xuICAgICAgbGluZS1oZWlnaHQ6ICR7aGVpZ2h0fXB4O1xuICAgICAgcGFkZGluZy1sZWZ0OiAke3dpZHRofXB4O1xuICAgIGApO1xuICB9KTtcbn1cblxuY29uc3QgdGVtcGxhdGVHZW9tZXRyaWVzID0ge307XG5cbmZ1bmN0aW9uIGdldFRlbXBsYXRlR2VvbWV0cnkoZGV0YWlsKSB7XG4gIGxldCBnZW9tID0gdGVtcGxhdGVHZW9tZXRyaWVzW2RldGFpbF07XG4gIGlmICghZ2VvbSkge1xuICAgIGdlb20gPSB0ZW1wbGF0ZUdlb21ldHJpZXNbZGV0YWlsXSA9IG5ldyBQbGFuZUdlb21ldHJ5KDEsIDEsIGRldGFpbCwgZGV0YWlsKS50cmFuc2xhdGUoMC41LCAwLjUsIDApO1xuICB9XG4gIHJldHVybiBnZW9tXG59XG5cbmNvbnN0IGdseXBoQm91bmRzQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQm91bmRzJztcbmNvbnN0IGdseXBoSW5kZXhBdHRyTmFtZSA9ICdhVHJvaWthR2x5cGhJbmRleCc7XG5jb25zdCBnbHlwaENvbG9yQXR0ck5hbWUgPSAnYVRyb2lrYUdseXBoQ29sb3InO1xuXG4vKipcbkBjbGFzcyBHbHlwaHNHZW9tZXRyeVxuXG5BIHNwZWNpYWxpemVkIEdlb21ldHJ5IGZvciByZW5kZXJpbmcgYSBzZXQgb2YgdGV4dCBnbHlwaHMuIFVzZXMgSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgdG9cbnJlbmRlciB0aGUgZ2x5cGhzIHVzaW5nIEdQVSBpbnN0YW5jaW5nIG9mIGEgc2luZ2xlIHF1YWQsIHJhdGhlciB0aGFuIGNvbnN0cnVjdGluZyBhIHdob2xlXG5nZW9tZXRyeSB3aXRoIHZlcnRpY2VzLCBmb3IgbXVjaCBzbWFsbGVyIGF0dHJpYnV0ZSBhcnJheWJ1ZmZlcnMgYWNjb3JkaW5nIHRvIHRoaXMgbWF0aDpcblxuICBXaGVyZSBOID0gbnVtYmVyIG9mIGdseXBocy4uLlxuXG4gIEluc3RhbmNlZDpcbiAgLSBwb3NpdGlvbjogNCAqIDNcbiAgLSBpbmRleDogMiAqIDNcbiAgLSBub3JtYWw6IDQgKiAzXG4gIC0gdXY6IDQgKiAyXG4gIC0gZ2x5cGggeC95IGJvdW5kczogTiAqIDRcbiAgLSBnbHlwaCBpbmRpY2VzOiBOICogMVxuICA9IDVOICsgMzhcblxuICBOb24taW5zdGFuY2VkOlxuICAtIHBvc2l0aW9uOiBOICogNCAqIDNcbiAgLSBpbmRleDogTiAqIDIgKiAzXG4gIC0gbm9ybWFsOiBOICogNCAqIDNcbiAgLSB1djogTiAqIDQgKiAyXG4gIC0gZ2x5cGggaW5kaWNlczogTiAqIDFcbiAgPSAzOU5cblxuQSBkb3duc2lkZSBvZiB0aGlzIGlzIHRoZSByYXJlLWJ1dC1wb3NzaWJsZSBsYWNrIG9mIHRoZSBpbnN0YW5jZWQgYXJyYXlzIGV4dGVuc2lvbixcbndoaWNoIHdlIGNvdWxkIHBvdGVudGlhbGx5IHdvcmsgYXJvdW5kIHdpdGggYSBmYWxsYmFjayBub24taW5zdGFuY2VkIGltcGxlbWVudGF0aW9uLlxuXG4qL1xuY2xhc3MgR2x5cGhzR2VvbWV0cnkgZXh0ZW5kcyBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmRldGFpbCA9IDE7XG4gICAgdGhpcy5jdXJ2ZVJhZGl1cyA9IDA7XG5cbiAgICAvLyBEZWZpbmUgZ3JvdXBzIGZvciByZW5kZXJpbmcgdGV4dCBvdXRsaW5lIGFzIGEgc2VwYXJhdGUgcGFzczsgdGhlc2Ugd2lsbCBvbmx5XG4gICAgLy8gYmUgdXNlZCB3aGVuIHRoZSBgbWF0ZXJpYWxgIGdldHRlciByZXR1cm5zIGFuIGFycmF5LCBpLmUuIG91dGxpbmVXaWR0aCA+IDAuXG4gICAgdGhpcy5ncm91cHMgPSBbXG4gICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMH0sXG4gICAgICB7c3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSwgbWF0ZXJpYWxJbmRleDogMX1cbiAgICBdO1xuXG4gICAgLy8gUHJlYWxsb2NhdGUgZW1wdHkgYm91bmRpbmcgb2JqZWN0c1xuICAgIHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG4gICAgdGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XG4gIH1cblxuICBjb21wdXRlQm91bmRpbmdTcGhlcmUgKCkge1xuICAgIC8vIE5vLW9wOyB3ZSdsbCBzeW5jIHRoZSBib3VuZGluZ1NwaGVyZSBwcm9hY3RpdmVseSB3aGVuIG5lZWRlZC5cbiAgfVxuXG4gIGNvbXB1dGVCb3VuZGluZ0JveCgpIHtcbiAgICAvLyBOby1vcDsgd2UnbGwgc3luYyB0aGUgYm91bmRpbmdCb3ggcHJvYWN0aXZlbHkgd2hlbiBuZWVkZWQuXG4gIH1cblxuICBzZXQgZGV0YWlsKGRldGFpbCkge1xuICAgIGlmIChkZXRhaWwgIT09IHRoaXMuX2RldGFpbCkge1xuICAgICAgdGhpcy5fZGV0YWlsID0gZGV0YWlsO1xuICAgICAgaWYgKHR5cGVvZiBkZXRhaWwgIT09ICdudW1iZXInIHx8IGRldGFpbCA8IDEpIHtcbiAgICAgICAgZGV0YWlsID0gMTtcbiAgICAgIH1cbiAgICAgIGxldCB0cGwgPSBnZXRUZW1wbGF0ZUdlb21ldHJ5KGRldGFpbClcbiAgICAgIDtbJ3Bvc2l0aW9uJywgJ25vcm1hbCcsICd1diddLmZvckVhY2goYXR0ciA9PiB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1thdHRyXSA9IHRwbC5hdHRyaWJ1dGVzW2F0dHJdLmNsb25lKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc2V0SW5kZXgodHBsLmdldEluZGV4KCkuY2xvbmUoKSk7XG4gICAgfVxuICB9XG4gIGdldCBkZXRhaWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RldGFpbFxuICB9XG5cbiAgc2V0IGN1cnZlUmFkaXVzKHIpIHtcbiAgICBpZiAociAhPT0gdGhpcy5fY3VydmVSYWRpdXMpIHtcbiAgICAgIHRoaXMuX2N1cnZlUmFkaXVzID0gcjtcbiAgICAgIHRoaXMuX3VwZGF0ZUJvdW5kcygpO1xuICAgIH1cbiAgfVxuICBnZXQgY3VydmVSYWRpdXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2N1cnZlUmFkaXVzXG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBnZW9tZXRyeSBmb3IgYSBuZXcgc2V0IG9mIGdseXBocy5cbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGdseXBoQm91bmRzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgcGxhbmFyIGJvdW5kcyBmb3IgYWxsIGdseXBoc1xuICAgKiAgICAgICAgdG8gYmUgcmVuZGVyZWQsIDQgZW50cmllcyBmb3IgZWFjaCBnbHlwaDogeDEseDIseTEseTFcbiAgICogQHBhcmFtIHtGbG9hdDMyQXJyYXl9IGdseXBoQXRsYXNJbmRpY2VzIC0gQW4gYXJyYXkgaG9sZGluZyB0aGUgaW5kZXggb2YgZWFjaCBnbHlwaCB3aXRoaW5cbiAgICogICAgICAgIHRoZSBTREYgYXRsYXMgdGV4dHVyZS5cbiAgICogQHBhcmFtIHtBcnJheX0gYmxvY2tCb3VuZHMgLSBBbiBhcnJheSBob2xkaW5nIHRoZSBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gYWNyb3NzIGFsbCBnbHlwaHNcbiAgICogQHBhcmFtIHtBcnJheX0gW2NodW5rZWRCb3VuZHNdIC0gQW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIGJvdW5kcyBmb3IgZWFjaCBjaHVuayBvZiBOXG4gICAqICAgICAgICBjb25zZWN1dGl2ZSBnbHlwaHM6IGB7c3RhcnQ6TiwgZW5kOk4sIHJlY3Q6W21pblgsIG1pblksIG1heFgsIG1heFldfWAuIFRoaXMgY2FuIGJlXG4gICAqICAgICAgICB1c2VkIHdpdGggYGFwcGx5Q2xpcFJlY3RgIHRvIGNob29zZSBhbiBvcHRpbWl6ZWQgYGluc3RhbmNlQ291bnRgLlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtnbHlwaENvbG9yc10gLSBBbiBhcnJheSBob2xkaW5nIHIsZyxiIHZhbHVlcyBmb3IgZWFjaCBnbHlwaC5cbiAgICovXG4gIHVwZGF0ZUdseXBocyhnbHlwaEJvdW5kcywgZ2x5cGhBdGxhc0luZGljZXMsIGJsb2NrQm91bmRzLCBjaHVua2VkQm91bmRzLCBnbHlwaENvbG9ycykge1xuICAgIC8vIFVwZGF0ZSB0aGUgaW5zdGFuY2UgYXR0cmlidXRlc1xuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlRGF0YShnbHlwaEJvdW5kc0F0dHJOYW1lLCBnbHlwaEJvdW5kcywgNCk7XG4gICAgdGhpcy51cGRhdGVBdHRyaWJ1dGVEYXRhKGdseXBoSW5kZXhBdHRyTmFtZSwgZ2x5cGhBdGxhc0luZGljZXMsIDEpO1xuICAgIHRoaXMudXBkYXRlQXR0cmlidXRlRGF0YShnbHlwaENvbG9yQXR0ck5hbWUsIGdseXBoQ29sb3JzLCAzKTtcbiAgICB0aGlzLl9ibG9ja0JvdW5kcyA9IGJsb2NrQm91bmRzO1xuICAgIHRoaXMuX2NodW5rZWRCb3VuZHMgPSBjaHVua2VkQm91bmRzO1xuICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IGdseXBoQXRsYXNJbmRpY2VzLmxlbmd0aDtcbiAgICB0aGlzLl91cGRhdGVCb3VuZHMoKTtcbiAgfVxuXG4gIF91cGRhdGVCb3VuZHMoKSB7XG4gICAgY29uc3QgYm91bmRzID0gdGhpcy5fYmxvY2tCb3VuZHM7XG4gICAgaWYgKGJvdW5kcykge1xuICAgICAgY29uc3QgeyBjdXJ2ZVJhZGl1cywgYm91bmRpbmdCb3g6IGJib3ggfSA9IHRoaXM7XG4gICAgICBpZiAoY3VydmVSYWRpdXMpIHtcbiAgICAgICAgY29uc3QgeyBQSSwgZmxvb3IsIG1pbiwgbWF4LCBzaW4sIGNvcyB9ID0gTWF0aDtcbiAgICAgICAgY29uc3QgaGFsZlBpID0gUEkgLyAyO1xuICAgICAgICBjb25zdCB0d29QaSA9IFBJICogMjtcbiAgICAgICAgY29uc3QgYWJzUiA9IE1hdGguYWJzKGN1cnZlUmFkaXVzKTtcbiAgICAgICAgY29uc3QgbGVmdEFuZ2xlID0gYm91bmRzWzBdIC8gYWJzUjtcbiAgICAgICAgY29uc3QgcmlnaHRBbmdsZSA9IGJvdW5kc1syXSAvIGFic1I7XG4gICAgICAgIGNvbnN0IG1pblggPSBmbG9vcigobGVmdEFuZ2xlICsgaGFsZlBpKSAvIHR3b1BpKSAhPT0gZmxvb3IoKHJpZ2h0QW5nbGUgKyBoYWxmUGkpIC8gdHdvUGkpXG4gICAgICAgICAgPyAtYWJzUiA6IG1pbihzaW4obGVmdEFuZ2xlKSAqIGFic1IsIHNpbihyaWdodEFuZ2xlKSAqIGFic1IpO1xuICAgICAgICBjb25zdCBtYXhYID0gZmxvb3IoKGxlZnRBbmdsZSAtIGhhbGZQaSkgLyB0d29QaSkgIT09IGZsb29yKChyaWdodEFuZ2xlIC0gaGFsZlBpKSAvIHR3b1BpKVxuICAgICAgICAgID8gYWJzUiA6IG1heChzaW4obGVmdEFuZ2xlKSAqIGFic1IsIHNpbihyaWdodEFuZ2xlKSAqIGFic1IpO1xuICAgICAgICBjb25zdCBtYXhaID0gZmxvb3IoKGxlZnRBbmdsZSArIFBJKSAvIHR3b1BpKSAhPT0gZmxvb3IoKHJpZ2h0QW5nbGUgKyBQSSkgLyB0d29QaSlcbiAgICAgICAgICA/IGFic1IgKiAyIDogbWF4KGFic1IgLSBjb3MobGVmdEFuZ2xlKSAqIGFic1IsIGFic1IgLSBjb3MocmlnaHRBbmdsZSkgKiBhYnNSKTtcbiAgICAgICAgYmJveC5taW4uc2V0KG1pblgsIGJvdW5kc1sxXSwgY3VydmVSYWRpdXMgPCAwID8gLW1heFogOiAwKTtcbiAgICAgICAgYmJveC5tYXguc2V0KG1heFgsIGJvdW5kc1szXSwgY3VydmVSYWRpdXMgPCAwID8gMCA6IG1heFopO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmJveC5taW4uc2V0KGJvdW5kc1swXSwgYm91bmRzWzFdLCAwKTtcbiAgICAgICAgYmJveC5tYXguc2V0KGJvdW5kc1syXSwgYm91bmRzWzNdLCAwKTtcbiAgICAgIH1cbiAgICAgIGJib3guZ2V0Qm91bmRpbmdTcGhlcmUodGhpcy5ib3VuZGluZ1NwaGVyZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgY2xpcHBpbmcgcmVjdCwgYW5kIHRoZSBjaHVua2VkQm91bmRzIGZyb20gdGhlIGxhc3QgdXBkYXRlR2x5cGhzIGNhbGwsIGNob29zZSB0aGUgbG93ZXN0XG4gICAqIGBpbnN0YW5jZUNvdW50YCB0aGF0IHdpbGwgc2hvdyBhbGwgZ2x5cGhzIHdpdGhpbiB0aGUgY2xpcHBlZCB2aWV3LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvblxuICAgKiBmb3IgbG9uZyBibG9ja3Mgb2YgdGV4dCB0aGF0IGFyZSBjbGlwcGVkLCB0byBza2lwIHZlcnRleCBzaGFkZXIgZXZhbHVhdGlvbiBmb3IgZ2x5cGhzIHRoYXQgd291bGRcbiAgICogYmUgY2xpcHBlZCBhbnl3YXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBzaW5jZSBgZHJhd0VsZW1lbnRzSW5zdGFuY2VkW0FOR0xFXWAgb25seSBhY2NlcHRzIGFuIGluc3RhbmNlIGNvdW50IGFuZCBub3QgYSBzdGFydGluZ1xuICAgKiBvZmZzZXQsIHRoaXMgb3B0aW1pemF0aW9uIGJlY29tZXMgbGVzcyBlZmZlY3RpdmUgYXMgdGhlIGNsaXBSZWN0IG1vdmVzIGNsb3NlciB0byB0aGUgZW5kIG9mIHRoZVxuICAgKiB0ZXh0IGJsb2NrLiBXZSBjb3VsZCBmaXggdGhhdCBieSBzd2l0Y2hpbmcgZnJvbSBpbnN0YW5jaW5nIHRvIGEgZnVsbCBnZW9tZXRyeSB3aXRoIGEgZHJhd1JhbmdlLFxuICAgKiBidXQgYXQgdGhlIGV4cGVuc2Ugb2YgbXVjaCBsYXJnZXIgYXR0cmlidXRlIGJ1ZmZlcnMgKHNlZSBjbGFzc2RvYyBhYm92ZS4pXG4gICAqXG4gICAqIEBwYXJhbSB7VmVjdG9yNH0gY2xpcFJlY3RcbiAgICovXG4gIGFwcGx5Q2xpcFJlY3QoY2xpcFJlY3QpIHtcbiAgICBsZXQgY291bnQgPSB0aGlzLmdldEF0dHJpYnV0ZShnbHlwaEluZGV4QXR0ck5hbWUpLmNvdW50O1xuICAgIGxldCBjaHVua3MgPSB0aGlzLl9jaHVua2VkQm91bmRzO1xuICAgIGlmIChjaHVua3MpIHtcbiAgICAgIGZvciAobGV0IGkgPSBjaHVua3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGNvdW50ID0gY2h1bmtzW2ldLmVuZDtcbiAgICAgICAgbGV0IHJlY3QgPSBjaHVua3NbaV0ucmVjdDtcbiAgICAgICAgLy8gbm90ZTogYm90aCByZWN0cyBhcmUgbC1iLXItdFxuICAgICAgICBpZiAocmVjdFsxXSA8IGNsaXBSZWN0LncgJiYgcmVjdFszXSA+IGNsaXBSZWN0LnkgJiYgcmVjdFswXSA8IGNsaXBSZWN0LnogJiYgcmVjdFsyXSA+IGNsaXBSZWN0LngpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5zdGFuY2VDb3VudCA9IGNvdW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgZm9yIHVwZGF0aW5nIGluc3RhbmNlIGF0dHJpYnV0ZXMgd2l0aCBhdXRvbWF0aWMgcmVzaXppbmdcbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZURhdGEoYXR0ck5hbWUsIG5ld0FycmF5LCBpdGVtU2l6ZSkge1xuICAgIGNvbnN0IGF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgaWYgKG5ld0FycmF5KSB7XG4gICAgICAvLyBJZiBsZW5ndGggaXNuJ3QgY2hhbmdpbmcsIGp1c3QgdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyBhcnJheSBkYXRhXG4gICAgICBpZiAoYXR0ciAmJiBhdHRyLmFycmF5Lmxlbmd0aCA9PT0gbmV3QXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGF0dHIuYXJyYXkuc2V0KG5ld0FycmF5KTtcbiAgICAgICAgYXR0ci5uZWVkc1VwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgbmV3IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZShuZXdBcnJheSwgaXRlbVNpemUpKTtcbiAgICAgICAgLy8gSWYgdGhlIG5ldyBhdHRyaWJ1dGUgaGFzIGEgZGlmZmVyZW50IHNpemUsIHdlIGFsc28gaGF2ZSB0byAoYXMgb2YgcjExNykgbWFudWFsbHkgY2xlYXIgdGhlXG4gICAgICAgIC8vIGludGVybmFsIGNhY2hlZCBtYXggaW5zdGFuY2UgY291bnQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2lzc3Vlcy8xOTcwNlxuICAgICAgICAvLyBJdCdzIHVuY2xlYXIgaWYgdGhpcyBpcyBhIHRocmVlanMgYnVnIG9yIGEgdHJ1bHkgdW5zdXBwb3J0ZWQgc2NlbmFyaW87IGRpc2N1c3Npb24gaW5cbiAgICAgICAgLy8gdGhhdCB0aWNrZXQgaXMgYW1iaWd1b3VzIGFzIHRvIHdoZXRoZXIgcmVwbGFjaW5nIGEgQnVmZmVyQXR0cmlidXRlIHdpdGggb25lIG9mIGFcbiAgICAgICAgLy8gZGlmZmVyZW50IHNpemUgaXMgc3VwcG9ydGVkLCBidXQgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzE3NDE4IHN0cm9uZ2x5XG4gICAgICAgIC8vIGltcGxpZXMgaXQgc2hvdWxkIGJlIHN1cHBvcnRlZC4gSXQncyBwb3NzaWJsZSB3ZSBuZWVkIHRvXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tYXhJbnN0YW5jZUNvdW50OyAvL2ZvciByMTE3KywgY291bGQgYmUgZnJhZ2lsZVxuICAgICAgICB0aGlzLmRpc3Bvc2UoKTsgLy9mb3IgcjExOCssIG1vcmUgcm9idXN0IGZlZWxpbmcsIGJ1dCBtb3JlIGhlYXZ5LWhhbmRlZCB0aGFuIEknZCBsaWtlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdHRyKSB7XG4gICAgICB0aGlzLmRlbGV0ZUF0dHJpYnV0ZShhdHRyTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIGxhbmd1YWdlPUdMU0xcbmNvbnN0IFZFUlRFWF9ERUZTID0gYFxudW5pZm9ybSB2ZWMyIHVUcm9pa2FTREZUZXh0dXJlU2l6ZTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYVNERkdseXBoU2l6ZTtcbnVuaWZvcm0gdmVjNCB1VHJvaWthVG90YWxCb3VuZHM7XG51bmlmb3JtIHZlYzQgdVRyb2lrYUNsaXBSZWN0O1xudW5pZm9ybSBtYXQzIHVUcm9pa2FPcmllbnQ7XG51bmlmb3JtIGJvb2wgdVRyb2lrYVVzZUdseXBoQ29sb3JzO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthRWRnZU9mZnNldDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUJsdXJSYWRpdXM7XG51bmlmb3JtIHZlYzIgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0O1xudW5pZm9ybSBmbG9hdCB1VHJvaWthQ3VydmVSYWRpdXM7XG5hdHRyaWJ1dGUgdmVjNCBhVHJvaWthR2x5cGhCb3VuZHM7XG5hdHRyaWJ1dGUgZmxvYXQgYVRyb2lrYUdseXBoSW5kZXg7XG5hdHRyaWJ1dGUgdmVjMyBhVHJvaWthR2x5cGhDb2xvcjtcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcbnZhcnlpbmcgdmVjNCB2VHJvaWthVGV4dHVyZVVWQm91bmRzO1xudmFyeWluZyBmbG9hdCB2VHJvaWthVGV4dHVyZUNoYW5uZWw7XG52YXJ5aW5nIHZlYzMgdlRyb2lrYUdseXBoQ29sb3I7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoRGltZW5zaW9ucztcbmA7XG5cbi8vIGxhbmd1YWdlPUdMU0wgcHJlZml4PVwidm9pZCBtYWluKCkge1wiIHN1ZmZpeD1cIn1cIlxuY29uc3QgVkVSVEVYX1RSQU5TRk9STSA9IGBcbnZlYzQgYm91bmRzID0gYVRyb2lrYUdseXBoQm91bmRzO1xuYm91bmRzLnh6ICs9IHVUcm9pa2FQb3NpdGlvbk9mZnNldC54O1xuYm91bmRzLnl3IC09IHVUcm9pa2FQb3NpdGlvbk9mZnNldC55O1xuXG52ZWM0IG91dGxpbmVCb3VuZHMgPSB2ZWM0KFxuICBib3VuZHMueHkgLSB1VHJvaWthRWRnZU9mZnNldCAtIHVUcm9pa2FCbHVyUmFkaXVzLFxuICBib3VuZHMuencgKyB1VHJvaWthRWRnZU9mZnNldCArIHVUcm9pa2FCbHVyUmFkaXVzXG4pO1xudmVjNCBjbGlwcGVkQm91bmRzID0gdmVjNChcbiAgY2xhbXAob3V0bGluZUJvdW5kcy54eSwgdVRyb2lrYUNsaXBSZWN0Lnh5LCB1VHJvaWthQ2xpcFJlY3QuencpLFxuICBjbGFtcChvdXRsaW5lQm91bmRzLnp3LCB1VHJvaWthQ2xpcFJlY3QueHksIHVUcm9pa2FDbGlwUmVjdC56dylcbik7XG5cbnZlYzIgY2xpcHBlZFhZID0gKG1peChjbGlwcGVkQm91bmRzLnh5LCBjbGlwcGVkQm91bmRzLnp3LCBwb3NpdGlvbi54eSkgLSBib3VuZHMueHkpIC8gKGJvdW5kcy56dyAtIGJvdW5kcy54eSk7XG5cbnBvc2l0aW9uLnh5ID0gbWl4KGJvdW5kcy54eSwgYm91bmRzLnp3LCBjbGlwcGVkWFkpO1xuXG51diA9IChwb3NpdGlvbi54eSAtIHVUcm9pa2FUb3RhbEJvdW5kcy54eSkgLyAodVRyb2lrYVRvdGFsQm91bmRzLnp3IC0gdVRyb2lrYVRvdGFsQm91bmRzLnh5KTtcblxuZmxvYXQgcmFkID0gdVRyb2lrYUN1cnZlUmFkaXVzO1xuaWYgKHJhZCAhPSAwLjApIHtcbiAgZmxvYXQgYW5nbGUgPSBwb3NpdGlvbi54IC8gcmFkO1xuICBwb3NpdGlvbi54eiA9IHZlYzIoc2luKGFuZ2xlKSAqIHJhZCwgcmFkIC0gY29zKGFuZ2xlKSAqIHJhZCk7XG4gIG5vcm1hbC54eiA9IHZlYzIoc2luKGFuZ2xlKSwgY29zKGFuZ2xlKSk7XG59XG4gIFxucG9zaXRpb24gPSB1VHJvaWthT3JpZW50ICogcG9zaXRpb247XG5ub3JtYWwgPSB1VHJvaWthT3JpZW50ICogbm9ybWFsO1xuXG52VHJvaWthR2x5cGhVViA9IGNsaXBwZWRYWS54eTtcbnZUcm9pa2FHbHlwaERpbWVuc2lvbnMgPSB2ZWMyKGJvdW5kc1syXSAtIGJvdW5kc1swXSwgYm91bmRzWzNdIC0gYm91bmRzWzFdKTtcblxuJHsnJy8qIE5PVEU6IGl0IHNlZW1zIGltcG9ydGFudCB0byBjYWxjdWxhdGUgdGhlIGdseXBoJ3MgYm91bmRpbmcgdGV4dHVyZSBVVnMgaGVyZSBpbiB0aGVcbiAgdmVydGV4IHNoYWRlciwgcmF0aGVyIHRoYW4gaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgYXMgdGhlIGxhdHRlciBnaXZlcyBzdHJhbmdlIGFydGlmYWN0c1xuICBvbiBzb21lIGdseXBocyAodGhvc2UgaW4gdGhlIGxlZnRtb3N0IHRleHR1cmUgY29sdW1uKSBvbiBzb21lIHN5c3RlbXMuIFRoZSBleGFjdCByZWFzb25cbiAgaXNuJ3QgdW5kZXJzdG9vZCBidXQgZG9pbmcgdGhpcyBoZXJlLCB0aGVuIG1peCgpLWluZyBpbiB0aGUgZnJhZ21lbnQgc2hhZGVyLCBzZWVtcyB0byB3b3JrLiAqL31cbmZsb2F0IHR4Q29scyA9IHVUcm9pa2FTREZUZXh0dXJlU2l6ZS54IC8gdVRyb2lrYVNERkdseXBoU2l6ZTtcbnZlYzIgdHhVdlBlclNxdWFyZSA9IHVUcm9pa2FTREZHbHlwaFNpemUgLyB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG52ZWMyIHR4U3RhcnRVViA9IHR4VXZQZXJTcXVhcmUgKiB2ZWMyKFxuICBtb2QoZmxvb3IoYVRyb2lrYUdseXBoSW5kZXggLyA0LjApLCB0eENvbHMpLFxuICBmbG9vcihmbG9vcihhVHJvaWthR2x5cGhJbmRleCAvIDQuMCkgLyB0eENvbHMpXG4pO1xudlRyb2lrYVRleHR1cmVVVkJvdW5kcyA9IHZlYzQodHhTdGFydFVWLCB2ZWMyKHR4U3RhcnRVVikgKyB0eFV2UGVyU3F1YXJlKTtcbnZUcm9pa2FUZXh0dXJlQ2hhbm5lbCA9IG1vZChhVHJvaWthR2x5cGhJbmRleCwgNC4wKTtcbmA7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbmNvbnN0IEZSQUdNRU5UX0RFRlMgPSBgXG51bmlmb3JtIHNhbXBsZXIyRCB1VHJvaWthU0RGVGV4dHVyZTtcbnVuaWZvcm0gdmVjMiB1VHJvaWthU0RGVGV4dHVyZVNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZHbHlwaFNpemU7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTREZFeHBvbmVudDtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUVkZ2VPZmZzZXQ7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FGaWxsT3BhY2l0eTtcbnVuaWZvcm0gZmxvYXQgdVRyb2lrYUJsdXJSYWRpdXM7XG51bmlmb3JtIHZlYzMgdVRyb2lrYVN0cm9rZUNvbG9yO1xudW5pZm9ybSBmbG9hdCB1VHJvaWthU3Ryb2tlV2lkdGg7XG51bmlmb3JtIGZsb2F0IHVUcm9pa2FTdHJva2VPcGFjaXR5O1xudW5pZm9ybSBib29sIHVUcm9pa2FTREZEZWJ1ZztcbnZhcnlpbmcgdmVjMiB2VHJvaWthR2x5cGhVVjtcbnZhcnlpbmcgdmVjNCB2VHJvaWthVGV4dHVyZVVWQm91bmRzO1xudmFyeWluZyBmbG9hdCB2VHJvaWthVGV4dHVyZUNoYW5uZWw7XG52YXJ5aW5nIHZlYzIgdlRyb2lrYUdseXBoRGltZW5zaW9ucztcblxuZmxvYXQgdHJvaWthU2RmVmFsdWVUb1NpZ25lZERpc3RhbmNlKGZsb2F0IGFscGhhKSB7XG4gIC8vIEludmVyc2Ugb2YgZXhwb25lbnRpYWwgZW5jb2RpbmcgaW4gd2ViZ2wtc2RmLWdlbmVyYXRvclxuICAkeycnLyogVE9ETyAtIHRoZXJlJ3Mgc29tZSBzbGlnaHQgaW5hY2N1cmFjeSBoZXJlIHdoZW4gZGVhbGluZyB3aXRoIGludGVycG9sYXRlZCBhbHBoYSB2YWx1ZXM7IHRob3NlXG4gICAgYXJlIGxpbmVhcmx5IGludGVycG9sYXRlZCB3aGVyZSB0aGUgZW5jb2RpbmcgaXMgZXhwb25lbnRpYWwuIExvb2sgaW50byBpbXByb3ZpbmcgdGhpcyBieSByb3VuZGluZ1xuICAgIHRvIG5lYXJlc3QgMiB3aG9sZSB0ZXhlbHMsIGRlY29kaW5nIHRob3NlIGV4cG9uZW50aWFsIHZhbHVlcywgYW5kIGxpbmVhcmx5IGludGVycG9sYXRpbmcgdGhlIHJlc3VsdC5cbiAgKi99XG4gIGZsb2F0IG1heERpbWVuc2lvbiA9IG1heCh2VHJvaWthR2x5cGhEaW1lbnNpb25zLngsIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMueSk7XG4gIGZsb2F0IGFic0Rpc3QgPSAoMS4wIC0gcG93KDIuMCAqIChhbHBoYSA+IDAuNSA/IDEuMCAtIGFscGhhIDogYWxwaGEpLCAxLjAgLyB1VHJvaWthU0RGRXhwb25lbnQpKSAqIG1heERpbWVuc2lvbjtcbiAgZmxvYXQgc2lnbmVkRGlzdCA9IGFic0Rpc3QgKiAoYWxwaGEgPiAwLjUgPyAtMS4wIDogMS4wKTtcbiAgcmV0dXJuIHNpZ25lZERpc3Q7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZlYzIgZ2x5cGhVVikge1xuICB2ZWMyIHRleHR1cmVVViA9IG1peCh2VHJvaWthVGV4dHVyZVVWQm91bmRzLnh5LCB2VHJvaWthVGV4dHVyZVVWQm91bmRzLnp3LCBnbHlwaFVWKTtcbiAgdmVjNCByZ2JhID0gdGV4dHVyZTJEKHVUcm9pa2FTREZUZXh0dXJlLCB0ZXh0dXJlVVYpO1xuICBmbG9hdCBjaCA9IGZsb29yKHZUcm9pa2FUZXh0dXJlQ2hhbm5lbCArIDAuNSk7IC8vTk9URTogY2FuJ3QgdXNlIHJvdW5kKCkgaW4gV2ViR0wxXG4gIHJldHVybiBjaCA9PSAwLjAgPyByZ2JhLnIgOiBjaCA9PSAxLjAgPyByZ2JhLmcgOiBjaCA9PSAyLjAgPyByZ2JhLmIgOiByZ2JhLmE7XG59XG5cbmZsb2F0IHRyb2lrYUdseXBoVXZUb0Rpc3RhbmNlKHZlYzIgdXYpIHtcbiAgcmV0dXJuIHRyb2lrYVNkZlZhbHVlVG9TaWduZWREaXN0YW5jZSh0cm9pa2FHbHlwaFV2VG9TZGZWYWx1ZSh1dikpO1xufVxuXG5mbG9hdCB0cm9pa2FHZXRBQURpc3QoKSB7XG4gICR7JycvKlxuICAgIFdoZW4gdGhlIHN0YW5kYXJkIGRlcml2YXRpdmVzIGV4dGVuc2lvbiBpcyBhdmFpbGFibGUsIHdlIGNob29zZSBhbiBhbnRpYWxpYXNpbmcgYWxwaGEgdGhyZXNob2xkIGJhc2VkXG4gICAgb24gdGhlIHBvdGVudGlhbCBjaGFuZ2UgaW4gdGhlIFNERidzIGFscGhhIGZyb20gdGhpcyBmcmFnbWVudCB0byBpdHMgbmVpZ2hib3IuIFRoaXMgc3RyYXRlZ3kgbWF4aW1pemVzIFxuICAgIHJlYWRhYmlsaXR5IGFuZCBlZGdlIGNyaXNwbmVzcyBhdCBhbGwgc2l6ZXMgYW5kIHNjcmVlbiByZXNvbHV0aW9ucy5cbiAgKi99XG4gICNpZiBkZWZpbmVkKEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcykgfHwgX19WRVJTSU9OX18gPj0gMzAwXG4gIHJldHVybiBsZW5ndGgoZndpZHRoKHZUcm9pa2FHbHlwaFVWICogdlRyb2lrYUdseXBoRGltZW5zaW9ucykpICogMC41O1xuICAjZWxzZVxuICByZXR1cm4gdlRyb2lrYUdseXBoRGltZW5zaW9ucy54IC8gNjQuMDtcbiAgI2VuZGlmXG59XG5cbmZsb2F0IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKSB7XG4gIHZlYzIgY2xhbXBlZEdseXBoVVYgPSBjbGFtcCh2VHJvaWthR2x5cGhVViwgMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSwgMS4wIC0gMC41IC8gdVRyb2lrYVNERkdseXBoU2l6ZSk7XG4gIGZsb2F0IGRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UoY2xhbXBlZEdseXBoVVYpO1xuIFxuICAvLyBFeHRyYXBvbGF0ZSBkaXN0YW5jZSB3aGVuIG91dHNpZGUgYm91bmRzOlxuICBkaXN0YW5jZSArPSBjbGFtcGVkR2x5cGhVViA9PSB2VHJvaWthR2x5cGhVViA/IDAuMCA6IFxuICAgIGxlbmd0aCgodlRyb2lrYUdseXBoVVYgLSBjbGFtcGVkR2x5cGhVVikgKiB2VHJvaWthR2x5cGhEaW1lbnNpb25zKTtcblxuICAkeycnLyogXG4gIC8vIFRPRE8gbW9yZSByZWZpbmVkIGV4dHJhcG9sYXRlZCBkaXN0YW5jZSBieSBhZGp1c3RpbmcgZm9yIGFuZ2xlIG9mIGdyYWRpZW50IGF0IGVkZ2UuLi5cbiAgLy8gVGhpcyBoYXMgcG90ZW50aWFsIGJ1dCBjdXJyZW50bHkgZ2l2ZXMgdmVyeSBqYWdnZWQgZXh0ZW5zaW9ucywgbWF5YmUgZHVlIHRvIHByZWNpc2lvbiBpc3N1ZXM/XG4gIGZsb2F0IHV2U3RlcCA9IDEuMCAvIHVUcm9pa2FTREZHbHlwaFNpemU7XG4gIHZlYzIgbmVpZ2hib3IxVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi55KSkgOlxuICAgIHZUcm9pa2FHbHlwaFVWLnkgIT0gY2xhbXBlZEdseXBoVVYueSA/IHZlYzIodXZTdGVwICogc2lnbigwLjUgLSB2VHJvaWthR2x5cGhVVi54KSwgMC4wKSA6XG4gICAgdmVjMigwLjApXG4gICk7XG4gIHZlYzIgbmVpZ2hib3IyVVYgPSBjbGFtcGVkR2x5cGhVViArIChcbiAgICB2VHJvaWthR2x5cGhVVi54ICE9IGNsYW1wZWRHbHlwaFVWLnggPyB2ZWMyKDAuMCwgdXZTdGVwICogLXNpZ24oMC41IC0gdlRyb2lrYUdseXBoVVYueSkpIDpcbiAgICB2VHJvaWthR2x5cGhVVi55ICE9IGNsYW1wZWRHbHlwaFVWLnkgPyB2ZWMyKHV2U3RlcCAqIC1zaWduKDAuNSAtIHZUcm9pa2FHbHlwaFVWLngpLCAwLjApIDpcbiAgICB2ZWMyKDAuMClcbiAgKTtcbiAgZmxvYXQgbmVpZ2hib3IxRGlzdGFuY2UgPSB0cm9pa2FHbHlwaFV2VG9EaXN0YW5jZShuZWlnaGJvcjFVVik7XG4gIGZsb2F0IG5laWdoYm9yMkRpc3RhbmNlID0gdHJvaWthR2x5cGhVdlRvRGlzdGFuY2UobmVpZ2hib3IyVVYpO1xuICBmbG9hdCBkaXN0VG9VbmNsYW1wZWQgPSBsZW5ndGgoKHZUcm9pa2FHbHlwaFVWIC0gY2xhbXBlZEdseXBoVVYpICogdlRyb2lrYUdseXBoRGltZW5zaW9ucyk7XG4gIGZsb2F0IGRpc3RUb05laWdoYm9yID0gbGVuZ3RoKChjbGFtcGVkR2x5cGhVViAtIG5laWdoYm9yMVVWKSAqIHZUcm9pa2FHbHlwaERpbWVuc2lvbnMpO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMSA9IG1pbihhc2luKGFicyhuZWlnaGJvcjFEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBmbG9hdCBncmFkaWVudEFuZ2xlMiA9IG1pbihhc2luKGFicyhuZWlnaGJvcjJEaXN0YW5jZSAtIGRpc3RhbmNlKSAvIGRpc3RUb05laWdoYm9yKSwgUEkgLyAyLjApO1xuICBkaXN0YW5jZSArPSAoY29zKGdyYWRpZW50QW5nbGUxKSArIGNvcyhncmFkaWVudEFuZ2xlMikpIC8gMi4wICogZGlzdFRvVW5jbGFtcGVkO1xuICAqL31cblxuICByZXR1cm4gZGlzdGFuY2U7XG59XG5cbmZsb2F0IHRyb2lrYUdldEVkZ2VBbHBoYShmbG9hdCBkaXN0YW5jZSwgZmxvYXQgZGlzdGFuY2VPZmZzZXQsIGZsb2F0IGFhRGlzdCkge1xuICAjaWYgZGVmaW5lZChJU19ERVBUSF9NQVRFUklBTCkgfHwgZGVmaW5lZChJU19ESVNUQU5DRV9NQVRFUklBTClcbiAgZmxvYXQgYWxwaGEgPSBzdGVwKC1kaXN0YW5jZU9mZnNldCwgLWRpc3RhbmNlKTtcbiAgI2Vsc2VcblxuICBmbG9hdCBhbHBoYSA9IHNtb290aHN0ZXAoXG4gICAgZGlzdGFuY2VPZmZzZXQgKyBhYURpc3QsXG4gICAgZGlzdGFuY2VPZmZzZXQgLSBhYURpc3QsXG4gICAgZGlzdGFuY2VcbiAgKTtcbiAgI2VuZGlmXG5cbiAgcmV0dXJuIGFscGhhO1xufVxuYDtcblxuLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG5jb25zdCBGUkFHTUVOVF9UUkFOU0ZPUk0gPSBgXG5mbG9hdCBhYURpc3QgPSB0cm9pa2FHZXRBQURpc3QoKTtcbmZsb2F0IGZyYWdEaXN0YW5jZSA9IHRyb2lrYUdldEZyYWdEaXN0VmFsdWUoKTtcbmZsb2F0IGVkZ2VBbHBoYSA9IHVUcm9pa2FTREZEZWJ1ZyA/XG4gIHRyb2lrYUdseXBoVXZUb1NkZlZhbHVlKHZUcm9pa2FHbHlwaFVWKSA6XG4gIHRyb2lrYUdldEVkZ2VBbHBoYShmcmFnRGlzdGFuY2UsIHVUcm9pa2FFZGdlT2Zmc2V0LCBtYXgoYWFEaXN0LCB1VHJvaWthQmx1clJhZGl1cykpO1xuXG4jaWYgIWRlZmluZWQoSVNfREVQVEhfTUFURVJJQUwpICYmICFkZWZpbmVkKElTX0RJU1RBTkNFX01BVEVSSUFMKVxudmVjNCBmaWxsUkdCQSA9IGdsX0ZyYWdDb2xvcjtcbmZpbGxSR0JBLmEgKj0gdVRyb2lrYUZpbGxPcGFjaXR5O1xudmVjNCBzdHJva2VSR0JBID0gdVRyb2lrYVN0cm9rZVdpZHRoID09IDAuMCA/IGZpbGxSR0JBIDogdmVjNCh1VHJvaWthU3Ryb2tlQ29sb3IsIHVUcm9pa2FTdHJva2VPcGFjaXR5KTtcbmlmIChmaWxsUkdCQS5hID09IDAuMCkgZmlsbFJHQkEucmdiID0gc3Ryb2tlUkdCQS5yZ2I7XG5nbF9GcmFnQ29sb3IgPSBtaXgoZmlsbFJHQkEsIHN0cm9rZVJHQkEsIHNtb290aHN0ZXAoXG4gIC11VHJvaWthU3Ryb2tlV2lkdGggLSBhYURpc3QsXG4gIC11VHJvaWthU3Ryb2tlV2lkdGggKyBhYURpc3QsXG4gIGZyYWdEaXN0YW5jZVxuKSk7XG5nbF9GcmFnQ29sb3IuYSAqPSBlZGdlQWxwaGE7XG4jZW5kaWZcblxuaWYgKGVkZ2VBbHBoYSA9PSAwLjApIHtcbiAgZGlzY2FyZDtcbn1cbmA7XG5cblxuLyoqXG4gKiBDcmVhdGUgYSBtYXRlcmlhbCBmb3IgcmVuZGVyaW5nIHRleHQsIGRlcml2ZWQgZnJvbSBhIGJhc2VNYXRlcmlhbFxuICovXG5mdW5jdGlvbiBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCkge1xuICBjb25zdCB0ZXh0TWF0ZXJpYWwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmFzZU1hdGVyaWFsLCB7XG4gICAgY2hhaW5lZDogdHJ1ZSxcbiAgICBleHRlbnNpb25zOiB7XG4gICAgICBkZXJpdmF0aXZlczogdHJ1ZVxuICAgIH0sXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIHVUcm9pa2FTREZUZXh0dXJlOiB7dmFsdWU6IG51bGx9LFxuICAgICAgdVRyb2lrYVNERlRleHR1cmVTaXplOiB7dmFsdWU6IG5ldyBWZWN0b3IyKCl9LFxuICAgICAgdVRyb2lrYVNERkdseXBoU2l6ZToge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FTREZFeHBvbmVudDoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FUb3RhbEJvdW5kczoge3ZhbHVlOiBuZXcgVmVjdG9yNCgwLDAsMCwwKX0sXG4gICAgICB1VHJvaWthQ2xpcFJlY3Q6IHt2YWx1ZTogbmV3IFZlY3RvcjQoMCwwLDAsMCl9LFxuICAgICAgdVRyb2lrYUVkZ2VPZmZzZXQ6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthRmlsbE9wYWNpdHk6IHt2YWx1ZTogMX0sXG4gICAgICB1VHJvaWthUG9zaXRpb25PZmZzZXQ6IHt2YWx1ZTogbmV3IFZlY3RvcjIoKX0sXG4gICAgICB1VHJvaWthQ3VydmVSYWRpdXM6IHt2YWx1ZTogMH0sXG4gICAgICB1VHJvaWthQmx1clJhZGl1czoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FTdHJva2VXaWR0aDoge3ZhbHVlOiAwfSxcbiAgICAgIHVUcm9pa2FTdHJva2VDb2xvcjoge3ZhbHVlOiBuZXcgQ29sb3IoKX0sXG4gICAgICB1VHJvaWthU3Ryb2tlT3BhY2l0eToge3ZhbHVlOiAxfSxcbiAgICAgIHVUcm9pa2FPcmllbnQ6IHt2YWx1ZTogbmV3IE1hdHJpeDMoKX0sXG4gICAgICB1VHJvaWthVXNlR2x5cGhDb2xvcnM6IHt2YWx1ZTogdHJ1ZX0sXG4gICAgICB1VHJvaWthU0RGRGVidWc6IHt2YWx1ZTogZmFsc2V9XG4gICAgfSxcbiAgICB2ZXJ0ZXhEZWZzOiBWRVJURVhfREVGUyxcbiAgICB2ZXJ0ZXhUcmFuc2Zvcm06IFZFUlRFWF9UUkFOU0ZPUk0sXG4gICAgZnJhZ21lbnREZWZzOiBGUkFHTUVOVF9ERUZTLFxuICAgIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm06IEZSQUdNRU5UX1RSQU5TRk9STSxcbiAgICBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pIHtcbiAgICAgIGxldCB1RGlmZnVzZVJFID0gL1xcYnVuaWZvcm1cXHMrdmVjM1xccytkaWZmdXNlXFxiLztcbiAgICAgIGlmICh1RGlmZnVzZVJFLnRlc3QoZnJhZ21lbnRTaGFkZXIpKSB7XG4gICAgICAgIC8vIFJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiBgZGlmZnVzZWAgd2l0aCBvdXIgdmFyeWluZ1xuICAgICAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyXG4gICAgICAgICAgLnJlcGxhY2UodURpZmZ1c2VSRSwgJ3ZhcnlpbmcgdmVjMyB2VHJvaWthR2x5cGhDb2xvcicpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcYmRpZmZ1c2VcXGIvZywgJ3ZUcm9pa2FHbHlwaENvbG9yJyk7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgdmVydGV4IHNoYWRlciBkZWNsYXJlcyB0aGUgdW5pZm9ybSBzbyB3ZSBjYW4gZ3JhYiBpdCBhcyBhIGZhbGxiYWNrXG4gICAgICAgIGlmICghdURpZmZ1c2VSRS50ZXN0KHZlcnRleFNoYWRlcikpIHtcbiAgICAgICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZShcbiAgICAgICAgICAgIHZvaWRNYWluUmVnRXhwLFxuICAgICAgICAgICAgJ3VuaWZvcm0gdmVjMyBkaWZmdXNlO1xcbiQmXFxudlRyb2lrYUdseXBoQ29sb3IgPSB1VHJvaWthVXNlR2x5cGhDb2xvcnMgPyBhVHJvaWthR2x5cGhDb2xvciAvIDI1NS4wIDogZGlmZnVzZTtcXG4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlciB9XG4gICAgfVxuICB9KTtcblxuICAvLyBGb3JjZSB0cmFuc3BhcmVuY3kgLSBUT0RPIGlzIHRoaXMgcmVhc29uYWJsZT9cbiAgdGV4dE1hdGVyaWFsLnRyYW5zcGFyZW50ID0gdHJ1ZTtcblxuICAvLyBGb3JjZSBzaW5nbGUgZHJhdyBjYWxsIHdoZW4gZG91YmxlLXNpZGVkXG4gIHRleHRNYXRlcmlhbC5mb3JjZVNpbmdsZVBhc3MgPSB0cnVlO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRleHRNYXRlcmlhbCwge1xuICAgIGlzVHJvaWthVGV4dE1hdGVyaWFsOiB7dmFsdWU6IHRydWV9LFxuXG4gICAgLy8gV2ViR0xTaGFkb3dNYXAgcmV2ZXJzZXMgdGhlIHNpZGUgb2YgdGhlIHNoYWRvdyBtYXRlcmlhbCBieSBkZWZhdWx0LCB3aGljaCBmYWlsc1xuICAgIC8vIGZvciBwbGFuZXMsIHNvIGhlcmUgd2UgZm9yY2UgdGhlIGBzaGFkb3dTaWRlYCB0byBhbHdheXMgbWF0Y2ggdGhlIG1haW4gc2lkZS5cbiAgICBzaGFkb3dTaWRlOiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZGVcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIC8vbm8tb3BcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0ZXh0TWF0ZXJpYWxcbn1cblxuY29uc3QgZGVmYXVsdE1hdGVyaWFsID0gLyojX19QVVJFX18qLyBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoe1xuICBjb2xvcjogMHhmZmZmZmYsXG4gIHNpZGU6IERvdWJsZVNpZGUsXG4gIHRyYW5zcGFyZW50OiB0cnVlXG59KTtcbmNvbnN0IGRlZmF1bHRTdHJva2VDb2xvciA9IDB4ODA4MDgwO1xuXG5jb25zdCB0ZW1wTWF0NCA9IC8qI19fUFVSRV9fKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IHRlbXBWZWMzYSA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBWZWMzYiA9IC8qI19fUFVSRV9fKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBBcnJheSA9IFtdO1xuY29uc3Qgb3JpZ2luID0gLyojX19QVVJFX18qLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgZGVmYXVsdE9yaWVudCA9ICcreCt5JztcblxuZnVuY3Rpb24gZmlyc3Qobykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShvKSA/IG9bMF0gOiBvXG59XG5cbmxldCBnZXRGbGF0UmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxKSxcbiAgICBkZWZhdWx0TWF0ZXJpYWxcbiAgKTtcbiAgZ2V0RmxhdFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgcmV0dXJuIG1lc2hcbn07XG5sZXQgZ2V0Q3VydmVkUmF5Y2FzdE1lc2ggPSAoKSA9PiB7XG4gIGNvbnN0IG1lc2ggPSBuZXcgTWVzaChcbiAgICBuZXcgUGxhbmVHZW9tZXRyeSgxLCAxLCAzMiwgMSksXG4gICAgZGVmYXVsdE1hdGVyaWFsXG4gICk7XG4gIGdldEN1cnZlZFJheWNhc3RNZXNoID0gKCkgPT4gbWVzaDtcbiAgcmV0dXJuIG1lc2hcbn07XG5cbmNvbnN0IHN5bmNTdGFydEV2ZW50ID0geyB0eXBlOiAnc3luY3N0YXJ0JyB9O1xuY29uc3Qgc3luY0NvbXBsZXRlRXZlbnQgPSB7IHR5cGU6ICdzeW5jY29tcGxldGUnIH07XG5cbmNvbnN0IFNZTkNBQkxFX1BST1BTID0gW1xuICAnZm9udCcsXG4gICdmb250U2l6ZScsXG4gICdmb250U3R5bGUnLFxuICAnZm9udFdlaWdodCcsXG4gICdsYW5nJyxcbiAgJ2xldHRlclNwYWNpbmcnLFxuICAnbGluZUhlaWdodCcsXG4gICdtYXhXaWR0aCcsXG4gICdvdmVyZmxvd1dyYXAnLFxuICAndGV4dCcsXG4gICdkaXJlY3Rpb24nLFxuICAndGV4dEFsaWduJyxcbiAgJ3RleHRJbmRlbnQnLFxuICAnd2hpdGVTcGFjZScsXG4gICdhbmNob3JYJyxcbiAgJ2FuY2hvclknLFxuICAnY29sb3JSYW5nZXMnLFxuICAnc2RmR2x5cGhTaXplJ1xuXTtcblxuY29uc3QgQ09QWUFCTEVfUFJPUFMgPSBTWU5DQUJMRV9QUk9QUy5jb25jYXQoXG4gICdtYXRlcmlhbCcsXG4gICdjb2xvcicsXG4gICdkZXB0aE9mZnNldCcsXG4gICdjbGlwUmVjdCcsXG4gICdjdXJ2ZVJhZGl1cycsXG4gICdvcmllbnRhdGlvbicsXG4gICdnbHlwaEdlb21ldHJ5RGV0YWlsJ1xuKTtcblxuLyoqXG4gKiBAY2xhc3MgVGV4dFxuICpcbiAqIEEgVGhyZWVKUyBNZXNoIHRoYXQgcmVuZGVycyBhIHN0cmluZyBvZiB0ZXh0IG9uIGEgcGxhbmUgaW4gM0Qgc3BhY2UgdXNpbmcgc2lnbmVkIGRpc3RhbmNlXG4gKiBmaWVsZHMgKFNERikuXG4gKi9cbmNsYXNzIFRleHQgZXh0ZW5kcyBNZXNoIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgY29uc3QgZ2VvbWV0cnkgPSBuZXcgR2x5cGhzR2VvbWV0cnkoKTtcbiAgICBzdXBlcihnZW9tZXRyeSwgbnVsbCk7XG5cbiAgICAvLyA9PT0gVGV4dCBsYXlvdXQgcHJvcGVydGllczogPT09IC8vXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IHRleHRcbiAgICAgKiBUaGUgc3RyaW5nIG9mIHRleHQgdG8gYmUgcmVuZGVyZWQuXG4gICAgICovXG4gICAgdGhpcy50ZXh0ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBhbmNob3JYXG4gICAgICogRGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBwb3NpdGlvbiBpbiB0aGUgdGV4dCBibG9jayB0aGF0IHNob3VsZCBsaW5lIHVwIHdpdGggdGhlIGxvY2FsIG9yaWdpbi5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGEgbnVtZXJpYyB4IHBvc2l0aW9uIGluIGxvY2FsIHVuaXRzLCBhIHN0cmluZyBwZXJjZW50YWdlIG9mIHRoZSB0b3RhbFxuICAgICAqIHRleHQgYmxvY2sgd2lkdGggZS5nLiBgJzI1JSdgLCBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXl3b3JkIHN0cmluZ3M6ICdsZWZ0JywgJ2NlbnRlcicsXG4gICAgICogb3IgJ3JpZ2h0Jy5cbiAgICAgKi9cbiAgICB0aGlzLmFuY2hvclggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gYW5jaG9yWVxuICAgICAqIERlZmluZXMgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIGluIHRoZSB0ZXh0IGJsb2NrIHRoYXQgc2hvdWxkIGxpbmUgdXAgd2l0aCB0aGUgbG9jYWwgb3JpZ2luLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgYSBudW1lcmljIHkgcG9zaXRpb24gaW4gbG9jYWwgdW5pdHMgKG5vdGU6IGRvd24gaXMgbmVnYXRpdmUgeSksIGEgc3RyaW5nXG4gICAgICogcGVyY2VudGFnZSBvZiB0aGUgdG90YWwgdGV4dCBibG9jayBoZWlnaHQgZS5nLiBgJzI1JSdgLCBvciBvbmUgb2YgdGhlIGZvbGxvd2luZyBrZXl3b3JkIHN0cmluZ3M6XG4gICAgICogJ3RvcCcsICd0b3AtYmFzZWxpbmUnLCAndG9wLWNhcCcsICd0b3AtZXgnLCAnbWlkZGxlJywgJ2JvdHRvbS1iYXNlbGluZScsIG9yICdib3R0b20nLlxuICAgICAqL1xuICAgIHRoaXMuYW5jaG9yWSA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGN1cnZlUmFkaXVzXG4gICAgICogRGVmaW5lcyBhIGN5bGluZHJpY2FsIHJhZGl1cyBhbG9uZyB3aGljaCB0aGUgdGV4dCdzIHBsYW5lIHdpbGwgYmUgY3VydmVkLiBQb3NpdGl2ZSBudW1iZXJzIHB1dFxuICAgICAqIHRoZSBjeWxpbmRlcidzIGNlbnRlcmxpbmUgKG9yaWVudGVkIHZlcnRpY2FsbHkpIHRoYXQgZGlzdGFuY2UgaW4gZnJvbnQgb2YgdGhlIHRleHQsIGZvciBhIGNvbmNhdmVcbiAgICAgKiBjdXJ2YXR1cmUsIHdoaWxlIG5lZ2F0aXZlIG51bWJlcnMgcHV0IGl0IGJlaGluZCB0aGUgdGV4dCBmb3IgYSBjb252ZXggY3VydmF0dXJlLiBUaGUgY2VudGVybGluZVxuICAgICAqIHdpbGwgYmUgYWxpZ25lZCB3aXRoIHRoZSB0ZXh0J3MgbG9jYWwgb3JpZ2luOyB5b3UgY2FuIHVzZSBgYW5jaG9yWGAgdG8gb2Zmc2V0IGl0LlxuICAgICAqXG4gICAgICogU2luY2UgZWFjaCBnbHlwaCBpcyBieSBkZWZhdWx0IHJlbmRlcmVkIHdpdGggYSBzaW1wbGUgcXVhZCwgZWFjaCBnbHlwaCByZW1haW5zIGEgZmxhdCBwbGFuZVxuICAgICAqIGludGVybmFsbHkuIFlvdSBjYW4gdXNlIGBnbHlwaEdlb21ldHJ5RGV0YWlsYCB0byBhZGQgbW9yZSB2ZXJ0aWNlcyBmb3IgY3VydmF0dXJlIGluc2lkZSBnbHlwaHMuXG4gICAgICovXG4gICAgdGhpcy5jdXJ2ZVJhZGl1cyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IGRpcmVjdGlvblxuICAgICAqIFNldHMgdGhlIGJhc2UgZGlyZWN0aW9uIGZvciB0aGUgdGV4dC4gVGhlIGRlZmF1bHQgdmFsdWUgb2YgXCJhdXRvXCIgd2lsbCBjaG9vc2UgYSBkaXJlY3Rpb24gYmFzZWRcbiAgICAgKiBvbiB0aGUgdGV4dCdzIGNvbnRlbnQgYWNjb3JkaW5nIHRvIHRoZSBiaWRpIHNwZWMuIEEgdmFsdWUgb2YgXCJsdHJcIiBvciBcInJ0bFwiIHdpbGwgZm9yY2UgdGhlIGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICB0aGlzLmRpcmVjdGlvbiA9ICdhdXRvJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudWxsfSBmb250XG4gICAgICogVVJMIG9mIGEgY3VzdG9tIGZvbnQgdG8gYmUgdXNlZC4gRm9udCBmaWxlcyBjYW4gYmUgaW4gLnR0ZiwgLm90Ziwgb3IgLndvZmYgKG5vdCAud29mZjIpIGZvcm1hdHMuXG4gICAgICogRGVmYXVsdHMgdG8gTm90byBTYW5zLlxuICAgICAqL1xuICAgIHRoaXMuZm9udCA9IG51bGw7IC8vd2lsbCB1c2UgZGVmYXVsdCBmcm9tIFRleHRCdWlsZGVyXG5cbiAgICB0aGlzLnVuaWNvZGVGb250c1VSTCA9IG51bGw7IC8vZGVmYXVsdHMgdG8gQ0ROXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZvbnRTaXplXG4gICAgICogVGhlIHNpemUgYXQgd2hpY2ggdG8gcmVuZGVyIHRoZSBmb250IGluIGxvY2FsIHVuaXRzOyBjb3JyZXNwb25kcyB0byB0aGUgZW0tYm94IGhlaWdodFxuICAgICAqIG9mIHRoZSBjaG9zZW4gYGZvbnRgLlxuICAgICAqL1xuICAgIHRoaXMuZm9udFNpemUgPSAwLjE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8J25vcm1hbCd8J2JvbGQnfVxuICAgICAqIFRoZSB3ZWlnaHQgb2YgdGhlIGZvbnQuIEN1cnJlbnRseSBvbmx5IHVzZWQgZm9yIGZhbGxiYWNrIE5vdG8gZm9udHMuXG4gICAgICovXG4gICAgdGhpcy5mb250V2VpZ2h0ID0gJ25vcm1hbCc7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHsnbm9ybWFsJ3wnaXRhbGljJ31cbiAgICAgKiBUaGUgc3R5bGUgb2YgdGhlIGZvbnQuIEN1cnJlbnRseSBvbmx5IHVzZWQgZm9yIGZhbGxiYWNrIE5vdG8gZm9udHMuXG4gICAgICovXG4gICAgdGhpcy5mb250U3R5bGUgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudWxsfSBsYW5nXG4gICAgICogVGhlIGxhbmd1YWdlIGNvZGUgb2YgdGhpcyB0ZXh0OyBjYW4gYmUgdXNlZCBmb3IgZXhwbGljaXRseSBzZWxlY3RpbmcgY2VydGFpbiBDSksgZm9udHMuXG4gICAgICovXG4gICAgdGhpcy5sYW5nID0gbnVsbDtcblxuICAgICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBsZXR0ZXJTcGFjaW5nXG4gICAgICogU2V0cyBhIHVuaWZvcm0gYWRqdXN0bWVudCB0byBzcGFjaW5nIGJldHdlZW4gbGV0dGVycyBhZnRlciBrZXJuaW5nIGlzIGFwcGxpZWQuIFBvc2l0aXZlXG4gICAgICogbnVtYmVycyBpbmNyZWFzZSBzcGFjaW5nIGFuZCBuZWdhdGl2ZSBudW1iZXJzIGRlY3JlYXNlIGl0LlxuICAgICAqL1xuICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBsaW5lSGVpZ2h0XG4gICAgICogU2V0cyB0aGUgaGVpZ2h0IG9mIGVhY2ggbGluZSBvZiB0ZXh0LCBhcyBhIG11bHRpcGxlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byAnbm9ybWFsJ1xuICAgICAqIHdoaWNoIGNob29zZXMgYSByZWFzb25hYmxlIGhlaWdodCBiYXNlZCBvbiB0aGUgY2hvc2VuIGZvbnQncyBhc2NlbmRlci9kZXNjZW5kZXIgbWV0cmljcy5cbiAgICAgKi9cbiAgICB0aGlzLmxpbmVIZWlnaHQgPSAnbm9ybWFsJztcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gbWF4V2lkdGhcbiAgICAgKiBUaGUgbWF4aW11bSB3aWR0aCBvZiB0aGUgdGV4dCBibG9jaywgYWJvdmUgd2hpY2ggdGV4dCBtYXkgc3RhcnQgd3JhcHBpbmcgYWNjb3JkaW5nIHRvIHRoZVxuICAgICAqIGB3aGl0ZVNwYWNlYCBhbmQgYG92ZXJmbG93V3JhcGAgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICB0aGlzLm1heFdpZHRoID0gSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd9IG92ZXJmbG93V3JhcFxuICAgICAqIERlZmluZXMgaG93IHRleHQgd3JhcHMgaWYgdGhlIGB3aGl0ZVNwYWNlYCBwcm9wZXJ0eSBpcyBgbm9ybWFsYC4gQ2FuIGJlIGVpdGhlciBgJ25vcm1hbCdgXG4gICAgICogdG8gYnJlYWsgYXQgd2hpdGVzcGFjZSBjaGFyYWN0ZXJzLCBvciBgJ2JyZWFrLXdvcmQnYCB0byBhbGxvdyBicmVha2luZyB3aXRoaW4gd29yZHMuXG4gICAgICogRGVmYXVsdHMgdG8gYCdub3JtYWwnYC5cbiAgICAgKi9cbiAgICB0aGlzLm92ZXJmbG93V3JhcCA9ICdub3JtYWwnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSB0ZXh0QWxpZ25cbiAgICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbm1lbnQgb2YgZWFjaCBsaW5lIG9mIHRleHQgd2l0aGluIHRoZSBvdmVyYWxsIHRleHQgYm91bmRpbmcgYm94LlxuICAgICAqL1xuICAgIHRoaXMudGV4dEFsaWduID0gJ2xlZnQnO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSB0ZXh0SW5kZW50XG4gICAgICogSW5kZW50YXRpb24gZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgb2YgYSBsaW5lOyBzZWUgQ1NTIGB0ZXh0LWluZGVudGAuXG4gICAgICovXG4gICAgdGhpcy50ZXh0SW5kZW50ID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ30gd2hpdGVTcGFjZVxuICAgICAqIERlZmluZXMgd2hldGhlciB0ZXh0IHNob3VsZCB3cmFwIHdoZW4gYSBsaW5lIHJlYWNoZXMgdGhlIGBtYXhXaWR0aGAuIENhblxuICAgICAqIGJlIGVpdGhlciBgJ25vcm1hbCdgICh0aGUgZGVmYXVsdCksIHRvIGFsbG93IHdyYXBwaW5nIGFjY29yZGluZyB0byB0aGUgYG92ZXJmbG93V3JhcGAgcHJvcGVydHksXG4gICAgICogb3IgYCdub3dyYXAnYCB0byBwcmV2ZW50IHdyYXBwaW5nLiBOb3RlIHRoYXQgYCdub3JtYWwnYCBoZXJlIGhvbm9ycyBuZXdsaW5lIGNoYXJhY3RlcnMgdG9cbiAgICAgKiBtYW51YWxseSBicmVhayBsaW5lcywgbWFraW5nIGl0IGJlaGF2ZSBtb3JlIGxpa2UgYCdwcmUtd3JhcCdgIGRvZXMgaW4gQ1NTLlxuICAgICAqL1xuICAgIHRoaXMud2hpdGVTcGFjZSA9ICdub3JtYWwnO1xuXG5cbiAgICAvLyA9PT0gUHJlc2VudGF0aW9uIHByb3BlcnRpZXM6ID09PSAvL1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7VEhSRUUuTWF0ZXJpYWx9IG1hdGVyaWFsXG4gICAgICogRGVmaW5lcyBhIF9iYXNlXyBtYXRlcmlhbCB0byBiZSB1c2VkIHdoZW4gcmVuZGVyaW5nIHRoZSB0ZXh0LiBUaGlzIG1hdGVyaWFsIHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIHdpdGggYSBtYXRlcmlhbCBkZXJpdmVkIGZyb20gaXQsIHRoYXQgYWRkcyBzaGFkZXIgY29kZSB0b1xuICAgICAqIGRlY3JlYXNlIHRoZSBhbHBoYSBmb3IgZWFjaCBmcmFnbWVudCAocGl4ZWwpIG91dHNpZGUgdGhlIHRleHQgZ2x5cGhzLCB3aXRoIGFudGlhbGlhc2luZy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IHdpbGwgZGVyaXZlIGZyb20gYSBzaW1wbGUgd2hpdGUgTWVzaEJhc2ljTWF0ZXJpYWwsIGJ1dCB5b3UgY2FuIHVzZSBhbnlcbiAgICAgKiBvZiB0aGUgb3RoZXIgbWVzaCBtYXRlcmlhbHMgdG8gZ2FpbiBvdGhlciBmZWF0dXJlcyBsaWtlIGxpZ2h0aW5nLCB0ZXh0dXJlIG1hcHMsIGV0Yy5cbiAgICAgKlxuICAgICAqIEFsc28gc2VlIHRoZSBgY29sb3JgIHNob3J0Y3V0IHByb3BlcnR5LlxuICAgICAqL1xuICAgIHRoaXMubWF0ZXJpYWwgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfG51bWJlcnxUSFJFRS5Db2xvcn0gY29sb3JcbiAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIGBjb2xvcmAgb2YgdGhlIHRleHQncyBtYXRlcmlhbC4gWW91IGNhbiB1c2UgdGhpc1xuICAgICAqIGlmIHlvdSBkb24ndCB3YW50IHRvIHNwZWNpZnkgYSB3aG9sZSBjdXN0b20gYG1hdGVyaWFsYC4gQWxzbywgaWYgeW91IGRvIHVzZSBhIGN1c3RvbVxuICAgICAqIGBtYXRlcmlhbGAsIHRoaXMgY29sb3Igd2lsbCBvbmx5IGJlIHVzZWQgZm9yIHRoaXMgcGFydGljdWFyIFRleHQgaW5zdGFuY2UsIGV2ZW4gaWZcbiAgICAgKiB0aGF0IHNhbWUgbWF0ZXJpYWwgaW5zdGFuY2UgaXMgc2hhcmVkIGFjcm9zcyBtdWx0aXBsZSBUZXh0IG9iamVjdHMuXG4gICAgICovXG4gICAgdGhpcy5jb2xvciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtvYmplY3R8bnVsbH0gY29sb3JSYW5nZXNcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhpcyBhbGxvd3MgbW9yZSBmaW5lLWdyYWluZWQgY29udHJvbCBvZiBjb2xvcnMgZm9yIGluZGl2aWR1YWwgb3IgcmFuZ2VzIG9mIGNoYXJhY3RlcnMsXG4gICAgICogdGFraW5nIHByZWNlZGVuY2Ugb3ZlciB0aGUgbWF0ZXJpYWwncyBgY29sb3JgLiBJdHMgZm9ybWF0IGlzIGFuIE9iamVjdCB3aG9zZSBrZXlzIGVhY2hcbiAgICAgKiBkZWZpbmUgYSBzdGFydGluZyBjaGFyYWN0ZXIgaW5kZXggZm9yIGEgcmFuZ2UsIGFuZCB3aG9zZSB2YWx1ZXMgYXJlIHRoZSBjb2xvciBmb3IgZWFjaFxuICAgICAqIHJhbmdlLiBUaGUgY29sb3IgdmFsdWUgY2FuIGJlIGEgbnVtZXJpYyBoZXggY29sb3IgdmFsdWUsIGEgYFRIUkVFLkNvbG9yYCBvYmplY3QsIG9yXG4gICAgICogYW55IG9mIHRoZSBzdHJpbmdzIGFjY2VwdGVkIGJ5IGBUSFJFRS5Db2xvcmAuXG4gICAgICovXG4gICAgdGhpcy5jb2xvclJhbmdlcyA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lV2lkdGhcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIHdpZHRoIG9mIGFuIG91dGxpbmUvaGFsbyB0byBiZSBkcmF3biBhcm91bmQgZWFjaCB0ZXh0IGdseXBoIHVzaW5nIHRoZSBgb3V0bGluZUNvbG9yYCBhbmQgYG91dGxpbmVPcGFjaXR5YC5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLlxuICAgICAqIGBcIjEyJVwiYCB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLCB3aGljaCBtZWFuc1xuICAgICAqIG5vIG91dGxpbmUgd2lsbCBiZSBkcmF3biB1bmxlc3MgYW4gYG91dGxpbmVPZmZzZXRYL1lgIG9yIGBvdXRsaW5lQmx1cmAgaXMgc2V0LlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZVdpZHRoID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge3N0cmluZ3xudW1iZXJ8VEhSRUUuQ29sb3J9IG91dGxpbmVDb2xvclxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgb3V0bGluZSwgaWYgYG91dGxpbmVXaWR0aGAvYG91dGxpbmVCbHVyYC9gb3V0bGluZU9mZnNldFgvWWAgYXJlIHNldC5cbiAgICAgKiBEZWZhdWx0cyB0byBibGFjay5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVDb2xvciA9IDB4MDAwMDAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfSBvdXRsaW5lT3BhY2l0eVxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgb3BhY2l0eSBvZiB0aGUgb3V0bGluZSwgaWYgYG91dGxpbmVXaWR0aGAvYG91dGxpbmVCbHVyYC9gb3V0bGluZU9mZnNldFgvWWAgYXJlIHNldC5cbiAgICAgKiBEZWZhdWx0cyB0byBgMWAuXG4gICAgICovXG4gICAgdGhpcy5vdXRsaW5lT3BhY2l0eSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8c3RyaW5nfSBvdXRsaW5lQmx1clxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBBIGJsdXIgcmFkaXVzIGFwcGxpZWQgdG8gdGhlIG91dGVyIGVkZ2Ugb2YgdGhlIHRleHQncyBvdXRsaW5lLiBJZiB0aGUgYG91dGxpbmVXaWR0aGAgaXNcbiAgICAgKiB6ZXJvLCB0aGUgYmx1ciB3aWxsIGJlIGFwcGxpZWQgYXQgdGhlIGdseXBoIGVkZ2UsIGxpa2UgQ1NTJ3MgYHRleHQtc2hhZG93YCBibHVyIHJhZGl1cy5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLlxuICAgICAqIGBcIjEyJVwiYCB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZUJsdXIgPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZU9mZnNldFhcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogQSBob3Jpem9udGFsIG9mZnNldCBmb3IgdGhlIHRleHQgb3V0bGluZS5cbiAgICAgKiBDYW4gYmUgc3BlY2lmaWVkIGFzIGVpdGhlciBhbiBhYnNvbHV0ZSBudW1iZXIgaW4gbG9jYWwgdW5pdHMsIG9yIGFzIGEgcGVyY2VudGFnZSBzdHJpbmcgZS5nLiBgXCIxMiVcImBcbiAgICAgKiB3aGljaCBpcyB0cmVhdGVkIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgYGZvbnRTaXplYC4gRGVmYXVsdHMgdG8gYDBgLlxuICAgICAqL1xuICAgIHRoaXMub3V0bGluZU9mZnNldFggPSAwO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7bnVtYmVyfHN0cmluZ30gb3V0bGluZU9mZnNldFlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogQSB2ZXJ0aWNhbCBvZmZzZXQgZm9yIHRoZSB0ZXh0IG91dGxpbmUuXG4gICAgICogQ2FuIGJlIHNwZWNpZmllZCBhcyBlaXRoZXIgYW4gYWJzb2x1dGUgbnVtYmVyIGluIGxvY2FsIHVuaXRzLCBvciBhcyBhIHBlcmNlbnRhZ2Ugc3RyaW5nIGUuZy4gYFwiMTIlXCJgXG4gICAgICogd2hpY2ggaXMgdHJlYXRlZCBhcyBhIHBlcmNlbnRhZ2Ugb2YgdGhlIGBmb250U2l6ZWAuIERlZmF1bHRzIHRvIGAwYC5cbiAgICAgKi9cbiAgICB0aGlzLm91dGxpbmVPZmZzZXRZID0gMDtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcnxzdHJpbmd9IHN0cm9rZVdpZHRoXG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSB3aWR0aCBvZiBhbiBpbm5lciBzdHJva2UgZHJhd24gaW5zaWRlIGVhY2ggdGV4dCBnbHlwaCB1c2luZyB0aGUgYHN0cm9rZUNvbG9yYCBhbmQgYHN0cm9rZU9wYWNpdHlgLlxuICAgICAqIENhbiBiZSBzcGVjaWZpZWQgYXMgZWl0aGVyIGFuIGFic29sdXRlIG51bWJlciBpbiBsb2NhbCB1bml0cywgb3IgYXMgYSBwZXJjZW50YWdlIHN0cmluZyBlLmcuIGBcIjEyJVwiYFxuICAgICAqIHdoaWNoIGlzIHRyZWF0ZWQgYXMgYSBwZXJjZW50YWdlIG9mIHRoZSBgZm9udFNpemVgLiBEZWZhdWx0cyB0byBgMGAuXG4gICAgICovXG4gICAgdGhpcy5zdHJva2VXaWR0aCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtzdHJpbmd8bnVtYmVyfFRIUkVFLkNvbG9yfSBzdHJva2VDb2xvclxuICAgICAqIFdBUk5JTkc6IFRoaXMgQVBJIGlzIGV4cGVyaW1lbnRhbCBhbmQgbWF5IGNoYW5nZS5cbiAgICAgKiBUaGUgY29sb3Igb2YgdGhlIHRleHQgc3Ryb2tlLCBpZiBgc3Ryb2tlV2lkdGhgIGlzIGdyZWF0ZXIgdGhhbiB6ZXJvLiBEZWZhdWx0cyB0byBncmF5LlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBkZWZhdWx0U3Ryb2tlQ29sb3I7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IHN0cm9rZU9wYWNpdHlcbiAgICAgKiBXQVJOSU5HOiBUaGlzIEFQSSBpcyBleHBlcmltZW50YWwgYW5kIG1heSBjaGFuZ2UuXG4gICAgICogVGhlIG9wYWNpdHkgb2YgdGhlIHN0cm9rZSwgaWYgYHN0cm9rZVdpZHRoYCBpcyBncmVhdGVyIHRoYW4gemVyby4gRGVmYXVsdHMgdG8gYDFgLlxuICAgICAqL1xuICAgIHRoaXMuc3Ryb2tlT3BhY2l0eSA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGZpbGxPcGFjaXR5XG4gICAgICogV0FSTklORzogVGhpcyBBUEkgaXMgZXhwZXJpbWVudGFsIGFuZCBtYXkgY2hhbmdlLlxuICAgICAqIFRoZSBvcGFjaXR5IG9mIHRoZSBnbHlwaCdzIGZpbGwgZnJvbSAwIHRvIDEuIFRoaXMgYmVoYXZlcyBsaWtlIHRoZSBtYXRlcmlhbCdzIGBvcGFjaXR5YCBidXQgYWxsb3dzXG4gICAgICogZ2l2aW5nIHRoZSBmaWxsIGEgZGlmZmVyZW50IG9wYWNpdHkgdGhhbiB0aGUgYHN0cm9rZU9wYWNpdHlgLiBBIGZpbGxPcGFjaXR5IG9mIGAwYCBtYWtlcyB0aGVcbiAgICAgKiBpbnRlcmlvciBvZiB0aGUgZ2x5cGggaW52aXNpYmxlLCBsZWF2aW5nIGp1c3QgdGhlIGBzdHJva2VXaWR0aGAuIERlZmF1bHRzIHRvIGAxYC5cbiAgICAgKi9cbiAgICB0aGlzLmZpbGxPcGFjaXR5ID0gMTtcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXIge251bWJlcn0gZGVwdGhPZmZzZXRcbiAgICAgKiBUaGlzIGlzIGEgc2hvcnRjdXQgZm9yIHNldHRpbmcgdGhlIG1hdGVyaWFsJ3MgYHBvbHlnb25PZmZzZXRgIGFuZCByZWxhdGVkIHByb3BlcnRpZXMsXG4gICAgICogd2hpY2ggY2FuIGJlIHVzZWZ1bCBpbiBwcmV2ZW50aW5nIHotZmlnaHRpbmcgd2hlbiB0aGlzIHRleHQgaXMgbGFpZCBvbiB0b3Agb2YgYW5vdGhlclxuICAgICAqIHBsYW5lIGluIHRoZSBzY2VuZS4gUG9zaXRpdmUgbnVtYmVycyBhcmUgZnVydGhlciBmcm9tIHRoZSBjYW1lcmEsIG5lZ2F0aXZlcyBjbG9zZXIuXG4gICAgICovXG4gICAgdGhpcy5kZXB0aE9mZnNldCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtBcnJheTxudW1iZXI+fSBjbGlwUmVjdFxuICAgICAqIElmIHNwZWNpZmllZCwgZGVmaW5lcyBhIGBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV1gIG9mIGEgcmVjdGFuZ2xlIG91dHNpZGUgb2Ygd2hpY2ggYWxsXG4gICAgICogcGl4ZWxzIHdpbGwgYmUgZGlzY2FyZGVkLiBUaGlzIGNhbiBiZSB1c2VkIGZvciBleGFtcGxlIHRvIGNsaXAgb3ZlcmZsb3dpbmcgdGV4dCB3aGVuXG4gICAgICogYHdoaXRlU3BhY2U9J25vd3JhcCdgLlxuICAgICAqL1xuICAgIHRoaXMuY2xpcFJlY3QgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlciB7c3RyaW5nfSBvcmllbnRhdGlvblxuICAgICAqIERlZmluZXMgdGhlIGF4aXMgcGxhbmUgb24gd2hpY2ggdGhlIHRleHQgc2hvdWxkIGJlIGxhaWQgb3V0IHdoZW4gdGhlIG1lc2ggaGFzIG5vIGV4dHJhXG4gICAgICogcm90YXRpb24gdHJhbnNmb3JtLiBJdCBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgd2l0aCB0d28gYXhlczogdGhlIGhvcml6b250YWwgYXhpcyB3aXRoXG4gICAgICogcG9zaXRpdmUgcG9pbnRpbmcgcmlnaHQsIGFuZCB0aGUgdmVydGljYWwgYXhpcyB3aXRoIHBvc2l0aXZlIHBvaW50aW5nIHVwLiBCeSBkZWZhdWx0IHRoaXNcbiAgICAgKiBpcyAnK3greScsIG1lYW5pbmcgdGhlIHRleHQgc2l0cyBvbiB0aGUgeHkgcGxhbmUgd2l0aCB0aGUgdGV4dCdzIHRvcCB0b3dhcmQgcG9zaXRpdmUgeVxuICAgICAqIGFuZCBmYWNpbmcgcG9zaXRpdmUgei4gQSB2YWx1ZSBvZiAnK3gteicgd291bGQgcGxhY2UgaXQgb24gdGhlIHh6IHBsYW5lIHdpdGggdGhlIHRleHQnc1xuICAgICAqIHRvcCB0b3dhcmQgbmVnYXRpdmUgeiBhbmQgZmFjaW5nIHBvc2l0aXZlIHkuXG4gICAgICovXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9IGRlZmF1bHRPcmllbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ9IGdseXBoR2VvbWV0cnlEZXRhaWxcbiAgICAgKiBDb250cm9scyBudW1iZXIgb2YgdmVydGljYWwvaG9yaXpvbnRhbCBzZWdtZW50cyB0aGF0IG1ha2UgdXAgZWFjaCBnbHlwaCdzIHJlY3Rhbmd1bGFyXG4gICAgICogcGxhbmUuIERlZmF1bHRzIHRvIDEuIFRoaXMgY2FuIGJlIGluY3JlYXNlZCB0byBwcm92aWRlIG1vcmUgZ2VvbWV0cmljYWwgZGV0YWlsIGZvciBjdXN0b21cbiAgICAgKiB2ZXJ0ZXggc2hhZGVyIGVmZmVjdHMsIGZvciBleGFtcGxlLlxuICAgICAqL1xuICAgIHRoaXMuZ2x5cGhHZW9tZXRyeURldGFpbCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtudW1iZXJ8bnVsbH0gc2RmR2x5cGhTaXplXG4gICAgICogVGhlIHNpemUgb2YgZWFjaCBnbHlwaCdzIFNERiAoc2lnbmVkIGRpc3RhbmNlIGZpZWxkKSB1c2VkIGZvciByZW5kZXJpbmcuIFRoaXMgbXVzdCBiZSBhXG4gICAgICogcG93ZXItb2YtdHdvIG51bWJlci4gRGVmYXVsdHMgdG8gNjQgd2hpY2ggaXMgZ2VuZXJhbGx5IGEgZ29vZCBiYWxhbmNlIG9mIHNpemUgYW5kIHF1YWxpdHlcbiAgICAgKiBmb3IgbW9zdCBmb250cy4gTGFyZ2VyIHNpemVzIGNhbiBpbXByb3ZlIHRoZSBxdWFsaXR5IG9mIGdseXBoIHJlbmRlcmluZyBieSBpbmNyZWFzaW5nXG4gICAgICogdGhlIHNoYXJwbmVzcyBvZiBjb3JuZXJzIGFuZCBwcmV2ZW50aW5nIGxvc3Mgb2YgdmVyeSB0aGluIGxpbmVzLCBhdCB0aGUgZXhwZW5zZSBvZlxuICAgICAqIGluY3JlYXNlZCBtZW1vcnkgZm9vdHByaW50IGFuZCBsb25nZXIgU0RGIGdlbmVyYXRpb24gdGltZS5cbiAgICAgKi9cbiAgICB0aGlzLnNkZkdseXBoU2l6ZSA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyIHtib29sZWFufSBncHVBY2NlbGVyYXRlU0RGXG4gICAgICogV2hlbiBgdHJ1ZWAsIHRoZSBTREYgZ2VuZXJhdGlvbiBwcm9jZXNzIHdpbGwgYmUgR1BVLWFjY2VsZXJhdGVkIHdpdGggV2ViR0wgd2hlbiBwb3NzaWJsZSxcbiAgICAgKiBtYWtpbmcgaXQgbXVjaCBmYXN0ZXIgZXNwZWNpYWxseSBmb3IgY29tcGxleCBnbHlwaHMsIGFuZCBmYWxsaW5nIGJhY2sgdG8gYSBKYXZhU2NyaXB0IHZlcnNpb25cbiAgICAgKiBleGVjdXRlZCBpbiB3ZWIgd29ya2VycyB3aGVuIHN1cHBvcnQgaXNuJ3QgYXZhaWxhYmxlLiBJdCBzaG91bGQgYXV0b21hdGljYWxseSBkZXRlY3Qgc3VwcG9ydCxcbiAgICAgKiBidXQgaXQncyBzdGlsbCBzb21ld2hhdCBleHBlcmltZW50YWwsIHNvIHlvdSBjYW4gc2V0IGl0IHRvIGBmYWxzZWAgdG8gZm9yY2UgaXQgdG8gdXNlIHRoZSBKU1xuICAgICAqIHZlcnNpb24gaWYgeW91IGVuY291bnRlciBpc3N1ZXMgd2l0aCBpdC5cbiAgICAgKi9cbiAgICB0aGlzLmdwdUFjY2VsZXJhdGVTREYgPSB0cnVlO1xuXG4gICAgdGhpcy5kZWJ1Z1NERiA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHRleHQgcmVuZGVyaW5nIGFjY29yZGluZyB0byB0aGUgY3VycmVudCB0ZXh0LXJlbGF0ZWQgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzLlxuICAgKiBUaGlzIGlzIGFuIGFzeW5jIHByb2Nlc3MsIHNvIHlvdSBjYW4gcGFzcyBpbiBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gaXRcbiAgICogZmluaXNoZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtjYWxsYmFja11cbiAgICovXG4gIHN5bmMoY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fbmVlZHNTeW5jKSB7XG4gICAgICB0aGlzLl9uZWVkc1N5bmMgPSBmYWxzZTtcblxuICAgICAgLy8gSWYgdGhlcmUncyBhbm90aGVyIHN5bmMgc3RpbGwgaW4gcHJvZ3Jlc3MsIHF1ZXVlXG4gICAgICBpZiAodGhpcy5faXNTeW5jaW5nKSB7XG4gICAgICAgICh0aGlzLl9xdWV1ZWRTeW5jcyB8fCAodGhpcy5fcXVldWVkU3luY3MgPSBbXSkpLnB1c2goY2FsbGJhY2spO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faXNTeW5jaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHN5bmNTdGFydEV2ZW50KTtcblxuICAgICAgICBnZXRUZXh0UmVuZGVySW5mbyh7XG4gICAgICAgICAgdGV4dDogdGhpcy50ZXh0LFxuICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udCxcbiAgICAgICAgICBsYW5nOiB0aGlzLmxhbmcsXG4gICAgICAgICAgZm9udFNpemU6IHRoaXMuZm9udFNpemUgfHwgMC4xLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuZm9udFdlaWdodCB8fCAnbm9ybWFsJyxcbiAgICAgICAgICBmb250U3R5bGU6IHRoaXMuZm9udFN0eWxlIHx8ICdub3JtYWwnLFxuICAgICAgICAgIGxldHRlclNwYWNpbmc6IHRoaXMubGV0dGVyU3BhY2luZyB8fCAwLFxuICAgICAgICAgIGxpbmVIZWlnaHQ6IHRoaXMubGluZUhlaWdodCB8fCAnbm9ybWFsJyxcbiAgICAgICAgICBtYXhXaWR0aDogdGhpcy5tYXhXaWR0aCxcbiAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuZGlyZWN0aW9uIHx8ICdhdXRvJyxcbiAgICAgICAgICB0ZXh0QWxpZ246IHRoaXMudGV4dEFsaWduLFxuICAgICAgICAgIHRleHRJbmRlbnQ6IHRoaXMudGV4dEluZGVudCxcbiAgICAgICAgICB3aGl0ZVNwYWNlOiB0aGlzLndoaXRlU3BhY2UsXG4gICAgICAgICAgb3ZlcmZsb3dXcmFwOiB0aGlzLm92ZXJmbG93V3JhcCxcbiAgICAgICAgICBhbmNob3JYOiB0aGlzLmFuY2hvclgsXG4gICAgICAgICAgYW5jaG9yWTogdGhpcy5hbmNob3JZLFxuICAgICAgICAgIGNvbG9yUmFuZ2VzOiB0aGlzLmNvbG9yUmFuZ2VzLFxuICAgICAgICAgIGluY2x1ZGVDYXJldFBvc2l0aW9uczogdHJ1ZSwgLy9UT0RPIHBhcmFtZXRlcml6ZVxuICAgICAgICAgIHNkZkdseXBoU2l6ZTogdGhpcy5zZGZHbHlwaFNpemUsXG4gICAgICAgICAgZ3B1QWNjZWxlcmF0ZVNERjogdGhpcy5ncHVBY2NlbGVyYXRlU0RGLFxuICAgICAgICAgIHVuaWNvZGVGb250c1VSTDogdGhpcy51bmljb2RlRm9udHNVUkwsXG4gICAgICAgIH0sIHRleHRSZW5kZXJJbmZvID0+IHtcbiAgICAgICAgICB0aGlzLl9pc1N5bmNpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIC8vIFNhdmUgcmVzdWx0IGZvciBsYXRlciB1c2UgaW4gb25CZWZvcmVSZW5kZXJcbiAgICAgICAgICB0aGlzLl90ZXh0UmVuZGVySW5mbyA9IHRleHRSZW5kZXJJbmZvO1xuXG4gICAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzXG4gICAgICAgICAgdGhpcy5nZW9tZXRyeS51cGRhdGVHbHlwaHMoXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5nbHlwaEJvdW5kcyxcbiAgICAgICAgICAgIHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uYmxvY2tCb3VuZHMsXG4gICAgICAgICAgICB0ZXh0UmVuZGVySW5mby5jaHVua2VkQm91bmRzLFxuICAgICAgICAgICAgdGV4dFJlbmRlckluZm8uZ2x5cGhDb2xvcnNcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgLy8gSWYgd2UgaGFkIGV4dHJhIHN5bmMgcmVxdWVzdHMgcXVldWVkIHVwLCBraWNrIGl0IG9mZlxuICAgICAgICAgIGNvbnN0IHF1ZXVlZCA9IHRoaXMuX3F1ZXVlZFN5bmNzO1xuICAgICAgICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlZFN5bmNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLnN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICBxdWV1ZWQuZm9yRWFjaChmbiA9PiBmbiAmJiBmbigpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChzeW5jQ29tcGxldGVFdmVudCk7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlIGEgc3luYyBpZiBuZWVkZWQgLSBub3RlIGl0IHdvbid0IGNvbXBsZXRlIHVudGlsIG5leHQgZnJhbWUgYXQgdGhlXG4gICAqIGVhcmxpZXN0IHNvIGlmIHBvc3NpYmxlIGl0J3MgYSBnb29kIGlkZWEgdG8gY2FsbCBzeW5jKCkgbWFudWFsbHkgYXMgc29vbiBhc1xuICAgKiBhbGwgdGhlIHByb3BlcnRpZXMgaGF2ZSBiZWVuIHNldC5cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBvbkJlZm9yZVJlbmRlcihyZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCkge1xuICAgIHRoaXMuc3luYygpO1xuXG4gICAgLy8gVGhpcyBtYXkgbm90IGFsd2F5cyBiZSBhIHRleHQgbWF0ZXJpYWwsIGUuZy4gaWYgdGhlcmUncyBhIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgcHJlc2VudFxuICAgIGlmIChtYXRlcmlhbC5pc1Ryb2lrYVRleHRNYXRlcmlhbCkge1xuICAgICAgdGhpcy5fcHJlcGFyZUZvclJlbmRlcihtYXRlcmlhbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3J0Y3V0IHRvIGRpc3Bvc2UgdGhlIGdlb21ldHJ5IHNwZWNpZmljIHRvIHRoaXMgaW5zdGFuY2UuXG4gICAqIE5vdGU6IHdlIGRvbid0IGFsc28gZGlzcG9zZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBoZXJlIGJlY2F1c2UgaWYgYW55dGhpbmcgZWxzZSBpc1xuICAgKiBzaGFyaW5nIHRoZSBzYW1lIGJhc2UgbWF0ZXJpYWwgaXQgd2lsbCByZXN1bHQgaW4gYSBwYXVzZSBuZXh0IGZyYW1lIGFzIHRoZSBwcm9ncmFtXG4gICAqIGlzIHJlY29tcGlsZWQuIEluc3RlYWQgdXNlcnMgY2FuIGRpc3Bvc2UgdGhlIGJhc2UgbWF0ZXJpYWwgbWFudWFsbHksIGxpa2Ugbm9ybWFsLFxuICAgKiBhbmQgd2UnbGwgYWxzbyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIGF0IHRoYXQgdGltZS5cbiAgICovXG4gIGRpc3Bvc2UoKSB7XG4gICAgdGhpcy5nZW9tZXRyeS5kaXNwb3NlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHByb3BlcnR5IHtUcm9pa2FUZXh0UmVuZGVySW5mb3xudWxsfSB0ZXh0UmVuZGVySW5mb1xuICAgKiBAcmVhZG9ubHlcbiAgICogVGhlIGN1cnJlbnQgcHJvY2Vzc2VkIHJlbmRlcmluZyBkYXRhIGZvciB0aGlzIFRleHRNZXNoLCByZXR1cm5lZCBieSB0aGUgVGV4dEJ1aWxkZXIgYWZ0ZXJcbiAgICogYSBgc3luYygpYCBjYWxsLiBUaGlzIHdpbGwgYmUgYG51bGxgIGluaXRpYWxseSwgYW5kIG1heSBiZSBzdGFsZSBmb3IgYSBzaG9ydCBwZXJpb2QgdW50aWxcbiAgICogdGhlIGFzeW5jaHJvdXMgYHN5bmMoKWAgcHJvY2VzcyBjb21wbGV0ZXMuXG4gICAqL1xuICBnZXQgdGV4dFJlbmRlckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RleHRSZW5kZXJJbmZvIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIHRleHQgZGVyaXZlZCBtYXRlcmlhbCBmcm9tIHRoZSBiYXNlIG1hdGVyaWFsLiBDYW4gYmUgb3ZlcnJpZGRlbiB0byB1c2UgYSBjdXN0b21cbiAgICogZGVyaXZlZCBtYXRlcmlhbC5cbiAgICovXG4gIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlVGV4dERlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpXG4gIH1cblxuICAvLyBIYW5kbGVyIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIHRoZSBiYXNlIG1hdGVyaWFsIHdpdGggb3VyIHVwZ3JhZGVzLiBXZSBkbyB0aGUgd3JhcHBpbmdcbiAgLy8gbGF6aWx5IG9uIF9yZWFkXyByYXRoZXIgdGhhbiB3cml0ZSB0byBhdm9pZCB1bm5lY2Vzc2FyeSB3cmFwcGluZyBvbiB0cmFuc2llbnQgdmFsdWVzLlxuICBnZXQgbWF0ZXJpYWwoKSB7XG4gICAgbGV0IGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbDtcbiAgICBjb25zdCBiYXNlTWF0ZXJpYWwgPSB0aGlzLl9iYXNlTWF0ZXJpYWwgfHwgdGhpcy5fZGVmYXVsdE1hdGVyaWFsIHx8ICh0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgPSBkZWZhdWx0TWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgIWRlcml2ZWRNYXRlcmlhbC5pc0Rlcml2ZWRGcm9tKGJhc2VNYXRlcmlhbCkpIHtcbiAgICAgIGRlcml2ZWRNYXRlcmlhbCA9IHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IHRoaXMuY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCk7XG4gICAgICAvLyBkaXNwb3NlIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHdoZW4gaXRzIGJhc2UgbWF0ZXJpYWwgaXMgZGlzcG9zZWQ6XG4gICAgICBiYXNlTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgYmFzZU1hdGVyaWFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Rpc3Bvc2UnLCBvbkRpc3Bvc2UpO1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuZGlzcG9zZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIElmIHRleHQgb3V0bGluZSBpcyBjb25maWd1cmVkLCByZW5kZXIgaXQgYXMgYSBwcmVsaW1pbmFyeSBkcmF3IHVzaW5nIFRocmVlJ3MgbXVsdGktbWF0ZXJpYWxcbiAgICAvLyBmZWF0dXJlIChzZWUgR2x5cGhzR2VvbWV0cnkgd2hpY2ggc2V0cyB1cCBgZ3JvdXBzYCBmb3IgdGhpcyBwdXJwb3NlKSBEb2luZyBpdCB3aXRoIG11bHRpXG4gICAgLy8gbWF0ZXJpYWxzIGVuc3VyZXMgdGhlIGxheWVycyBhcmUgYWx3YXlzIHJlbmRlcmVkIGNvbnNlY3V0aXZlbHkgaW4gYSBjb25zaXN0ZW50IG9yZGVyLlxuICAgIC8vIEVhY2ggbGF5ZXIgd2lsbCB0cmlnZ2VyIG9uQmVmb3JlUmVuZGVyIHdpdGggdGhlIGFwcHJvcHJpYXRlIG1hdGVyaWFsLlxuICAgIGlmICh0aGlzLmhhc091dGxpbmUoKSkge1xuICAgICAgbGV0IG91dGxpbmVNYXRlcmlhbCA9IGRlcml2ZWRNYXRlcmlhbC5fb3V0bGluZU10bDtcbiAgICAgIGlmICghb3V0bGluZU1hdGVyaWFsKSB7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbCA9IGRlcml2ZWRNYXRlcmlhbC5fb3V0bGluZU10bCA9IE9iamVjdC5jcmVhdGUoZGVyaXZlZE1hdGVyaWFsLCB7XG4gICAgICAgICAgaWQ6IHt2YWx1ZTogZGVyaXZlZE1hdGVyaWFsLmlkICsgMC4xfVxuICAgICAgICB9KTtcbiAgICAgICAgb3V0bGluZU1hdGVyaWFsLmlzVGV4dE91dGxpbmVNYXRlcmlhbCA9IHRydWU7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5kZXB0aFdyaXRlID0gZmFsc2U7XG4gICAgICAgIG91dGxpbmVNYXRlcmlhbC5tYXAgPSBudWxsOyAvLz8/P1xuICAgICAgICBkZXJpdmVkTWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIGZ1bmN0aW9uIG9uRGlzcG9zZSgpIHtcbiAgICAgICAgICBkZXJpdmVkTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgICAgb3V0bGluZU1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW1xuICAgICAgICBvdXRsaW5lTWF0ZXJpYWwsXG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbFxuICAgICAgXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGVyaXZlZE1hdGVyaWFsXG4gICAgfVxuICB9XG4gIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICBpZiAoYmFzZU1hdGVyaWFsICYmIGJhc2VNYXRlcmlhbC5pc1Ryb2lrYVRleHRNYXRlcmlhbCkgeyAvL3ByZXZlbnQgZG91YmxlLWRlcml2YXRpb25cbiAgICAgIHRoaXMuX2Rlcml2ZWRNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbC5iYXNlTWF0ZXJpYWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2Jhc2VNYXRlcmlhbCA9IGJhc2VNYXRlcmlhbDtcbiAgICB9XG4gIH1cblxuICBoYXNPdXRsaW5lKCkge1xuICAgIHJldHVybiAhISh0aGlzLm91dGxpbmVXaWR0aCB8fCB0aGlzLm91dGxpbmVCbHVyIHx8IHRoaXMub3V0bGluZU9mZnNldFggfHwgdGhpcy5vdXRsaW5lT2Zmc2V0WSlcbiAgfVxuXG4gIGdldCBnbHlwaEdlb21ldHJ5RGV0YWlsKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmRldGFpbFxuICB9XG4gIHNldCBnbHlwaEdlb21ldHJ5RGV0YWlsKGRldGFpbCkge1xuICAgIHRoaXMuZ2VvbWV0cnkuZGV0YWlsID0gZGV0YWlsO1xuICB9XG5cbiAgZ2V0IGN1cnZlUmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5LmN1cnZlUmFkaXVzXG4gIH1cbiAgc2V0IGN1cnZlUmFkaXVzKHIpIHtcbiAgICB0aGlzLmdlb21ldHJ5LmN1cnZlUmFkaXVzID0gcjtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhbmQgdXBkYXRlIG1hdGVyaWFsIGZvciBzaGFkb3dzIHVwb24gcmVxdWVzdDpcbiAgZ2V0IGN1c3RvbURlcHRoTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGZpcnN0KHRoaXMubWF0ZXJpYWwpLmdldERlcHRoTWF0ZXJpYWwoKVxuICB9XG4gIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiBmaXJzdCh0aGlzLm1hdGVyaWFsKS5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgfVxuXG4gIF9wcmVwYXJlRm9yUmVuZGVyKG1hdGVyaWFsKSB7XG4gICAgY29uc3QgaXNPdXRsaW5lID0gbWF0ZXJpYWwuaXNUZXh0T3V0bGluZU1hdGVyaWFsO1xuICAgIGNvbnN0IHVuaWZvcm1zID0gbWF0ZXJpYWwudW5pZm9ybXM7XG4gICAgY29uc3QgdGV4dEluZm8gPSB0aGlzLnRleHRSZW5kZXJJbmZvO1xuICAgIGlmICh0ZXh0SW5mbykge1xuICAgICAgY29uc3Qge3NkZlRleHR1cmUsIGJsb2NrQm91bmRzfSA9IHRleHRJbmZvO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmUudmFsdWUgPSBzZGZUZXh0dXJlO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERlRleHR1cmVTaXplLnZhbHVlLnNldChzZGZUZXh0dXJlLmltYWdlLndpZHRoLCBzZGZUZXh0dXJlLmltYWdlLmhlaWdodCk7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthU0RGR2x5cGhTaXplLnZhbHVlID0gdGV4dEluZm8uc2RmR2x5cGhTaXplO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVNERkV4cG9uZW50LnZhbHVlID0gdGV4dEluZm8uc2RmRXhwb25lbnQ7XG4gICAgICB1bmlmb3Jtcy51VHJvaWthVG90YWxCb3VuZHMudmFsdWUuZnJvbUFycmF5KGJsb2NrQm91bmRzKTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FVc2VHbHlwaENvbG9ycy52YWx1ZSA9ICFpc091dGxpbmUgJiYgISF0ZXh0SW5mby5nbHlwaENvbG9ycztcblxuICAgICAgbGV0IGRpc3RhbmNlT2Zmc2V0ID0gMDtcbiAgICAgIGxldCBibHVyUmFkaXVzID0gMDtcbiAgICAgIGxldCBzdHJva2VXaWR0aCA9IDA7XG4gICAgICBsZXQgZmlsbE9wYWNpdHk7XG4gICAgICBsZXQgc3Ryb2tlT3BhY2l0eTtcbiAgICAgIGxldCBzdHJva2VDb2xvcjtcbiAgICAgIGxldCBvZmZzZXRYID0gMDtcbiAgICAgIGxldCBvZmZzZXRZID0gMDtcblxuICAgICAgaWYgKGlzT3V0bGluZSkge1xuICAgICAgICBsZXQge291dGxpbmVXaWR0aCwgb3V0bGluZU9mZnNldFgsIG91dGxpbmVPZmZzZXRZLCBvdXRsaW5lQmx1ciwgb3V0bGluZU9wYWNpdHl9ID0gdGhpcztcbiAgICAgICAgZGlzdGFuY2VPZmZzZXQgPSB0aGlzLl9wYXJzZVBlcmNlbnQob3V0bGluZVdpZHRoKSB8fCAwO1xuICAgICAgICBibHVyUmFkaXVzID0gTWF0aC5tYXgoMCwgdGhpcy5fcGFyc2VQZXJjZW50KG91dGxpbmVCbHVyKSB8fCAwKTtcbiAgICAgICAgZmlsbE9wYWNpdHkgPSBvdXRsaW5lT3BhY2l0eTtcbiAgICAgICAgb2Zmc2V0WCA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lT2Zmc2V0WCkgfHwgMDtcbiAgICAgICAgb2Zmc2V0WSA9IHRoaXMuX3BhcnNlUGVyY2VudChvdXRsaW5lT2Zmc2V0WSkgfHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZVdpZHRoID0gTWF0aC5tYXgoMCwgdGhpcy5fcGFyc2VQZXJjZW50KHRoaXMuc3Ryb2tlV2lkdGgpIHx8IDApO1xuICAgICAgICBpZiAoc3Ryb2tlV2lkdGgpIHtcbiAgICAgICAgICBzdHJva2VDb2xvciA9IHRoaXMuc3Ryb2tlQ29sb3I7XG4gICAgICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZUNvbG9yLnZhbHVlLnNldChzdHJva2VDb2xvciA9PSBudWxsID8gZGVmYXVsdFN0cm9rZUNvbG9yIDogc3Ryb2tlQ29sb3IpO1xuICAgICAgICAgIHN0cm9rZU9wYWNpdHkgPSB0aGlzLnN0cm9rZU9wYWNpdHk7XG4gICAgICAgICAgaWYgKHN0cm9rZU9wYWNpdHkgPT0gbnVsbCkgc3Ryb2tlT3BhY2l0eSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZmlsbE9wYWNpdHkgPSB0aGlzLmZpbGxPcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICB1bmlmb3Jtcy51VHJvaWthRWRnZU9mZnNldC52YWx1ZSA9IGRpc3RhbmNlT2Zmc2V0O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVBvc2l0aW9uT2Zmc2V0LnZhbHVlLnNldChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FCbHVyUmFkaXVzLnZhbHVlID0gYmx1clJhZGl1cztcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FTdHJva2VXaWR0aC52YWx1ZSA9IHN0cm9rZVdpZHRoO1xuICAgICAgdW5pZm9ybXMudVRyb2lrYVN0cm9rZU9wYWNpdHkudmFsdWUgPSBzdHJva2VPcGFjaXR5O1xuICAgICAgdW5pZm9ybXMudVRyb2lrYUZpbGxPcGFjaXR5LnZhbHVlID0gZmlsbE9wYWNpdHkgPT0gbnVsbCA/IDEgOiBmaWxsT3BhY2l0eTtcbiAgICAgIHVuaWZvcm1zLnVUcm9pa2FDdXJ2ZVJhZGl1cy52YWx1ZSA9IHRoaXMuY3VydmVSYWRpdXMgfHwgMDtcblxuICAgICAgbGV0IGNsaXBSZWN0ID0gdGhpcy5jbGlwUmVjdDtcbiAgICAgIGlmIChjbGlwUmVjdCAmJiBBcnJheS5pc0FycmF5KGNsaXBSZWN0KSAmJiBjbGlwUmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLmZyb21BcnJheShjbGlwUmVjdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBjbGlwcGluZyAtIGNob29zZSBhIGZpbml0ZSByZWN0IHRoYXQgc2hvdWxkbid0IGV2ZXIgYmUgcmVhY2hlZCBieSBvdmVyZmxvd2luZyBnbHlwaHMgb3Igb3V0bGluZXNcbiAgICAgICAgY29uc3QgcGFkID0gKHRoaXMuZm9udFNpemUgfHwgMC4xKSAqIDEwMDtcbiAgICAgICAgdW5pZm9ybXMudVRyb2lrYUNsaXBSZWN0LnZhbHVlLnNldChcbiAgICAgICAgICBibG9ja0JvdW5kc1swXSAtIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1sxXSAtIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1syXSArIHBhZCxcbiAgICAgICAgICBibG9ja0JvdW5kc1szXSArIHBhZFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5nZW9tZXRyeS5hcHBseUNsaXBSZWN0KHVuaWZvcm1zLnVUcm9pa2FDbGlwUmVjdC52YWx1ZSk7XG4gICAgfVxuICAgIHVuaWZvcm1zLnVUcm9pa2FTREZEZWJ1Zy52YWx1ZSA9ICEhdGhpcy5kZWJ1Z1NERjtcbiAgICBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0ID0gISF0aGlzLmRlcHRoT2Zmc2V0O1xuICAgIG1hdGVyaWFsLnBvbHlnb25PZmZzZXRGYWN0b3IgPSBtYXRlcmlhbC5wb2x5Z29uT2Zmc2V0VW5pdHMgPSB0aGlzLmRlcHRoT2Zmc2V0IHx8IDA7XG5cbiAgICAvLyBTaG9ydGN1dCBmb3Igc2V0dGluZyBtYXRlcmlhbCBjb2xvciB2aWEgYGNvbG9yYCBwcm9wIG9uIHRoZSBtZXNoOyB0aGlzIGlzXG4gICAgLy8gYXBwbGllZCBvbmx5IHRvIHRoZSBkZXJpdmVkIG1hdGVyaWFsIHRvIGF2b2lkIG11dGF0aW5nIGEgc2hhcmVkIGJhc2UgbWF0ZXJpYWwuXG4gICAgY29uc3QgY29sb3IgPSBpc091dGxpbmUgPyAodGhpcy5vdXRsaW5lQ29sb3IgfHwgMCkgOiB0aGlzLmNvbG9yO1xuXG4gICAgaWYgKGNvbG9yID09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSBtYXRlcmlhbC5jb2xvcjsgLy9pbmhlcml0IGZyb20gYmFzZVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb2xvck9iaiA9IG1hdGVyaWFsLmhhc093blByb3BlcnR5KCdjb2xvcicpID8gbWF0ZXJpYWwuY29sb3IgOiAobWF0ZXJpYWwuY29sb3IgPSBuZXcgQ29sb3IoKSk7XG4gICAgICBpZiAoY29sb3IgIT09IGNvbG9yT2JqLl9pbnB1dCB8fCB0eXBlb2YgY29sb3IgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbG9yT2JqLnNldChjb2xvck9iai5faW5wdXQgPSBjb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYmFzZSBvcmllbnRhdGlvblxuICAgIGxldCBvcmllbnQgPSB0aGlzLm9yaWVudGF0aW9uIHx8IGRlZmF1bHRPcmllbnQ7XG4gICAgaWYgKG9yaWVudCAhPT0gbWF0ZXJpYWwuX29yaWVudGF0aW9uKSB7XG4gICAgICBsZXQgcm90TWF0ID0gdW5pZm9ybXMudVRyb2lrYU9yaWVudC52YWx1ZTtcbiAgICAgIG9yaWVudCA9IG9yaWVudC5yZXBsYWNlKC9bXi0reHl6XS9nLCAnJyk7XG4gICAgICBsZXQgbWF0Y2ggPSBvcmllbnQgIT09IGRlZmF1bHRPcmllbnQgJiYgb3JpZW50Lm1hdGNoKC9eKFstK10pKFt4eXpdKShbLStdKShbeHl6XSkkLyk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbGV0IFssIGhTaWduLCBoQXhpcywgdlNpZ24sIHZBeGlzXSA9IG1hdGNoO1xuICAgICAgICB0ZW1wVmVjM2Euc2V0KDAsIDAsIDApW2hBeGlzXSA9IGhTaWduID09PSAnLScgPyAxIDogLTE7XG4gICAgICAgIHRlbXBWZWMzYi5zZXQoMCwgMCwgMClbdkF4aXNdID0gdlNpZ24gPT09ICctJyA/IC0xIDogMTtcbiAgICAgICAgdGVtcE1hdDQubG9va0F0KG9yaWdpbiwgdGVtcFZlYzNhLmNyb3NzKHRlbXBWZWMzYiksIHRlbXBWZWMzYik7XG4gICAgICAgIHJvdE1hdC5zZXRGcm9tTWF0cml4NCh0ZW1wTWF0NCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3RNYXQuaWRlbnRpdHkoKTtcbiAgICAgIH1cbiAgICAgIG1hdGVyaWFsLl9vcmllbnRhdGlvbiA9IG9yaWVudDtcbiAgICB9XG4gIH1cblxuICBfcGFyc2VQZXJjZW50KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxldCBtYXRjaCA9IHZhbHVlLm1hdGNoKC9eKC0/W1xcZC5dKyklJC8pO1xuICAgICAgbGV0IHBjdCA9IG1hdGNoID8gcGFyc2VGbG9hdChtYXRjaFsxXSkgOiBOYU47XG4gICAgICB2YWx1ZSA9IChpc05hTihwY3QpID8gMCA6IHBjdCAvIDEwMCkgKiB0aGlzLmZvbnRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiBsb2NhbCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAqL1xuICBsb2NhbFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG4gICAgdGFyZ2V0LmNvcHkocG9zaXRpb24pOyAvL3NpbXBsZSBub24tY3VydmVkIGNhc2UgaXMgMToxXG4gICAgY29uc3QgciA9IHRoaXMuY3VydmVSYWRpdXM7XG4gICAgaWYgKHIpIHsgLy9mbGF0dGVuIHRoZSBjdXJ2ZVxuICAgICAgdGFyZ2V0LnggPSBNYXRoLmF0YW4yKHBvc2l0aW9uLngsIE1hdGguYWJzKHIpIC0gTWF0aC5hYnMocG9zaXRpb24ueikpICogTWF0aC5hYnMocik7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXRcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2xhdGUgYSBwb2ludCBpbiB3b3JsZCBzcGFjZSB0byBhbiB4L3kgaW4gdGhlIHRleHQgcGxhbmUuXG4gICAqL1xuICB3b3JsZFBvc2l0aW9uVG9UZXh0Q29vcmRzKHBvc2l0aW9uLCB0YXJnZXQgPSBuZXcgVmVjdG9yMigpKSB7XG4gICAgdGVtcFZlYzNhLmNvcHkocG9zaXRpb24pO1xuICAgIHJldHVybiB0aGlzLmxvY2FsUG9zaXRpb25Ub1RleHRDb29yZHModGhpcy53b3JsZFRvTG9jYWwodGVtcFZlYzNhKSwgdGFyZ2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZSBDdXN0b20gcmF5Y2FzdGluZyB0byB0ZXN0IGFnYWluc3QgdGhlIHdob2xlIHRleHQgYmxvY2sncyBtYXggcmVjdGFuZ3VsYXIgYm91bmRzXG4gICAqIFRPRE8gaXMgdGhlcmUgYW55IHJlYXNvbiB0byBtYWtlIHRoaXMgbW9yZSBncmFudWxhciwgbGlrZSB3aXRoaW4gaW5kaXZpZHVhbCBsaW5lIG9yIGdseXBoIHJlY3RzP1xuICAgKi9cbiAgcmF5Y2FzdChyYXljYXN0ZXIsIGludGVyc2VjdHMpIHtcbiAgICBjb25zdCB7dGV4dFJlbmRlckluZm8sIGN1cnZlUmFkaXVzfSA9IHRoaXM7XG4gICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICBjb25zdCBib3VuZHMgPSB0ZXh0UmVuZGVySW5mby5ibG9ja0JvdW5kcztcbiAgICAgIGNvbnN0IHJheWNhc3RNZXNoID0gY3VydmVSYWRpdXMgPyBnZXRDdXJ2ZWRSYXljYXN0TWVzaCgpIDogZ2V0RmxhdFJheWNhc3RNZXNoKCk7XG4gICAgICBjb25zdCBnZW9tID0gcmF5Y2FzdE1lc2guZ2VvbWV0cnk7XG4gICAgICBjb25zdCB7cG9zaXRpb24sIHV2fSA9IGdlb20uYXR0cmlidXRlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXYuY291bnQ7IGkrKykge1xuICAgICAgICBsZXQgeCA9IGJvdW5kc1swXSArICh1di5nZXRYKGkpICogKGJvdW5kc1syXSAtIGJvdW5kc1swXSkpO1xuICAgICAgICBjb25zdCB5ID0gYm91bmRzWzFdICsgKHV2LmdldFkoaSkgKiAoYm91bmRzWzNdIC0gYm91bmRzWzFdKSk7XG4gICAgICAgIGxldCB6ID0gMDtcbiAgICAgICAgaWYgKGN1cnZlUmFkaXVzKSB7XG4gICAgICAgICAgeiA9IGN1cnZlUmFkaXVzIC0gTWF0aC5jb3MoeCAvIGN1cnZlUmFkaXVzKSAqIGN1cnZlUmFkaXVzO1xuICAgICAgICAgIHggPSBNYXRoLnNpbih4IC8gY3VydmVSYWRpdXMpICogY3VydmVSYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb24uc2V0WFlaKGksIHgsIHksIHopO1xuICAgICAgfVxuICAgICAgZ2VvbS5ib3VuZGluZ1NwaGVyZSA9IHRoaXMuZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmU7XG4gICAgICBnZW9tLmJvdW5kaW5nQm94ID0gdGhpcy5nZW9tZXRyeS5ib3VuZGluZ0JveDtcbiAgICAgIHJheWNhc3RNZXNoLm1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcbiAgICAgIHJheWNhc3RNZXNoLm1hdGVyaWFsLnNpZGUgPSB0aGlzLm1hdGVyaWFsLnNpZGU7XG4gICAgICB0ZW1wQXJyYXkubGVuZ3RoID0gMDtcbiAgICAgIHJheWNhc3RNZXNoLnJheWNhc3QocmF5Y2FzdGVyLCB0ZW1wQXJyYXkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGVtcEFycmF5W2ldLm9iamVjdCA9IHRoaXM7XG4gICAgICAgIGludGVyc2VjdHMucHVzaCh0ZW1wQXJyYXlbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNvcHkoc291cmNlKSB7XG4gICAgLy8gUHJldmVudCBjb3B5aW5nIHRoZSBnZW9tZXRyeSByZWZlcmVuY2Ugc28gd2UgZG9uJ3QgZW5kIHVwIHNoYXJpbmcgYXR0cmlidXRlcyBiZXR3ZWVuIGluc3RhbmNlc1xuICAgIGNvbnN0IGdlb20gPSB0aGlzLmdlb21ldHJ5O1xuICAgIHN1cGVyLmNvcHkoc291cmNlKTtcbiAgICB0aGlzLmdlb21ldHJ5ID0gZ2VvbTtcblxuICAgIENPUFlBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICB0aGlzW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KHRoaXMpXG4gIH1cbn1cblxuXG4vLyBDcmVhdGUgc2V0dGVycyBmb3IgcHJvcGVydGllcyB0aGF0IGFmZmVjdCB0ZXh0IGxheW91dDpcblNZTkNBQkxFX1BST1BTLmZvckVhY2gocHJvcCA9PiB7XG4gIGNvbnN0IHByaXZhdGVLZXkgPSAnX3ByaXZhdGVfJyArIHByb3A7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUZXh0LnByb3RvdHlwZSwgcHJvcCwge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzW3ByaXZhdGVLZXldXG4gICAgfSxcbiAgICBzZXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSAhPT0gdGhpc1twcml2YXRlS2V5XSkge1xuICAgICAgICB0aGlzW3ByaXZhdGVLZXldID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX25lZWRzU3luYyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn0pO1xuXG5jb25zdCBzeW5jU3RhcnRFdmVudCQxID0geyB0eXBlOiBcInN5bmNzdGFydFwiIH07XG5jb25zdCBzeW5jQ29tcGxldGVFdmVudCQxID0geyB0eXBlOiBcInN5bmNjb21wbGV0ZVwiIH07XG5jb25zdCBtZW1iZXJJbmRleEF0dHJOYW1lID0gXCJhVHJvaWthVGV4dEJhdGNoTWVtYmVySW5kZXhcIjtcblxuXG4vKlxuRGF0YSB0ZXh0dXJlIHBhY2tpbmcgc3RyYXRlZ3k6XG5cbiMgQ29tbW9uOlxuMC0xNTogbWF0cml4XG4xNi0xOTogdVRyb2lrYVRvdGFsQm91bmRzXG4yMC0yMzogdVRyb2lrYUNsaXBSZWN0XG4yNDogZGlmZnVzZSAoY29sb3Ivb3V0bGluZUNvbG9yKVxuMjU6IHVUcm9pa2FGaWxsT3BhY2l0eSAoZmlsbE9wYWNpdHkvb3V0bGluZU9wYWNpdHkpXG4yNjogdVRyb2lrYUN1cnZlUmFkaXVzXG4yNzogPGJsYW5rPlxuXG4jIE1haW46XG4yODogdVRyb2lrYVN0cm9rZVdpZHRoXG4yOTogdVRyb2lrYVN0cm9rZUNvbG9yXG4zMDogdVRyb2lrYVN0cm9rZU9wYWNpdHlcblxuIyBPdXRsaW5lOlxuMjgtMjk6IHVUcm9pa2FQb3NpdGlvbk9mZnNldFxuMzA6IHVUcm9pa2FFZGdlT2Zmc2V0XG4zMTogdVRyb2lrYUJsdXJSYWRpdXNcbiovXG5jb25zdCBmbG9hdHNQZXJNZW1iZXIgPSAzMjtcblxuY29uc3QgdGVtcEJveDMgPSBuZXcgQm94MygpO1xuY29uc3QgdGVtcENvbG9yJDEgPSBuZXcgQ29sb3IoKTtcblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKlxuICogQSBzcGVjaWFsaXplZCBgVGV4dGAgaW1wbGVtZW50YXRpb24gdGhhdCBhY2NlcHRzIGFueSBudW1iZXIgb2YgYFRleHRgIGNoaWxkcmVuXG4gKiBhbmQgYXV0b21hdGljYWxseSBiYXRjaGVzIHRoZW0gdG9nZXRoZXIgdG8gcmVuZGVyIGluIGEgc2luZ2xlIGRyYXcgY2FsbC5cbiAqXG4gKiBUaGUgYG1hdGVyaWFsYCBvZiBlYWNoIGNoaWxkIGBUZXh0YCB3aWxsIGJlIGlnbm9yZWQsIGFuZCB0aGUgYG1hdGVyaWFsYCBvZiB0aGVcbiAqIGBCYXRjaGVkVGV4dGAgd2lsbCBiZSB1c2VkIGZvciBhbGwgb2YgdGhlbSBpbnN0ZWFkLlxuICpcbiAqIE5PVEU6IFRoaXMgb25seSB3b3JrcyBpbiBXZWJHTDIgb3Igd2hlcmUgdGhlIE9FU190ZXh0dXJlX2Zsb2F0IGV4dGVuc2lvbiBpcyBhdmFpbGFibGUuXG4gKi9cbmNsYXNzIEJhdGNoZWRUZXh0IGV4dGVuZHMgVGV4dCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge09iamVjdH0gUGFja2luZ0luZm9cbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaW5kZXggLSB0aGUgcGFja2luZyBvcmRlciBpbmRleCB3aGVuIGxhc3QgcGFja2VkLCBvciAtMVxuICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZGlydHkgLSB3aGV0aGVyIGl0IGhhcyBzeW5jZWQgc2luY2UgbGFzdCBwYWNrXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPFRleHQsIFBhY2tpbmdJbmZvPn1cbiAgICAgKi9cbiAgICB0aGlzLl9tZW1iZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2RhdGFUZXh0dXJlcyA9IHt9O1xuXG4gICAgdGhpcy5fb25NZW1iZXJTeW5jZWQgPSAoZSkgPT4ge1xuICAgICAgdGhpcy5fbWVtYmVycy5nZXQoZS50YXJnZXQpLmRpcnR5ID0gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBCYXRjaCBhbnkgVGV4dCBvYmplY3RzIGFkZGVkIGFzIGNoaWxkcmVuXG4gICAqL1xuICBhZGQgKC4uLm9iamVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChvYmplY3RzW2ldIGluc3RhbmNlb2YgVGV4dCkge1xuICAgICAgICB0aGlzLmFkZFRleHQob2JqZWN0c1tpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlci5hZGQob2JqZWN0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgcmVtb3ZlICguLi5vYmplY3RzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmplY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqZWN0c1tpXSBpbnN0YW5jZW9mIFRleHQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVUZXh0KG9iamVjdHNbaV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIucmVtb3ZlKG9iamVjdHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RleHR9IHRleHRcbiAgICovXG4gIGFkZFRleHQgKHRleHQpIHtcbiAgICBpZiAoIXRoaXMuX21lbWJlcnMuaGFzKHRleHQpKSB7XG4gICAgICB0aGlzLl9tZW1iZXJzLnNldCh0ZXh0LCB7XG4gICAgICAgIGluZGV4OiAtMSxcbiAgICAgICAgZ2x5cGhDb3VudDogLTEsXG4gICAgICAgIGRpcnR5OiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHRleHQuYWRkRXZlbnRMaXN0ZW5lcihcInN5bmNjb21wbGV0ZVwiLCB0aGlzLl9vbk1lbWJlclN5bmNlZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VGV4dH0gdGV4dFxuICAgKi9cbiAgcmVtb3ZlVGV4dCAodGV4dCkge1xuICAgIHRoaXMuX25lZWRzUmVwYWNrID0gdHJ1ZTtcbiAgICB0ZXh0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzeW5jY29tcGxldGVcIiwgdGhpcy5fb25NZW1iZXJTeW5jZWQpO1xuICAgIHRoaXMuX21lbWJlcnMuZGVsZXRlKHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZSB0aGUgY3VzdG9tIGRlcml2YXRpb24gd2l0aCBleHRyYSBiYXRjaGluZyBsb2dpY1xuICAgKi9cbiAgY3JlYXRlRGVyaXZlZE1hdGVyaWFsIChiYXNlTWF0ZXJpYWwpIHtcbiAgICByZXR1cm4gY3JlYXRlQmF0Y2hlZFRleHRNYXRlcmlhbChiYXNlTWF0ZXJpYWwpO1xuICB9XG5cbiAgdXBkYXRlTWF0cml4V29ybGQgKGZvcmNlKSB7XG4gICAgc3VwZXIudXBkYXRlTWF0cml4V29ybGQoZm9yY2UpO1xuICAgIHRoaXMudXBkYXRlQm91bmRzKCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBiYXRjaGVkIGdlb21ldHJ5IGJvdW5kcyB0byBob2xkIGFsbCBtZW1iZXJzXG4gICAqL1xuICB1cGRhdGVCb3VuZHMgKCkge1xuICAgIC8vIFVwZGF0ZSBtZW1iZXIgbG9jYWwgbWF0cmljZXMgYW5kIHRoZSBvdmVyYWxsIGJvdW5kc1xuICAgIGNvbnN0IGJib3ggPSB0aGlzLmdlb21ldHJ5LmJvdW5kaW5nQm94Lm1ha2VFbXB0eSgpO1xuICAgIHRoaXMuX21lbWJlcnMuZm9yRWFjaCgoXywgdGV4dCkgPT4ge1xuICAgICAgaWYgKHRleHQubWF0cml4QXV0b1VwZGF0ZSkgdGV4dC51cGRhdGVNYXRyaXgoKTsgLy8gaWdub3JlIHdvcmxkIG1hdHJpeFxuICAgICAgdGVtcEJveDMuY29weSh0ZXh0Lmdlb21ldHJ5LmJvdW5kaW5nQm94KS5hcHBseU1hdHJpeDQodGV4dC5tYXRyaXgpO1xuICAgICAgYmJveC51bmlvbih0ZW1wQm94Myk7XG4gICAgfSk7XG4gICAgYmJveC5nZXRCb3VuZGluZ1NwaGVyZSh0aGlzLmdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlKTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaGFzT3V0bGluZSgpIHtcbiAgICAvLyBJdGVyYXRvci5zb21lKCkgbm90IHN1cHBvcnRlZCBpbiBTYWZhcmlcbiAgICBmb3IgKGxldCBtZW1iZXIgb2YgdGhpcy5fbWVtYmVycy5rZXlzKCkpIHtcbiAgICAgIGlmIChtZW1iZXIuaGFzT3V0bGluZSgpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKiBDb3B5IG1lbWJlciBtYXRyaWNlcyBhbmQgdW5pZm9ybSB2YWx1ZXMgaW50byB0aGUgZGF0YSB0ZXh0dXJlXG4gICAqL1xuICBfcHJlcGFyZUZvclJlbmRlciAobWF0ZXJpYWwpIHtcbiAgICBjb25zdCBpc091dGxpbmUgPSBtYXRlcmlhbC5pc1RleHRPdXRsaW5lTWF0ZXJpYWw7XG4gICAgbWF0ZXJpYWwudW5pZm9ybXMudVRyb2lrYUlzT3V0bGluZS52YWx1ZSA9IGlzT3V0bGluZTtcblxuICAgIC8vIFJlc2l6ZSB0aGUgdGV4dHVyZSB0byBmaXQgaW4gcG93ZXJzIG9mIDJcbiAgICBsZXQgdGV4dHVyZSA9IHRoaXMuX2RhdGFUZXh0dXJlc1tpc091dGxpbmUgPyAnb3V0bGluZScgOiAnbWFpbiddO1xuICAgIGNvbnN0IGRhdGFMZW5ndGggPSBNYXRoLnBvdygyLCBNYXRoLmNlaWwoTWF0aC5sb2cyKHRoaXMuX21lbWJlcnMuc2l6ZSAqIGZsb2F0c1Blck1lbWJlcikpKTtcbiAgICBpZiAoIXRleHR1cmUgfHwgZGF0YUxlbmd0aCAhPT0gdGV4dHVyZS5pbWFnZS5kYXRhLmxlbmd0aCkge1xuICAgICAgLy8gY29uc29sZS5sb2coYHJlc2l6aW5nOiAke2RhdGFMZW5ndGh9YCk7XG4gICAgICBpZiAodGV4dHVyZSkgdGV4dHVyZS5kaXNwb3NlKCk7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKGRhdGFMZW5ndGggLyA0LCAxMDI0KTtcbiAgICAgIHRleHR1cmUgPSB0aGlzLl9kYXRhVGV4dHVyZXNbaXNPdXRsaW5lID8gJ291dGxpbmUnIDogJ21haW4nXSA9IG5ldyBEYXRhVGV4dHVyZShcbiAgICAgICAgbmV3IEZsb2F0MzJBcnJheShkYXRhTGVuZ3RoKSxcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGRhdGFMZW5ndGggLyA0IC8gd2lkdGgsXG4gICAgICAgIFJHQkFGb3JtYXQsXG4gICAgICAgIEZsb2F0VHlwZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0ZXhEYXRhID0gdGV4dHVyZS5pbWFnZS5kYXRhO1xuICAgIGNvbnN0IHNldFRleERhdGEgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgIT09IHRleERhdGFbaW5kZXhdKSB7XG4gICAgICAgIHRleERhdGFbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHRleHR1cmUubmVlZHNVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKCh7IGluZGV4LCBkaXJ0eSB9LCB0ZXh0KSA9PiB7XG4gICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXggKiBmbG9hdHNQZXJNZW1iZXI7XG5cbiAgICAgICAgLy8gTWF0cml4XG4gICAgICAgIGNvbnN0IG1hdHJpeCA9IHRleHQubWF0cml4LmVsZW1lbnRzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyBpLCBtYXRyaXhbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGV0IHRoZSBtZW1iZXIgcG9wdWxhdGUgdGhlIHVuaWZvcm1zLCBzaW5jZSB0aGF0IGRvZXMgYWxsIHRoZSBhcHByb3ByaWF0ZVxuICAgICAgICAvLyBsb2dpYyBhbmQgaGFuZGxpbmcgb2YgZGVmYXVsdHMsIGFuZCB3ZSdsbCBqdXN0IGdyYWIgdGhlIHJlc3VsdHMgZnJvbSB0aGVyZVxuICAgICAgICB0ZXh0Ll9wcmVwYXJlRm9yUmVuZGVyKG1hdGVyaWFsKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHVUcm9pa2FUb3RhbEJvdW5kcyxcbiAgICAgICAgICB1VHJvaWthQ2xpcFJlY3QsXG4gICAgICAgICAgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0LFxuICAgICAgICAgIHVUcm9pa2FFZGdlT2Zmc2V0LFxuICAgICAgICAgIHVUcm9pa2FCbHVyUmFkaXVzLFxuICAgICAgICAgIHVUcm9pa2FTdHJva2VXaWR0aCxcbiAgICAgICAgICB1VHJvaWthU3Ryb2tlQ29sb3IsXG4gICAgICAgICAgdVRyb2lrYVN0cm9rZU9wYWNpdHksXG4gICAgICAgICAgdVRyb2lrYUZpbGxPcGFjaXR5LFxuICAgICAgICAgIHVUcm9pa2FDdXJ2ZVJhZGl1cyxcbiAgICAgICAgfSA9IG1hdGVyaWFsLnVuaWZvcm1zO1xuXG4gICAgICAgIC8vIFRvdGFsIGJvdW5kcyBmb3IgdXZcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAxNiArIGksIHVUcm9pa2FUb3RhbEJvdW5kcy52YWx1ZS5nZXRDb21wb25lbnQoaSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2xpcCByZWN0XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMjAgKyBpLCB1VHJvaWthQ2xpcFJlY3QudmFsdWUuZ2V0Q29tcG9uZW50KGkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbG9yXG4gICAgICAgIGxldCBjb2xvciA9IGlzT3V0bGluZSA/ICh0ZXh0Lm91dGxpbmVDb2xvciB8fCAwKSA6IHRleHQuY29sb3I7XG4gICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHRoaXMuY29sb3I7XG4gICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IHRoaXMubWF0ZXJpYWwuY29sb3I7XG4gICAgICAgIGlmIChjb2xvciA9PSBudWxsKSBjb2xvciA9IDB4ZmZmZmZmO1xuICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAyNCwgdGVtcENvbG9yJDEuc2V0KGNvbG9yKS5nZXRIZXgoKSk7XG5cbiAgICAgICAgLy8gRmlsbCBvcGFjaXR5IC8gb3V0bGluZSBvcGFjaXR5XG4gICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI1LCB1VHJvaWthRmlsbE9wYWNpdHkudmFsdWUpO1xuXG4gICAgICAgIC8vIEN1cnZlIHJhZGl1c1xuICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAyNiwgdVRyb2lrYUN1cnZlUmFkaXVzLnZhbHVlKTtcblxuICAgICAgICBpZiAoaXNPdXRsaW5lKSB7XG4gICAgICAgICAgLy8gT3V0bGluZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMjgsIHVUcm9pa2FQb3NpdGlvbk9mZnNldC52YWx1ZS54KTtcbiAgICAgICAgICBzZXRUZXhEYXRhKHN0YXJ0SW5kZXggKyAyOSwgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0LnZhbHVlLnkpO1xuICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDMwLCB1VHJvaWthRWRnZU9mZnNldC52YWx1ZSk7XG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMzEsIHVUcm9pa2FCbHVyUmFkaXVzLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBTdHJva2UgcHJvcGVydGllc1xuICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI4LCB1VHJvaWthU3Ryb2tlV2lkdGgudmFsdWUpO1xuICAgICAgICAgIHNldFRleERhdGEoc3RhcnRJbmRleCArIDI5LCB0ZW1wQ29sb3IkMS5zZXQodVRyb2lrYVN0cm9rZUNvbG9yLnZhbHVlKS5nZXRIZXgoKSk7XG4gICAgICAgICAgc2V0VGV4RGF0YShzdGFydEluZGV4ICsgMzAsIHVUcm9pa2FTdHJva2VPcGFjaXR5LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG1hdGVyaWFsLnNldE1hdHJpeFRleHR1cmUodGV4dHVyZSk7XG5cbiAgICAvLyBGb3IgdGhlIG5vbi1tZW1iZXItc3BlY2lmaWMgdW5pZm9ybXM6XG4gICAgc3VwZXIuX3ByZXBhcmVGb3JSZW5kZXIobWF0ZXJpYWwpO1xuICB9XG5cbiAgc3luYyAoY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBza2lwIG1lbWJlcnMgdXBkYXRpbmcgdGhlaXIgZ2VvbWV0cmllcywganVzdCB1c2UgdGV4dFJlbmRlckluZm8gZGlyZWN0bHlcblxuICAgIC8vIFRyaWdnZXIgc3luYyBvbiBhbGwgbWVtYmVycyB0aGF0IG5lZWQgaXRcbiAgICBsZXQgc3luY1Byb21pc2VzID0gdGhpcy5fbmVlZHNSZXBhY2sgPyBbXSA6IG51bGw7XG4gICAgdGhpcy5fbmVlZHNSZXBhY2sgPSBmYWxzZTtcbiAgICB0aGlzLl9tZW1iZXJzLmZvckVhY2goKHBhY2tpbmdJbmZvLCB0ZXh0KSA9PiB7XG4gICAgICBpZiAocGFja2luZ0luZm8uZGlydHkgfHwgdGV4dC5fbmVlZHNTeW5jKSB7XG4gICAgICAgIHBhY2tpbmdJbmZvLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIChzeW5jUHJvbWlzZXMgfHwgKHN5bmNQcm9taXNlcyA9IFtdKSkucHVzaChuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBpZiAodGV4dC5fbmVlZHNTeW5jKSB7XG4gICAgICAgICAgICB0ZXh0LnN5bmMocmVzb2x2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIElmIGFueSBuZWVkZWQgc3luY2luZywgd2FpdCBmb3IgdGhlbSBhbmQgdGhlbiByZXBhY2sgdGhlIGJhdGNoZWQgZ2VvbWV0cnlcbiAgICBpZiAoc3luY1Byb21pc2VzKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY1N0YXJ0RXZlbnQkMSk7XG5cbiAgICAgIFByb21pc2UuYWxsKHN5bmNQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZ2VvbWV0cnkgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJhdGNoZWRBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcbiAgICAgICAgbGV0IG1lbWJlckluZGV4ZXMgPSBiYXRjaGVkQXR0cmlidXRlc1ttZW1iZXJJbmRleEF0dHJOYW1lXSAmJiBiYXRjaGVkQXR0cmlidXRlc1ttZW1iZXJJbmRleEF0dHJOYW1lXS5hcnJheSB8fCBuZXcgVWludDE2QXJyYXkoMCk7XG4gICAgICAgIGxldCBiYXRjaGVkR2x5cGhJbmRleGVzID0gYmF0Y2hlZEF0dHJpYnV0ZXNbZ2x5cGhJbmRleEF0dHJOYW1lXSAmJiBiYXRjaGVkQXR0cmlidXRlc1tnbHlwaEluZGV4QXR0ck5hbWVdLmFycmF5IHx8IG5ldyBGbG9hdDMyQXJyYXkoMCk7XG4gICAgICAgIGxldCBiYXRjaGVkR2x5cGhCb3VuZHMgPSBiYXRjaGVkQXR0cmlidXRlc1tnbHlwaEJvdW5kc0F0dHJOYW1lXSAmJiBiYXRjaGVkQXR0cmlidXRlc1tnbHlwaEJvdW5kc0F0dHJOYW1lXS5hcnJheSB8fCBuZXcgRmxvYXQzMkFycmF5KDApO1xuXG4gICAgICAgIC8vIEluaXRpYWwgcGFzcyB0byBjb2xsZWN0IHRvdGFsIGdseXBoIGNvdW50IGFuZCByZXNpemUgdGhlIGFycmF5cyBpZiBuZWVkZWRcbiAgICAgICAgbGV0IHRvdGFsR2x5cGhDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuX21lbWJlcnMuZm9yRWFjaCgocGFja2luZ0luZm8sIHsgdGV4dFJlbmRlckluZm8gfSkgPT4ge1xuICAgICAgICAgIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgICAgICAgICAgdG90YWxHbHlwaENvdW50ICs9IHRleHRSZW5kZXJJbmZvLmdseXBoQXRsYXNJbmRpY2VzLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuX3RleHRSZW5kZXJJbmZvID0gdGV4dFJlbmRlckluZm87IC8vIFRPRE8gLSBuZWVkIHRoaXMsIGJ1dCBiZSBzbWFydGVyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRvdGFsR2x5cGhDb3VudCAhPT0gbWVtYmVySW5kZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICBtZW1iZXJJbmRleGVzID0gY2xvbmVBbmRSZXNpemUobWVtYmVySW5kZXhlcywgdG90YWxHbHlwaENvdW50KTtcbiAgICAgICAgICBiYXRjaGVkR2x5cGhJbmRleGVzID0gY2xvbmVBbmRSZXNpemUoYmF0Y2hlZEdseXBoSW5kZXhlcywgdG90YWxHbHlwaENvdW50KTtcbiAgICAgICAgICBiYXRjaGVkR2x5cGhCb3VuZHMgPSBjbG9uZUFuZFJlc2l6ZShiYXRjaGVkR2x5cGhCb3VuZHMsIHRvdGFsR2x5cGhDb3VudCAqIDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUG9wdWxhdGUgYmF0Y2ggYXJyYXlzXG4gICAgICAgIGxldCBtZW1iZXJJbmRleCA9IDA7XG4gICAgICAgIGxldCBnbHlwaEluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKChwYWNraW5nSW5mbywgeyB0ZXh0UmVuZGVySW5mbyB9KSA9PiB7XG4gICAgICAgICAgaWYgKHRleHRSZW5kZXJJbmZvKSB7XG4gICAgICAgICAgICBjb25zdCBnbHlwaENvdW50ID0gdGV4dFJlbmRlckluZm8uZ2x5cGhBdGxhc0luZGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgbWVtYmVySW5kZXhlcy5maWxsKG1lbWJlckluZGV4LCBnbHlwaEluZGV4LCBnbHlwaEluZGV4ICsgZ2x5cGhDb3VudCk7XG5cbiAgICAgICAgICAgIC8vIFRPRE8gY2FuIHNraXAgdGhlc2UgZm9yIG1lbWJlcnMgdGhhdCBhcmUgbm90IGRpcnR5IG9yIHNoaWZ0aW5nIG92ZXJhbGwgcG9zaXRpb246XG4gICAgICAgICAgICBiYXRjaGVkR2x5cGhJbmRleGVzLnNldCh0ZXh0UmVuZGVySW5mby5nbHlwaEF0bGFzSW5kaWNlcywgZ2x5cGhJbmRleCwgZ2x5cGhJbmRleCArIGdseXBoQ291bnQpO1xuICAgICAgICAgICAgYmF0Y2hlZEdseXBoQm91bmRzLnNldCh0ZXh0UmVuZGVySW5mby5nbHlwaEJvdW5kcywgZ2x5cGhJbmRleCAqIDQsIChnbHlwaEluZGV4ICsgZ2x5cGhDb3VudCkgKiA0KTtcblxuICAgICAgICAgICAgZ2x5cGhJbmRleCArPSBnbHlwaENvdW50O1xuICAgICAgICAgICAgcGFja2luZ0luZm8uaW5kZXggPSBtZW1iZXJJbmRleCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVXBkYXRlIHRoZSBnZW9tZXRyeSBhdHRyaWJ1dGVzXG4gICAgICAgIGdlb21ldHJ5LnVwZGF0ZUF0dHJpYnV0ZURhdGEobWVtYmVySW5kZXhBdHRyTmFtZSwgbWVtYmVySW5kZXhlcywgMSk7XG4gICAgICAgIGdlb21ldHJ5LmdldEF0dHJpYnV0ZShtZW1iZXJJbmRleEF0dHJOYW1lKS5zZXRVc2FnZShEeW5hbWljRHJhd1VzYWdlKTtcbiAgICAgICAgZ2VvbWV0cnkudXBkYXRlQXR0cmlidXRlRGF0YShnbHlwaEluZGV4QXR0ck5hbWUsIGJhdGNoZWRHbHlwaEluZGV4ZXMsIDEpO1xuICAgICAgICBnZW9tZXRyeS51cGRhdGVBdHRyaWJ1dGVEYXRhKGdseXBoQm91bmRzQXR0ck5hbWUsIGJhdGNoZWRHbHlwaEJvdW5kcywgNCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGVCb3VuZHMoKTtcblxuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoc3luY0NvbXBsZXRlRXZlbnQkMSk7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvcHkgKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBCYXRjaGVkVGV4dCkge1xuICAgICAgc3VwZXIuY29weShzb3VyY2UpO1xuICAgICAgdGhpcy5fbWVtYmVycy5mb3JFYWNoKChfLCB0ZXh0KSA9PiB0aGlzLnJlbW92ZVRleHQodGV4dCkpO1xuICAgICAgc291cmNlLl9tZW1iZXJzLmZvckVhY2goKF8sIHRleHQpID0+IHRoaXMuYWRkVGV4dCh0ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZGlzcG9zZSAoKSB7XG4gICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIE9iamVjdC52YWx1ZXModGhpcy5fZGF0YVRleHR1cmVzKS5mb3JFYWNoKHRleCA9PiB0ZXguZGlzcG9zZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlc2l6ZSAoc291cmNlLCBuZXdMZW5ndGgpIHtcbiAgY29uc3QgY29weSA9IG5ldyBzb3VyY2UuY29uc3RydWN0b3IobmV3TGVuZ3RoKTtcbiAgY29weS5zZXQoc291cmNlLnN1YmFycmF5KDAsIG5ld0xlbmd0aCkpO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQmF0Y2hlZFRleHRNYXRlcmlhbCAoYmFzZU1hdGVyaWFsKSB7XG4gIGNvbnN0IHRleFVuaWZvcm1OYW1lID0gXCJ1VHJvaWthTWF0cmljZXNUZXh0dXJlXCI7XG4gIGNvbnN0IHRleFNpemVVbmlmb3JtTmFtZSA9IFwidVRyb2lrYU1hdHJpY2VzVGV4dHVyZVNpemVcIjtcblxuICAvLyBEdWUgdG8gaG93IHZlcnRleFRyYW5zZm9ybSBnZXRzIGluamVjdGVkLCB0aGUgbWF0cml4IHRyYW5zZm9ybXMgbXVzdCBoYXBwZW5cbiAgLy8gaW4gdGhlIGJhc2UgbWF0ZXJpYWwgb2YgVGV4dERlcml2ZWRNYXRlcmlhbCwgYnV0IG90aGVyIHRyYW5zZm9ybXMgdG8gaXRzXG4gIC8vIHNoYWRlciBtdXN0IGNvbWUgYWZ0ZXIsIHNvIHdlIHNhbmR3aWNoIGl0IGJldHdlZW4gdHdvIGRlcml2YXRpb25zLlxuXG4gIC8vIFRyYW5zZm9ybSB0aGUgdmVydGV4IHBvc2l0aW9uXG4gIGxldCBiYXRjaE1hdGVyaWFsID0gY3JlYXRlRGVyaXZlZE1hdGVyaWFsKGJhc2VNYXRlcmlhbCwge1xuICAgIGNoYWluZWQ6IHRydWUsXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIFt0ZXhTaXplVW5pZm9ybU5hbWVdOiB7IHZhbHVlOiBuZXcgVmVjdG9yMigpIH0sXG4gICAgICBbdGV4VW5pZm9ybU5hbWVdOiB7IHZhbHVlOiBudWxsIH1cbiAgICB9LFxuICAgIC8vIGxhbmd1YWdlPUdMU0xcbiAgICB2ZXJ0ZXhEZWZzOiBgXG4gICAgICB1bmlmb3JtIGhpZ2hwIHNhbXBsZXIyRCAke3RleFVuaWZvcm1OYW1lfTtcbiAgICAgIHVuaWZvcm0gdmVjMiAke3RleFNpemVVbmlmb3JtTmFtZX07XG4gICAgICBhdHRyaWJ1dGUgZmxvYXQgJHttZW1iZXJJbmRleEF0dHJOYW1lfTtcblxuICAgICAgdmVjNCB0cm9pa2FCYXRjaFRleGVsKGZsb2F0IG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgKz0gJHttZW1iZXJJbmRleEF0dHJOYW1lfSAqICR7ZmxvYXRzUGVyTWVtYmVyLnRvRml4ZWQoMSl9IC8gNC4wO1xuICAgICAgICBmbG9hdCB3ID0gJHt0ZXhTaXplVW5pZm9ybU5hbWV9Lng7XG4gICAgICAgIHZlYzIgdXYgPSAodmVjMihtb2Qob2Zmc2V0LCB3KSwgZmxvb3Iob2Zmc2V0IC8gdykpICsgMC41KSAvICR7dGV4U2l6ZVVuaWZvcm1OYW1lfTtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUyRCgke3RleFVuaWZvcm1OYW1lfSwgdXYpO1xuICAgICAgfVxuICAgIGAsXG4gICAgLy8gbGFuZ3VhZ2U9R0xTTCBwcmVmaXg9XCJ2b2lkIG1haW4oKSB7XCIgc3VmZml4PVwifVwiXG4gICAgdmVydGV4VHJhbnNmb3JtOiBgXG4gICAgICBtYXQ0IG1hdHJpeCA9IG1hdDQoXG4gICAgICAgIHRyb2lrYUJhdGNoVGV4ZWwoMC4wKSxcbiAgICAgICAgdHJvaWthQmF0Y2hUZXhlbCgxLjApLFxuICAgICAgICB0cm9pa2FCYXRjaFRleGVsKDIuMCksXG4gICAgICAgIHRyb2lrYUJhdGNoVGV4ZWwoMy4wKVxuICAgICAgKTtcbiAgICAgIHBvc2l0aW9uLnh5eiA9IChtYXRyaXggKiB2ZWM0KHBvc2l0aW9uLCAxLjApKS54eXo7XG4gICAgYCxcbiAgfSk7XG5cbiAgLy8gQWRkIHRoZSB0ZXh0IHNoYWRlcnNcbiAgYmF0Y2hNYXRlcmlhbCA9IGNyZWF0ZVRleHREZXJpdmVkTWF0ZXJpYWwoYmF0Y2hNYXRlcmlhbCk7XG5cbiAgLy8gTm93IG1ha2Ugb3RoZXIgY2hhbmdlcyB0byB0aGUgZGVyaXZlZCB0ZXh0IHNoYWRlciBjb2RlXG4gIGJhdGNoTWF0ZXJpYWwgPSBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwoYmF0Y2hNYXRlcmlhbCwge1xuICAgIGNoYWluZWQ6IHRydWUsXG4gICAgdW5pZm9ybXM6IHtcbiAgICAgIHVUcm9pa2FJc091dGxpbmU6IHt2YWx1ZTogZmFsc2V9LFxuICAgIH0sXG4gICAgY3VzdG9tUmV3cml0ZXIoc2hhZGVycykge1xuICAgICAgLy8gQ29udmVydCBzb21lIHRleHQgc2hhZGVyIHVuaWZvcm1zIHRvIHZhcnlpbmdzXG4gICAgICBjb25zdCB2YXJ5aW5nVW5pZm9ybXMgPSBbXG4gICAgICAgICd1VHJvaWthVG90YWxCb3VuZHMnLFxuICAgICAgICAndVRyb2lrYUNsaXBSZWN0JyxcbiAgICAgICAgJ3VUcm9pa2FQb3NpdGlvbk9mZnNldCcsXG4gICAgICAgICd1VHJvaWthRWRnZU9mZnNldCcsXG4gICAgICAgICd1VHJvaWthQmx1clJhZGl1cycsXG4gICAgICAgICd1VHJvaWthU3Ryb2tlV2lkdGgnLFxuICAgICAgICAndVRyb2lrYVN0cm9rZUNvbG9yJyxcbiAgICAgICAgJ3VUcm9pa2FTdHJva2VPcGFjaXR5JyxcbiAgICAgICAgJ3VUcm9pa2FGaWxsT3BhY2l0eScsXG4gICAgICAgICd1VHJvaWthQ3VydmVSYWRpdXMnLFxuICAgICAgICAnZGlmZnVzZSdcbiAgICAgIF07XG4gICAgICB2YXJ5aW5nVW5pZm9ybXMuZm9yRWFjaCh1bmlmb3JtTmFtZSA9PiB7XG4gICAgICAgIHNoYWRlcnMgPSB1bmlmb3JtVG9WYXJ5aW5nKHNoYWRlcnMsIHVuaWZvcm1OYW1lKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNoYWRlcnNcbiAgICB9LFxuICAgIC8vIGxhbmd1YWdlPUdMU0xcbiAgICB2ZXJ0ZXhEZWZzOiBgXG4gICAgICB1bmlmb3JtIGJvb2wgdVRyb2lrYUlzT3V0bGluZTtcbiAgICAgIHZlYzMgdHJvaWthRmxvYXRUb0NvbG9yKGZsb2F0IHYpIHtcbiAgICAgICAgcmV0dXJuIG1vZChmbG9vcih2ZWMzKHYgLyA2NTUzNi4wLCB2IC8gMjU2LjAsIHYpKSwgMjU2LjApIC8gMjU2LjA7XG4gICAgICB9XG4gICAgYCxcbiAgICAvLyBsYW5ndWFnZT1HTFNMIHByZWZpeD1cInZvaWQgbWFpbigpIHtcIiBzdWZmaXg9XCJ9XCJcbiAgICB2ZXJ0ZXhUcmFuc2Zvcm06IGBcbiAgICAgIHVUcm9pa2FUb3RhbEJvdW5kcyA9IHRyb2lrYUJhdGNoVGV4ZWwoNC4wKTtcbiAgICAgIHVUcm9pa2FDbGlwUmVjdCA9IHRyb2lrYUJhdGNoVGV4ZWwoNS4wKTtcbiAgICAgIFxuICAgICAgdmVjNCBkYXRhID0gdHJvaWthQmF0Y2hUZXhlbCg2LjApO1xuICAgICAgZGlmZnVzZSA9IHRyb2lrYUZsb2F0VG9Db2xvcihkYXRhLngpO1xuICAgICAgdVRyb2lrYUZpbGxPcGFjaXR5ID0gZGF0YS55O1xuICAgICAgdVRyb2lrYUN1cnZlUmFkaXVzID0gZGF0YS56O1xuICAgICAgXG4gICAgICBkYXRhID0gdHJvaWthQmF0Y2hUZXhlbCg3LjApO1xuICAgICAgaWYgKHVUcm9pa2FJc091dGxpbmUpIHtcbiAgICAgICAgaWYgKGRhdGEgPT0gdmVjNCgwLjApKSB7IC8vIGRlZ2VuZXJhdGUgaWYgemVybyBvdXRsaW5lXG4gICAgICAgICAgcG9zaXRpb24gPSB2ZWMzKDAuMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdVRyb2lrYVBvc2l0aW9uT2Zmc2V0ID0gZGF0YS54eTtcbiAgICAgICAgICB1VHJvaWthRWRnZU9mZnNldCA9IGRhdGEuejtcbiAgICAgICAgICB1VHJvaWthQmx1clJhZGl1cyA9IGRhdGEudztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdVRyb2lrYVN0cm9rZVdpZHRoID0gZGF0YS54O1xuICAgICAgICB1VHJvaWthU3Ryb2tlQ29sb3IgPSB0cm9pa2FGbG9hdFRvQ29sb3IoZGF0YS55KTtcbiAgICAgICAgdVRyb2lrYVN0cm9rZU9wYWNpdHkgPSBkYXRhLno7XG4gICAgICB9XG4gICAgYCxcbiAgfSk7XG5cbiAgYmF0Y2hNYXRlcmlhbC5zZXRNYXRyaXhUZXh0dXJlID0gKHRleHR1cmUpID0+IHtcbiAgICBiYXRjaE1hdGVyaWFsLnVuaWZvcm1zW3RleFVuaWZvcm1OYW1lXS52YWx1ZSA9IHRleHR1cmU7XG4gICAgYmF0Y2hNYXRlcmlhbC51bmlmb3Jtc1t0ZXhTaXplVW5pZm9ybU5hbWVdLnZhbHVlLnNldCh0ZXh0dXJlLmltYWdlLndpZHRoLCB0ZXh0dXJlLmltYWdlLmhlaWdodCk7XG4gIH07XG4gIHJldHVybiBiYXRjaE1hdGVyaWFsO1xufVxuXG4vKipcbiAqIFR1cm4gYSB1bmlmb3JtIGludG8gYSB2YXJ5aW5nL3dyaXRlYWJsZSB2YWx1ZS5cbiAqIC0gSWYgdGhlIHVuaWZvcm0gd2FzIHVzZWQgaW4gdGhlIGZyYWdtZW50IHNoYWRlciwgaXQgd2lsbCBiZWNvbWUgYSB2YXJ5aW5nIGluIGJvdGggc2hhZGVycy5cbiAqIC0gSWYgdGhlIHVuaWZvcm0gd2FzIG9ubHkgdXNlZCBpbiB0aGUgdmVydGV4IHNoYWRlciwgaXQgd2lsbCBiZWNvbWUgYSB3cml0ZWFibGUgdmFyLlxuICovXG5mdW5jdGlvbiB1bmlmb3JtVG9WYXJ5aW5nKHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSwgdW5pZm9ybU5hbWUsIHZhcnlpbmdOYW1lID0gdW5pZm9ybU5hbWUpIHtcbiAgY29uc3QgdW5pZm9ybVJFID0gbmV3IFJlZ0V4cChgdW5pZm9ybVxcXFxzKyhib29sfGZsb2F0fHZlY1syMzRdfG1hdFszNF0pXFxcXHMrJHt1bmlmb3JtTmFtZX1cXFxcYmApO1xuXG4gIGxldCB0eXBlO1xuICBsZXQgaGFkRnJhZ21lbnRVbmlmb3JtID0gZmFsc2U7XG4gIGZyYWdtZW50U2hhZGVyID0gZnJhZ21lbnRTaGFkZXIucmVwbGFjZSh1bmlmb3JtUkUsICgkMCwgJDEpID0+IHtcbiAgICBoYWRGcmFnbWVudFVuaWZvcm0gPSB0cnVlO1xuICAgIHJldHVybiBgdmFyeWluZyAke3R5cGUgPSAkMX0gJHt2YXJ5aW5nTmFtZX1gXG4gIH0pO1xuXG4gIGxldCBoYWRWZXJ0ZXhVbmlmb3JtID0gZmFsc2U7XG4gIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKHVuaWZvcm1SRSwgKF8sICQxKSA9PiB7XG4gICAgaGFkVmVydGV4VW5pZm9ybSA9IHRydWU7XG4gICAgcmV0dXJuIGAke2hhZEZyYWdtZW50VW5pZm9ybSA/ICd2YXJ5aW5nJyA6ICcnfSAke3R5cGUgPSAkMX0gJHt2YXJ5aW5nTmFtZX1gXG4gIH0pO1xuICBpZiAoIWhhZFZlcnRleFVuaWZvcm0pIHtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBgJHtoYWRGcmFnbWVudFVuaWZvcm0gPyAndmFyeWluZycgOiAnJ30gJHt0eXBlfSAke3ZhcnlpbmdOYW1lfTtcXG4ke3ZlcnRleFNoYWRlcn1gO1xuICB9XG4gIHJldHVybiB7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn1cbn1cblxuLy89PT0gVXRpbGl0eSBmdW5jdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBjYXJldHMgYW5kIHNlbGVjdGlvbiByYW5nZXMgPT09Ly9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUZXh0Q2FyZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4IC0geCBwb3NpdGlvbiBvZiB0aGUgY2FyZXRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB5IC0geSBwb3NpdGlvbiBvZiB0aGUgY2FyZXQncyBib3R0b21cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBoZWlnaHQgLSBoZWlnaHQgb2YgdGhlIGNhcmV0XG4gKiBAcHJvcGVydHkge251bWJlcn0gY2hhckluZGV4IC0gdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCBpbnB1dCBzdHJpbmcgb2YgdGhpcyBjYXJldCdzIHRhcmdldFxuICogICBjaGFyYWN0ZXI7IHRoZSBjYXJldCB3aWxsIGJlIGZvciB0aGUgcG9zaXRpb24gX2JlZm9yZV8gdGhhdCBjaGFyYWN0ZXIuXG4gKi9cblxuLyoqXG4gKiBHaXZlbiBhIGxvY2FsIHgveSBjb29yZGluYXRlIGluIHRoZSB0ZXh0IGJsb2NrIHBsYW5lLCBmaW5kIHRoZSBuZWFyZXN0IGNhcmV0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm8gLSBhIHJlc3VsdCBvYmplY3QgZnJvbSBUZXh0QnVpbGRlciNnZXRUZXh0UmVuZGVySW5mb1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gKiBAcmV0dXJuIHtUZXh0Q2FyZXQgfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRDYXJldEF0UG9pbnQodGV4dFJlbmRlckluZm8sIHgsIHkpIHtcbiAgbGV0IGNsb3Nlc3RDYXJldCA9IG51bGw7XG4gIGNvbnN0IHJvd3MgPSBncm91cENhcmV0c0J5Um93KHRleHRSZW5kZXJJbmZvKTtcblxuICAvLyBGaW5kIG5lYXJlc3Qgcm93IGJ5IHkgZmlyc3RcbiAgbGV0IGNsb3Nlc3RSb3cgPSBudWxsO1xuICByb3dzLmZvckVhY2gocm93ID0+IHtcbiAgICBpZiAoIWNsb3Nlc3RSb3cgfHwgTWF0aC5hYnMoeSAtIChyb3cudG9wICsgcm93LmJvdHRvbSkgLyAyKSA8IE1hdGguYWJzKHkgLSAoY2xvc2VzdFJvdy50b3AgKyBjbG9zZXN0Um93LmJvdHRvbSkgLyAyKSkge1xuICAgICAgY2xvc2VzdFJvdyA9IHJvdztcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZW4gZmluZCBjbG9zZXN0IGNhcmV0IGJ5IHggd2l0aGluIHRoYXQgcm93XG4gIGNsb3Nlc3RSb3cuY2FyZXRzLmZvckVhY2goY2FyZXQgPT4ge1xuICAgIGlmICghY2xvc2VzdENhcmV0IHx8IE1hdGguYWJzKHggLSBjYXJldC54KSA8IE1hdGguYWJzKHggLSBjbG9zZXN0Q2FyZXQueCkpIHtcbiAgICAgIGNsb3Nlc3RDYXJldCA9IGNhcmV0O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjbG9zZXN0Q2FyZXRcbn1cblxuXG5jb25zdCBfcmVjdHNDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG5cbi8qKlxuICogR2l2ZW4gc3RhcnQgYW5kIGVuZCBjaGFyYWN0ZXIgaW5kZXhlcywgcmV0dXJuIGEgbGlzdCBvZiByZWN0YW5nbGVzIGNvdmVyaW5nIGFsbCB0aGVcbiAqIGNoYXJhY3RlcnMgd2l0aGluIHRoYXQgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtUcm9pa2FUZXh0UmVuZGVySW5mb30gdGV4dFJlbmRlckluZm9cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIGluZGV4IG9mIHRoZSBmaXJzdCBjaGFyIGluIHRoZSBzZWxlY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgLSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhciBhZnRlciB0aGUgc2VsZWN0aW9uXG4gKiBAcmV0dXJuIHtBcnJheTx7bGVmdCwgdG9wLCByaWdodCwgYm90dG9tfT4gfCBudWxsfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25SZWN0cyh0ZXh0UmVuZGVySW5mbywgc3RhcnQsIGVuZCkge1xuICBsZXQgcmVjdHM7XG4gIGlmICh0ZXh0UmVuZGVySW5mbykge1xuICAgIC8vIENoZWNrIGNhY2hlIC0gdGV4dFJlbmRlckluZm8gaXMgZnJvemVuIHNvIGl0J3Mgc2FmZSB0byBjYWNoZSBiYXNlZCBvbiBpdFxuICAgIGxldCBwcmV2UmVzdWx0ID0gX3JlY3RzQ2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgICBpZiAocHJldlJlc3VsdCAmJiBwcmV2UmVzdWx0LnN0YXJ0ID09PSBzdGFydCAmJiBwcmV2UmVzdWx0LmVuZCA9PT0gZW5kKSB7XG4gICAgICByZXR1cm4gcHJldlJlc3VsdC5yZWN0c1xuICAgIH1cblxuICAgIGNvbnN0IHtjYXJldFBvc2l0aW9uc30gPSB0ZXh0UmVuZGVySW5mbztcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgY29uc3QgcyA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICBlbmQgPSBzO1xuICAgIH1cbiAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICBlbmQgPSBNYXRoLm1pbihlbmQsIGNhcmV0UG9zaXRpb25zLmxlbmd0aCArIDEpO1xuXG4gICAgLy8gQnVpbGQgbGlzdCBvZiByZWN0cywgZXhwYW5kaW5nIHRoZSBjdXJyZW50IHJlY3QgZm9yIGFsbCBjaGFyYWN0ZXJzIGluIGEgcnVuIGFuZCBzdGFydGluZ1xuICAgIC8vIGEgbmV3IHJlY3Qgd2hlbmV2ZXIgcmVhY2hpbmcgYSBuZXcgbGluZSBvciBhIG5ldyBiaWRpIGRpcmVjdGlvblxuICAgIHJlY3RzID0gW107XG4gICAgbGV0IGN1cnJlbnRSZWN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgY29uc3QgeDEgPSBjYXJldFBvc2l0aW9uc1tpICogNF07XG4gICAgICBjb25zdCB4MiA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgMV07XG4gICAgICBjb25zdCBsZWZ0ID0gTWF0aC5taW4oeDEsIHgyKTtcbiAgICAgIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoeDEsIHgyKTtcbiAgICAgIGNvbnN0IGJvdHRvbSA9IGNhcmV0UG9zaXRpb25zW2kgKiA0ICsgMl07XG4gICAgICBjb25zdCB0b3AgPSBjYXJldFBvc2l0aW9uc1tpICogNCArIDNdO1xuICAgICAgaWYgKCFjdXJyZW50UmVjdCB8fCBib3R0b20gIT09IGN1cnJlbnRSZWN0LmJvdHRvbSB8fCB0b3AgIT09IGN1cnJlbnRSZWN0LnRvcCB8fCBsZWZ0ID4gY3VycmVudFJlY3QucmlnaHQgfHwgcmlnaHQgPCBjdXJyZW50UmVjdC5sZWZ0KSB7XG4gICAgICAgIGN1cnJlbnRSZWN0ID0ge1xuICAgICAgICAgIGxlZnQ6IEluZmluaXR5LFxuICAgICAgICAgIHJpZ2h0OiAtSW5maW5pdHksXG4gICAgICAgICAgYm90dG9tLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVjdHMucHVzaChjdXJyZW50UmVjdCk7XG4gICAgICB9XG4gICAgICBjdXJyZW50UmVjdC5sZWZ0ID0gTWF0aC5taW4obGVmdCwgY3VycmVudFJlY3QubGVmdCk7XG4gICAgICBjdXJyZW50UmVjdC5yaWdodCA9IE1hdGgubWF4KHJpZ2h0LCBjdXJyZW50UmVjdC5yaWdodCk7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2UgYW55IG92ZXJsYXBwaW5nIHJlY3RzLCBlLmcuIHRob3NlIGZvcm1lZCBieSBhZGphY2VudCBiaWRpIHJ1bnNcbiAgICByZWN0cy5zb3J0KChhLCBiKSA9PiBiLmJvdHRvbSAtIGEuYm90dG9tIHx8IGEubGVmdCAtIGIubGVmdCk7XG4gICAgZm9yIChsZXQgaSA9IHJlY3RzLmxlbmd0aCAtIDE7IGktLSA+IDA7KSB7XG4gICAgICBjb25zdCByZWN0QSA9IHJlY3RzW2ldO1xuICAgICAgY29uc3QgcmVjdEIgPSByZWN0c1tpICsgMV07XG4gICAgICBpZiAocmVjdEEuYm90dG9tID09PSByZWN0Qi5ib3R0b20gJiYgcmVjdEEudG9wID09PSByZWN0Qi50b3AgJiYgcmVjdEEubGVmdCA8PSByZWN0Qi5yaWdodCAmJiByZWN0QS5yaWdodCA+PSByZWN0Qi5sZWZ0KSB7XG4gICAgICAgIHJlY3RCLmxlZnQgPSBNYXRoLm1pbihyZWN0Qi5sZWZ0LCByZWN0QS5sZWZ0KTtcbiAgICAgICAgcmVjdEIucmlnaHQgPSBNYXRoLm1heChyZWN0Qi5yaWdodCwgcmVjdEEucmlnaHQpO1xuICAgICAgICByZWN0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX3JlY3RzQ2FjaGUuc2V0KHRleHRSZW5kZXJJbmZvLCB7c3RhcnQsIGVuZCwgcmVjdHN9KTtcbiAgfVxuICByZXR1cm4gcmVjdHNcbn1cblxuY29uc3QgX2NhcmV0c0J5Um93Q2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4vKipcbiAqIEdyb3VwIGEgc2V0IG9mIGNhcmV0cyBieSByb3cgb2YgdGV4dCwgY2FjaGluZyB0aGUgcmVzdWx0LiBBIHNpbmdsZSByb3cgb2YgdGV4dCBtYXkgY29udGFpbiBjYXJldHMgb2ZcbiAqIGRpZmZlcmluZyBwb3NpdGlvbnMvaGVpZ2h0cyBpZiBpdCBoYXMgbXVsdGlwbGUgZm9udHMsIGFuZCB0aGV5IG1heSBvdmVybGFwIHNsaWdodGx5IGFjcm9zcyByb3dzLCBzbyB0aGlzXG4gKiB1c2VzIGFuIGFzc3VtcHRpb24gb2YgXCJhdCBsZWFzdCBvdmVybGFwcGluZyBieSBoYWxmXCIgdG8gcHV0IHRoZW0gaW4gdGhlIHNhbWUgcm93LlxuICogQHJldHVybiBBcnJheTx7Ym90dG9tOiBudW1iZXIsIHRvcDogbnVtYmVyLCBjYXJldHM6IFRleHRDYXJldFtdfT5cbiAqL1xuZnVuY3Rpb24gZ3JvdXBDYXJldHNCeVJvdyh0ZXh0UmVuZGVySW5mbykge1xuICAvLyB0ZXh0UmVuZGVySW5mbyBpcyBmcm96ZW4gc28gaXQncyBzYWZlIHRvIGNhY2hlIGJhc2VkIG9uIGl0XG4gIGxldCByb3dzID0gX2NhcmV0c0J5Um93Q2FjaGUuZ2V0KHRleHRSZW5kZXJJbmZvKTtcbiAgaWYgKCFyb3dzKSB7XG4gICAgcm93cyA9IFtdO1xuICAgIGNvbnN0IHtjYXJldFBvc2l0aW9uc30gPSB0ZXh0UmVuZGVySW5mbztcbiAgICBsZXQgY3VyUm93O1xuXG4gICAgY29uc3QgdmlzaXRDYXJldCA9ICh4LCBib3R0b20sIHRvcCwgY2hhckluZGV4KSA9PiB7XG4gICAgICAvLyBuZXcgcm93IGlmIG5vdCBvdmVybGFwcGluZyBieSBhdCBsZWFzdCBoYWxmXG4gICAgICBpZiAoIWN1clJvdyB8fCAodG9wIDwgKGN1clJvdy50b3AgKyBjdXJSb3cuYm90dG9tKSAvIDIpKSB7XG4gICAgICAgIHJvd3MucHVzaChjdXJSb3cgPSB7Ym90dG9tLCB0b3AsIGNhcmV0czogW119KTtcbiAgICAgIH1cbiAgICAgIC8vIGV4cGFuZCB2ZXJ0aWNhbCBsaW1pdHMgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAodG9wID4gY3VyUm93LnRvcCkgY3VyUm93LnRvcCA9IHRvcDtcbiAgICAgIGlmIChib3R0b20gPCBjdXJSb3cuYm90dG9tKSBjdXJSb3cuYm90dG9tID0gYm90dG9tO1xuICAgICAgY3VyUm93LmNhcmV0cy5wdXNoKHtcbiAgICAgICAgeCxcbiAgICAgICAgeTogYm90dG9tLFxuICAgICAgICBoZWlnaHQ6IHRvcCAtIGJvdHRvbSxcbiAgICAgICAgY2hhckluZGV4LFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IGNhcmV0UG9zaXRpb25zLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICB2aXNpdENhcmV0KGNhcmV0UG9zaXRpb25zW2ldLCBjYXJldFBvc2l0aW9uc1tpICsgMl0sIGNhcmV0UG9zaXRpb25zW2kgKyAzXSwgaSAvIDQpO1xuICAgIH1cbiAgICAvLyBBZGQgb25lIG1vcmUgY2FyZXQgYWZ0ZXIgdGhlIGZpbmFsIGNoYXJcbiAgICB2aXNpdENhcmV0KGNhcmV0UG9zaXRpb25zW2kgLSAzXSwgY2FyZXRQb3NpdGlvbnNbaSAtIDJdLCBjYXJldFBvc2l0aW9uc1tpIC0gMV0sIGkgLyA0KTtcbiAgfVxuICBfY2FyZXRzQnlSb3dDYWNoZS5zZXQodGV4dFJlbmRlckluZm8sIHJvd3MpO1xuICByZXR1cm4gcm93c1xufVxuXG5leHBvcnQgeyBCYXRjaGVkVGV4dCwgR2x5cGhzR2VvbWV0cnksIFRleHQsIGNvbmZpZ3VyZVRleHRCdWlsZGVyLCBjcmVhdGVUZXh0RGVyaXZlZE1hdGVyaWFsLCBkdW1wU0RGVGV4dHVyZXMsIGZvbnRSZXNvbHZlcldvcmtlck1vZHVsZSwgZ2V0Q2FyZXRBdFBvaW50LCBnZXRTZWxlY3Rpb25SZWN0cywgZ2V0VGV4dFJlbmRlckluZm8sIHByZWxvYWRGb250LCB0eXBlc2V0dGVyV29ya2VyTW9kdWxlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/troika-three-text/dist/troika-three-text.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js":
/*!************************************************************************!*\
  !*** ./node_modules/troika-three-utils/dist/troika-three-utils.esm.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BezierMesh: function() { return /* binding */ BezierMesh; },\n/* harmony export */   createDerivedMaterial: function() { return /* binding */ createDerivedMaterial; },\n/* harmony export */   expandShaderIncludes: function() { return /* binding */ expandShaderIncludes; },\n/* harmony export */   getShaderUniformTypes: function() { return /* binding */ getShaderUniformTypes; },\n/* harmony export */   getShadersForMaterial: function() { return /* binding */ getShadersForMaterial; },\n/* harmony export */   invertMatrix4: function() { return /* binding */ invertMatrix4; },\n/* harmony export */   voidMainRegExp: function() { return /* binding */ voidMainRegExp; }\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n\n\n/**\n * Regular expression for matching the `void main() {` opener line in GLSL.\n * @type {RegExp}\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\n * Recursively expands all `#include <xyz>` statements within string of shader code.\n * Copied from three's WebGLProgram#parseIncludes for external use.\n *\n * @param {string} source - The GLSL source code to evaluate\n * @return {string} The GLSL code with all includes expanded\n */\nfunction expandShaderIncludes( source ) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = three__WEBPACK_IMPORTED_MODULE_0__.ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match\n  }\n  return source.replace( pattern, replace )\n}\n\n/*\n * This is a direct copy of MathUtils.generateUUID from Three.js, to preserve compatibility with three\n * versions before 0.113.0 as it was changed from Math to MathUtils in that version.\n * https://github.com/mrdoob/three.js/blob/dd8b5aa3b270c17096b90945cd2d6d1b13aaec53/src/math/MathUtils.js#L16\n */\n\nconst _lut = [];\n\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n}\n\nfunction generateUUID() {\n\n  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\n\n  const d0 = Math.random() * 0xffffffff | 0;\n  const d1 = Math.random() * 0xffffffff | 0;\n  const d2 = Math.random() * 0xffffffff | 0;\n  const d3 = Math.random() * 0xffffffff | 0;\n  const uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' +\n    _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' +\n    _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] +\n    _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];\n\n  // .toUpperCase() here flattens concatenated strings to save heap memory space.\n  return uuid.toUpperCase()\n\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function(/*target, ...sources*/) {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (Object.prototype.hasOwnProperty.call(source, prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target\n};\n\n\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\n * A utility for creating a custom shader material derived from another material's\n * shaders. This allows you to inject custom shader logic and transforms into the\n * builtin ThreeJS materials without having to recreate them from scratch.\n *\n * @param {THREE.Material} baseMaterial - the original material to derive from\n *\n * @param {Object} options - How the base material should be modified.\n * @param {Object=} options.defines - Custom `defines` for the material\n * @param {Object=} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\n * @param {Object=} options.uniforms - Custom `uniforms` for use in the modified shader. These can\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\n * @param {String=} options.timeUniform - If specified, a uniform of this name will be injected into\n *        both shaders, and it will automatically be updated on each render frame with a number of\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\n *        true calendar time.\n * @param {String=} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String=} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\n *        shader's `void main` function.\n * @param {String=} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\n *        shader's `void main` function.\n * @param {String=} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\n *        those attributes exposed by their normal names as read/write values.\n * @param {String=} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\n *        definitions, above the `void main()` function.\n * @param {String=} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\n *        shader's `void main` function.\n * @param {String=} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\n *        want those to apply to your changes use `fragmentColorTransform` instead.\n * @param {String=} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\n *        output value. Will be injected near the end of the `void main` function, but before any\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\n *        `fragmentMainOutro`.\n * @param {function({fragmentShader: string, vertexShader:string}):\n *        {fragmentShader: string, vertexShader:string}} options.customRewriter - A function\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\n *        special that's not covered by the other builtin options. This function will be executed before\n *        any other transforms are applied.\n * @param {boolean=} options.chained - Set to `true` to prototype-chain the derived material to the base\n *        material, rather than the default behavior of copying it. This allows the derived material to\n *        automatically pick up changes made to the base material and its properties. This can be useful\n *        where the derived material is hidden from the user as an implementation detail, allowing them\n *        to work with the original material like normal. But it can result in unexpected behavior if not\n *        handled carefully.\n *\n * @return {THREE.Material}\n *\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\n * which can be called to get a variant of the derived material for use in shadow casting. If the\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, (ctorsByDerivation = Object.create(null)));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]()\n  }\n\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo, renderer) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo, renderer);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = this.customProgramCacheKey() + '|' + shaderInfo.vertexShader + '|' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(this, shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {return Date.now() - epoch}\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone())\n  };\n\n  const derive = function(base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', { value: baseMaterial });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', { value: materialInstanceId++ });\n    derived.uuid = generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n\n    return derived\n  };\n\n  const descriptor = {\n    constructor: {value: DerivedMaterial},\n    isDerivedMaterial: {value: true},\n\n    type: {\n      get: () => baseMaterial.type,\n      set: (value) => {baseMaterial.type = value;}\n    },\n\n    isDerivedFrom: {\n      writable: true,\n      configurable: true,\n      value: function (testMaterial) {\n        const base = this.baseMaterial;\n        return testMaterial === base || (base.isDerivedMaterial && base.isDerivedFrom(testMaterial)) || false\n      }\n    },\n\n    customProgramCacheKey: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        return baseMaterial.customProgramCacheKey() + '|' + optionsKey\n      }\n    },\n\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone(source.uniforms));\n        }\n        return this\n      }\n    },\n\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this)\n      }\n    },\n\n    /**\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDepthMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDepthMaterial({ depthPacking: three__WEBPACK_IMPORTED_MODULE_0__.RGBADepthPacking }),\n            options\n          );\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial\n      }\n    },\n\n    /**\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\n     * transformations and discarded fragments.\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function() {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(\n            baseMaterial.isDerivedMaterial\n              ? baseMaterial.getDistanceMaterial()\n              : new three__WEBPACK_IMPORTED_MODULE_0__.MeshDistanceMaterial(),\n            options\n          );\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial\n      }\n    },\n\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {_depthMaterial, _distanceMaterial} = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial()\n}\n\n\nfunction upgradeShaders(material, {vertexShader, fragmentShader}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(\n      /^[ \\t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm,\n      '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n'\n    );\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({vertexShader, fragmentShader});\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(\n      /^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm, // [^]+? = non-greedy match of any chars including newlines\n      match => {\n        postChunks.push(match);\n        return ''\n      }\n    );\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    // Hoist these defs to the very top so they work in other function defs\n    vertexShader = `vec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\n${vertexShader}\n`;\n    vertexDefs = `${vertexDefs}\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`\n    });\n\n    // Three r152 introduced the MAP_UV token, replace it too if it's pointing to the main 'uv'\n    // Perhaps the other textures too going forward?\n    if (!(material.map && material.map.channel > 0)) {\n      vertexShader = vertexShader.replace(/\\bMAP_UV\\b/g, `troika_uv_${key}`);\n    }\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n\n  return {\n    vertexShader,\n    fragmentShader\n  }\n}\n\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`\n    );\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode\n}\n\n\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value\n}\n\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, (id = ++_idCtr));\n  }\n  return id\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'toon',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\n * used to render that material.\n *\n * @param material - the Material instance\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? three__WEBPACK_IMPORTED_MODULE_0__.ShaderLib[builtinType] : material //TODO fallback for unknown type?\n}\n\n/**\n * Find all uniforms and their types within a shader code string.\n *\n * @param {string} shader - The shader code to parse\n * @return {object} mapping of uniform names to their glsl type\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234]|mat[34])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms\n}\n\n/**\n * Helper for smoothing out the `m.getInverse(x)` --> `m.copy(x).invert()` conversion\n * that happened in ThreeJS r123.\n * @param {Matrix4} srcMatrix\n * @param {Matrix4} [tgtMatrix]\n */\nfunction invertMatrix4(srcMatrix, tgtMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4()) {\n  if (typeof tgtMatrix.invert === 'function') {\n    tgtMatrix.copy(srcMatrix).invert();\n  } else {\n    tgtMatrix.getInverse(srcMatrix);\n  }\n  return tgtMatrix\n}\n\n/*\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\ndivided into a reasonable number of height segments.\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\n\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\n\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\n\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\n\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(\n    baseMaterial,\n    {\n      chained: true,\n      uniforms: {\n        pointA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlA: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        controlB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        pointB: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()},\n        radius: {value: 0.01},\n        dashing: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3()} //on, off, offset\n      },\n      vertexDefs,\n      vertexTransform,\n      fragmentDefs,\n      fragmentMainIntro\n    }\n  )\n}\n\nlet geometry = null;\n\nconst defaultBaseMaterial = /*#__PURE__*/new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({color: 0xffffff, side: three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide});\n\n\n/**\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\n * automatically.\n *\n * The cubiz bezier path is determined by its four `Vector3` properties:\n * - `pointA`\n * - `controlA`\n * - `controlB`\n * - `pointB`\n *\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\n *\n * You can also give the tube a dashed appearance with two properties:\n *\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\n *   used as input to the cubic bezier function, not its visible length.)\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\n *\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\n * thicker tubes.\n *\n * TODO: proper geometry bounding sphere and raycasting\n * TODO: allow control of the geometry's segment counts\n */\nclass BezierMesh extends three__WEBPACK_IMPORTED_MODULE_0__.Mesh {\n  static getGeometry() {\n    return geometry || (geometry =\n      new three__WEBPACK_IMPORTED_MODULE_0__.CylinderGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0)\n    )\n  }\n\n  constructor() {\n    super(\n      BezierMesh.getGeometry(),\n      defaultBaseMaterial\n    );\n\n    this.pointA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlA = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.controlB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.pointB = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    this.radius = 0.01;\n    this.dashArray = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial()\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial()\n  }\n\n  onBeforeRender() {\n    const {uniforms} = this.material;\n    const {pointA, controlA, controlB, pointB, radius, dashArray, dashOffset} = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n\n  raycast(/*raycaster, intersects*/) {\n    // TODO - just fail for now\n  }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdXRpbHMvZGlzdC90cm9pa2EtdGhyZWUtdXRpbHMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQThNOztBQUU5TTtBQUNBLHFEQUFxRDtBQUNyRCxVQUFVO0FBQ1Y7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVMsa0VBQWtFLGtCQUFrQjtBQUN4RyxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7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QkFBc0IsMENBQU87QUFDN0Isd0JBQXdCLDBDQUFPO0FBQy9CLHdCQUF3QiwwQ0FBTztBQUMvQixzQkFBc0IsMENBQU87QUFDN0I7QUFDQSx5QkFBeUIsMENBQU87QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxtRUFBbUU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90cm9pa2EtdGhyZWUtdXRpbHMvZGlzdC90cm9pa2EtdGhyZWUtdXRpbHMuZXNtLmpzP2ExZjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2hhZGVyQ2h1bmssIFVuaWZvcm1zVXRpbHMsIE1lc2hEZXB0aE1hdGVyaWFsLCBSR0JBRGVwdGhQYWNraW5nLCBNZXNoRGlzdGFuY2VNYXRlcmlhbCwgU2hhZGVyTGliLCBNYXRyaXg0LCBWZWN0b3IzLCBNZXNoLCBDeWxpbmRlckdlb21ldHJ5LCBWZWN0b3IyLCBNZXNoU3RhbmRhcmRNYXRlcmlhbCwgRG91YmxlU2lkZSB9IGZyb20gJ3RocmVlJztcblxuLyoqXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gZm9yIG1hdGNoaW5nIHRoZSBgdm9pZCBtYWluKCkge2Agb3BlbmVyIGxpbmUgaW4gR0xTTC5cbiAqIEB0eXBlIHtSZWdFeHB9XG4gKi9cbmNvbnN0IHZvaWRNYWluUmVnRXhwID0gL1xcYnZvaWRcXHMrbWFpblxccypcXChcXHMqXFwpXFxzKnsvZztcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBleHBhbmRzIGFsbCBgI2luY2x1ZGUgPHh5ej5gIHN0YXRlbWVudHMgd2l0aGluIHN0cmluZyBvZiBzaGFkZXIgY29kZS5cbiAqIENvcGllZCBmcm9tIHRocmVlJ3MgV2ViR0xQcm9ncmFtI3BhcnNlSW5jbHVkZXMgZm9yIGV4dGVybmFsIHVzZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gVGhlIEdMU0wgc291cmNlIGNvZGUgdG8gZXZhbHVhdGVcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEdMU0wgY29kZSB3aXRoIGFsbCBpbmNsdWRlcyBleHBhbmRlZFxuICovXG5mdW5jdGlvbiBleHBhbmRTaGFkZXJJbmNsdWRlcyggc291cmNlICkge1xuICBjb25zdCBwYXR0ZXJuID0gL15bIFxcdF0qI2luY2x1ZGUgKzwoW1xcd1xcZC4vXSspPi9nbTtcbiAgZnVuY3Rpb24gcmVwbGFjZShtYXRjaCwgaW5jbHVkZSkge1xuICAgIGxldCBjaHVuayA9IFNoYWRlckNodW5rW2luY2x1ZGVdO1xuICAgIHJldHVybiBjaHVuayA/IGV4cGFuZFNoYWRlckluY2x1ZGVzKGNodW5rKSA6IG1hdGNoXG4gIH1cbiAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlIClcbn1cblxuLypcbiAqIFRoaXMgaXMgYSBkaXJlY3QgY29weSBvZiBNYXRoVXRpbHMuZ2VuZXJhdGVVVUlEIGZyb20gVGhyZWUuanMsIHRvIHByZXNlcnZlIGNvbXBhdGliaWxpdHkgd2l0aCB0aHJlZVxuICogdmVyc2lvbnMgYmVmb3JlIDAuMTEzLjAgYXMgaXQgd2FzIGNoYW5nZWQgZnJvbSBNYXRoIHRvIE1hdGhVdGlscyBpbiB0aGF0IHZlcnNpb24uXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvZGQ4YjVhYTNiMjcwYzE3MDk2YjkwOTQ1Y2QyZDZkMWIxM2FhZWM1My9zcmMvbWF0aC9NYXRoVXRpbHMuanMjTDE2XG4gKi9cblxuY29uc3QgX2x1dCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gIF9sdXRbaV0gPSAoaSA8IDE2ID8gJzAnIDogJycpICsgKGkpLnRvU3RyaW5nKDE2KTtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKCkge1xuXG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTk2MzEzNiMyMTk2MzEzNlxuXG4gIGNvbnN0IGQwID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCBkMSA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcbiAgY29uc3QgZDIgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XG4gIGNvbnN0IGQzID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xuICBjb25zdCB1dWlkID0gX2x1dFtkMCAmIDB4ZmZdICsgX2x1dFtkMCA+PiA4ICYgMHhmZl0gKyBfbHV0W2QwID4+IDE2ICYgMHhmZl0gKyBfbHV0W2QwID4+IDI0ICYgMHhmZl0gKyAnLScgK1xuICAgIF9sdXRbZDEgJiAweGZmXSArIF9sdXRbZDEgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMSA+PiAxNiAmIDB4MGYgfCAweDQwXSArIF9sdXRbZDEgPj4gMjQgJiAweGZmXSArICctJyArXG4gICAgX2x1dFtkMiAmIDB4M2YgfCAweDgwXSArIF9sdXRbZDIgPj4gOCAmIDB4ZmZdICsgJy0nICsgX2x1dFtkMiA+PiAxNiAmIDB4ZmZdICsgX2x1dFtkMiA+PiAyNCAmIDB4ZmZdICtcbiAgICBfbHV0W2QzICYgMHhmZl0gKyBfbHV0W2QzID4+IDggJiAweGZmXSArIF9sdXRbZDMgPj4gMTYgJiAweGZmXSArIF9sdXRbZDMgPj4gMjQgJiAweGZmXTtcblxuICAvLyAudG9VcHBlckNhc2UoKSBoZXJlIGZsYXR0ZW5zIGNvbmNhdGVuYXRlZCBzdHJpbmdzIHRvIHNhdmUgaGVhcCBtZW1vcnkgc3BhY2UuXG4gIHJldHVybiB1dWlkLnRvVXBwZXJDYXNlKClcblxufVxuXG4vLyBMb2NhbCBhc3NpZ24gcG9seWZpbGwgdG8gYXZvaWQgaW1wb3J0aW5nIHRyb2lrYS1jb3JlXG5jb25zdCBhc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKC8qdGFyZ2V0LCAuLi5zb3VyY2VzKi8pIHtcbiAgbGV0IHRhcmdldCA9IGFyZ3VtZW50c1swXTtcbiAgZm9yIChsZXQgaSA9IDEsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgdGFyZ2V0W3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXRcbn07XG5cblxuY29uc3QgZXBvY2ggPSBEYXRlLm5vdygpO1xuY29uc3QgQ09OU1RSVUNUT1JfQ0FDSEUgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgU0hBREVSX1VQR1JBREVfQ0FDSEUgPSBuZXcgTWFwKCk7XG5cbi8vIE1hdGVyaWFsIGlkcyBtdXN0IGJlIGludGVnZXJzLCBidXQgd2UgY2FuJ3QgYWNjZXNzIHRoZSBpbmNyZW1lbnQgZnJvbSBUaHJlZSdzIGBNYXRlcmlhbGAgbW9kdWxlLFxuLy8gc28gbGV0J3MgY2hvb3NlIGEgc3VmZmljaWVudGx5IGxhcmdlIHN0YXJ0aW5nIHZhbHVlIHRoYXQgc2hvdWxkIHRoZW9yZXRpY2FsbHkgbmV2ZXIgY29sbGlkZS5cbmxldCBtYXRlcmlhbEluc3RhbmNlSWQgPSAxZTEwO1xuXG4vKipcbiAqIEEgdXRpbGl0eSBmb3IgY3JlYXRpbmcgYSBjdXN0b20gc2hhZGVyIG1hdGVyaWFsIGRlcml2ZWQgZnJvbSBhbm90aGVyIG1hdGVyaWFsJ3NcbiAqIHNoYWRlcnMuIFRoaXMgYWxsb3dzIHlvdSB0byBpbmplY3QgY3VzdG9tIHNoYWRlciBsb2dpYyBhbmQgdHJhbnNmb3JtcyBpbnRvIHRoZVxuICogYnVpbHRpbiBUaHJlZUpTIG1hdGVyaWFscyB3aXRob3V0IGhhdmluZyB0byByZWNyZWF0ZSB0aGVtIGZyb20gc2NyYXRjaC5cbiAqXG4gKiBAcGFyYW0ge1RIUkVFLk1hdGVyaWFsfSBiYXNlTWF0ZXJpYWwgLSB0aGUgb3JpZ2luYWwgbWF0ZXJpYWwgdG8gZGVyaXZlIGZyb21cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEhvdyB0aGUgYmFzZSBtYXRlcmlhbCBzaG91bGQgYmUgbW9kaWZpZWQuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuZGVmaW5lcyAtIEN1c3RvbSBgZGVmaW5lc2AgZm9yIHRoZSBtYXRlcmlhbFxuICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLmV4dGVuc2lvbnMgLSBDdXN0b20gYGV4dGVuc2lvbnNgIGZvciB0aGUgbWF0ZXJpYWwsIGUuZy4gYHtkZXJpdmF0aXZlczogdHJ1ZX1gXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMudW5pZm9ybXMgLSBDdXN0b20gYHVuaWZvcm1zYCBmb3IgdXNlIGluIHRoZSBtb2RpZmllZCBzaGFkZXIuIFRoZXNlIGNhblxuICogICAgICAgIGJlIGFjY2Vzc2VkIGFuZCBtYW5pcHVsYXRlZCB2aWEgdGhlIHJlc3VsdGluZyBtYXRlcmlhbCdzIGB1bmlmb3Jtc2AgcHJvcGVydHksIGp1c3QgbGlrZVxuICogICAgICAgIGluIGEgU2hhZGVyTWF0ZXJpYWwuIFlvdSBkbyBub3QgbmVlZCB0byByZXBlYXQgdGhlIGJhc2UgbWF0ZXJpYWwncyBvd24gdW5pZm9ybXMgaGVyZS5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy50aW1lVW5pZm9ybSAtIElmIHNwZWNpZmllZCwgYSB1bmlmb3JtIG9mIHRoaXMgbmFtZSB3aWxsIGJlIGluamVjdGVkIGludG9cbiAqICAgICAgICBib3RoIHNoYWRlcnMsIGFuZCBpdCB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgdXBkYXRlZCBvbiBlYWNoIHJlbmRlciBmcmFtZSB3aXRoIGEgbnVtYmVyIG9mXG4gKiAgICAgICAgZWxhcHNlZCBtaWxsaXNlY29uZHMuIFRoZSBcInplcm9cIiBlcG9jaCB0aW1lIGlzIG5vdCBzaWduaWZpY2FudCBzbyBkb24ndCByZWx5IG9uIHRoaXMgYXMgYVxuICogICAgICAgIHRydWUgY2FsZW5kYXIgdGltZS5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhEZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgdmVydGV4IHNoYWRlcidzIHRvcC1sZXZlbFxuICogICAgICAgIGRlZmluaXRpb25zLCBhYm92ZSB0aGUgYHZvaWQgbWFpbigpYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhNYWluSW50cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgdG9wIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhNYWluT3V0cm8gLSBDdXN0b20gR0xTTCBjb2RlIHRvIGluamVjdCBhdCB0aGUgZW5kIG9mIHRoZSB2ZXJ0ZXhcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy52ZXJ0ZXhUcmFuc2Zvcm0gLSBDdXN0b20gR0xTTCBjb2RlIHRvIG1hbmlwdWxhdGUgdGhlIGBwb3NpdGlvbmAsIGBub3JtYWxgLFxuICogICAgICAgIGFuZC9vciBgdXZgIHZlcnRleCBhdHRyaWJ1dGVzLiBUaGlzIGNvZGUgd2lsbCBiZSB3cmFwcGVkIHdpdGhpbiBhIHN0YW5kYWxvbmUgZnVuY3Rpb24gd2l0aFxuICogICAgICAgIHRob3NlIGF0dHJpYnV0ZXMgZXhwb3NlZCBieSB0aGVpciBub3JtYWwgbmFtZXMgYXMgcmVhZC93cml0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge1N0cmluZz19IG9wdGlvbnMuZnJhZ21lbnREZWZzIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgaW50byB0aGUgZnJhZ21lbnQgc2hhZGVyJ3MgdG9wLWxldmVsXG4gKiAgICAgICAgZGVmaW5pdGlvbnMsIGFib3ZlIHRoZSBgdm9pZCBtYWluKClgIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTdHJpbmc9fSBvcHRpb25zLmZyYWdtZW50TWFpbkludHJvIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBpbmplY3QgYXQgdGhlIHRvcCBvZiB0aGUgZnJhZ21lbnRcbiAqICAgICAgICBzaGFkZXIncyBgdm9pZCBtYWluYCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy5mcmFnbWVudE1haW5PdXRybyAtIEN1c3RvbSBHTFNMIGNvZGUgdG8gaW5qZWN0IGF0IHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50XG4gKiAgICAgICAgc2hhZGVyJ3MgYHZvaWQgbWFpbmAgZnVuY3Rpb24uIFlvdSBjYW4gbWFuaXB1bGF0ZSBgZ2xfRnJhZ0NvbG9yYCBoZXJlIGJ1dCBrZWVwIGluIG1pbmQgaXQgZ29lc1xuICogICAgICAgIGFmdGVyIGFueSBvZiBUaHJlZUpTJ3MgY29sb3IgcG9zdHByb2Nlc3Npbmcgc2hhZGVyIGNodW5rcyAodG9uZW1hcHBpbmcsIGZvZywgZXRjLiksIHNvIGlmIHlvdVxuICogICAgICAgIHdhbnQgdGhvc2UgdG8gYXBwbHkgdG8geW91ciBjaGFuZ2VzIHVzZSBgZnJhZ21lbnRDb2xvclRyYW5zZm9ybWAgaW5zdGVhZC5cbiAqIEBwYXJhbSB7U3RyaW5nPX0gb3B0aW9ucy5mcmFnbWVudENvbG9yVHJhbnNmb3JtIC0gQ3VzdG9tIEdMU0wgY29kZSB0byBtYW5pcHVsYXRlIHRoZSBgZ2xfRnJhZ0NvbG9yYFxuICogICAgICAgIG91dHB1dCB2YWx1ZS4gV2lsbCBiZSBpbmplY3RlZCBuZWFyIHRoZSBlbmQgb2YgdGhlIGB2b2lkIG1haW5gIGZ1bmN0aW9uLCBidXQgYmVmb3JlIGFueVxuICogICAgICAgIG9mIFRocmVlSlMncyBjb2xvciBwb3N0cHJvY2Vzc2luZyBzaGFkZXIgY2h1bmtzICh0b25lbWFwcGluZywgZm9nLCBldGMuKSwgYW5kIGJlZm9yZSB0aGVcbiAqICAgICAgICBgZnJhZ21lbnRNYWluT3V0cm9gLlxuICogQHBhcmFtIHtmdW5jdGlvbih7ZnJhZ21lbnRTaGFkZXI6IHN0cmluZywgdmVydGV4U2hhZGVyOnN0cmluZ30pOlxuICogICAgICAgIHtmcmFnbWVudFNoYWRlcjogc3RyaW5nLCB2ZXJ0ZXhTaGFkZXI6c3RyaW5nfX0gb3B0aW9ucy5jdXN0b21SZXdyaXRlciAtIEEgZnVuY3Rpb25cbiAqICAgICAgICBmb3IgcGVyZm9ybWluZyBjdXN0b20gcmV3cml0ZXMgb2YgdGhlIGZ1bGwgc2hhZGVyIGNvZGUuIFVzZWZ1bCBpZiB5b3UgbmVlZCB0byBkbyBzb21ldGhpbmdcbiAqICAgICAgICBzcGVjaWFsIHRoYXQncyBub3QgY292ZXJlZCBieSB0aGUgb3RoZXIgYnVpbHRpbiBvcHRpb25zLiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlXG4gKiAgICAgICAgYW55IG90aGVyIHRyYW5zZm9ybXMgYXJlIGFwcGxpZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvcHRpb25zLmNoYWluZWQgLSBTZXQgdG8gYHRydWVgIHRvIHByb3RvdHlwZS1jaGFpbiB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0byB0aGUgYmFzZVxuICogICAgICAgIG1hdGVyaWFsLCByYXRoZXIgdGhhbiB0aGUgZGVmYXVsdCBiZWhhdmlvciBvZiBjb3B5aW5nIGl0LiBUaGlzIGFsbG93cyB0aGUgZGVyaXZlZCBtYXRlcmlhbCB0b1xuICogICAgICAgIGF1dG9tYXRpY2FsbHkgcGljayB1cCBjaGFuZ2VzIG1hZGUgdG8gdGhlIGJhc2UgbWF0ZXJpYWwgYW5kIGl0cyBwcm9wZXJ0aWVzLiBUaGlzIGNhbiBiZSB1c2VmdWxcbiAqICAgICAgICB3aGVyZSB0aGUgZGVyaXZlZCBtYXRlcmlhbCBpcyBoaWRkZW4gZnJvbSB0aGUgdXNlciBhcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwsIGFsbG93aW5nIHRoZW1cbiAqICAgICAgICB0byB3b3JrIHdpdGggdGhlIG9yaWdpbmFsIG1hdGVyaWFsIGxpa2Ugbm9ybWFsLiBCdXQgaXQgY2FuIHJlc3VsdCBpbiB1bmV4cGVjdGVkIGJlaGF2aW9yIGlmIG5vdFxuICogICAgICAgIGhhbmRsZWQgY2FyZWZ1bGx5LlxuICpcbiAqIEByZXR1cm4ge1RIUkVFLk1hdGVyaWFsfVxuICpcbiAqIFRoZSByZXR1cm5lZCBtYXRlcmlhbCB3aWxsIGFsc28gaGF2ZSB0d28gbmV3IG1ldGhvZHMsIGBnZXREZXB0aE1hdGVyaWFsKClgIGFuZCBgZ2V0RGlzdGFuY2VNYXRlcmlhbCgpYCxcbiAqIHdoaWNoIGNhbiBiZSBjYWxsZWQgdG8gZ2V0IGEgdmFyaWFudCBvZiB0aGUgZGVyaXZlZCBtYXRlcmlhbCBmb3IgdXNlIGluIHNoYWRvdyBjYXN0aW5nLiBJZiB0aGVcbiAqIHRhcmdldCBtZXNoIGlzIGV4cGVjdGVkIHRvIGNhc3Qgc2hhZG93cywgdGhlbiB5b3UgY2FuIGFzc2lnbiB0aGVzZSB0byB0aGUgbWVzaCdzIGBjdXN0b21EZXB0aE1hdGVyaWFsYFxuICogKGZvciBkaXJlY3Rpb25hbCBhbmQgc3BvdCBsaWdodHMpIGFuZC9vciBgY3VzdG9tRGlzdGFuY2VNYXRlcmlhbGAgKGZvciBwb2ludCBsaWdodHMpIHByb3BlcnRpZXMgdG9cbiAqIGFsbG93IHRoZSBjYXN0IHNoYWRvdyB0byBob25vciB5b3VyIGRlcml2ZWQgc2hhZGVyJ3MgdmVydGV4IHRyYW5zZm9ybXMgYW5kIGRpc2NhcmRlZCBmcmFnbWVudHMuIFRoZXNlXG4gKiB3aWxsIGFsc28gc2V0IGEgY3VzdG9tIGAjZGVmaW5lIElTX0RFUFRIX01BVEVSSUFMYCBvciBgI2RlZmluZSBJU19ESVNUQU5DRV9NQVRFUklBTGAgdGhhdCB5b3UgY2FuIGxvb2tcbiAqIGZvciBpbiB5b3VyIGRlcml2ZWQgc2hhZGVycyB3aXRoIGAjaWZkZWZgIHRvIGN1c3RvbWl6ZSB0aGVpciBiZWhhdmlvciBmb3IgdGhlIGRlcHRoIG9yIGRpc3RhbmNlXG4gKiBzY2VuYXJpb3MsIGUuZy4gc2tpcHBpbmcgYW50aWFsaWFzaW5nIG9yIGV4cGVuc2l2ZSBzaGFkZXIgbG9naWMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChiYXNlTWF0ZXJpYWwsIG9wdGlvbnMpIHtcbiAgLy8gR2VuZXJhdGUgYSBrZXkgdGhhdCBpcyB1bmlxdWUgdG8gdGhlIGNvbnRlbnQgb2YgdGhlc2UgYG9wdGlvbnNgLiBXZSdsbCB1c2UgdGhpc1xuICAvLyB0aHJvdWdob3V0IGZvciBjYWNoaW5nIGFuZCBmb3IgZ2VuZXJhdGluZyB0aGUgdXBncmFkZWQgc2hhZGVyIGNvZGUuIFRoaXMgaW5jcmVhc2VzXG4gIC8vIHRoZSBsaWtlbGlob29kIHRoYXQgdGhlIHJlc3VsdGluZyBzaGFkZXJzIHdpbGwgbGluZSB1cCBhY3Jvc3MgbXVsdGlwbGUgY2FsbHMgc29cbiAgLy8gdGhlaXIgR0wgcHJvZ3JhbXMgY2FuIGJlIHNoYXJlZCBhbmQgY2FjaGVkLlxuICBjb25zdCBvcHRpb25zS2V5ID0gZ2V0S2V5Rm9yT3B0aW9ucyhvcHRpb25zKTtcblxuICAvLyBGaXJzdCBjaGVjayB0byBzZWUgaWYgd2UndmUgYWxyZWFkeSBkZXJpdmVkIGZyb20gdGhpcyBiYXNlTWF0ZXJpYWwgdXNpbmcgdGhpc1xuICAvLyB1bmlxdWUgc2V0IG9mIG9wdGlvbnMsIGFuZCBpZiBzbyByZXVzZSB0aGUgY29uc3RydWN0b3IgdG8gYXZvaWQgc29tZSBhbGxvY2F0aW9ucy5cbiAgbGV0IGN0b3JzQnlEZXJpdmF0aW9uID0gQ09OU1RSVUNUT1JfQ0FDSEUuZ2V0KGJhc2VNYXRlcmlhbCk7XG4gIGlmICghY3RvcnNCeURlcml2YXRpb24pIHtcbiAgICBDT05TVFJVQ1RPUl9DQUNIRS5zZXQoYmFzZU1hdGVyaWFsLCAoY3RvcnNCeURlcml2YXRpb24gPSBPYmplY3QuY3JlYXRlKG51bGwpKSk7XG4gIH1cbiAgaWYgKGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldKSB7XG4gICAgcmV0dXJuIG5ldyBjdG9yc0J5RGVyaXZhdGlvbltvcHRpb25zS2V5XSgpXG4gIH1cblxuICBjb25zdCBwcml2YXRlQmVmb3JlQ29tcGlsZVByb3AgPSBgX29uQmVmb3JlQ29tcGlsZSR7b3B0aW9uc0tleX1gO1xuXG4gIC8vIFByaXZhdGUgb25CZWZvcmVDb21waWxlIGhhbmRsZXIgdGhhdCBpbmplY3RzIHRoZSBtb2RpZmllZCBzaGFkZXJzIGFuZCB1bmlmb3JtcyB3aGVuXG4gIC8vIHRoZSByZW5kZXJlciBzd2l0Y2hlcyB0byB0aGlzIG1hdGVyaWFsJ3MgcHJvZ3JhbVxuICBjb25zdCBvbkJlZm9yZUNvbXBpbGUgPSBmdW5jdGlvbiAoc2hhZGVySW5mbywgcmVuZGVyZXIpIHtcbiAgICBiYXNlTWF0ZXJpYWwub25CZWZvcmVDb21waWxlLmNhbGwodGhpcywgc2hhZGVySW5mbywgcmVuZGVyZXIpO1xuXG4gICAgLy8gVXBncmFkZSB0aGUgc2hhZGVycywgY2FjaGluZyB0aGUgcmVzdWx0IGJ5IGluY29taW5nIHNvdXJjZSBjb2RlXG4gICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgc2hhZGVySW5mby52ZXJ0ZXhTaGFkZXIgKyAnfCcgKyBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyO1xuICAgIGxldCB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV07XG4gICAgaWYgKCF1cGdyYWRlZFNoYWRlcnMpIHtcbiAgICAgIGNvbnN0IHVwZ3JhZGVkID0gdXBncmFkZVNoYWRlcnModGhpcywgc2hhZGVySW5mbywgb3B0aW9ucywgb3B0aW9uc0tleSk7XG4gICAgICB1cGdyYWRlZFNoYWRlcnMgPSBTSEFERVJfVVBHUkFERV9DQUNIRVtjYWNoZUtleV0gPSB1cGdyYWRlZDtcbiAgICB9XG5cbiAgICAvLyBJbmplY3QgdXBncmFkZWQgc2hhZGVycyBhbmQgdW5pZm9ybXMgaW50byB0aGUgcHJvZ3JhbVxuICAgIHNoYWRlckluZm8udmVydGV4U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLnZlcnRleFNoYWRlcjtcbiAgICBzaGFkZXJJbmZvLmZyYWdtZW50U2hhZGVyID0gdXBncmFkZWRTaGFkZXJzLmZyYWdtZW50U2hhZGVyO1xuICAgIGFzc2lnbihzaGFkZXJJbmZvLnVuaWZvcm1zLCB0aGlzLnVuaWZvcm1zKTtcblxuICAgIC8vIEluamVjdCBhdXRvLXVwZGF0aW5nIHRpbWUgdW5pZm9ybSBpZiByZXF1ZXN0ZWRcbiAgICBpZiAob3B0aW9ucy50aW1lVW5pZm9ybSkge1xuICAgICAgc2hhZGVySW5mby51bmlmb3Jtc1tvcHRpb25zLnRpbWVVbmlmb3JtXSA9IHtcbiAgICAgICAgZ2V0IHZhbHVlKCkge3JldHVybiBEYXRlLm5vdygpIC0gZXBvY2h9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFVzZXJzIGNhbiBzdGlsbCBhZGQgdGhlaXIgb3duIGhhbmRsZXJzIG9uIHRvcCBvZiBvdXJzXG4gICAgaWYgKHRoaXNbcHJpdmF0ZUJlZm9yZUNvbXBpbGVQcm9wXSkge1xuICAgICAgdGhpc1twcml2YXRlQmVmb3JlQ29tcGlsZVByb3BdKHNoYWRlckluZm8pO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCBEZXJpdmVkTWF0ZXJpYWwgPSBmdW5jdGlvbiBEZXJpdmVkTWF0ZXJpYWwoKSB7XG4gICAgcmV0dXJuIGRlcml2ZShvcHRpb25zLmNoYWluZWQgPyBiYXNlTWF0ZXJpYWwgOiBiYXNlTWF0ZXJpYWwuY2xvbmUoKSlcbiAgfTtcblxuICBjb25zdCBkZXJpdmUgPSBmdW5jdGlvbihiYXNlKSB7XG4gICAgLy8gUHJvdG90eXBlIGNoYWluIHRvIHRoZSBiYXNlIG1hdGVyaWFsXG4gICAgY29uc3QgZGVyaXZlZCA9IE9iamVjdC5jcmVhdGUoYmFzZSwgZGVzY3JpcHRvcik7XG5cbiAgICAvLyBTdG9yZSB0aGUgYmFzZU1hdGVyaWFsIGZvciByZWZlcmVuY2U7IHRoaXMgaXMgYWx3YXlzIHRoZSBvcmlnaW5hbCBldmVuIHdoZW4gY2xvbmluZ1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZXJpdmVkLCAnYmFzZU1hdGVyaWFsJywgeyB2YWx1ZTogYmFzZU1hdGVyaWFsIH0pO1xuXG4gICAgLy8gTmVlZHMgaXRzIG93biBpZHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVyaXZlZCwgJ2lkJywgeyB2YWx1ZTogbWF0ZXJpYWxJbnN0YW5jZUlkKysgfSk7XG4gICAgZGVyaXZlZC51dWlkID0gZ2VuZXJhdGVVVUlEKCk7XG5cbiAgICAvLyBNZXJnZSB1bmlmb3JtcywgZGVmaW5lcywgYW5kIGV4dGVuc2lvbnNcbiAgICBkZXJpdmVkLnVuaWZvcm1zID0gYXNzaWduKHt9LCBiYXNlLnVuaWZvcm1zLCBvcHRpb25zLnVuaWZvcm1zKTtcbiAgICBkZXJpdmVkLmRlZmluZXMgPSBhc3NpZ24oe30sIGJhc2UuZGVmaW5lcywgb3B0aW9ucy5kZWZpbmVzKTtcbiAgICBkZXJpdmVkLmRlZmluZXNbYFRST0lLQV9ERVJJVkVEX01BVEVSSUFMXyR7b3B0aW9uc0tleX1gXSA9ICcnOyAvL2ZvcmNlIGEgcHJvZ3JhbSBjaGFuZ2UgZnJvbSB0aGUgYmFzZSBtYXRlcmlhbFxuICAgIGRlcml2ZWQuZXh0ZW5zaW9ucyA9IGFzc2lnbih7fSwgYmFzZS5leHRlbnNpb25zLCBvcHRpb25zLmV4dGVuc2lvbnMpO1xuXG4gICAgLy8gRG9uJ3QgaW5oZXJpdCBFdmVudERpc3BhdGNoZXIgbGlzdGVuZXJzXG4gICAgZGVyaXZlZC5fbGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGRlcml2ZWRcbiAgfTtcblxuICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgIGNvbnN0cnVjdG9yOiB7dmFsdWU6IERlcml2ZWRNYXRlcmlhbH0sXG4gICAgaXNEZXJpdmVkTWF0ZXJpYWw6IHt2YWx1ZTogdHJ1ZX0sXG5cbiAgICB0eXBlOiB7XG4gICAgICBnZXQ6ICgpID0+IGJhc2VNYXRlcmlhbC50eXBlLFxuICAgICAgc2V0OiAodmFsdWUpID0+IHtiYXNlTWF0ZXJpYWwudHlwZSA9IHZhbHVlO31cbiAgICB9LFxuXG4gICAgaXNEZXJpdmVkRnJvbToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHRlc3RNYXRlcmlhbCkge1xuICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5iYXNlTWF0ZXJpYWw7XG4gICAgICAgIHJldHVybiB0ZXN0TWF0ZXJpYWwgPT09IGJhc2UgfHwgKGJhc2UuaXNEZXJpdmVkTWF0ZXJpYWwgJiYgYmFzZS5pc0Rlcml2ZWRGcm9tKHRlc3RNYXRlcmlhbCkpIHx8IGZhbHNlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGN1c3RvbVByb2dyYW1DYWNoZUtleToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYmFzZU1hdGVyaWFsLmN1c3RvbVByb2dyYW1DYWNoZUtleSgpICsgJ3wnICsgb3B0aW9uc0tleVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkJlZm9yZUNvbXBpbGU6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG9uQmVmb3JlQ29tcGlsZVxuICAgICAgfSxcbiAgICAgIHNldChmbikge1xuICAgICAgICB0aGlzW3ByaXZhdGVCZWZvcmVDb21waWxlUHJvcF0gPSBmbjtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29weToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwuY29weS5jYWxsKHRoaXMsIHNvdXJjZSk7XG4gICAgICAgIGlmICghYmFzZU1hdGVyaWFsLmlzU2hhZGVyTWF0ZXJpYWwgJiYgIWJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbCkge1xuICAgICAgICAgIGFzc2lnbih0aGlzLmV4dGVuc2lvbnMsIHNvdXJjZS5leHRlbnNpb25zKTtcbiAgICAgICAgICBhc3NpZ24odGhpcy5kZWZpbmVzLCBzb3VyY2UuZGVmaW5lcyk7XG4gICAgICAgICAgYXNzaWduKHRoaXMudW5pZm9ybXMsIFVuaWZvcm1zVXRpbHMuY2xvbmUoc291cmNlLnVuaWZvcm1zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xvbmU6IHtcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgbmV3QmFzZSA9IG5ldyBiYXNlTWF0ZXJpYWwuY29uc3RydWN0b3IoKTtcbiAgICAgICAgcmV0dXJuIGRlcml2ZShuZXdCYXNlKS5jb3B5KHRoaXMpXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERlcHRoTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREZXB0aE1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRlcHRoTWF0ZXJpYWwgPSB0aGlzLl9kZXB0aE1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRlcHRoTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsID0gdGhpcy5fZGVwdGhNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREZXB0aE1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERlcHRoTWF0ZXJpYWwoeyBkZXB0aFBhY2tpbmc6IFJHQkFEZXB0aFBhY2tpbmcgfSksXG4gICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLmRlZmluZXMuSVNfREVQVEhfTUFURVJJQUwgPSAnJztcbiAgICAgICAgICBkZXB0aE1hdGVyaWFsLnVuaWZvcm1zID0gdGhpcy51bmlmb3JtczsgLy9hdXRvbWF0aWNhbGx5IHJlY2lldmUgc2FtZSB1bmlmb3JtIHZhbHVlc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXB0aE1hdGVyaWFsXG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFV0aWxpdHkgdG8gZ2V0IGEgTWVzaERpc3RhbmNlTWF0ZXJpYWwgdGhhdCB3aWxsIGhvbm9yIHRoaXMgZGVyaXZlZCBtYXRlcmlhbCdzIHZlcnRleFxuICAgICAqIHRyYW5zZm9ybWF0aW9ucyBhbmQgZGlzY2FyZGVkIGZyYWdtZW50cy5cbiAgICAgKi9cbiAgICBnZXREaXN0YW5jZU1hdGVyaWFsOiB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgbGV0IGRpc3RhbmNlTWF0ZXJpYWwgPSB0aGlzLl9kaXN0YW5jZU1hdGVyaWFsO1xuICAgICAgICBpZiAoIWRpc3RhbmNlTWF0ZXJpYWwpIHtcbiAgICAgICAgICBkaXN0YW5jZU1hdGVyaWFsID0gdGhpcy5fZGlzdGFuY2VNYXRlcmlhbCA9IGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICAgICAgICAgIGJhc2VNYXRlcmlhbC5pc0Rlcml2ZWRNYXRlcmlhbFxuICAgICAgICAgICAgICA/IGJhc2VNYXRlcmlhbC5nZXREaXN0YW5jZU1hdGVyaWFsKClcbiAgICAgICAgICAgICAgOiBuZXcgTWVzaERpc3RhbmNlTWF0ZXJpYWwoKSxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICApO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwuZGVmaW5lcy5JU19ESVNUQU5DRV9NQVRFUklBTCA9ICcnO1xuICAgICAgICAgIGRpc3RhbmNlTWF0ZXJpYWwudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zOyAvL2F1dG9tYXRpY2FsbHkgcmVjaWV2ZSBzYW1lIHVuaWZvcm0gdmFsdWVzXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlTWF0ZXJpYWxcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcG9zZToge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB2YWx1ZSgpIHtcbiAgICAgICAgY29uc3Qge19kZXB0aE1hdGVyaWFsLCBfZGlzdGFuY2VNYXRlcmlhbH0gPSB0aGlzO1xuICAgICAgICBpZiAoX2RlcHRoTWF0ZXJpYWwpIF9kZXB0aE1hdGVyaWFsLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKF9kaXN0YW5jZU1hdGVyaWFsKSBfZGlzdGFuY2VNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICAgIGJhc2VNYXRlcmlhbC5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGN0b3JzQnlEZXJpdmF0aW9uW29wdGlvbnNLZXldID0gRGVyaXZlZE1hdGVyaWFsO1xuICByZXR1cm4gbmV3IERlcml2ZWRNYXRlcmlhbCgpXG59XG5cblxuZnVuY3Rpb24gdXBncmFkZVNoYWRlcnMobWF0ZXJpYWwsIHt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyfSwgb3B0aW9ucywga2V5KSB7XG4gIGxldCB7XG4gICAgdmVydGV4RGVmcyxcbiAgICB2ZXJ0ZXhNYWluSW50cm8sXG4gICAgdmVydGV4TWFpbk91dHJvLFxuICAgIHZlcnRleFRyYW5zZm9ybSxcbiAgICBmcmFnbWVudERlZnMsXG4gICAgZnJhZ21lbnRNYWluSW50cm8sXG4gICAgZnJhZ21lbnRNYWluT3V0cm8sXG4gICAgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSxcbiAgICBjdXN0b21SZXdyaXRlcixcbiAgICB0aW1lVW5pZm9ybVxuICB9ID0gb3B0aW9ucztcblxuICB2ZXJ0ZXhEZWZzID0gdmVydGV4RGVmcyB8fCAnJztcbiAgdmVydGV4TWFpbkludHJvID0gdmVydGV4TWFpbkludHJvIHx8ICcnO1xuICB2ZXJ0ZXhNYWluT3V0cm8gPSB2ZXJ0ZXhNYWluT3V0cm8gfHwgJyc7XG4gIGZyYWdtZW50RGVmcyA9IGZyYWdtZW50RGVmcyB8fCAnJztcbiAgZnJhZ21lbnRNYWluSW50cm8gPSBmcmFnbWVudE1haW5JbnRybyB8fCAnJztcbiAgZnJhZ21lbnRNYWluT3V0cm8gPSBmcmFnbWVudE1haW5PdXRybyB8fCAnJztcblxuICAvLyBFeHBhbmQgaW5jbHVkZXMgaWYgbmVlZGVkXG4gIGlmICh2ZXJ0ZXhUcmFuc2Zvcm0gfHwgY3VzdG9tUmV3cml0ZXIpIHtcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBleHBhbmRTaGFkZXJJbmNsdWRlcyh2ZXJ0ZXhTaGFkZXIpO1xuICB9XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtIHx8IGN1c3RvbVJld3JpdGVyKSB7XG4gICAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIGZpbmQgcG9zdHByb2Nlc3NpbmcgY2h1bmtzIGFmdGVyIGluY2x1ZGUgZXhwYW5zaW9uIGluIG9yZGVyIHRvXG4gICAgLy8gcHV0IHRoZW0gYWZ0ZXIgdGhlIGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0sIHNvIG1hcmsgdGhlbSB3aXRoIGNvbW1lbnRzIGZpcnN0LiBFdmVuIGlmXG4gICAgLy8gdGhpcyBwYXJ0aWN1bGFyIGRlcml2YXRpb24gZG9lc24ndCBoYXZlIGEgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSwgb3RoZXIgZGVyaXZhdGlvbnMgbWF5LFxuICAgIC8vIHNvIHdlIHN0aWxsIG1hcmsgdGhlbS5cbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlsgXFx0XSojaW5jbHVkZSA8KCg/OnRvbmVtYXBwaW5nfGVuY29kaW5nc3xjb2xvcnNwYWNlfGZvZ3xwcmVtdWx0aXBsaWVkX2FscGhhfGRpdGhlcmluZylfZnJhZ21lbnQpPi9nbSxcbiAgICAgICdcXG4vLyFCRUdJTl9QT1NUX0NIVU5LICQxXFxuJCZcXG4vLyFFTkRfUE9TVF9DSFVOS1xcbidcbiAgICApO1xuICAgIGZyYWdtZW50U2hhZGVyID0gZXhwYW5kU2hhZGVySW5jbHVkZXMoZnJhZ21lbnRTaGFkZXIpO1xuICB9XG5cbiAgLy8gQXBwbHkgY3VzdG9tIHJld3JpdGVyIGZ1bmN0aW9uXG4gIGlmIChjdXN0b21SZXdyaXRlcikge1xuICAgIGxldCByZXMgPSBjdXN0b21SZXdyaXRlcih7dmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcn0pO1xuICAgIHZlcnRleFNoYWRlciA9IHJlcy52ZXJ0ZXhTaGFkZXI7XG4gICAgZnJhZ21lbnRTaGFkZXIgPSByZXMuZnJhZ21lbnRTaGFkZXI7XG4gIH1cblxuICAvLyBUaGUgZnJhZ21lbnRDb2xvclRyYW5zZm9ybSBuZWVkcyB0byBnbyBiZWZvcmUgYW55IHBvc3Rwcm9jZXNzaW5nIGNodW5rcywgc28gZXh0cmFjdFxuICAvLyB0aG9zZSBhbmQgcmUtaW5zZXJ0IHRoZW0gaW50byB0aGUgb3V0cm8gaW4gdGhlIGNvcnJlY3QgcGxhY2U6XG4gIGlmIChmcmFnbWVudENvbG9yVHJhbnNmb3JtKSB7XG4gICAgbGV0IHBvc3RDaHVua3MgPSBbXTtcbiAgICBmcmFnbWVudFNoYWRlciA9IGZyYWdtZW50U2hhZGVyLnJlcGxhY2UoXG4gICAgICAvXlxcL1xcLyFCRUdJTl9QT1NUX0NIVU5LW15dKz9eXFwvXFwvIUVORF9QT1NUX0NIVU5LL2dtLCAvLyBbXl0rPyA9IG5vbi1ncmVlZHkgbWF0Y2ggb2YgYW55IGNoYXJzIGluY2x1ZGluZyBuZXdsaW5lc1xuICAgICAgbWF0Y2ggPT4ge1xuICAgICAgICBwb3N0Q2h1bmtzLnB1c2gobWF0Y2gpO1xuICAgICAgICByZXR1cm4gJydcbiAgICAgIH1cbiAgICApO1xuICAgIGZyYWdtZW50TWFpbk91dHJvID0gYCR7ZnJhZ21lbnRDb2xvclRyYW5zZm9ybX1cXG4ke3Bvc3RDaHVua3Muam9pbignXFxuJyl9XFxuJHtmcmFnbWVudE1haW5PdXRyb31gO1xuICB9XG5cbiAgLy8gSW5qZWN0IGF1dG8tdXBkYXRpbmcgdGltZSB1bmlmb3JtIGlmIHJlcXVlc3RlZFxuICBpZiAodGltZVVuaWZvcm0pIHtcbiAgICBjb25zdCBjb2RlID0gYFxcbnVuaWZvcm0gZmxvYXQgJHt0aW1lVW5pZm9ybX07XFxuYDtcbiAgICB2ZXJ0ZXhEZWZzID0gY29kZSArIHZlcnRleERlZnM7XG4gICAgZnJhZ21lbnREZWZzID0gY29kZSArIGZyYWdtZW50RGVmcztcbiAgfVxuXG4gIC8vIEluamVjdCBhIGZ1bmN0aW9uIGZvciB0aGUgdmVydGV4VHJhbnNmb3JtIGFuZCByZW5hbWUgYWxsIHVzYWdlcyBvZiBwb3NpdGlvbi9ub3JtYWwvdXZcbiAgaWYgKHZlcnRleFRyYW5zZm9ybSkge1xuICAgIC8vIEhvaXN0IHRoZXNlIGRlZnMgdG8gdGhlIHZlcnkgdG9wIHNvIHRoZXkgd29yayBpbiBvdGhlciBmdW5jdGlvbiBkZWZzXG4gICAgdmVydGV4U2hhZGVyID0gYHZlYzMgdHJvaWthX3Bvc2l0aW9uXyR7a2V5fTtcbnZlYzMgdHJvaWthX25vcm1hbF8ke2tleX07XG52ZWMyIHRyb2lrYV91dl8ke2tleX07XG4ke3ZlcnRleFNoYWRlcn1cbmA7XG4gICAgdmVydGV4RGVmcyA9IGAke3ZlcnRleERlZnN9XG52b2lkIHRyb2lrYVZlcnRleFRyYW5zZm9ybSR7a2V5fShpbm91dCB2ZWMzIHBvc2l0aW9uLCBpbm91dCB2ZWMzIG5vcm1hbCwgaW5vdXQgdmVjMiB1dikge1xuICAke3ZlcnRleFRyYW5zZm9ybX1cbn1cbmA7XG4gICAgdmVydGV4TWFpbkludHJvID0gYFxudHJvaWthX3Bvc2l0aW9uXyR7a2V5fSA9IHZlYzMocG9zaXRpb24pO1xudHJvaWthX25vcm1hbF8ke2tleX0gPSB2ZWMzKG5vcm1hbCk7XG50cm9pa2FfdXZfJHtrZXl9ID0gdmVjMih1dik7XG50cm9pa2FWZXJ0ZXhUcmFuc2Zvcm0ke2tleX0odHJvaWthX3Bvc2l0aW9uXyR7a2V5fSwgdHJvaWthX25vcm1hbF8ke2tleX0sIHRyb2lrYV91dl8ke2tleX0pO1xuJHt2ZXJ0ZXhNYWluSW50cm99XG5gO1xuICAgIHZlcnRleFNoYWRlciA9IHZlcnRleFNoYWRlci5yZXBsYWNlKC9cXGIocG9zaXRpb258bm9ybWFsfHV2KVxcYi9nLCAobWF0Y2gsIG1hdGNoMSwgaW5kZXgsIGZ1bGxTdHIpID0+IHtcbiAgICAgIHJldHVybiAvXFxiYXR0cmlidXRlXFxzK3ZlY1syM11cXHMrJC8udGVzdChmdWxsU3RyLnN1YnN0cigwLCBpbmRleCkpID8gbWF0Y2gxIDogYHRyb2lrYV8ke21hdGNoMX1fJHtrZXl9YFxuICAgIH0pO1xuXG4gICAgLy8gVGhyZWUgcjE1MiBpbnRyb2R1Y2VkIHRoZSBNQVBfVVYgdG9rZW4sIHJlcGxhY2UgaXQgdG9vIGlmIGl0J3MgcG9pbnRpbmcgdG8gdGhlIG1haW4gJ3V2J1xuICAgIC8vIFBlcmhhcHMgdGhlIG90aGVyIHRleHR1cmVzIHRvbyBnb2luZyBmb3J3YXJkP1xuICAgIGlmICghKG1hdGVyaWFsLm1hcCAmJiBtYXRlcmlhbC5tYXAuY2hhbm5lbCA+IDApKSB7XG4gICAgICB2ZXJ0ZXhTaGFkZXIgPSB2ZXJ0ZXhTaGFkZXIucmVwbGFjZSgvXFxiTUFQX1VWXFxiL2csIGB0cm9pa2FfdXZfJHtrZXl9YCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW5qZWN0IGRlZnMgYW5kIGludHJvL291dHJvIHNuaXBwZXRzXG4gIHZlcnRleFNoYWRlciA9IGluamVjdEludG9TaGFkZXJDb2RlKHZlcnRleFNoYWRlciwga2V5LCB2ZXJ0ZXhEZWZzLCB2ZXJ0ZXhNYWluSW50cm8sIHZlcnRleE1haW5PdXRybyk7XG4gIGZyYWdtZW50U2hhZGVyID0gaW5qZWN0SW50b1NoYWRlckNvZGUoZnJhZ21lbnRTaGFkZXIsIGtleSwgZnJhZ21lbnREZWZzLCBmcmFnbWVudE1haW5JbnRybywgZnJhZ21lbnRNYWluT3V0cm8pO1xuXG4gIHJldHVybiB7XG4gICAgdmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyXG4gIH1cbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b1NoYWRlckNvZGUoc2hhZGVyQ29kZSwgaWQsIGRlZnMsIGludHJvLCBvdXRybykge1xuICBpZiAoaW50cm8gfHwgb3V0cm8gfHwgZGVmcykge1xuICAgIHNoYWRlckNvZGUgPSBzaGFkZXJDb2RlLnJlcGxhY2Uodm9pZE1haW5SZWdFeHAsIGBcbiR7ZGVmc31cbnZvaWQgdHJvaWthT3JpZ01haW4ke2lkfSgpIHtgXG4gICAgKTtcbiAgICBzaGFkZXJDb2RlICs9IGBcbnZvaWQgbWFpbigpIHtcbiAgJHtpbnRyb31cbiAgdHJvaWthT3JpZ01haW4ke2lkfSgpO1xuICAke291dHJvfVxufWA7XG4gIH1cbiAgcmV0dXJuIHNoYWRlckNvZGVcbn1cblxuXG5mdW5jdGlvbiBvcHRpb25zSnNvblJlcGxhY2VyKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGtleSA9PT0gJ3VuaWZvcm1zJyA/IHVuZGVmaW5lZCA6IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnRvU3RyaW5nKCkgOiB2YWx1ZVxufVxuXG5sZXQgX2lkQ3RyID0gMDtcbmNvbnN0IG9wdGlvbnNIYXNoZXNUb0lkcyA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldEtleUZvck9wdGlvbnMob3B0aW9ucykge1xuICBjb25zdCBvcHRpb25zSGFzaCA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMsIG9wdGlvbnNKc29uUmVwbGFjZXIpO1xuICBsZXQgaWQgPSBvcHRpb25zSGFzaGVzVG9JZHMuZ2V0KG9wdGlvbnNIYXNoKTtcbiAgaWYgKGlkID09IG51bGwpIHtcbiAgICBvcHRpb25zSGFzaGVzVG9JZHMuc2V0KG9wdGlvbnNIYXNoLCAoaWQgPSArK19pZEN0cikpO1xuICB9XG4gIHJldHVybiBpZFxufVxuXG4vLyBDb3BpZWQgZnJvbSB0aHJlZWpzIFdlYkdMUHJvZ3JhbXMuanMgc28gd2UgY2FuIHJlc29sdmUgYnVpbHRpbiBtYXRlcmlhbHMgdG8gdGhlaXIgc2hhZGVyc1xuLy8gVE9ETyBob3cgY2FuIHdlIGtlZXAgdGhpcyBmcm9tIGdldHRpbmcgc3RhbGU/XG5jb25zdCBNQVRFUklBTF9UWVBFU19UT19TSEFERVJTID0ge1xuICBNZXNoRGVwdGhNYXRlcmlhbDogJ2RlcHRoJyxcbiAgTWVzaERpc3RhbmNlTWF0ZXJpYWw6ICdkaXN0YW5jZVJHQkEnLFxuICBNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxuICBNZXNoQmFzaWNNYXRlcmlhbDogJ2Jhc2ljJyxcbiAgTWVzaExhbWJlcnRNYXRlcmlhbDogJ2xhbWJlcnQnLFxuICBNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcbiAgTWVzaFRvb25NYXRlcmlhbDogJ3Rvb24nLFxuICBNZXNoU3RhbmRhcmRNYXRlcmlhbDogJ3BoeXNpY2FsJyxcbiAgTWVzaFBoeXNpY2FsTWF0ZXJpYWw6ICdwaHlzaWNhbCcsXG4gIE1lc2hNYXRjYXBNYXRlcmlhbDogJ21hdGNhcCcsXG4gIExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxuICBMaW5lRGFzaGVkTWF0ZXJpYWw6ICdkYXNoZWQnLFxuICBQb2ludHNNYXRlcmlhbDogJ3BvaW50cycsXG4gIFNoYWRvd01hdGVyaWFsOiAnc2hhZG93JyxcbiAgU3ByaXRlTWF0ZXJpYWw6ICdzcHJpdGUnXG59O1xuXG4vKipcbiAqIEdpdmVuIGEgVGhyZWUuanMgYE1hdGVyaWFsYCBpbnN0YW5jZSwgZmluZCB0aGUgc2hhZGVycy91bmlmb3JtcyB0aGF0IHdpbGwgYmVcbiAqIHVzZWQgdG8gcmVuZGVyIHRoYXQgbWF0ZXJpYWwuXG4gKlxuICogQHBhcmFtIG1hdGVyaWFsIC0gdGhlIE1hdGVyaWFsIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gdGhlIG1hdGVyaWFsJ3Mgc2hhZGVyIGluZm86IGB7dW5pZm9ybXM6e30sIGZyYWdtZW50U2hhZGVyOicnLCB2ZXJ0ZXhTaGFkZXI6Jyd9YFxuICovXG5mdW5jdGlvbiBnZXRTaGFkZXJzRm9yTWF0ZXJpYWwobWF0ZXJpYWwpIHtcbiAgbGV0IGJ1aWx0aW5UeXBlID0gTUFURVJJQUxfVFlQRVNfVE9fU0hBREVSU1ttYXRlcmlhbC50eXBlXTtcbiAgcmV0dXJuIGJ1aWx0aW5UeXBlID8gU2hhZGVyTGliW2J1aWx0aW5UeXBlXSA6IG1hdGVyaWFsIC8vVE9ETyBmYWxsYmFjayBmb3IgdW5rbm93biB0eXBlP1xufVxuXG4vKipcbiAqIEZpbmQgYWxsIHVuaWZvcm1zIGFuZCB0aGVpciB0eXBlcyB3aXRoaW4gYSBzaGFkZXIgY29kZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNoYWRlciAtIFRoZSBzaGFkZXIgY29kZSB0byBwYXJzZVxuICogQHJldHVybiB7b2JqZWN0fSBtYXBwaW5nIG9mIHVuaWZvcm0gbmFtZXMgdG8gdGhlaXIgZ2xzbCB0eXBlXG4gKi9cbmZ1bmN0aW9uIGdldFNoYWRlclVuaWZvcm1UeXBlcyhzaGFkZXIpIHtcbiAgbGV0IHVuaWZvcm1SRSA9IC9cXGJ1bmlmb3JtXFxzKyhpbnR8ZmxvYXR8dmVjWzIzNF18bWF0WzM0XSlcXHMrKFtBLVphLXpfXVtcXHddKikvZztcbiAgbGV0IHVuaWZvcm1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IG1hdGNoO1xuICB3aGlsZSAoKG1hdGNoID0gdW5pZm9ybVJFLmV4ZWMoc2hhZGVyKSkgIT09IG51bGwpIHtcbiAgICB1bmlmb3Jtc1ttYXRjaFsyXV0gPSBtYXRjaFsxXTtcbiAgfVxuICByZXR1cm4gdW5pZm9ybXNcbn1cblxuLyoqXG4gKiBIZWxwZXIgZm9yIHNtb290aGluZyBvdXQgdGhlIGBtLmdldEludmVyc2UoeClgIC0tPiBgbS5jb3B5KHgpLmludmVydCgpYCBjb252ZXJzaW9uXG4gKiB0aGF0IGhhcHBlbmVkIGluIFRocmVlSlMgcjEyMy5cbiAqIEBwYXJhbSB7TWF0cml4NH0gc3JjTWF0cml4XG4gKiBAcGFyYW0ge01hdHJpeDR9IFt0Z3RNYXRyaXhdXG4gKi9cbmZ1bmN0aW9uIGludmVydE1hdHJpeDQoc3JjTWF0cml4LCB0Z3RNYXRyaXggPSBuZXcgTWF0cml4NCgpKSB7XG4gIGlmICh0eXBlb2YgdGd0TWF0cml4LmludmVydCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRndE1hdHJpeC5jb3B5KHNyY01hdHJpeCkuaW52ZXJ0KCk7XG4gIH0gZWxzZSB7XG4gICAgdGd0TWF0cml4LmdldEludmVyc2Uoc3JjTWF0cml4KTtcbiAgfVxuICByZXR1cm4gdGd0TWF0cml4XG59XG5cbi8qXG5JbnB1dCBnZW9tZXRyeSBpcyBhIGN5bGluZGVyIHdpdGggcj0xLCBoZWlnaHQgaW4geSBkaW1lbnNpb24gZnJvbSAwIHRvIDEsXG5kaXZpZGVkIGludG8gYSByZWFzb25hYmxlIG51bWJlciBvZiBoZWlnaHQgc2VnbWVudHMuXG4qL1xuXG5jb25zdCB2ZXJ0ZXhEZWZzID0gYFxudW5pZm9ybSB2ZWMzIHBvaW50QTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQTtcbnVuaWZvcm0gdmVjMyBjb250cm9sQjtcbnVuaWZvcm0gdmVjMyBwb2ludEI7XG51bmlmb3JtIGZsb2F0IHJhZGl1cztcbnZhcnlpbmcgZmxvYXQgYmV6aWVyVDtcblxudmVjMyBjdWJpY0Jlemllcih2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgZmxvYXQgYjAgPSB0MiAqIHQyICogdDI7XG4gIGZsb2F0IGIxID0gMy4wICogdCAqIHQyICogdDI7XG4gIGZsb2F0IGIyID0gMy4wICogdCAqIHQgKiB0MjtcbiAgZmxvYXQgYjMgPSB0ICogdCAqIHQ7XG4gIHJldHVybiBiMCAqIHAxICsgYjEgKiBjMSArIGIyICogYzIgKyBiMyAqIHAyO1xufVxuXG52ZWMzIGN1YmljQmV6aWVyRGVyaXZhdGl2ZSh2ZWMzIHAxLCB2ZWMzIGMxLCB2ZWMzIGMyLCB2ZWMzIHAyLCBmbG9hdCB0KSB7XG4gIGZsb2F0IHQyID0gMS4wIC0gdDtcbiAgcmV0dXJuIC0zLjAgKiBwMSAqIHQyICogdDIgK1xuICAgIGMxICogKDMuMCAqIHQyICogdDIgLSA2LjAgKiB0MiAqIHQpICtcbiAgICBjMiAqICg2LjAgKiB0MiAqIHQgLSAzLjAgKiB0ICogdCkgK1xuICAgIDMuMCAqIHAyICogdCAqIHQ7XG59XG5gO1xuXG5jb25zdCB2ZXJ0ZXhUcmFuc2Zvcm0gPSBgXG5mbG9hdCB0ID0gcG9zaXRpb24ueTtcbmJlemllclQgPSB0O1xudmVjMyBiZXppZXJDZW50ZXJQb3MgPSBjdWJpY0Jlemllcihwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KTtcbnZlYzMgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0KSk7XG5cbi8vIE1ha2UgXCJzaWRld2F5c1wiIGFsd2F5cyBwZXJwZW5kaWN1bGFyIHRvIHRoZSBjYW1lcmEgcmF5OyB0aGlzIGVuc3VyZXMgdGhhdCBhbnkgdHdpc3RzXG4vLyBpbiB0aGUgY3lsaW5kZXIgb2NjdXIgd2hlcmUgeW91IHdvbid0IHNlZSB0aGVtOiBcbnZlYzMgdmlld0RpcmVjdGlvbiA9IG5vcm1hbE1hdHJpeCAqIHZlYzMoMC4wLCAwLjAsIDEuMCk7XG5pZiAoYmV6aWVyRGlyID09IHZpZXdEaXJlY3Rpb24pIHtcbiAgYmV6aWVyRGlyID0gbm9ybWFsaXplKGN1YmljQmV6aWVyRGVyaXZhdGl2ZShwb2ludEEsIGNvbnRyb2xBLCBjb250cm9sQiwgcG9pbnRCLCB0ID09IDEuMCA/IHQgLSAwLjAwMDEgOiB0ICsgMC4wMDAxKSk7XG59XG52ZWMzIHNpZGV3YXlzID0gbm9ybWFsaXplKGNyb3NzKGJlemllckRpciwgdmlld0RpcmVjdGlvbikpO1xudmVjMyB1cGlzaCA9IG5vcm1hbGl6ZShjcm9zcyhzaWRld2F5cywgYmV6aWVyRGlyKSk7XG5cbi8vIEJ1aWxkIGEgbWF0cml4IGZvciB0cmFuc2Zvcm1pbmcgdGhpcyBkaXNjIGluIHRoZSBjeWxpbmRlcjpcbm1hdDQgZGlzY1R4O1xuZGlzY1R4WzBdLnh5eiA9IHNpZGV3YXlzICogcmFkaXVzO1xuZGlzY1R4WzFdLnh5eiA9IGJlemllckRpciAqIHJhZGl1cztcbmRpc2NUeFsyXS54eXogPSB1cGlzaCAqIHJhZGl1cztcbmRpc2NUeFszXS54eXogPSBiZXppZXJDZW50ZXJQb3M7XG5kaXNjVHhbM11bM10gPSAxLjA7XG5cbi8vIEFwcGx5IHRyYW5zZm9ybSwgaWdub3Jpbmcgb3JpZ2luYWwgeVxucG9zaXRpb24gPSAoZGlzY1R4ICogdmVjNChwb3NpdGlvbi54LCAwLjAsIHBvc2l0aW9uLnosIDEuMCkpLnh5ejtcbm5vcm1hbCA9IG5vcm1hbGl6ZShtYXQzKGRpc2NUeCkgKiBub3JtYWwpO1xuYDtcblxuY29uc3QgZnJhZ21lbnREZWZzID0gYFxudW5pZm9ybSB2ZWMzIGRhc2hpbmc7XG52YXJ5aW5nIGZsb2F0IGJlemllclQ7XG5gO1xuXG5jb25zdCBmcmFnbWVudE1haW5JbnRybyA9IGBcbmlmIChkYXNoaW5nLnggKyBkYXNoaW5nLnkgPiAwLjApIHtcbiAgZmxvYXQgZGFzaEZyYWMgPSBtb2QoYmV6aWVyVCAtIGRhc2hpbmcueiwgZGFzaGluZy54ICsgZGFzaGluZy55KTtcbiAgaWYgKGRhc2hGcmFjID4gZGFzaGluZy54KSB7XG4gICAgZGlzY2FyZDtcbiAgfVxufVxuYDtcblxuLy8gRGVidWdnaW5nOiBzZXBhcmF0ZSBjb2xvciBmb3IgZWFjaCBvZiB0aGUgNiBzaWRlczpcbi8vIGNvbnN0IGZyYWdtZW50Q29sb3JUcmFuc2Zvcm0gPSBgXG4vLyBmbG9hdCBzaWRlTnVtID0gZmxvb3IodlVWLnggKiA2LjApO1xuLy8gdmVjMyBtaXhDb2xvciA9IHNpZGVOdW0gPCAxLjAgPyB2ZWMzKDEuMCwgMC4wLCAwLjApIDpcbi8vICAgc2lkZU51bSA8IDIuMCA/IHZlYzMoMC4wLCAxLjAsIDEuMCkgOlxuLy8gICBzaWRlTnVtIDwgMy4wID8gdmVjMygxLjAsIDEuMCwgMC4wKSA6XG4vLyAgIHNpZGVOdW0gPCA0LjAgPyB2ZWMzKDAuMCwgMC4wLCAxLjApIDpcbi8vICAgc2lkZU51bSA8IDUuMCA/IHZlYzMoMC4wLCAxLjAsIDAuMCkgOlxuLy8gICB2ZWMzKDEuMCwgMC4wLCAxLjApO1xuLy8gZ2xfRnJhZ0NvbG9yLnh5eiA9IG1peChnbF9GcmFnQ29sb3IueHl6LCBtaXhDb2xvciwgMC41KTtcbi8vIGBcblxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUJlemllck1lc2hNYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgcmV0dXJuIGNyZWF0ZURlcml2ZWRNYXRlcmlhbChcbiAgICBiYXNlTWF0ZXJpYWwsXG4gICAge1xuICAgICAgY2hhaW5lZDogdHJ1ZSxcbiAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgIHBvaW50QToge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSxcbiAgICAgICAgY29udHJvbEE6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIGNvbnRyb2xCOiB7dmFsdWU6IG5ldyBWZWN0b3IzKCl9LFxuICAgICAgICBwb2ludEI6IHt2YWx1ZTogbmV3IFZlY3RvcjMoKX0sXG4gICAgICAgIHJhZGl1czoge3ZhbHVlOiAwLjAxfSxcbiAgICAgICAgZGFzaGluZzoge3ZhbHVlOiBuZXcgVmVjdG9yMygpfSAvL29uLCBvZmYsIG9mZnNldFxuICAgICAgfSxcbiAgICAgIHZlcnRleERlZnMsXG4gICAgICB2ZXJ0ZXhUcmFuc2Zvcm0sXG4gICAgICBmcmFnbWVudERlZnMsXG4gICAgICBmcmFnbWVudE1haW5JbnRyb1xuICAgIH1cbiAgKVxufVxuXG5sZXQgZ2VvbWV0cnkgPSBudWxsO1xuXG5jb25zdCBkZWZhdWx0QmFzZU1hdGVyaWFsID0gLyojX19QVVJFX18qL25ldyBNZXNoU3RhbmRhcmRNYXRlcmlhbCh7Y29sb3I6IDB4ZmZmZmZmLCBzaWRlOiBEb3VibGVTaWRlfSk7XG5cblxuLyoqXG4gKiBBIFRocmVlSlMgYE1lc2hgIHRoYXQgYmVuZHMgYSB0dWJlIHNoYXBlIGFsb25nIGEgM0QgY3ViaWMgYmV6aWVyIHBhdGguIFRoZSBiZW5kaW5nIGlzIGRvbmVcbiAqIGJ5IGRlZm9ybWluZyBhIHN0cmFpZ2h0IGN5bGluZHJpY2FsIGdlb21ldHJ5IGluIHRoZSB2ZXJ0ZXggc2hhZGVyIGJhc2VkIG9uIGEgc2V0IG9mIGZvdXJcbiAqIGNvbnRyb2wgcG9pbnQgdW5pZm9ybXMuIEl0IHBhdGNoZXMgdGhlIG5lY2Vzc2FyeSBHTFNMIGludG8gdGhlIG1lc2gncyBhc3NpZ25lZCBgbWF0ZXJpYWxgXG4gKiBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFRoZSBjdWJpeiBiZXppZXIgcGF0aCBpcyBkZXRlcm1pbmVkIGJ5IGl0cyBmb3VyIGBWZWN0b3IzYCBwcm9wZXJ0aWVzOlxuICogLSBgcG9pbnRBYFxuICogLSBgY29udHJvbEFgXG4gKiAtIGBjb250cm9sQmBcbiAqIC0gYHBvaW50QmBcbiAqXG4gKiBUaGUgdHViZSdzIHJhZGl1cyBpcyBjb250cm9sbGVkIGJ5IGl0cyBgcmFkaXVzYCBwcm9wZXJ0eSwgd2hpY2ggZGVmYXVsdHMgdG8gYDAuMDFgLlxuICpcbiAqIFlvdSBjYW4gYWxzbyBnaXZlIHRoZSB0dWJlIGEgZGFzaGVkIGFwcGVhcmFuY2Ugd2l0aCB0d28gcHJvcGVydGllczpcbiAqXG4gKiAtIGBkYXNoQXJyYXlgIC0gYW4gYXJyYXkgb2YgdHdvIG51bWJlcnMsIGRlZmluaW5nIHRoZSBsZW5ndGggb2YgXCJvblwiIGFuZCBcIm9mZlwiIHBhcnRzIG9mXG4gKiAgIHRoZSBkYXNoLiBFYWNoIGlzIGEgMC0xIHJhdGlvIG9mIHRoZSBlbnRpcmUgcGF0aCdzIGxlbmd0aC4gKEFjdHVhbGx5IHRoaXMgaXMgdGhlIGB0YCBsZW5ndGhcbiAqICAgdXNlZCBhcyBpbnB1dCB0byB0aGUgY3ViaWMgYmV6aWVyIGZ1bmN0aW9uLCBub3QgaXRzIHZpc2libGUgbGVuZ3RoLilcbiAqIC0gYGRhc2hPZmZzZXRgIC0gb2Zmc2V0IG9mIHdoZXJlIHRoZSBkYXNoIHN0YXJ0cy4gWW91IGNhbiBhbmltYXRlIHRoaXMgdG8gbWFrZSB0aGUgZGFzaGVzIG1vdmUuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBkYXNoZXMgd2lsbCBhcHBlYXIgbGlrZSBhIGhvbGxvdyB0dWJlLCBub3Qgc29saWQuIFRoaXMgd2lsbCBiZSBtb3JlIGFwcGFyZW50IG9uXG4gKiB0aGlja2VyIHR1YmVzLlxuICpcbiAqIFRPRE86IHByb3BlciBnZW9tZXRyeSBib3VuZGluZyBzcGhlcmUgYW5kIHJheWNhc3RpbmdcbiAqIFRPRE86IGFsbG93IGNvbnRyb2wgb2YgdGhlIGdlb21ldHJ5J3Mgc2VnbWVudCBjb3VudHNcbiAqL1xuY2xhc3MgQmV6aWVyTWVzaCBleHRlbmRzIE1lc2gge1xuICBzdGF0aWMgZ2V0R2VvbWV0cnkoKSB7XG4gICAgcmV0dXJuIGdlb21ldHJ5IHx8IChnZW9tZXRyeSA9XG4gICAgICBuZXcgQ3lsaW5kZXJHZW9tZXRyeSgxLCAxLCAxLCA2LCA2NCkudHJhbnNsYXRlKDAsIDAuNSwgMClcbiAgICApXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcbiAgICAgIEJlemllck1lc2guZ2V0R2VvbWV0cnkoKSxcbiAgICAgIGRlZmF1bHRCYXNlTWF0ZXJpYWxcbiAgICApO1xuXG4gICAgdGhpcy5wb2ludEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEEgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMuY29udHJvbEIgPSBuZXcgVmVjdG9yMygpO1xuICAgIHRoaXMucG9pbnRCID0gbmV3IFZlY3RvcjMoKTtcbiAgICB0aGlzLnJhZGl1cyA9IDAuMDE7XG4gICAgdGhpcy5kYXNoQXJyYXkgPSBuZXcgVmVjdG9yMigpO1xuICAgIHRoaXMuZGFzaE9mZnNldCA9IDA7XG5cbiAgICAvLyBUT0RPIC0gZGlzYWJsaW5nIGZydXN0dW0gY3VsbGluZyB1bnRpbCBJIGZpZ3VyZSBvdXQgaG93IHRvIGN1c3RvbWl6ZSB0aGVcbiAgICAvLyAgZ2VvbWV0cnkncyBib3VuZGluZyBzcGhlcmUgdGhhdCBnZXRzIHVzZWRcbiAgICB0aGlzLmZydXN0dW1DdWxsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEhhbmRsZXIgZm9yIGF1dG9tYXRpY2FsbHkgd3JhcHBpbmcgdGhlIGJhc2UgbWF0ZXJpYWwgd2l0aCBvdXIgdXBncmFkZXMuIFdlIGRvIHRoZSB3cmFwcGluZ1xuICAvLyBsYXppbHkgb24gX3JlYWRfIHJhdGhlciB0aGFuIHdyaXRlIHRvIGF2b2lkIHVubmVjZXNzYXJ5IHdyYXBwaW5nIG9uIHRyYW5zaWVudCB2YWx1ZXMuXG4gIGdldCBtYXRlcmlhbCgpIHtcbiAgICBsZXQgZGVyaXZlZE1hdGVyaWFsID0gdGhpcy5fZGVyaXZlZE1hdGVyaWFsO1xuICAgIGNvbnN0IGJhc2VNYXRlcmlhbCA9IHRoaXMuX2Jhc2VNYXRlcmlhbCB8fCB0aGlzLl9kZWZhdWx0TWF0ZXJpYWwgfHwgKHRoaXMuX2RlZmF1bHRNYXRlcmlhbCA9IGRlZmF1bHRCYXNlTWF0ZXJpYWwuY2xvbmUoKSk7XG4gICAgaWYgKCFkZXJpdmVkTWF0ZXJpYWwgfHwgZGVyaXZlZE1hdGVyaWFsLmJhc2VNYXRlcmlhbCAhPT0gYmFzZU1hdGVyaWFsKSB7XG4gICAgICBkZXJpdmVkTWF0ZXJpYWwgPSB0aGlzLl9kZXJpdmVkTWF0ZXJpYWwgPSBjcmVhdGVCZXppZXJNZXNoTWF0ZXJpYWwoYmFzZU1hdGVyaWFsKTtcbiAgICAgIC8vIGRpc3Bvc2UgdGhlIGRlcml2ZWQgbWF0ZXJpYWwgd2hlbiBpdHMgYmFzZSBtYXRlcmlhbCBpcyBkaXNwb3NlZDpcbiAgICAgIGJhc2VNYXRlcmlhbC5hZGRFdmVudExpc3RlbmVyKCdkaXNwb3NlJywgZnVuY3Rpb24gb25EaXNwb3NlKCkge1xuICAgICAgICBiYXNlTWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZGlzcG9zZScsIG9uRGlzcG9zZSk7XG4gICAgICAgIGRlcml2ZWRNYXRlcmlhbC5kaXNwb3NlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlcml2ZWRNYXRlcmlhbFxuICB9XG4gIHNldCBtYXRlcmlhbChiYXNlTWF0ZXJpYWwpIHtcbiAgICB0aGlzLl9iYXNlTWF0ZXJpYWwgPSBiYXNlTWF0ZXJpYWw7XG4gIH1cblxuICAvLyBDcmVhdGUgYW5kIHVwZGF0ZSBtYXRlcmlhbCBmb3Igc2hhZG93cyB1cG9uIHJlcXVlc3Q6XG4gIGdldCBjdXN0b21EZXB0aE1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERlcHRoTWF0ZXJpYWwoKVxuICB9XG4gIGdldCBjdXN0b21EaXN0YW5jZU1hdGVyaWFsKCkge1xuICAgIHJldHVybiB0aGlzLm1hdGVyaWFsLmdldERpc3RhbmNlTWF0ZXJpYWwoKVxuICB9XG5cbiAgb25CZWZvcmVSZW5kZXIoKSB7XG4gICAgY29uc3Qge3VuaWZvcm1zfSA9IHRoaXMubWF0ZXJpYWw7XG4gICAgY29uc3Qge3BvaW50QSwgY29udHJvbEEsIGNvbnRyb2xCLCBwb2ludEIsIHJhZGl1cywgZGFzaEFycmF5LCBkYXNoT2Zmc2V0fSA9IHRoaXM7XG4gICAgdW5pZm9ybXMucG9pbnRBLnZhbHVlLmNvcHkocG9pbnRBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQS52YWx1ZS5jb3B5KGNvbnRyb2xBKTtcbiAgICB1bmlmb3Jtcy5jb250cm9sQi52YWx1ZS5jb3B5KGNvbnRyb2xCKTtcbiAgICB1bmlmb3Jtcy5wb2ludEIudmFsdWUuY29weShwb2ludEIpO1xuICAgIHVuaWZvcm1zLnJhZGl1cy52YWx1ZSA9IHJhZGl1cztcbiAgICB1bmlmb3Jtcy5kYXNoaW5nLnZhbHVlLnNldChkYXNoQXJyYXkueCwgZGFzaEFycmF5LnksIGRhc2hPZmZzZXQgfHwgMCk7XG4gIH1cblxuICByYXljYXN0KC8qcmF5Y2FzdGVyLCBpbnRlcnNlY3RzKi8pIHtcbiAgICAvLyBUT0RPIC0ganVzdCBmYWlsIGZvciBub3dcbiAgfVxufVxuXG5leHBvcnQgeyBCZXppZXJNZXNoLCBjcmVhdGVEZXJpdmVkTWF0ZXJpYWwsIGV4cGFuZFNoYWRlckluY2x1ZGVzLCBnZXRTaGFkZXJVbmlmb3JtVHlwZXMsIGdldFNoYWRlcnNGb3JNYXRlcmlhbCwgaW52ZXJ0TWF0cml4NCwgdm9pZE1haW5SZWdFeHAgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/troika-three-utils/dist/troika-three-utils.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   defineWorkerModule: function() { return /* binding */ defineWorkerModule; },\n/* harmony export */   stringifyFunction: function() { return /* binding */ stringifyFunction; },\n/* harmony export */   terminateWorker: function() { return /* binding */ terminateWorker; }\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Main content for the worker that handles the loading and execution of\n * modules within it.\n */\nfunction workerBootstrap() {\n  var modules = Object.create(null);\n\n  // Handle messages for registering a module\n  function registerModule(ref, callback) {\n    var id = ref.id;\n    var name = ref.name;\n    var dependencies = ref.dependencies; if ( dependencies === void 0 ) dependencies = [];\n    var init = ref.init; if ( init === void 0 ) init = function(){};\n    var getTransferables = ref.getTransferables; if ( getTransferables === void 0 ) getTransferables = null;\n\n    // Only register once\n    if (modules[id]) { return }\n\n    try {\n      // If any dependencies are modules, ensure they're registered and grab their value\n      dependencies = dependencies.map(function (dep) {\n        if (dep && dep.isWorkerModule) {\n          registerModule(dep, function (depResult) {\n            if (depResult instanceof Error) { throw depResult }\n          });\n          dep = modules[dep.id].value;\n        }\n        return dep\n      });\n\n      // Rehydrate functions\n      init = rehydrate((\"<\" + name + \">.init\"), init);\n      if (getTransferables) {\n        getTransferables = rehydrate((\"<\" + name + \">.getTransferables\"), getTransferables);\n      }\n\n      // Initialize the module and store its value\n      var value = null;\n      if (typeof init === 'function') {\n        value = init.apply(void 0, dependencies);\n      } else {\n        console.error('worker module init function failed to rehydrate');\n      }\n      modules[id] = {\n        id: id,\n        value: value,\n        getTransferables: getTransferables\n      };\n      callback(value);\n    } catch(err) {\n      if (!(err && err.noLog)) {\n        console.error(err);\n      }\n      callback(err);\n    }\n  }\n\n  // Handle messages for calling a registered module's result function\n  function callModule(ref, callback) {\n    var ref$1;\n\n    var id = ref.id;\n    var args = ref.args;\n    if (!modules[id] || typeof modules[id].value !== 'function') {\n      callback(new Error((\"Worker module \" + id + \": not found or its 'init' did not return a function\")));\n    }\n    try {\n      var result = (ref$1 = modules[id]).value.apply(ref$1, args);\n      if (result && typeof result.then === 'function') {\n        result.then(handleResult, function (rej) { return callback(rej instanceof Error ? rej : new Error('' + rej)); });\n      } else {\n        handleResult(result);\n      }\n    } catch(err) {\n      callback(err);\n    }\n    function handleResult(result) {\n      try {\n        var tx = modules[id].getTransferables && modules[id].getTransferables(result);\n        if (!tx || !Array.isArray(tx) || !tx.length) {\n          tx = undefined; //postMessage is very picky about not passing null or empty transferables\n        }\n        callback(result, tx);\n      } catch(err) {\n        console.error(err);\n        callback(err);\n      }\n    }\n  }\n\n  function rehydrate(name, str) {\n    var result = void 0;\n    self.troikaDefine = function (r) { return result = r; };\n    var url = URL.createObjectURL(\n      new Blob(\n        [(\"/** \" + (name.replace(/\\*/g, '')) + \" **/\\n\\ntroikaDefine(\\n\" + str + \"\\n)\")],\n        {type: 'application/javascript'}\n      )\n    );\n    try {\n      importScripts(url);\n    } catch(err) {\n      console.error(err);\n    }\n    URL.revokeObjectURL(url);\n    delete self.troikaDefine;\n    return result\n  }\n\n  // Handler for all messages within the worker\n  self.addEventListener('message', function (e) {\n    var ref = e.data;\n    var messageId = ref.messageId;\n    var action = ref.action;\n    var data = ref.data;\n    try {\n      // Module registration\n      if (action === 'registerModule') {\n        registerModule(data, function (result) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: {isCallable: typeof result === 'function'}\n            });\n          }\n        });\n      }\n      // Invocation\n      if (action === 'callModule') {\n        callModule(data, function (result, transferables) {\n          if (result instanceof Error) {\n            postMessage({\n              messageId: messageId,\n              success: false,\n              error: result.message\n            });\n          } else {\n            postMessage({\n              messageId: messageId,\n              success: true,\n              result: result\n            }, transferables || undefined);\n          }\n        });\n      }\n    } catch(err) {\n      postMessage({\n        messageId: messageId,\n        success: false,\n        error: err.stack\n      });\n    }\n  });\n}\n\n/**\n * Fallback for `defineWorkerModule` that behaves identically but runs in the main\n * thread, for when the execution environment doesn't support web workers or they\n * are disallowed due to e.g. CSP security restrictions.\n */\nfunction defineMainThreadModule(options) {\n  var moduleFunc = function() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return moduleFunc._getInitResult().then(function (initResult) {\n      if (typeof initResult === 'function') {\n        return initResult.apply(void 0, args)\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  };\n  moduleFunc._getInitResult = function() {\n    // We can ignore getTransferables in main thread. TODO workerId?\n    var dependencies = options.dependencies;\n    var init = options.init;\n\n    // Resolve dependencies\n    dependencies = Array.isArray(dependencies) ? dependencies.map(function (dep) {\n      if (dep) {\n        // If it's a worker module, use its main thread impl\n        dep = dep.onMainThread || dep;\n        // If it's a main thread worker module, use its init return value\n        if (dep._getInitResult) {\n          dep = dep._getInitResult();\n        }\n      }\n      return dep\n    }) : [];\n\n    // Invoke init with the resolved dependencies\n    var initPromise = Promise.all(dependencies).then(function (deps) {\n      return init.apply(null, deps)\n    });\n\n    // Cache the resolved promise for subsequent calls\n    moduleFunc._getInitResult = function () { return initPromise; };\n\n    return initPromise\n  };\n  return moduleFunc\n}\n\nvar supportsWorkers = function () {\n  var supported = false;\n\n  // Only attempt worker initialization in browsers; elsewhere it would just be\n  // noise e.g. loading into a Node environment for SSR.\n  if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {\n    try {\n      // TODO additional checks for things like importScripts within the worker?\n      //  Would need to be an async check.\n      var worker = new Worker(\n        URL.createObjectURL(new Blob([''], { type: 'application/javascript' }))\n      );\n      worker.terminate();\n      supported = true;\n    } catch (err) {\n      if (typeof process !== 'undefined' && \"development\" === 'test') {} else {\n        console.log(\n          (\"Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [\" + (err.message) + \"]\")\n        );\n      }\n    }\n  }\n\n  // Cached result\n  supportsWorkers = function () { return supported; };\n  return supported\n};\n\nvar _workerModuleId = 0;\nvar _messageId = 0;\nvar _allowInitAsString = false;\nvar workers = Object.create(null);\nvar registeredModules = Object.create(null); //workerId -> Set<unregisterFn>\nvar openRequests = Object.create(null);\n\n\n/**\n * Define a module of code that will be executed with a web worker. This provides a simple\n * interface for moving chunks of logic off the main thread, and managing their dependencies\n * among one another.\n *\n * @param {object} options\n * @param {function} options.init\n * @param {array} [options.dependencies]\n * @param {function} [options.getTransferables]\n * @param {string} [options.name]\n * @param {string} [options.workerId]\n * @return {function(...[*]): {then}}\n */\nfunction defineWorkerModule(options) {\n  if ((!options || typeof options.init !== 'function') && !_allowInitAsString) {\n    throw new Error('requires `options.init` function')\n  }\n  var dependencies = options.dependencies;\n  var init = options.init;\n  var getTransferables = options.getTransferables;\n  var workerId = options.workerId;\n\n  var onMainThread = defineMainThreadModule(options);\n\n  if (workerId == null) {\n    workerId = '#default';\n  }\n  var id = \"workerModule\" + (++_workerModuleId);\n  var name = options.name || id;\n  var registrationPromise = null;\n\n  dependencies = dependencies && dependencies.map(function (dep) {\n    // Wrap raw functions as worker modules with no dependencies\n    if (typeof dep === 'function' && !dep.workerModuleData) {\n      _allowInitAsString = true;\n      dep = defineWorkerModule({\n        workerId: workerId,\n        name: (\"<\" + name + \"> function dependency: \" + (dep.name)),\n        init: (\"function(){return (\\n\" + (stringifyFunction(dep)) + \"\\n)}\")\n      });\n      _allowInitAsString = false;\n    }\n    // Grab postable data for worker modules\n    if (dep && dep.workerModuleData) {\n      dep = dep.workerModuleData;\n    }\n    return dep\n  });\n\n  function moduleFunc() {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    if (!supportsWorkers()) {\n      return onMainThread.apply(void 0, args)\n    }\n\n    // Register this module if needed\n    if (!registrationPromise) {\n      registrationPromise = callWorker(workerId,'registerModule', moduleFunc.workerModuleData);\n      var unregister = function () {\n        registrationPromise = null;\n        registeredModules[workerId].delete(unregister);\n      }\n      ;(registeredModules[workerId] || (registeredModules[workerId] = new Set())).add(unregister);\n    }\n\n    // Invoke the module, returning a promise\n    return registrationPromise.then(function (ref) {\n      var isCallable = ref.isCallable;\n\n      if (isCallable) {\n        return callWorker(workerId,'callModule', {id: id, args: args})\n      } else {\n        throw new Error('Worker module function was called but `init` did not return a callable function')\n      }\n    })\n  }\n  moduleFunc.workerModuleData = {\n    isWorkerModule: true,\n    id: id,\n    name: name,\n    dependencies: dependencies,\n    init: stringifyFunction(init),\n    getTransferables: getTransferables && stringifyFunction(getTransferables)\n  };\n\n  moduleFunc.onMainThread = onMainThread;\n\n  return moduleFunc\n}\n\n/**\n * Terminate an active Worker by a workerId that was passed to defineWorkerModule.\n * This only terminates the Worker itself; the worker module will remain available\n * and if you call it again its Worker will be respawned.\n * @param {string} workerId\n */\nfunction terminateWorker(workerId) {\n  // Unregister all modules that were registered in that worker\n  if (registeredModules[workerId]) {\n    registeredModules[workerId].forEach(function (unregister) {\n      unregister();\n    });\n  }\n  // Terminate the Worker object\n  if (workers[workerId]) {\n    workers[workerId].terminate();\n    delete workers[workerId];\n  }\n}\n\n/**\n * Stringifies a function into a form that can be deserialized in the worker\n * @param fn\n */\nfunction stringifyFunction(fn) {\n  var str = fn.toString();\n  // If it was defined in object method/property format, it needs to be modified\n  if (!/^function/.test(str) && /^\\w+\\s*\\(/.test(str)) {\n    str = 'function ' + str;\n  }\n  return str\n}\n\n\nfunction getWorker(workerId) {\n  var worker = workers[workerId];\n  if (!worker) {\n    // Bootstrap the worker's content\n    var bootstrap = stringifyFunction(workerBootstrap);\n\n    // Create the worker from the bootstrap function content\n    worker = workers[workerId] = new Worker(\n      URL.createObjectURL(\n        new Blob(\n          [(\"/** Worker Module Bootstrap: \" + (workerId.replace(/\\*/g, '')) + \" **/\\n\\n;(\" + bootstrap + \")()\")],\n          {type: 'application/javascript'}\n        )\n      )\n    );\n\n    // Single handler for response messages from the worker\n    worker.onmessage = function (e) {\n      var response = e.data;\n      var msgId = response.messageId;\n      var callback = openRequests[msgId];\n      if (!callback) {\n        throw new Error('WorkerModule response with empty or unknown messageId')\n      }\n      delete openRequests[msgId];\n      callback(response);\n    };\n  }\n  return worker\n}\n\n// Issue a call to the worker with a callback to handle the response\nfunction callWorker(workerId, action, data) {\n  return new Promise(function (resolve, reject) {\n    var messageId = ++_messageId;\n    openRequests[messageId] = function (response) {\n      if (response.success) {\n        resolve(response.result);\n      } else {\n        reject(new Error((\"Error in worker \" + action + \" call: \" + (response.error))));\n      }\n    };\n    getWorker(workerId).postMessage({\n      messageId: messageId,\n      action: action,\n      data: data\n    });\n  })\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90cm9pa2Etd29ya2VyLXV0aWxzL2Rpc3QvdHJvaWthLXdvcmtlci11dGlscy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5QkFBeUI7QUFDekIsaURBQWlEOztBQUVqRDtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELG9FQUFvRTtBQUN2SCxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QixhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsOENBQThDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0NBQWdDO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixpQkFBaUIsT0FBTyxvQkFBb0IsYUFBb0IsYUFBYSxFQUFDLENBQUM7QUFDL0U7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qzs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOENBQThDO0FBQ3pFLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrREFBa0QsbUJBQW1CO0FBQ3JFLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RixXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVrRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdHJvaWthLXdvcmtlci11dGlscy9kaXN0L3Ryb2lrYS13b3JrZXItdXRpbHMuZXNtLmpzPzY2MmIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBNYWluIGNvbnRlbnQgZm9yIHRoZSB3b3JrZXIgdGhhdCBoYW5kbGVzIHRoZSBsb2FkaW5nIGFuZCBleGVjdXRpb24gb2ZcbiAqIG1vZHVsZXMgd2l0aGluIGl0LlxuICovXG5mdW5jdGlvbiB3b3JrZXJCb290c3RyYXAoKSB7XG4gIHZhciBtb2R1bGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvLyBIYW5kbGUgbWVzc2FnZXMgZm9yIHJlZ2lzdGVyaW5nIGEgbW9kdWxlXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyTW9kdWxlKHJlZiwgY2FsbGJhY2spIHtcbiAgICB2YXIgaWQgPSByZWYuaWQ7XG4gICAgdmFyIG5hbWUgPSByZWYubmFtZTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gcmVmLmRlcGVuZGVuY2llczsgaWYgKCBkZXBlbmRlbmNpZXMgPT09IHZvaWQgMCApIGRlcGVuZGVuY2llcyA9IFtdO1xuICAgIHZhciBpbml0ID0gcmVmLmluaXQ7IGlmICggaW5pdCA9PT0gdm9pZCAwICkgaW5pdCA9IGZ1bmN0aW9uKCl7fTtcbiAgICB2YXIgZ2V0VHJhbnNmZXJhYmxlcyA9IHJlZi5nZXRUcmFuc2ZlcmFibGVzOyBpZiAoIGdldFRyYW5zZmVyYWJsZXMgPT09IHZvaWQgMCApIGdldFRyYW5zZmVyYWJsZXMgPSBudWxsO1xuXG4gICAgLy8gT25seSByZWdpc3RlciBvbmNlXG4gICAgaWYgKG1vZHVsZXNbaWRdKSB7IHJldHVybiB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gSWYgYW55IGRlcGVuZGVuY2llcyBhcmUgbW9kdWxlcywgZW5zdXJlIHRoZXkncmUgcmVnaXN0ZXJlZCBhbmQgZ3JhYiB0aGVpciB2YWx1ZVxuICAgICAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICAgIGlmIChkZXAgJiYgZGVwLmlzV29ya2VyTW9kdWxlKSB7XG4gICAgICAgICAgcmVnaXN0ZXJNb2R1bGUoZGVwLCBmdW5jdGlvbiAoZGVwUmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoZGVwUmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHsgdGhyb3cgZGVwUmVzdWx0IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZXAgPSBtb2R1bGVzW2RlcC5pZF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlcFxuICAgICAgfSk7XG5cbiAgICAgIC8vIFJlaHlkcmF0ZSBmdW5jdGlvbnNcbiAgICAgIGluaXQgPSByZWh5ZHJhdGUoKFwiPFwiICsgbmFtZSArIFwiPi5pbml0XCIpLCBpbml0KTtcbiAgICAgIGlmIChnZXRUcmFuc2ZlcmFibGVzKSB7XG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXMgPSByZWh5ZHJhdGUoKFwiPFwiICsgbmFtZSArIFwiPi5nZXRUcmFuc2ZlcmFibGVzXCIpLCBnZXRUcmFuc2ZlcmFibGVzKTtcbiAgICAgIH1cblxuICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgbW9kdWxlIGFuZCBzdG9yZSBpdHMgdmFsdWVcbiAgICAgIHZhciB2YWx1ZSA9IG51bGw7XG4gICAgICBpZiAodHlwZW9mIGluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBpbml0LmFwcGx5KHZvaWQgMCwgZGVwZW5kZW5jaWVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ3dvcmtlciBtb2R1bGUgaW5pdCBmdW5jdGlvbiBmYWlsZWQgdG8gcmVoeWRyYXRlJyk7XG4gICAgICB9XG4gICAgICBtb2R1bGVzW2lkXSA9IHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGdldFRyYW5zZmVyYWJsZXM6IGdldFRyYW5zZmVyYWJsZXNcbiAgICAgIH07XG4gICAgICBjYWxsYmFjayh2YWx1ZSk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGlmICghKGVyciAmJiBlcnIubm9Mb2cpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIG1lc3NhZ2VzIGZvciBjYWxsaW5nIGEgcmVnaXN0ZXJlZCBtb2R1bGUncyByZXN1bHQgZnVuY3Rpb25cbiAgZnVuY3Rpb24gY2FsbE1vZHVsZShyZWYsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlZiQxO1xuXG4gICAgdmFyIGlkID0gcmVmLmlkO1xuICAgIHZhciBhcmdzID0gcmVmLmFyZ3M7XG4gICAgaWYgKCFtb2R1bGVzW2lkXSB8fCB0eXBlb2YgbW9kdWxlc1tpZF0udmFsdWUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcigoXCJXb3JrZXIgbW9kdWxlIFwiICsgaWQgKyBcIjogbm90IGZvdW5kIG9yIGl0cyAnaW5pdCcgZGlkIG5vdCByZXR1cm4gYSBmdW5jdGlvblwiKSkpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdmFyIHJlc3VsdCA9IChyZWYkMSA9IG1vZHVsZXNbaWRdKS52YWx1ZS5hcHBseShyZWYkMSwgYXJncyk7XG4gICAgICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXN1bHQudGhlbihoYW5kbGVSZXN1bHQsIGZ1bmN0aW9uIChyZWopIHsgcmV0dXJuIGNhbGxiYWNrKHJlaiBpbnN0YW5jZW9mIEVycm9yID8gcmVqIDogbmV3IEVycm9yKCcnICsgcmVqKSk7IH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdChyZXN1bHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciB0eCA9IG1vZHVsZXNbaWRdLmdldFRyYW5zZmVyYWJsZXMgJiYgbW9kdWxlc1tpZF0uZ2V0VHJhbnNmZXJhYmxlcyhyZXN1bHQpO1xuICAgICAgICBpZiAoIXR4IHx8ICFBcnJheS5pc0FycmF5KHR4KSB8fCAhdHgubGVuZ3RoKSB7XG4gICAgICAgICAgdHggPSB1bmRlZmluZWQ7IC8vcG9zdE1lc3NhZ2UgaXMgdmVyeSBwaWNreSBhYm91dCBub3QgcGFzc2luZyBudWxsIG9yIGVtcHR5IHRyYW5zZmVyYWJsZXNcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjayhyZXN1bHQsIHR4KTtcbiAgICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWh5ZHJhdGUobmFtZSwgc3RyKSB7XG4gICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICBzZWxmLnRyb2lrYURlZmluZSA9IGZ1bmN0aW9uIChyKSB7IHJldHVybiByZXN1bHQgPSByOyB9O1xuICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKFxuICAgICAgbmV3IEJsb2IoXG4gICAgICAgIFsoXCIvKiogXCIgKyAobmFtZS5yZXBsYWNlKC9cXCovZywgJycpKSArIFwiICoqL1xcblxcbnRyb2lrYURlZmluZShcXG5cIiArIHN0ciArIFwiXFxuKVwiKV0sXG4gICAgICAgIHt0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCd9XG4gICAgICApXG4gICAgKTtcbiAgICB0cnkge1xuICAgICAgaW1wb3J0U2NyaXB0cyh1cmwpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICAgIFVSTC5yZXZva2VPYmplY3RVUkwodXJsKTtcbiAgICBkZWxldGUgc2VsZi50cm9pa2FEZWZpbmU7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gSGFuZGxlciBmb3IgYWxsIG1lc3NhZ2VzIHdpdGhpbiB0aGUgd29ya2VyXG4gIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHJlZiA9IGUuZGF0YTtcbiAgICB2YXIgbWVzc2FnZUlkID0gcmVmLm1lc3NhZ2VJZDtcbiAgICB2YXIgYWN0aW9uID0gcmVmLmFjdGlvbjtcbiAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgIHRyeSB7XG4gICAgICAvLyBNb2R1bGUgcmVnaXN0cmF0aW9uXG4gICAgICBpZiAoYWN0aW9uID09PSAncmVnaXN0ZXJNb2R1bGUnKSB7XG4gICAgICAgIHJlZ2lzdGVyTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0Lm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICByZXN1bHQ6IHtpc0NhbGxhYmxlOiB0eXBlb2YgcmVzdWx0ID09PSAnZnVuY3Rpb24nfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEludm9jYXRpb25cbiAgICAgIGlmIChhY3Rpb24gPT09ICdjYWxsTW9kdWxlJykge1xuICAgICAgICBjYWxsTW9kdWxlKGRhdGEsIGZ1bmN0aW9uIChyZXN1bHQsIHRyYW5zZmVyYWJsZXMpIHtcbiAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICBlcnJvcjogcmVzdWx0Lm1lc3NhZ2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIG1lc3NhZ2VJZDogbWVzc2FnZUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcyB8fCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogZXJyLnN0YWNrXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEZhbGxiYWNrIGZvciBgZGVmaW5lV29ya2VyTW9kdWxlYCB0aGF0IGJlaGF2ZXMgaWRlbnRpY2FsbHkgYnV0IHJ1bnMgaW4gdGhlIG1haW5cbiAqIHRocmVhZCwgZm9yIHdoZW4gdGhlIGV4ZWN1dGlvbiBlbnZpcm9ubWVudCBkb2Vzbid0IHN1cHBvcnQgd2ViIHdvcmtlcnMgb3IgdGhleVxuICogYXJlIGRpc2FsbG93ZWQgZHVlIHRvIGUuZy4gQ1NQIHNlY3VyaXR5IHJlc3RyaWN0aW9ucy5cbiAqL1xuZnVuY3Rpb24gZGVmaW5lTWFpblRocmVhZE1vZHVsZShvcHRpb25zKSB7XG4gIHZhciBtb2R1bGVGdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBbXSwgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoIGxlbi0tICkgYXJnc1sgbGVuIF0gPSBhcmd1bWVudHNbIGxlbiBdO1xuXG4gICAgcmV0dXJuIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQoKS50aGVuKGZ1bmN0aW9uIChpbml0UmVzdWx0KSB7XG4gICAgICBpZiAodHlwZW9mIGluaXRSZXN1bHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGluaXRSZXN1bHQuYXBwbHkodm9pZCAwLCBhcmdzKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgbW9kdWxlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnV0IGBpbml0YCBkaWQgbm90IHJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9KVxuICB9O1xuICBtb2R1bGVGdW5jLl9nZXRJbml0UmVzdWx0ID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gV2UgY2FuIGlnbm9yZSBnZXRUcmFuc2ZlcmFibGVzIGluIG1haW4gdGhyZWFkLiBUT0RPIHdvcmtlcklkP1xuICAgIHZhciBkZXBlbmRlbmNpZXMgPSBvcHRpb25zLmRlcGVuZGVuY2llcztcbiAgICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcblxuICAgIC8vIFJlc29sdmUgZGVwZW5kZW5jaWVzXG4gICAgZGVwZW5kZW5jaWVzID0gQXJyYXkuaXNBcnJheShkZXBlbmRlbmNpZXMpID8gZGVwZW5kZW5jaWVzLm1hcChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoZGVwKSB7XG4gICAgICAgIC8vIElmIGl0J3MgYSB3b3JrZXIgbW9kdWxlLCB1c2UgaXRzIG1haW4gdGhyZWFkIGltcGxcbiAgICAgICAgZGVwID0gZGVwLm9uTWFpblRocmVhZCB8fCBkZXA7XG4gICAgICAgIC8vIElmIGl0J3MgYSBtYWluIHRocmVhZCB3b3JrZXIgbW9kdWxlLCB1c2UgaXRzIGluaXQgcmV0dXJuIHZhbHVlXG4gICAgICAgIGlmIChkZXAuX2dldEluaXRSZXN1bHQpIHtcbiAgICAgICAgICBkZXAgPSBkZXAuX2dldEluaXRSZXN1bHQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlcFxuICAgIH0pIDogW107XG5cbiAgICAvLyBJbnZva2UgaW5pdCB3aXRoIHRoZSByZXNvbHZlZCBkZXBlbmRlbmNpZXNcbiAgICB2YXIgaW5pdFByb21pc2UgPSBQcm9taXNlLmFsbChkZXBlbmRlbmNpZXMpLnRoZW4oZnVuY3Rpb24gKGRlcHMpIHtcbiAgICAgIHJldHVybiBpbml0LmFwcGx5KG51bGwsIGRlcHMpXG4gICAgfSk7XG5cbiAgICAvLyBDYWNoZSB0aGUgcmVzb2x2ZWQgcHJvbWlzZSBmb3Igc3Vic2VxdWVudCBjYWxsc1xuICAgIG1vZHVsZUZ1bmMuX2dldEluaXRSZXN1bHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbml0UHJvbWlzZTsgfTtcblxuICAgIHJldHVybiBpbml0UHJvbWlzZVxuICB9O1xuICByZXR1cm4gbW9kdWxlRnVuY1xufVxuXG52YXIgc3VwcG9ydHNXb3JrZXJzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3VwcG9ydGVkID0gZmFsc2U7XG5cbiAgLy8gT25seSBhdHRlbXB0IHdvcmtlciBpbml0aWFsaXphdGlvbiBpbiBicm93c2VyczsgZWxzZXdoZXJlIGl0IHdvdWxkIGp1c3QgYmVcbiAgLy8gbm9pc2UgZS5nLiBsb2FkaW5nIGludG8gYSBOb2RlIGVudmlyb25tZW50IGZvciBTU1IuXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAvLyBUT0RPIGFkZGl0aW9uYWwgY2hlY2tzIGZvciB0aGluZ3MgbGlrZSBpbXBvcnRTY3JpcHRzIHdpdGhpbiB0aGUgd29ya2VyP1xuICAgICAgLy8gIFdvdWxkIG5lZWQgdG8gYmUgYW4gYXN5bmMgY2hlY2suXG4gICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihcbiAgICAgICAgVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbJyddLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KSlcbiAgICAgICk7XG4gICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICBzdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSA7IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICAoXCJUcm9pa2EgY3JlYXRlV29ya2VyTW9kdWxlOiB3ZWIgd29ya2VycyBub3QgYWxsb3dlZDsgZmFsbGluZyBiYWNrIHRvIG1haW4gdGhyZWFkIGV4ZWN1dGlvbi4gQ2F1c2U6IFtcIiArIChlcnIubWVzc2FnZSkgKyBcIl1cIilcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDYWNoZWQgcmVzdWx0XG4gIHN1cHBvcnRzV29ya2VycyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1cHBvcnRlZDsgfTtcbiAgcmV0dXJuIHN1cHBvcnRlZFxufTtcblxudmFyIF93b3JrZXJNb2R1bGVJZCA9IDA7XG52YXIgX21lc3NhZ2VJZCA9IDA7XG52YXIgX2FsbG93SW5pdEFzU3RyaW5nID0gZmFsc2U7XG52YXIgd29ya2VycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG52YXIgcmVnaXN0ZXJlZE1vZHVsZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvL3dvcmtlcklkIC0+IFNldDx1bnJlZ2lzdGVyRm4+XG52YXIgb3BlblJlcXVlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuXG4vKipcbiAqIERlZmluZSBhIG1vZHVsZSBvZiBjb2RlIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aXRoIGEgd2ViIHdvcmtlci4gVGhpcyBwcm92aWRlcyBhIHNpbXBsZVxuICogaW50ZXJmYWNlIGZvciBtb3ZpbmcgY2h1bmtzIG9mIGxvZ2ljIG9mZiB0aGUgbWFpbiB0aHJlYWQsIGFuZCBtYW5hZ2luZyB0aGVpciBkZXBlbmRlbmNpZXNcbiAqIGFtb25nIG9uZSBhbm90aGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zLmluaXRcbiAqIEBwYXJhbSB7YXJyYXl9IFtvcHRpb25zLmRlcGVuZGVuY2llc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtvcHRpb25zLmdldFRyYW5zZmVyYWJsZXNdXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubmFtZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy53b3JrZXJJZF1cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKC4uLlsqXSk6IHt0aGVufX1cbiAqL1xuZnVuY3Rpb24gZGVmaW5lV29ya2VyTW9kdWxlKG9wdGlvbnMpIHtcbiAgaWYgKCghb3B0aW9ucyB8fCB0eXBlb2Ygb3B0aW9ucy5pbml0ICE9PSAnZnVuY3Rpb24nKSAmJiAhX2FsbG93SW5pdEFzU3RyaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyZXF1aXJlcyBgb3B0aW9ucy5pbml0YCBmdW5jdGlvbicpXG4gIH1cbiAgdmFyIGRlcGVuZGVuY2llcyA9IG9wdGlvbnMuZGVwZW5kZW5jaWVzO1xuICB2YXIgaW5pdCA9IG9wdGlvbnMuaW5pdDtcbiAgdmFyIGdldFRyYW5zZmVyYWJsZXMgPSBvcHRpb25zLmdldFRyYW5zZmVyYWJsZXM7XG4gIHZhciB3b3JrZXJJZCA9IG9wdGlvbnMud29ya2VySWQ7XG5cbiAgdmFyIG9uTWFpblRocmVhZCA9IGRlZmluZU1haW5UaHJlYWRNb2R1bGUob3B0aW9ucyk7XG5cbiAgaWYgKHdvcmtlcklkID09IG51bGwpIHtcbiAgICB3b3JrZXJJZCA9ICcjZGVmYXVsdCc7XG4gIH1cbiAgdmFyIGlkID0gXCJ3b3JrZXJNb2R1bGVcIiArICgrK193b3JrZXJNb2R1bGVJZCk7XG4gIHZhciBuYW1lID0gb3B0aW9ucy5uYW1lIHx8IGlkO1xuICB2YXIgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IG51bGw7XG5cbiAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzICYmIGRlcGVuZGVuY2llcy5tYXAoZnVuY3Rpb24gKGRlcCkge1xuICAgIC8vIFdyYXAgcmF3IGZ1bmN0aW9ucyBhcyB3b3JrZXIgbW9kdWxlcyB3aXRoIG5vIGRlcGVuZGVuY2llc1xuICAgIGlmICh0eXBlb2YgZGVwID09PSAnZnVuY3Rpb24nICYmICFkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgX2FsbG93SW5pdEFzU3RyaW5nID0gdHJ1ZTtcbiAgICAgIGRlcCA9IGRlZmluZVdvcmtlck1vZHVsZSh7XG4gICAgICAgIHdvcmtlcklkOiB3b3JrZXJJZCxcbiAgICAgICAgbmFtZTogKFwiPFwiICsgbmFtZSArIFwiPiBmdW5jdGlvbiBkZXBlbmRlbmN5OiBcIiArIChkZXAubmFtZSkpLFxuICAgICAgICBpbml0OiAoXCJmdW5jdGlvbigpe3JldHVybiAoXFxuXCIgKyAoc3RyaW5naWZ5RnVuY3Rpb24oZGVwKSkgKyBcIlxcbil9XCIpXG4gICAgICB9KTtcbiAgICAgIF9hbGxvd0luaXRBc1N0cmluZyA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBHcmFiIHBvc3RhYmxlIGRhdGEgZm9yIHdvcmtlciBtb2R1bGVzXG4gICAgaWYgKGRlcCAmJiBkZXAud29ya2VyTW9kdWxlRGF0YSkge1xuICAgICAgZGVwID0gZGVwLndvcmtlck1vZHVsZURhdGE7XG4gICAgfVxuICAgIHJldHVybiBkZXBcbiAgfSk7XG5cbiAgZnVuY3Rpb24gbW9kdWxlRnVuYygpIHtcbiAgICB2YXIgYXJncyA9IFtdLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHdoaWxlICggbGVuLS0gKSBhcmdzWyBsZW4gXSA9IGFyZ3VtZW50c1sgbGVuIF07XG5cbiAgICBpZiAoIXN1cHBvcnRzV29ya2VycygpKSB7XG4gICAgICByZXR1cm4gb25NYWluVGhyZWFkLmFwcGx5KHZvaWQgMCwgYXJncylcbiAgICB9XG5cbiAgICAvLyBSZWdpc3RlciB0aGlzIG1vZHVsZSBpZiBuZWVkZWRcbiAgICBpZiAoIXJlZ2lzdHJhdGlvblByb21pc2UpIHtcbiAgICAgIHJlZ2lzdHJhdGlvblByb21pc2UgPSBjYWxsV29ya2VyKHdvcmtlcklkLCdyZWdpc3Rlck1vZHVsZScsIG1vZHVsZUZ1bmMud29ya2VyTW9kdWxlRGF0YSk7XG4gICAgICB2YXIgdW5yZWdpc3RlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IG51bGw7XG4gICAgICAgIHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXS5kZWxldGUodW5yZWdpc3Rlcik7XG4gICAgICB9XG4gICAgICA7KHJlZ2lzdGVyZWRNb2R1bGVzW3dvcmtlcklkXSB8fCAocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdID0gbmV3IFNldCgpKSkuYWRkKHVucmVnaXN0ZXIpO1xuICAgIH1cblxuICAgIC8vIEludm9rZSB0aGUgbW9kdWxlLCByZXR1cm5pbmcgYSBwcm9taXNlXG4gICAgcmV0dXJuIHJlZ2lzdHJhdGlvblByb21pc2UudGhlbihmdW5jdGlvbiAocmVmKSB7XG4gICAgICB2YXIgaXNDYWxsYWJsZSA9IHJlZi5pc0NhbGxhYmxlO1xuXG4gICAgICBpZiAoaXNDYWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gY2FsbFdvcmtlcih3b3JrZXJJZCwnY2FsbE1vZHVsZScsIHtpZDogaWQsIGFyZ3M6IGFyZ3N9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXb3JrZXIgbW9kdWxlIGZ1bmN0aW9uIHdhcyBjYWxsZWQgYnV0IGBpbml0YCBkaWQgbm90IHJldHVybiBhIGNhbGxhYmxlIGZ1bmN0aW9uJylcbiAgICAgIH1cbiAgICB9KVxuICB9XG4gIG1vZHVsZUZ1bmMud29ya2VyTW9kdWxlRGF0YSA9IHtcbiAgICBpc1dvcmtlck1vZHVsZTogdHJ1ZSxcbiAgICBpZDogaWQsXG4gICAgbmFtZTogbmFtZSxcbiAgICBkZXBlbmRlbmNpZXM6IGRlcGVuZGVuY2llcyxcbiAgICBpbml0OiBzdHJpbmdpZnlGdW5jdGlvbihpbml0KSxcbiAgICBnZXRUcmFuc2ZlcmFibGVzOiBnZXRUcmFuc2ZlcmFibGVzICYmIHN0cmluZ2lmeUZ1bmN0aW9uKGdldFRyYW5zZmVyYWJsZXMpXG4gIH07XG5cbiAgbW9kdWxlRnVuYy5vbk1haW5UaHJlYWQgPSBvbk1haW5UaHJlYWQ7XG5cbiAgcmV0dXJuIG1vZHVsZUZ1bmNcbn1cblxuLyoqXG4gKiBUZXJtaW5hdGUgYW4gYWN0aXZlIFdvcmtlciBieSBhIHdvcmtlcklkIHRoYXQgd2FzIHBhc3NlZCB0byBkZWZpbmVXb3JrZXJNb2R1bGUuXG4gKiBUaGlzIG9ubHkgdGVybWluYXRlcyB0aGUgV29ya2VyIGl0c2VsZjsgdGhlIHdvcmtlciBtb2R1bGUgd2lsbCByZW1haW4gYXZhaWxhYmxlXG4gKiBhbmQgaWYgeW91IGNhbGwgaXQgYWdhaW4gaXRzIFdvcmtlciB3aWxsIGJlIHJlc3Bhd25lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSB3b3JrZXJJZFxuICovXG5mdW5jdGlvbiB0ZXJtaW5hdGVXb3JrZXIod29ya2VySWQpIHtcbiAgLy8gVW5yZWdpc3RlciBhbGwgbW9kdWxlcyB0aGF0IHdlcmUgcmVnaXN0ZXJlZCBpbiB0aGF0IHdvcmtlclxuICBpZiAocmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdKSB7XG4gICAgcmVnaXN0ZXJlZE1vZHVsZXNbd29ya2VySWRdLmZvckVhY2goZnVuY3Rpb24gKHVucmVnaXN0ZXIpIHtcbiAgICAgIHVucmVnaXN0ZXIoKTtcbiAgICB9KTtcbiAgfVxuICAvLyBUZXJtaW5hdGUgdGhlIFdvcmtlciBvYmplY3RcbiAgaWYgKHdvcmtlcnNbd29ya2VySWRdKSB7XG4gICAgd29ya2Vyc1t3b3JrZXJJZF0udGVybWluYXRlKCk7XG4gICAgZGVsZXRlIHdvcmtlcnNbd29ya2VySWRdO1xuICB9XG59XG5cbi8qKlxuICogU3RyaW5naWZpZXMgYSBmdW5jdGlvbiBpbnRvIGEgZm9ybSB0aGF0IGNhbiBiZSBkZXNlcmlhbGl6ZWQgaW4gdGhlIHdvcmtlclxuICogQHBhcmFtIGZuXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ2lmeUZ1bmN0aW9uKGZuKSB7XG4gIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICAvLyBJZiBpdCB3YXMgZGVmaW5lZCBpbiBvYmplY3QgbWV0aG9kL3Byb3BlcnR5IGZvcm1hdCwgaXQgbmVlZHMgdG8gYmUgbW9kaWZpZWRcbiAgaWYgKCEvXmZ1bmN0aW9uLy50ZXN0KHN0cikgJiYgL15cXHcrXFxzKlxcKC8udGVzdChzdHIpKSB7XG4gICAgc3RyID0gJ2Z1bmN0aW9uICcgKyBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5cbmZ1bmN0aW9uIGdldFdvcmtlcih3b3JrZXJJZCkge1xuICB2YXIgd29ya2VyID0gd29ya2Vyc1t3b3JrZXJJZF07XG4gIGlmICghd29ya2VyKSB7XG4gICAgLy8gQm9vdHN0cmFwIHRoZSB3b3JrZXIncyBjb250ZW50XG4gICAgdmFyIGJvb3RzdHJhcCA9IHN0cmluZ2lmeUZ1bmN0aW9uKHdvcmtlckJvb3RzdHJhcCk7XG5cbiAgICAvLyBDcmVhdGUgdGhlIHdvcmtlciBmcm9tIHRoZSBib290c3RyYXAgZnVuY3Rpb24gY29udGVudFxuICAgIHdvcmtlciA9IHdvcmtlcnNbd29ya2VySWRdID0gbmV3IFdvcmtlcihcbiAgICAgIFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgICAgIG5ldyBCbG9iKFxuICAgICAgICAgIFsoXCIvKiogV29ya2VyIE1vZHVsZSBCb290c3RyYXA6IFwiICsgKHdvcmtlcklkLnJlcGxhY2UoL1xcKi9nLCAnJykpICsgXCIgKiovXFxuXFxuOyhcIiArIGJvb3RzdHJhcCArIFwiKSgpXCIpXSxcbiAgICAgICAgICB7dHlwZTogJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnfVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcblxuICAgIC8vIFNpbmdsZSBoYW5kbGVyIGZvciByZXNwb25zZSBtZXNzYWdlcyBmcm9tIHRoZSB3b3JrZXJcbiAgICB3b3JrZXIub25tZXNzYWdlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgIHZhciByZXNwb25zZSA9IGUuZGF0YTtcbiAgICAgIHZhciBtc2dJZCA9IHJlc3BvbnNlLm1lc3NhZ2VJZDtcbiAgICAgIHZhciBjYWxsYmFjayA9IG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya2VyTW9kdWxlIHJlc3BvbnNlIHdpdGggZW1wdHkgb3IgdW5rbm93biBtZXNzYWdlSWQnKVxuICAgICAgfVxuICAgICAgZGVsZXRlIG9wZW5SZXF1ZXN0c1ttc2dJZF07XG4gICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gd29ya2VyXG59XG5cbi8vIElzc3VlIGEgY2FsbCB0byB0aGUgd29ya2VyIHdpdGggYSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIHJlc3BvbnNlXG5mdW5jdGlvbiBjYWxsV29ya2VyKHdvcmtlcklkLCBhY3Rpb24sIGRhdGEpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgbWVzc2FnZUlkID0gKytfbWVzc2FnZUlkO1xuICAgIG9wZW5SZXF1ZXN0c1ttZXNzYWdlSWRdID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3VjY2Vzcykge1xuICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKChcIkVycm9yIGluIHdvcmtlciBcIiArIGFjdGlvbiArIFwiIGNhbGw6IFwiICsgKHJlc3BvbnNlLmVycm9yKSkpKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGdldFdvcmtlcih3b3JrZXJJZCkucG9zdE1lc3NhZ2Uoe1xuICAgICAgbWVzc2FnZUlkOiBtZXNzYWdlSWQsXG4gICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfSlcbn1cblxuZXhwb3J0IHsgZGVmaW5lV29ya2VyTW9kdWxlLCBzdHJpbmdpZnlGdW5jdGlvbiwgdGVybWluYXRlV29ya2VyIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/troika-worker-utils/dist/troika-worker-utils.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs":
/*!***********************************************************************************!*\
  !*** ./node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Animated: function() { return /* binding */ Animated; },\n/* harmony export */   AnimatedArray: function() { return /* binding */ AnimatedArray; },\n/* harmony export */   AnimatedObject: function() { return /* binding */ AnimatedObject; },\n/* harmony export */   AnimatedString: function() { return /* binding */ AnimatedString; },\n/* harmony export */   AnimatedValue: function() { return /* binding */ AnimatedValue; },\n/* harmony export */   createHost: function() { return /* binding */ createHost; },\n/* harmony export */   getAnimated: function() { return /* binding */ getAnimated; },\n/* harmony export */   getAnimatedType: function() { return /* binding */ getAnimatedType; },\n/* harmony export */   getPayload: function() { return /* binding */ getPayload; },\n/* harmony export */   isAnimated: function() { return /* binding */ isAnimated; },\n/* harmony export */   setAnimated: function() { return /* binding */ setAnimated; }\n/* harmony export */ });\n/* harmony import */ var _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-spring/shared */ \"(app-pages-browser)/./node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n// src/Animated.ts\n\nvar $node = Symbol.for(\"Animated:node\");\nvar isAnimated = (value) => !!value && value[$node] === value;\nvar getAnimated = (owner) => owner && owner[$node];\nvar setAnimated = (owner, node) => (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.defineHidden)(owner, $node, node);\nvar getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();\nvar Animated = class {\n  constructor() {\n    setAnimated(this, this);\n  }\n  /** Get every `AnimatedValue` used by this node. */\n  getPayload() {\n    return this.payload || [];\n  }\n};\n\n// src/AnimatedValue.ts\n\nvar AnimatedValue = class extends Animated {\n  constructor(_value) {\n    super();\n    this._value = _value;\n    this.done = true;\n    this.durationProgress = 0;\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.num(this._value)) {\n      this.lastPosition = this._value;\n    }\n  }\n  /** @internal */\n  static create(value) {\n    return new AnimatedValue(value);\n  }\n  getPayload() {\n    return [this];\n  }\n  getValue() {\n    return this._value;\n  }\n  setValue(value, step) {\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.num(value)) {\n      this.lastPosition = value;\n      if (step) {\n        value = Math.round(value / step) * step;\n        if (this.done) {\n          this.lastPosition = value;\n        }\n      }\n    }\n    if (this._value === value) {\n      return false;\n    }\n    this._value = value;\n    return true;\n  }\n  reset() {\n    const { done } = this;\n    this.done = false;\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.num(this._value)) {\n      this.elapsedTime = 0;\n      this.durationProgress = 0;\n      this.lastPosition = this._value;\n      if (done)\n        this.lastVelocity = null;\n      this.v0 = null;\n    }\n  }\n};\n\n// src/AnimatedString.ts\n\nvar AnimatedString = class extends AnimatedValue {\n  constructor(value) {\n    super(0);\n    this._string = null;\n    this._toString = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.createInterpolator)({\n      output: [value, value]\n    });\n  }\n  /** @internal */\n  static create(value) {\n    return new AnimatedString(value);\n  }\n  getValue() {\n    const value = this._string;\n    return value == null ? this._string = this._toString(this._value) : value;\n  }\n  setValue(value) {\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.str(value)) {\n      if (value == this._string) {\n        return false;\n      }\n      this._string = value;\n      this._value = 1;\n    } else if (super.setValue(value)) {\n      this._string = null;\n    } else {\n      return false;\n    }\n    return true;\n  }\n  reset(goal) {\n    if (goal) {\n      this._toString = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.createInterpolator)({\n        output: [this.getValue(), goal]\n      });\n    }\n    this._value = 0;\n    super.reset();\n  }\n};\n\n// src/AnimatedArray.ts\n\n\n// src/AnimatedObject.ts\n\n\n// src/context.ts\nvar TreeContext = { dependencies: null };\n\n// src/AnimatedObject.ts\nvar AnimatedObject = class extends Animated {\n  constructor(source) {\n    super();\n    this.source = source;\n    this.setValue(source);\n  }\n  getValue(animated) {\n    const values = {};\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(this.source, (source, key) => {\n      if (isAnimated(source)) {\n        values[key] = source.getValue(animated);\n      } else if ((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(source)) {\n        values[key] = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(source);\n      } else if (!animated) {\n        values[key] = source;\n      }\n    });\n    return values;\n  }\n  /** Replace the raw object data */\n  setValue(source) {\n    this.source = source;\n    this.payload = this._makePayload(source);\n  }\n  reset() {\n    if (this.payload) {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(this.payload, (node) => node.reset());\n    }\n  }\n  /** Create a payload set. */\n  _makePayload(source) {\n    if (source) {\n      const payload = /* @__PURE__ */ new Set();\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(source, this._addToPayload, payload);\n      return Array.from(payload);\n    }\n  }\n  /** Add to a payload set. */\n  _addToPayload(source) {\n    if (TreeContext.dependencies && (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(source)) {\n      TreeContext.dependencies.add(source);\n    }\n    const payload = getPayload(source);\n    if (payload) {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(payload, (node) => this.add(node));\n    }\n  }\n};\n\n// src/AnimatedArray.ts\nvar AnimatedArray = class extends AnimatedObject {\n  constructor(source) {\n    super(source);\n  }\n  /** @internal */\n  static create(source) {\n    return new AnimatedArray(source);\n  }\n  getValue() {\n    return this.source.map((node) => node.getValue());\n  }\n  setValue(source) {\n    const payload = this.getPayload();\n    if (source.length == payload.length) {\n      return payload.map((node, i) => node.setValue(source[i])).some(Boolean);\n    }\n    super.setValue(source.map(makeAnimated));\n    return true;\n  }\n};\nfunction makeAnimated(value) {\n  const nodeType = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isAnimatedString)(value) ? AnimatedString : AnimatedValue;\n  return nodeType.create(value);\n}\n\n// src/getAnimatedType.ts\n\nfunction getAnimatedType(value) {\n  const parentNode = getAnimated(value);\n  return parentNode ? parentNode.constructor : _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(value) ? AnimatedArray : (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isAnimatedString)(value) ? AnimatedString : AnimatedValue;\n}\n\n// src/createHost.ts\n\n\n// src/withAnimated.tsx\n\n\n\nvar withAnimated = (Component, host) => {\n  const hasInstance = (\n    // Function components must use \"forwardRef\" to avoid being\n    // re-rendered on every animation frame.\n    !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(Component) || Component.prototype && Component.prototype.isReactComponent\n  );\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)((givenProps, givenRef) => {\n    const instanceRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(\n      (value) => {\n        instanceRef.current = updateRef(givenRef, value);\n      },\n      [givenRef]\n    );\n    const [props, deps] = getAnimatedState(givenProps, host);\n    const forceUpdate = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useForceUpdate)();\n    const callback = () => {\n      const instance = instanceRef.current;\n      if (hasInstance && !instance) {\n        return;\n      }\n      const didUpdate = instance ? host.applyAnimatedValues(instance, props.getValue(true)) : false;\n      if (didUpdate === false) {\n        forceUpdate();\n      }\n    };\n    const observer = new PropsObserver(callback, deps);\n    const observerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n      observerRef.current = observer;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(deps, (dep) => (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.addFluidObserver)(dep, observer));\n      return () => {\n        if (observerRef.current) {\n          (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(\n            observerRef.current.deps,\n            (dep) => (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.removeFluidObserver)(dep, observerRef.current)\n          );\n          _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.cancel(observerRef.current.update);\n        }\n      };\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(callback, []);\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useOnce)(() => () => {\n      const observer2 = observerRef.current;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(observer2.deps, (dep) => (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.removeFluidObserver)(dep, observer2));\n    });\n    const usedProps = host.getComponentProps(props.getValue());\n    return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Component, { ...usedProps, ref });\n  });\n};\nvar PropsObserver = class {\n  constructor(update, deps) {\n    this.update = update;\n    this.deps = deps;\n  }\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.write(this.update);\n    }\n  }\n};\nfunction getAnimatedState(props, host) {\n  const dependencies = /* @__PURE__ */ new Set();\n  TreeContext.dependencies = dependencies;\n  if (props.style)\n    props = {\n      ...props,\n      style: host.createAnimatedStyle(props.style)\n    };\n  props = new AnimatedObject(props);\n  TreeContext.dependencies = null;\n  return [props, dependencies];\n}\nfunction updateRef(ref, value) {\n  if (ref) {\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(ref))\n      ref(value);\n    else\n      ref.current = value;\n  }\n  return value;\n}\n\n// src/createHost.ts\nvar cacheKey = Symbol.for(\"AnimatedComponent\");\nvar createHost = (components, {\n  applyAnimatedValues = () => false,\n  createAnimatedStyle = (style) => new AnimatedObject(style),\n  getComponentProps = (props) => props\n} = {}) => {\n  const hostConfig = {\n    applyAnimatedValues,\n    createAnimatedStyle,\n    getComponentProps\n  };\n  const animated = (Component) => {\n    const displayName = getDisplayName(Component) || \"Anonymous\";\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.str(Component)) {\n      Component = animated[Component] || (animated[Component] = withAnimated(Component, hostConfig));\n    } else {\n      Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));\n    }\n    Component.displayName = `Animated(${displayName})`;\n    return Component;\n  };\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(components, (Component, key) => {\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(components)) {\n      key = getDisplayName(Component);\n    }\n    animated[key] = animated(Component);\n  });\n  return {\n    animated\n  };\n};\nvar getDisplayName = (arg) => _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.str(arg) ? arg : arg && _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.str(arg.displayName) ? arg.displayName : _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(arg) && arg.name || null;\n\n//# sourceMappingURL=react-spring_animated.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL2FuaW1hdGVkL2Rpc3QvcmVhY3Qtc3ByaW5nX2FuaW1hdGVkLm1vZGVybi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ29EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxrRUFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9EQUFFO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQUU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxRQUFRLG9EQUFFO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3FFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdFQUFrQjtBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQUc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3RUFBa0I7QUFDekM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUN3RDs7QUFFeEQ7QUFNOEI7O0FBRTlCO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhEQUFRO0FBQ1o7QUFDQTtBQUNBLFFBQVEsU0FBUyxtRUFBYTtBQUM5QixzQkFBc0IsbUVBQWE7QUFDbkMsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sOERBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1FQUFhO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBSTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzRUFBZ0I7QUFDbkM7QUFDQTs7QUFFQTtBQUN3RjtBQUN4RjtBQUNBO0FBQ0EsK0NBQStDLG9EQUFHLDhCQUE4QixzRUFBaUI7QUFDakc7O0FBRUE7QUFDd0U7O0FBRXhFO0FBQytCO0FBQ29DO0FBVXJDO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvREFBRztBQUNSO0FBQ0EsU0FBUyxpREFBVTtBQUNuQix3QkFBd0IsNkNBQU07QUFDOUI7QUFDQSxJQUFJLGtEQUFXO0FBQ2Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0VBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw2Q0FBTTtBQUM5QixJQUFJLCtFQUF5QjtBQUM3QjtBQUNBLE1BQU0sMERBQUssZ0JBQWdCLHNFQUFnQjtBQUMzQztBQUNBO0FBQ0EsVUFBVSwwREFBSztBQUNmO0FBQ0EscUJBQXFCLHlFQUFtQjtBQUN4QztBQUNBLFVBQVUscURBQUc7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYixJQUFJLDZEQUFPO0FBQ1g7QUFDQSxNQUFNLDBEQUFLLDBCQUEwQix5RUFBbUI7QUFDeEQsS0FBSztBQUNMO0FBQ0EsMkJBQTJCLGdEQUFtQixjQUFjLG1CQUFtQjtBQUMvRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0scURBQUc7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBRztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQUc7QUFDWDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0NBQXdDLFlBQVk7QUFDcEQ7QUFDQTtBQUNBLEVBQUUsOERBQVM7QUFDWCxRQUFRLG9EQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9EQUFHLHlCQUF5QixvREFBRywwQ0FBMEMsb0RBQUc7QUFheEc7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9hbmltYXRlZC9kaXN0L3JlYWN0LXNwcmluZ19hbmltYXRlZC5tb2Rlcm4ubWpzP2U4MmQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL0FuaW1hdGVkLnRzXG5pbXBvcnQgeyBkZWZpbmVIaWRkZW4gfSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcbnZhciAkbm9kZSA9IFN5bWJvbC5mb3IoXCJBbmltYXRlZDpub2RlXCIpO1xudmFyIGlzQW5pbWF0ZWQgPSAodmFsdWUpID0+ICEhdmFsdWUgJiYgdmFsdWVbJG5vZGVdID09PSB2YWx1ZTtcbnZhciBnZXRBbmltYXRlZCA9IChvd25lcikgPT4gb3duZXIgJiYgb3duZXJbJG5vZGVdO1xudmFyIHNldEFuaW1hdGVkID0gKG93bmVyLCBub2RlKSA9PiBkZWZpbmVIaWRkZW4ob3duZXIsICRub2RlLCBub2RlKTtcbnZhciBnZXRQYXlsb2FkID0gKG93bmVyKSA9PiBvd25lciAmJiBvd25lclskbm9kZV0gJiYgb3duZXJbJG5vZGVdLmdldFBheWxvYWQoKTtcbnZhciBBbmltYXRlZCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc2V0QW5pbWF0ZWQodGhpcywgdGhpcyk7XG4gIH1cbiAgLyoqIEdldCBldmVyeSBgQW5pbWF0ZWRWYWx1ZWAgdXNlZCBieSB0aGlzIG5vZGUuICovXG4gIGdldFBheWxvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF5bG9hZCB8fCBbXTtcbiAgfVxufTtcblxuLy8gc3JjL0FuaW1hdGVkVmFsdWUudHNcbmltcG9ydCB7IGlzIH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG52YXIgQW5pbWF0ZWRWYWx1ZSA9IGNsYXNzIGV4dGVuZHMgQW5pbWF0ZWQge1xuICBjb25zdHJ1Y3RvcihfdmFsdWUpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3ZhbHVlID0gX3ZhbHVlO1xuICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgdGhpcy5kdXJhdGlvblByb2dyZXNzID0gMDtcbiAgICBpZiAoaXMubnVtKHRoaXMuX3ZhbHVlKSkge1xuICAgICAgdGhpcy5sYXN0UG9zaXRpb24gPSB0aGlzLl92YWx1ZTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBBbmltYXRlZFZhbHVlKHZhbHVlKTtcbiAgfVxuICBnZXRQYXlsb2FkKCkge1xuICAgIHJldHVybiBbdGhpc107XG4gIH1cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldFZhbHVlKHZhbHVlLCBzdGVwKSB7XG4gICAgaWYgKGlzLm51bSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gdmFsdWU7XG4gICAgICBpZiAoc3RlcCkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgLyBzdGVwKSAqIHN0ZXA7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICB0aGlzLmxhc3RQb3NpdGlvbiA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLl92YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBjb25zdCB7IGRvbmUgfSA9IHRoaXM7XG4gICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgaWYgKGlzLm51bSh0aGlzLl92YWx1ZSkpIHtcbiAgICAgIHRoaXMuZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgdGhpcy5kdXJhdGlvblByb2dyZXNzID0gMDtcbiAgICAgIHRoaXMubGFzdFBvc2l0aW9uID0gdGhpcy5fdmFsdWU7XG4gICAgICBpZiAoZG9uZSlcbiAgICAgICAgdGhpcy5sYXN0VmVsb2NpdHkgPSBudWxsO1xuICAgICAgdGhpcy52MCA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvQW5pbWF0ZWRTdHJpbmcudHNcbmltcG9ydCB7IGlzIGFzIGlzMiwgY3JlYXRlSW50ZXJwb2xhdG9yIH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG52YXIgQW5pbWF0ZWRTdHJpbmcgPSBjbGFzcyBleHRlbmRzIEFuaW1hdGVkVmFsdWUge1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKDApO1xuICAgIHRoaXMuX3N0cmluZyA9IG51bGw7XG4gICAgdGhpcy5fdG9TdHJpbmcgPSBjcmVhdGVJbnRlcnBvbGF0b3Ioe1xuICAgICAgb3V0cHV0OiBbdmFsdWUsIHZhbHVlXVxuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGNyZWF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiBuZXcgQW5pbWF0ZWRTdHJpbmcodmFsdWUpO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fc3RyaW5nO1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdGhpcy5fc3RyaW5nID0gdGhpcy5fdG9TdHJpbmcodGhpcy5fdmFsdWUpIDogdmFsdWU7XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICBpZiAoaXMyLnN0cih2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSB0aGlzLl9zdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RyaW5nID0gdmFsdWU7XG4gICAgICB0aGlzLl92YWx1ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdXBlci5zZXRWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX3N0cmluZyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmVzZXQoZ29hbCkge1xuICAgIGlmIChnb2FsKSB7XG4gICAgICB0aGlzLl90b1N0cmluZyA9IGNyZWF0ZUludGVycG9sYXRvcih7XG4gICAgICAgIG91dHB1dDogW3RoaXMuZ2V0VmFsdWUoKSwgZ29hbF1cbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl92YWx1ZSA9IDA7XG4gICAgc3VwZXIucmVzZXQoKTtcbiAgfVxufTtcblxuLy8gc3JjL0FuaW1hdGVkQXJyYXkudHNcbmltcG9ydCB7IGlzQW5pbWF0ZWRTdHJpbmcgfSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcblxuLy8gc3JjL0FuaW1hdGVkT2JqZWN0LnRzXG5pbXBvcnQge1xuICBlYWNoLFxuICBlYWNoUHJvcCxcbiAgZ2V0Rmx1aWRWYWx1ZSxcbiAgaGFzRmx1aWRWYWx1ZVxufSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcblxuLy8gc3JjL2NvbnRleHQudHNcbnZhciBUcmVlQ29udGV4dCA9IHsgZGVwZW5kZW5jaWVzOiBudWxsIH07XG5cbi8vIHNyYy9BbmltYXRlZE9iamVjdC50c1xudmFyIEFuaW1hdGVkT2JqZWN0ID0gY2xhc3MgZXh0ZW5kcyBBbmltYXRlZCB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5zZXRWYWx1ZShzb3VyY2UpO1xuICB9XG4gIGdldFZhbHVlKGFuaW1hdGVkKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgZWFjaFByb3AodGhpcy5zb3VyY2UsIChzb3VyY2UsIGtleSkgPT4ge1xuICAgICAgaWYgKGlzQW5pbWF0ZWQoc291cmNlKSkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IHNvdXJjZS5nZXRWYWx1ZShhbmltYXRlZCk7XG4gICAgICB9IGVsc2UgaWYgKGhhc0ZsdWlkVmFsdWUoc291cmNlKSkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IGdldEZsdWlkVmFsdWUoc291cmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWFuaW1hdGVkKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gc291cmNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgLyoqIFJlcGxhY2UgdGhlIHJhdyBvYmplY3QgZGF0YSAqL1xuICBzZXRWYWx1ZShzb3VyY2UpIHtcbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLnBheWxvYWQgPSB0aGlzLl9tYWtlUGF5bG9hZChzb3VyY2UpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLnBheWxvYWQpIHtcbiAgICAgIGVhY2godGhpcy5wYXlsb2FkLCAobm9kZSkgPT4gbm9kZS5yZXNldCgpKTtcbiAgICB9XG4gIH1cbiAgLyoqIENyZWF0ZSBhIHBheWxvYWQgc2V0LiAqL1xuICBfbWFrZVBheWxvYWQoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgY29uc3QgcGF5bG9hZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBlYWNoUHJvcChzb3VyY2UsIHRoaXMuX2FkZFRvUGF5bG9hZCwgcGF5bG9hZCk7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShwYXlsb2FkKTtcbiAgICB9XG4gIH1cbiAgLyoqIEFkZCB0byBhIHBheWxvYWQgc2V0LiAqL1xuICBfYWRkVG9QYXlsb2FkKHNvdXJjZSkge1xuICAgIGlmIChUcmVlQ29udGV4dC5kZXBlbmRlbmNpZXMgJiYgaGFzRmx1aWRWYWx1ZShzb3VyY2UpKSB7XG4gICAgICBUcmVlQ29udGV4dC5kZXBlbmRlbmNpZXMuYWRkKHNvdXJjZSk7XG4gICAgfVxuICAgIGNvbnN0IHBheWxvYWQgPSBnZXRQYXlsb2FkKHNvdXJjZSk7XG4gICAgaWYgKHBheWxvYWQpIHtcbiAgICAgIGVhY2gocGF5bG9hZCwgKG5vZGUpID0+IHRoaXMuYWRkKG5vZGUpKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIHNyYy9BbmltYXRlZEFycmF5LnRzXG52YXIgQW5pbWF0ZWRBcnJheSA9IGNsYXNzIGV4dGVuZHMgQW5pbWF0ZWRPYmplY3Qge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICBzdXBlcihzb3VyY2UpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc3RhdGljIGNyZWF0ZShzb3VyY2UpIHtcbiAgICByZXR1cm4gbmV3IEFuaW1hdGVkQXJyYXkoc291cmNlKTtcbiAgfVxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2UubWFwKChub2RlKSA9PiBub2RlLmdldFZhbHVlKCkpO1xuICB9XG4gIHNldFZhbHVlKHNvdXJjZSkge1xuICAgIGNvbnN0IHBheWxvYWQgPSB0aGlzLmdldFBheWxvYWQoKTtcbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PSBwYXlsb2FkLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHBheWxvYWQubWFwKChub2RlLCBpKSA9PiBub2RlLnNldFZhbHVlKHNvdXJjZVtpXSkpLnNvbWUoQm9vbGVhbik7XG4gICAgfVxuICAgIHN1cGVyLnNldFZhbHVlKHNvdXJjZS5tYXAobWFrZUFuaW1hdGVkKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5mdW5jdGlvbiBtYWtlQW5pbWF0ZWQodmFsdWUpIHtcbiAgY29uc3Qgbm9kZVR5cGUgPSBpc0FuaW1hdGVkU3RyaW5nKHZhbHVlKSA/IEFuaW1hdGVkU3RyaW5nIDogQW5pbWF0ZWRWYWx1ZTtcbiAgcmV0dXJuIG5vZGVUeXBlLmNyZWF0ZSh2YWx1ZSk7XG59XG5cbi8vIHNyYy9nZXRBbmltYXRlZFR5cGUudHNcbmltcG9ydCB7IGlzIGFzIGlzMywgaXNBbmltYXRlZFN0cmluZyBhcyBpc0FuaW1hdGVkU3RyaW5nMiB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xuZnVuY3Rpb24gZ2V0QW5pbWF0ZWRUeXBlKHZhbHVlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRBbmltYXRlZCh2YWx1ZSk7XG4gIHJldHVybiBwYXJlbnROb2RlID8gcGFyZW50Tm9kZS5jb25zdHJ1Y3RvciA6IGlzMy5hcnIodmFsdWUpID8gQW5pbWF0ZWRBcnJheSA6IGlzQW5pbWF0ZWRTdHJpbmcyKHZhbHVlKSA/IEFuaW1hdGVkU3RyaW5nIDogQW5pbWF0ZWRWYWx1ZTtcbn1cblxuLy8gc3JjL2NyZWF0ZUhvc3QudHNcbmltcG9ydCB7IGlzIGFzIGlzNSwgZWFjaFByb3AgYXMgZWFjaFByb3AyIH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG5cbi8vIHNyYy93aXRoQW5pbWF0ZWQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgaXMgYXMgaXM0LFxuICBlYWNoIGFzIGVhY2gyLFxuICByYWYsXG4gIHVzZUZvcmNlVXBkYXRlLFxuICB1c2VPbmNlLFxuICBhZGRGbHVpZE9ic2VydmVyLFxuICByZW1vdmVGbHVpZE9ic2VydmVyLFxuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0XG59IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xudmFyIHdpdGhBbmltYXRlZCA9IChDb21wb25lbnQsIGhvc3QpID0+IHtcbiAgY29uc3QgaGFzSW5zdGFuY2UgPSAoXG4gICAgLy8gRnVuY3Rpb24gY29tcG9uZW50cyBtdXN0IHVzZSBcImZvcndhcmRSZWZcIiB0byBhdm9pZCBiZWluZ1xuICAgIC8vIHJlLXJlbmRlcmVkIG9uIGV2ZXJ5IGFuaW1hdGlvbiBmcmFtZS5cbiAgICAhaXM0LmZ1bihDb21wb25lbnQpIHx8IENvbXBvbmVudC5wcm90b3R5cGUgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50XG4gICk7XG4gIHJldHVybiBmb3J3YXJkUmVmKChnaXZlblByb3BzLCBnaXZlblJlZikgPT4ge1xuICAgIGNvbnN0IGluc3RhbmNlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHJlZiA9IGhhc0luc3RhbmNlICYmIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgIHVzZUNhbGxiYWNrKFxuICAgICAgKHZhbHVlKSA9PiB7XG4gICAgICAgIGluc3RhbmNlUmVmLmN1cnJlbnQgPSB1cGRhdGVSZWYoZ2l2ZW5SZWYsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBbZ2l2ZW5SZWZdXG4gICAgKTtcbiAgICBjb25zdCBbcHJvcHMsIGRlcHNdID0gZ2V0QW5pbWF0ZWRTdGF0ZShnaXZlblByb3BzLCBob3N0KTtcbiAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IGluc3RhbmNlUmVmLmN1cnJlbnQ7XG4gICAgICBpZiAoaGFzSW5zdGFuY2UgJiYgIWluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRpZFVwZGF0ZSA9IGluc3RhbmNlID8gaG9zdC5hcHBseUFuaW1hdGVkVmFsdWVzKGluc3RhbmNlLCBwcm9wcy5nZXRWYWx1ZSh0cnVlKSkgOiBmYWxzZTtcbiAgICAgIGlmIChkaWRVcGRhdGUgPT09IGZhbHNlKSB7XG4gICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBQcm9wc09ic2VydmVyKGNhbGxiYWNrLCBkZXBzKTtcbiAgICBjb25zdCBvYnNlcnZlclJlZiA9IHVzZVJlZigpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgb2JzZXJ2ZXJSZWYuY3VycmVudCA9IG9ic2VydmVyO1xuICAgICAgZWFjaDIoZGVwcywgKGRlcCkgPT4gYWRkRmx1aWRPYnNlcnZlcihkZXAsIG9ic2VydmVyKSk7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBpZiAob2JzZXJ2ZXJSZWYuY3VycmVudCkge1xuICAgICAgICAgIGVhY2gyKFxuICAgICAgICAgICAgb2JzZXJ2ZXJSZWYuY3VycmVudC5kZXBzLFxuICAgICAgICAgICAgKGRlcCkgPT4gcmVtb3ZlRmx1aWRPYnNlcnZlcihkZXAsIG9ic2VydmVyUmVmLmN1cnJlbnQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICByYWYuY2FuY2VsKG9ic2VydmVyUmVmLmN1cnJlbnQudXBkYXRlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoY2FsbGJhY2ssIFtdKTtcbiAgICB1c2VPbmNlKCgpID0+ICgpID0+IHtcbiAgICAgIGNvbnN0IG9ic2VydmVyMiA9IG9ic2VydmVyUmVmLmN1cnJlbnQ7XG4gICAgICBlYWNoMihvYnNlcnZlcjIuZGVwcywgKGRlcCkgPT4gcmVtb3ZlRmx1aWRPYnNlcnZlcihkZXAsIG9ic2VydmVyMikpO1xuICAgIH0pO1xuICAgIGNvbnN0IHVzZWRQcm9wcyA9IGhvc3QuZ2V0Q29tcG9uZW50UHJvcHMocHJvcHMuZ2V0VmFsdWUoKSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgeyAuLi51c2VkUHJvcHMsIHJlZiB9KTtcbiAgfSk7XG59O1xudmFyIFByb3BzT2JzZXJ2ZXIgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHVwZGF0ZSwgZGVwcykge1xuICAgIHRoaXMudXBkYXRlID0gdXBkYXRlO1xuICAgIHRoaXMuZGVwcyA9IGRlcHM7XG4gIH1cbiAgZXZlbnRPYnNlcnZlZChldmVudCkge1xuICAgIGlmIChldmVudC50eXBlID09IFwiY2hhbmdlXCIpIHtcbiAgICAgIHJhZi53cml0ZSh0aGlzLnVwZGF0ZSk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gZ2V0QW5pbWF0ZWRTdGF0ZShwcm9wcywgaG9zdCkge1xuICBjb25zdCBkZXBlbmRlbmNpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBUcmVlQ29udGV4dC5kZXBlbmRlbmNpZXMgPSBkZXBlbmRlbmNpZXM7XG4gIGlmIChwcm9wcy5zdHlsZSlcbiAgICBwcm9wcyA9IHtcbiAgICAgIC4uLnByb3BzLFxuICAgICAgc3R5bGU6IGhvc3QuY3JlYXRlQW5pbWF0ZWRTdHlsZShwcm9wcy5zdHlsZSlcbiAgICB9O1xuICBwcm9wcyA9IG5ldyBBbmltYXRlZE9iamVjdChwcm9wcyk7XG4gIFRyZWVDb250ZXh0LmRlcGVuZGVuY2llcyA9IG51bGw7XG4gIHJldHVybiBbcHJvcHMsIGRlcGVuZGVuY2llc107XG59XG5mdW5jdGlvbiB1cGRhdGVSZWYocmVmLCB2YWx1ZSkge1xuICBpZiAocmVmKSB7XG4gICAgaWYgKGlzNC5mdW4ocmVmKSlcbiAgICAgIHJlZih2YWx1ZSk7XG4gICAgZWxzZVxuICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHNyYy9jcmVhdGVIb3N0LnRzXG52YXIgY2FjaGVLZXkgPSBTeW1ib2wuZm9yKFwiQW5pbWF0ZWRDb21wb25lbnRcIik7XG52YXIgY3JlYXRlSG9zdCA9IChjb21wb25lbnRzLCB7XG4gIGFwcGx5QW5pbWF0ZWRWYWx1ZXMgPSAoKSA9PiBmYWxzZSxcbiAgY3JlYXRlQW5pbWF0ZWRTdHlsZSA9IChzdHlsZSkgPT4gbmV3IEFuaW1hdGVkT2JqZWN0KHN0eWxlKSxcbiAgZ2V0Q29tcG9uZW50UHJvcHMgPSAocHJvcHMpID0+IHByb3BzXG59ID0ge30pID0+IHtcbiAgY29uc3QgaG9zdENvbmZpZyA9IHtcbiAgICBhcHBseUFuaW1hdGVkVmFsdWVzLFxuICAgIGNyZWF0ZUFuaW1hdGVkU3R5bGUsXG4gICAgZ2V0Q29tcG9uZW50UHJvcHNcbiAgfTtcbiAgY29uc3QgYW5pbWF0ZWQgPSAoQ29tcG9uZW50KSA9PiB7XG4gICAgY29uc3QgZGlzcGxheU5hbWUgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpIHx8IFwiQW5vbnltb3VzXCI7XG4gICAgaWYgKGlzNS5zdHIoQ29tcG9uZW50KSkge1xuICAgICAgQ29tcG9uZW50ID0gYW5pbWF0ZWRbQ29tcG9uZW50XSB8fCAoYW5pbWF0ZWRbQ29tcG9uZW50XSA9IHdpdGhBbmltYXRlZChDb21wb25lbnQsIGhvc3RDb25maWcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgQ29tcG9uZW50ID0gQ29tcG9uZW50W2NhY2hlS2V5XSB8fCAoQ29tcG9uZW50W2NhY2hlS2V5XSA9IHdpdGhBbmltYXRlZChDb21wb25lbnQsIGhvc3RDb25maWcpKTtcbiAgICB9XG4gICAgQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gYEFuaW1hdGVkKCR7ZGlzcGxheU5hbWV9KWA7XG4gICAgcmV0dXJuIENvbXBvbmVudDtcbiAgfTtcbiAgZWFjaFByb3AyKGNvbXBvbmVudHMsIChDb21wb25lbnQsIGtleSkgPT4ge1xuICAgIGlmIChpczUuYXJyKGNvbXBvbmVudHMpKSB7XG4gICAgICBrZXkgPSBnZXREaXNwbGF5TmFtZShDb21wb25lbnQpO1xuICAgIH1cbiAgICBhbmltYXRlZFtrZXldID0gYW5pbWF0ZWQoQ29tcG9uZW50KTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYW5pbWF0ZWRcbiAgfTtcbn07XG52YXIgZ2V0RGlzcGxheU5hbWUgPSAoYXJnKSA9PiBpczUuc3RyKGFyZykgPyBhcmcgOiBhcmcgJiYgaXM1LnN0cihhcmcuZGlzcGxheU5hbWUpID8gYXJnLmRpc3BsYXlOYW1lIDogaXM1LmZ1bihhcmcpICYmIGFyZy5uYW1lIHx8IG51bGw7XG5leHBvcnQge1xuICBBbmltYXRlZCxcbiAgQW5pbWF0ZWRBcnJheSxcbiAgQW5pbWF0ZWRPYmplY3QsXG4gIEFuaW1hdGVkU3RyaW5nLFxuICBBbmltYXRlZFZhbHVlLFxuICBjcmVhdGVIb3N0LFxuICBnZXRBbmltYXRlZCxcbiAgZ2V0QW5pbWF0ZWRUeXBlLFxuICBnZXRQYXlsb2FkLFxuICBpc0FuaW1hdGVkLFxuICBzZXRBbmltYXRlZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXNwcmluZ19hbmltYXRlZC5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-spring/core/dist/react-spring_core.modern.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-spring/core/dist/react-spring_core.modern.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Any: function() { return /* reexport safe */ _react_spring_types__WEBPACK_IMPORTED_MODULE_3__.Any; },\n/* harmony export */   BailSignal: function() { return /* binding */ BailSignal; },\n/* harmony export */   Controller: function() { return /* binding */ Controller; },\n/* harmony export */   FrameValue: function() { return /* binding */ FrameValue; },\n/* harmony export */   Globals: function() { return /* reexport safe */ _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals; },\n/* harmony export */   Interpolation: function() { return /* binding */ Interpolation; },\n/* harmony export */   Spring: function() { return /* binding */ Spring; },\n/* harmony export */   SpringContext: function() { return /* binding */ SpringContext; },\n/* harmony export */   SpringRef: function() { return /* binding */ SpringRef; },\n/* harmony export */   SpringValue: function() { return /* binding */ SpringValue; },\n/* harmony export */   Trail: function() { return /* binding */ Trail; },\n/* harmony export */   Transition: function() { return /* binding */ Transition; },\n/* harmony export */   config: function() { return /* binding */ config; },\n/* harmony export */   createInterpolator: function() { return /* reexport safe */ _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.createInterpolator; },\n/* harmony export */   easings: function() { return /* reexport safe */ _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.easings; },\n/* harmony export */   inferTo: function() { return /* binding */ inferTo; },\n/* harmony export */   interpolate: function() { return /* binding */ interpolate; },\n/* harmony export */   to: function() { return /* binding */ to; },\n/* harmony export */   update: function() { return /* binding */ update; },\n/* harmony export */   useChain: function() { return /* binding */ useChain; },\n/* harmony export */   useInView: function() { return /* binding */ useInView; },\n/* harmony export */   useIsomorphicLayoutEffect: function() { return /* reexport safe */ _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect; },\n/* harmony export */   useReducedMotion: function() { return /* reexport safe */ _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useReducedMotion; },\n/* harmony export */   useResize: function() { return /* binding */ useResize; },\n/* harmony export */   useScroll: function() { return /* binding */ useScroll; },\n/* harmony export */   useSpring: function() { return /* binding */ useSpring; },\n/* harmony export */   useSpringRef: function() { return /* binding */ useSpringRef; },\n/* harmony export */   useSpringValue: function() { return /* binding */ useSpringValue; },\n/* harmony export */   useSprings: function() { return /* binding */ useSprings; },\n/* harmony export */   useTrail: function() { return /* binding */ useTrail; },\n/* harmony export */   useTransition: function() { return /* binding */ useTransition; }\n/* harmony export */ });\n/* harmony import */ var _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-spring/shared */ \"(app-pages-browser)/./node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _react_spring_animated__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-spring/animated */ \"(app-pages-browser)/./node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs\");\n/* harmony import */ var _react_spring_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-spring/types */ \"(app-pages-browser)/./node_modules/@react-spring/types/dist/react-spring_types.modern.mjs\");\n// src/hooks/useChain.ts\n\n\n// src/helpers.ts\n\nfunction callProp(value, ...args) {\n  return _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(value) ? value(...args) : value;\n}\nvar matchProp = (value, key) => value === true || !!(key && value && (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(value) ? value(key) : (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(value).includes(key)));\nvar resolveProp = (prop, key) => _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(prop) ? key && prop[key] : prop;\nvar getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;\nvar noopTransform = (value) => value;\nvar getDefaultProps = (props, transform = noopTransform) => {\n  let keys = DEFAULT_PROPS;\n  if (props.default && props.default !== true) {\n    props = props.default;\n    keys = Object.keys(props);\n  }\n  const defaults2 = {};\n  for (const key of keys) {\n    const value = transform(props[key], key);\n    if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(value)) {\n      defaults2[key] = value;\n    }\n  }\n  return defaults2;\n};\nvar DEFAULT_PROPS = [\n  \"config\",\n  \"onProps\",\n  \"onStart\",\n  \"onChange\",\n  \"onPause\",\n  \"onResume\",\n  \"onRest\"\n];\nvar RESERVED_PROPS = {\n  config: 1,\n  from: 1,\n  to: 1,\n  ref: 1,\n  loop: 1,\n  reset: 1,\n  pause: 1,\n  cancel: 1,\n  reverse: 1,\n  immediate: 1,\n  default: 1,\n  delay: 1,\n  onProps: 1,\n  onStart: 1,\n  onChange: 1,\n  onPause: 1,\n  onResume: 1,\n  onRest: 1,\n  onResolve: 1,\n  // Transition props\n  items: 1,\n  trail: 1,\n  sort: 1,\n  expires: 1,\n  initial: 1,\n  enter: 1,\n  update: 1,\n  leave: 1,\n  children: 1,\n  onDestroyed: 1,\n  // Internal props\n  keys: 1,\n  callId: 1,\n  parentId: 1\n};\nfunction getForwardProps(props) {\n  const forward = {};\n  let count = 0;\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(props, (value, prop) => {\n    if (!RESERVED_PROPS[prop]) {\n      forward[prop] = value;\n      count++;\n    }\n  });\n  if (count) {\n    return forward;\n  }\n}\nfunction inferTo(props) {\n  const to2 = getForwardProps(props);\n  if (to2) {\n    const out = { to: to2 };\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(props, (val, key) => key in to2 || (out[key] = val));\n    return out;\n  }\n  return { ...props };\n}\nfunction computeGoal(value) {\n  value = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(value);\n  return _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(value) ? value.map(computeGoal) : (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isAnimatedString)(value) ? _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.createStringInterpolator({\n    range: [0, 1],\n    output: [value, value]\n  })(1) : value;\n}\nfunction hasProps(props) {\n  for (const _ in props)\n    return true;\n  return false;\n}\nfunction isAsyncTo(to2) {\n  return _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(to2) || _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(to2) && _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(to2[0]);\n}\nfunction detachRefs(ctrl, ref) {\n  ctrl.ref?.delete(ctrl);\n  ref?.delete(ctrl);\n}\nfunction replaceRef(ctrl, ref) {\n  if (ref && ctrl.ref !== ref) {\n    ctrl.ref?.delete(ctrl);\n    ref.add(ctrl);\n    ctrl.ref = ref;\n  }\n}\n\n// src/hooks/useChain.ts\nfunction useChain(refs, timeSteps, timeFrame = 1e3) {\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n    if (timeSteps) {\n      let prevDelay = 0;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(refs, (ref, i) => {\n        const controllers = ref.current;\n        if (controllers.length) {\n          let delay = timeFrame * timeSteps[i];\n          if (isNaN(delay))\n            delay = prevDelay;\n          else\n            prevDelay = delay;\n          (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(controllers, (ctrl) => {\n            (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(ctrl.queue, (props) => {\n              const memoizedDelayProp = props.delay;\n              props.delay = (key) => delay + callProp(memoizedDelayProp || 0, key);\n            });\n          });\n          ref.start();\n        }\n      });\n    } else {\n      let p = Promise.resolve();\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(refs, (ref) => {\n        const controllers = ref.current;\n        if (controllers.length) {\n          const queues = controllers.map((ctrl) => {\n            const q = ctrl.queue;\n            ctrl.queue = [];\n            return q;\n          });\n          p = p.then(() => {\n            (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(\n              controllers,\n              (ctrl, i) => (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(queues[i] || [], (update2) => ctrl.queue.push(update2))\n            );\n            return Promise.all(ref.start());\n          });\n        }\n      });\n    }\n  });\n}\n\n// src/hooks/useSpring.ts\n\n\n// src/hooks/useSprings.ts\n\n\n\n// src/SpringValue.ts\n\n\n\n// src/AnimationConfig.ts\n\n\n// src/constants.ts\nvar config = {\n  default: { tension: 170, friction: 26 },\n  gentle: { tension: 120, friction: 14 },\n  wobbly: { tension: 180, friction: 12 },\n  stiff: { tension: 210, friction: 20 },\n  slow: { tension: 280, friction: 60 },\n  molasses: { tension: 280, friction: 120 }\n};\n\n// src/AnimationConfig.ts\nvar defaults = {\n  ...config.default,\n  mass: 1,\n  damping: 1,\n  easing: _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.easings.linear,\n  clamp: false\n};\nvar AnimationConfig = class {\n  constructor() {\n    /**\n     * The initial velocity of one or more values.\n     *\n     * @default 0\n     */\n    this.velocity = 0;\n    Object.assign(this, defaults);\n  }\n};\nfunction mergeConfig(config2, newConfig, defaultConfig) {\n  if (defaultConfig) {\n    defaultConfig = { ...defaultConfig };\n    sanitizeConfig(defaultConfig, newConfig);\n    newConfig = { ...defaultConfig, ...newConfig };\n  }\n  sanitizeConfig(config2, newConfig);\n  Object.assign(config2, newConfig);\n  for (const key in defaults) {\n    if (config2[key] == null) {\n      config2[key] = defaults[key];\n    }\n  }\n  let { frequency, damping } = config2;\n  const { mass } = config2;\n  if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(frequency)) {\n    if (frequency < 0.01)\n      frequency = 0.01;\n    if (damping < 0)\n      damping = 0;\n    config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;\n    config2.friction = 4 * Math.PI * damping * mass / frequency;\n  }\n  return config2;\n}\nfunction sanitizeConfig(config2, props) {\n  if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.decay)) {\n    config2.duration = void 0;\n  } else {\n    const isTensionConfig = !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.tension) || !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.friction);\n    if (isTensionConfig || !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.frequency) || !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.damping) || !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.mass)) {\n      config2.duration = void 0;\n      config2.decay = void 0;\n    }\n    if (isTensionConfig) {\n      config2.frequency = void 0;\n    }\n  }\n}\n\n// src/Animation.ts\nvar emptyArray = [];\nvar Animation = class {\n  constructor() {\n    this.changed = false;\n    this.values = emptyArray;\n    this.toValues = null;\n    this.fromValues = emptyArray;\n    this.config = new AnimationConfig();\n    this.immediate = false;\n  }\n};\n\n// src/scheduleProps.ts\n\nfunction scheduleProps(callId, { key, props, defaultProps, state, actions }) {\n  return new Promise((resolve, reject) => {\n    let delay;\n    let timeout;\n    let cancel = matchProp(props.cancel ?? defaultProps?.cancel, key);\n    if (cancel) {\n      onStart();\n    } else {\n      if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.pause)) {\n        state.paused = matchProp(props.pause, key);\n      }\n      let pause = defaultProps?.pause;\n      if (pause !== true) {\n        pause = state.paused || matchProp(pause, key);\n      }\n      delay = callProp(props.delay || 0, key);\n      if (pause) {\n        state.resumeQueue.add(onResume);\n        actions.pause();\n      } else {\n        actions.resume();\n        onResume();\n      }\n    }\n    function onPause() {\n      state.resumeQueue.add(onResume);\n      state.timeouts.delete(timeout);\n      timeout.cancel();\n      delay = timeout.time - _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.now();\n    }\n    function onResume() {\n      if (delay > 0 && !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.skipAnimation) {\n        state.delayed = true;\n        timeout = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.setTimeout(onStart, delay);\n        state.pauseQueue.add(onPause);\n        state.timeouts.add(timeout);\n      } else {\n        onStart();\n      }\n    }\n    function onStart() {\n      if (state.delayed) {\n        state.delayed = false;\n      }\n      state.pauseQueue.delete(onPause);\n      state.timeouts.delete(timeout);\n      if (callId <= (state.cancelId || 0)) {\n        cancel = true;\n      }\n      try {\n        actions.start({ ...props, callId, cancel }, resolve);\n      } catch (err) {\n        reject(err);\n      }\n    }\n  });\n}\n\n// src/runAsync.ts\n\n\n// src/AnimationResult.ts\nvar getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(\n  target.get(),\n  results.every((result) => result.finished)\n);\nvar getNoopResult = (value) => ({\n  value,\n  noop: true,\n  finished: true,\n  cancelled: false\n});\nvar getFinishedResult = (value, finished, cancelled = false) => ({\n  value,\n  finished,\n  cancelled\n});\nvar getCancelledResult = (value) => ({\n  value,\n  cancelled: true,\n  finished: false\n});\n\n// src/runAsync.ts\nfunction runAsync(to2, props, state, target) {\n  const { callId, parentId, onRest } = props;\n  const { asyncTo: prevTo, promise: prevPromise } = state;\n  if (!parentId && to2 === prevTo && !props.reset) {\n    return prevPromise;\n  }\n  return state.promise = (async () => {\n    state.asyncId = callId;\n    state.asyncTo = to2;\n    const defaultProps = getDefaultProps(\n      props,\n      (value, key) => (\n        // The `onRest` prop is only called when the `runAsync` promise is resolved.\n        key === \"onRest\" ? void 0 : value\n      )\n    );\n    let preventBail;\n    let bail;\n    const bailPromise = new Promise(\n      (resolve, reject) => (preventBail = resolve, bail = reject)\n    );\n    const bailIfEnded = (bailSignal) => {\n      const bailResult = (\n        // The `cancel` prop or `stop` method was used.\n        callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.\n        callId !== state.asyncId && getFinishedResult(target, false)\n      );\n      if (bailResult) {\n        bailSignal.result = bailResult;\n        bail(bailSignal);\n        throw bailSignal;\n      }\n    };\n    const animate = (arg1, arg2) => {\n      const bailSignal = new BailSignal();\n      const skipAnimationSignal = new SkipAnimationSignal();\n      return (async () => {\n        if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.skipAnimation) {\n          stopAsync(state);\n          skipAnimationSignal.result = getFinishedResult(target, false);\n          bail(skipAnimationSignal);\n          throw skipAnimationSignal;\n        }\n        bailIfEnded(bailSignal);\n        const props2 = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(arg1) ? { ...arg1 } : { ...arg2, to: arg1 };\n        props2.parentId = callId;\n        (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(defaultProps, (value, key) => {\n          if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props2[key])) {\n            props2[key] = value;\n          }\n        });\n        const result2 = await target.start(props2);\n        bailIfEnded(bailSignal);\n        if (state.paused) {\n          await new Promise((resume) => {\n            state.resumeQueue.add(resume);\n          });\n        }\n        return result2;\n      })();\n    };\n    let result;\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.skipAnimation) {\n      stopAsync(state);\n      return getFinishedResult(target, false);\n    }\n    try {\n      let animating;\n      if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(to2)) {\n        animating = (async (queue) => {\n          for (const props2 of queue) {\n            await animate(props2);\n          }\n        })(to2);\n      } else {\n        animating = Promise.resolve(to2(animate, target.stop.bind(target)));\n      }\n      await Promise.all([animating.then(preventBail), bailPromise]);\n      result = getFinishedResult(target.get(), true, false);\n    } catch (err) {\n      if (err instanceof BailSignal) {\n        result = err.result;\n      } else if (err instanceof SkipAnimationSignal) {\n        result = err.result;\n      } else {\n        throw err;\n      }\n    } finally {\n      if (callId == state.asyncId) {\n        state.asyncId = parentId;\n        state.asyncTo = parentId ? prevTo : void 0;\n        state.promise = parentId ? prevPromise : void 0;\n      }\n    }\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(onRest)) {\n      _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates(() => {\n        onRest(result, target, target.item);\n      });\n    }\n    return result;\n  })();\n}\nfunction stopAsync(state, cancelId) {\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flush)(state.timeouts, (t) => t.cancel());\n  state.pauseQueue.clear();\n  state.resumeQueue.clear();\n  state.asyncId = state.asyncTo = state.promise = void 0;\n  if (cancelId)\n    state.cancelId = cancelId;\n}\nvar BailSignal = class extends Error {\n  constructor() {\n    super(\n      \"An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.\"\n    );\n  }\n};\nvar SkipAnimationSignal = class extends Error {\n  constructor() {\n    super(\"SkipAnimationSignal\");\n  }\n};\n\n// src/FrameValue.ts\n\n\nvar isFrameValue = (value) => value instanceof FrameValue;\nvar nextId = 1;\nvar FrameValue = class extends _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.FluidValue {\n  constructor() {\n    super(...arguments);\n    this.id = nextId++;\n    this._priority = 0;\n  }\n  get priority() {\n    return this._priority;\n  }\n  set priority(priority) {\n    if (this._priority != priority) {\n      this._priority = priority;\n      this._onPriorityChange(priority);\n    }\n  }\n  /** Get the current value */\n  get() {\n    const node = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this);\n    return node && node.getValue();\n  }\n  /** Create a spring that maps our value to another value */\n  to(...args) {\n    return _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.to(this, args);\n  }\n  /** @deprecated Use the `to` method instead. */\n  interpolate(...args) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.deprecateInterpolate)();\n    return _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.to(this, args);\n  }\n  toJSON() {\n    return this.get();\n  }\n  observerAdded(count) {\n    if (count == 1)\n      this._attach();\n  }\n  observerRemoved(count) {\n    if (count == 0)\n      this._detach();\n  }\n  /** Called when the first child is added. */\n  _attach() {\n  }\n  /** Called when the last child is removed. */\n  _detach() {\n  }\n  /** Tell our children about our new value */\n  _onChange(value, idle = false) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.callFluidObservers)(this, {\n      type: \"change\",\n      parent: this,\n      value,\n      idle\n    });\n  }\n  /** Tell our children about our new priority */\n  _onPriorityChange(priority) {\n    if (!this.idle) {\n      _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.frameLoop.sort(this);\n    }\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.callFluidObservers)(this, {\n      type: \"priority\",\n      parent: this,\n      priority\n    });\n  }\n};\n\n// src/SpringPhase.ts\nvar $P = Symbol.for(\"SpringPhase\");\nvar HAS_ANIMATED = 1;\nvar IS_ANIMATING = 2;\nvar IS_PAUSED = 4;\nvar hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;\nvar isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;\nvar isPaused = (target) => (target[$P] & IS_PAUSED) > 0;\nvar setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;\nvar setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;\n\n// src/SpringValue.ts\nvar SpringValue = class extends FrameValue {\n  constructor(arg1, arg2) {\n    super();\n    /** The animation state */\n    this.animation = new Animation();\n    /** Some props have customizable default values */\n    this.defaultProps = {};\n    /** The state for `runAsync` calls */\n    this._state = {\n      paused: false,\n      delayed: false,\n      pauseQueue: /* @__PURE__ */ new Set(),\n      resumeQueue: /* @__PURE__ */ new Set(),\n      timeouts: /* @__PURE__ */ new Set()\n    };\n    /** The promise resolvers of pending `start` calls */\n    this._pendingCalls = /* @__PURE__ */ new Set();\n    /** The counter for tracking `scheduleProps` calls */\n    this._lastCallId = 0;\n    /** The last `scheduleProps` call that changed the `to` prop */\n    this._lastToId = 0;\n    this._memoizedDuration = 0;\n    if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(arg1) || !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(arg2)) {\n      const props = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(arg1) ? { ...arg1 } : { ...arg2, from: arg1 };\n      if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.default)) {\n        props.default = true;\n      }\n      this.start(props);\n    }\n  }\n  /** Equals true when not advancing on each frame. */\n  get idle() {\n    return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);\n  }\n  get goal() {\n    return (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(this.animation.to);\n  }\n  get velocity() {\n    const node = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this);\n    return node instanceof _react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.AnimatedValue ? node.lastVelocity || 0 : node.getPayload().map((node2) => node2.lastVelocity || 0);\n  }\n  /**\n   * When true, this value has been animated at least once.\n   */\n  get hasAnimated() {\n    return hasAnimated(this);\n  }\n  /**\n   * When true, this value has an unfinished animation,\n   * which is either active or paused.\n   */\n  get isAnimating() {\n    return isAnimating(this);\n  }\n  /**\n   * When true, all current and future animations are paused.\n   */\n  get isPaused() {\n    return isPaused(this);\n  }\n  /**\n   *\n   *\n   */\n  get isDelayed() {\n    return this._state.delayed;\n  }\n  /** Advance the current animation by a number of milliseconds */\n  advance(dt) {\n    let idle = true;\n    let changed = false;\n    const anim = this.animation;\n    let { toValues } = anim;\n    const { config: config2 } = anim;\n    const payload = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getPayload)(anim.to);\n    if (!payload && (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(anim.to)) {\n      toValues = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(anim.to));\n    }\n    anim.values.forEach((node2, i) => {\n      if (node2.done)\n        return;\n      const to2 = (\n        // Animated strings always go from 0 to 1.\n        node2.constructor == _react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]\n      );\n      let finished = anim.immediate;\n      let position = to2;\n      if (!finished) {\n        position = node2.lastPosition;\n        if (config2.tension <= 0) {\n          node2.done = true;\n          return;\n        }\n        let elapsed = node2.elapsedTime += dt;\n        const from = anim.fromValues[i];\n        const v0 = node2.v0 != null ? node2.v0 : node2.v0 = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;\n        let velocity;\n        const precision = config2.precision || (from == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from) * 1e-3));\n        if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(config2.duration)) {\n          let p = 1;\n          if (config2.duration > 0) {\n            if (this._memoizedDuration !== config2.duration) {\n              this._memoizedDuration = config2.duration;\n              if (node2.durationProgress > 0) {\n                node2.elapsedTime = config2.duration * node2.durationProgress;\n                elapsed = node2.elapsedTime += dt;\n              }\n            }\n            p = (config2.progress || 0) + elapsed / this._memoizedDuration;\n            p = p > 1 ? 1 : p < 0 ? 0 : p;\n            node2.durationProgress = p;\n          }\n          position = from + config2.easing(p) * (to2 - from);\n          velocity = (position - node2.lastPosition) / dt;\n          finished = p == 1;\n        } else if (config2.decay) {\n          const decay = config2.decay === true ? 0.998 : config2.decay;\n          const e = Math.exp(-(1 - decay) * elapsed);\n          position = from + v0 / (1 - decay) * (1 - e);\n          finished = Math.abs(node2.lastPosition - position) <= precision;\n          velocity = v0 * e;\n        } else {\n          velocity = node2.lastVelocity == null ? v0 : node2.lastVelocity;\n          const restVelocity = config2.restVelocity || precision / 10;\n          const bounceFactor = config2.clamp ? 0 : config2.bounce;\n          const canBounce = !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(bounceFactor);\n          const isGrowing = from == to2 ? node2.v0 > 0 : from < to2;\n          let isMoving;\n          let isBouncing = false;\n          const step = 1;\n          const numSteps = Math.ceil(dt / step);\n          for (let n = 0; n < numSteps; ++n) {\n            isMoving = Math.abs(velocity) > restVelocity;\n            if (!isMoving) {\n              finished = Math.abs(to2 - position) <= precision;\n              if (finished) {\n                break;\n              }\n            }\n            if (canBounce) {\n              isBouncing = position == to2 || position > to2 == isGrowing;\n              if (isBouncing) {\n                velocity = -velocity * bounceFactor;\n                position = to2;\n              }\n            }\n            const springForce = -config2.tension * 1e-6 * (position - to2);\n            const dampingForce = -config2.friction * 1e-3 * velocity;\n            const acceleration = (springForce + dampingForce) / config2.mass;\n            velocity = velocity + acceleration * step;\n            position = position + velocity * step;\n          }\n        }\n        node2.lastVelocity = velocity;\n        if (Number.isNaN(position)) {\n          console.warn(`Got NaN while animating:`, this);\n          finished = true;\n        }\n      }\n      if (payload && !payload[i].done) {\n        finished = false;\n      }\n      if (finished) {\n        node2.done = true;\n      } else {\n        idle = false;\n      }\n      if (node2.setValue(position, config2.round)) {\n        changed = true;\n      }\n    });\n    const node = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this);\n    const currVal = node.getValue();\n    if (idle) {\n      const finalVal = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(anim.to);\n      if ((currVal !== finalVal || changed) && !config2.decay) {\n        node.setValue(finalVal);\n        this._onChange(finalVal);\n      } else if (changed && config2.decay) {\n        this._onChange(currVal);\n      }\n      this._stop();\n    } else if (changed) {\n      this._onChange(currVal);\n    }\n  }\n  /** Set the current value, while stopping the current animation */\n  set(value) {\n    _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates(() => {\n      this._stop();\n      this._focus(value);\n      this._set(value);\n    });\n    return this;\n  }\n  /**\n   * Freeze the active animation in time, as well as any updates merged\n   * before `resume` is called.\n   */\n  pause() {\n    this._update({ pause: true });\n  }\n  /** Resume the animation if paused. */\n  resume() {\n    this._update({ pause: false });\n  }\n  /** Skip to the end of the current animation. */\n  finish() {\n    if (isAnimating(this)) {\n      const { to: to2, config: config2 } = this.animation;\n      _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates(() => {\n        this._onStart();\n        if (!config2.decay) {\n          this._set(to2, false);\n        }\n        this._stop();\n      });\n    }\n    return this;\n  }\n  /** Push props into the pending queue. */\n  update(props) {\n    const queue = this.queue || (this.queue = []);\n    queue.push(props);\n    return this;\n  }\n  start(to2, arg2) {\n    let queue;\n    if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(to2)) {\n      queue = [_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(to2) ? to2 : { ...arg2, to: to2 }];\n    } else {\n      queue = this.queue || [];\n      this.queue = [];\n    }\n    return Promise.all(\n      queue.map((props) => {\n        const up = this._update(props);\n        return up;\n      })\n    ).then((results) => getCombinedResult(this, results));\n  }\n  /**\n   * Stop the current animation, and cancel any delayed updates.\n   *\n   * Pass `true` to call `onRest` with `cancelled: true`.\n   */\n  stop(cancel) {\n    const { to: to2 } = this.animation;\n    this._focus(this.get());\n    stopAsync(this._state, cancel && this._lastCallId);\n    _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates(() => this._stop(to2, cancel));\n    return this;\n  }\n  /** Restart the animation. */\n  reset() {\n    this._update({ reset: true });\n  }\n  /** @internal */\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._start();\n    } else if (event.type == \"priority\") {\n      this.priority = event.priority + 1;\n    }\n  }\n  /**\n   * Parse the `to` and `from` range from the given `props` object.\n   *\n   * This also ensures the initial value is available to animated components\n   * during the render phase.\n   */\n  _prepareNode(props) {\n    const key = this.key || \"\";\n    let { to: to2, from } = props;\n    to2 = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(to2) ? to2[key] : to2;\n    if (to2 == null || isAsyncTo(to2)) {\n      to2 = void 0;\n    }\n    from = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(from) ? from[key] : from;\n    if (from == null) {\n      from = void 0;\n    }\n    const range = { to: to2, from };\n    if (!hasAnimated(this)) {\n      if (props.reverse)\n        [to2, from] = [from, to2];\n      from = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(from);\n      if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(from)) {\n        this._set(from);\n      } else if (!(0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this)) {\n        this._set(to2);\n      }\n    }\n    return range;\n  }\n  /** Every update is processed by this method before merging. */\n  _update({ ...props }, isLoop) {\n    const { key, defaultProps } = this;\n    if (props.default)\n      Object.assign(\n        defaultProps,\n        getDefaultProps(\n          props,\n          (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value\n        )\n      );\n    mergeActiveFn(this, props, \"onProps\");\n    sendEvent(this, \"onProps\", props, this);\n    const range = this._prepareNode(props);\n    if (Object.isFrozen(this)) {\n      throw Error(\n        \"Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?\"\n      );\n    }\n    const state = this._state;\n    return scheduleProps(++this._lastCallId, {\n      key,\n      props,\n      defaultProps,\n      state,\n      actions: {\n        pause: () => {\n          if (!isPaused(this)) {\n            setPausedBit(this, true);\n            (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flushCalls)(state.pauseQueue);\n            sendEvent(\n              this,\n              \"onPause\",\n              getFinishedResult(this, checkFinished(this, this.animation.to)),\n              this\n            );\n          }\n        },\n        resume: () => {\n          if (isPaused(this)) {\n            setPausedBit(this, false);\n            if (isAnimating(this)) {\n              this._resume();\n            }\n            (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flushCalls)(state.resumeQueue);\n            sendEvent(\n              this,\n              \"onResume\",\n              getFinishedResult(this, checkFinished(this, this.animation.to)),\n              this\n            );\n          }\n        },\n        start: this._merge.bind(this, range)\n      }\n    }).then((result) => {\n      if (props.loop && result.finished && !(isLoop && result.noop)) {\n        const nextProps = createLoopUpdate(props);\n        if (nextProps) {\n          return this._update(nextProps, true);\n        }\n      }\n      return result;\n    });\n  }\n  /** Merge props into the current animation */\n  _merge(range, props, resolve) {\n    if (props.cancel) {\n      this.stop(true);\n      return resolve(getCancelledResult(this));\n    }\n    const hasToProp = !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(range.to);\n    const hasFromProp = !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(range.from);\n    if (hasToProp || hasFromProp) {\n      if (props.callId > this._lastToId) {\n        this._lastToId = props.callId;\n      } else {\n        return resolve(getCancelledResult(this));\n      }\n    }\n    const { key, defaultProps, animation: anim } = this;\n    const { to: prevTo, from: prevFrom } = anim;\n    let { to: to2 = prevTo, from = prevFrom } = range;\n    if (hasFromProp && !hasToProp && (!props.default || _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(to2))) {\n      to2 = from;\n    }\n    if (props.reverse)\n      [to2, from] = [from, to2];\n    const hasFromChanged = !(0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(from, prevFrom);\n    if (hasFromChanged) {\n      anim.from = from;\n    }\n    from = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(from);\n    const hasToChanged = !(0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(to2, prevTo);\n    if (hasToChanged) {\n      this._focus(to2);\n    }\n    const hasAsyncTo = isAsyncTo(props.to);\n    const { config: config2 } = anim;\n    const { decay, velocity } = config2;\n    if (hasToProp || hasFromProp) {\n      config2.velocity = 0;\n    }\n    if (props.config && !hasAsyncTo) {\n      mergeConfig(\n        config2,\n        callProp(props.config, key),\n        // Avoid calling the same \"config\" prop twice.\n        props.config !== defaultProps.config ? callProp(defaultProps.config, key) : void 0\n      );\n    }\n    let node = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this);\n    if (!node || _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(to2)) {\n      return resolve(getFinishedResult(this, true));\n    }\n    const reset = (\n      // When `reset` is undefined, the `from` prop implies `reset: true`,\n      // except for declarative updates. When `reset` is defined, there\n      // must exist a value to animate from.\n      _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props.reset) ? hasFromProp && !props.default : !_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(from) && matchProp(props.reset, key)\n    );\n    const value = reset ? from : this.get();\n    const goal = computeGoal(to2);\n    const isAnimatable = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.num(goal) || _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(goal) || (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isAnimatedString)(goal);\n    const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps.immediate || props.immediate, key));\n    if (hasToChanged) {\n      const nodeType = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimatedType)(to2);\n      if (nodeType !== node.constructor) {\n        if (immediate) {\n          node = this._set(goal);\n        } else\n          throw Error(\n            `Cannot animate between ${node.constructor.name} and ${nodeType.name}, as the \"to\" prop suggests`\n          );\n      }\n    }\n    const goalType = node.constructor;\n    let started = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(to2);\n    let finished = false;\n    if (!started) {\n      const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;\n      if (hasToChanged || hasValueChanged) {\n        finished = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(computeGoal(value), goal);\n        started = !finished;\n      }\n      if (!(0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(anim.immediate, immediate) && !immediate || !(0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(config2.decay, decay) || !(0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(config2.velocity, velocity)) {\n        started = true;\n      }\n    }\n    if (finished && isAnimating(this)) {\n      if (anim.changed && !reset) {\n        started = true;\n      } else if (!started) {\n        this._stop(prevTo);\n      }\n    }\n    if (!hasAsyncTo) {\n      if (started || (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(prevTo)) {\n        anim.values = node.getPayload();\n        anim.toValues = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(to2) ? null : goalType == _react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.AnimatedString ? [1] : (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(goal);\n      }\n      if (anim.immediate != immediate) {\n        anim.immediate = immediate;\n        if (!immediate && !reset) {\n          this._set(prevTo);\n        }\n      }\n      if (started) {\n        const { onRest } = anim;\n        (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));\n        const result = getFinishedResult(this, checkFinished(this, prevTo));\n        (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flushCalls)(this._pendingCalls, result);\n        this._pendingCalls.add(resolve);\n        if (anim.changed)\n          _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates(() => {\n            anim.changed = !reset;\n            onRest?.(result, this);\n            if (reset) {\n              callProp(defaultProps.onRest, result);\n            } else {\n              anim.onStart?.(result, this);\n            }\n          });\n      }\n    }\n    if (reset) {\n      this._set(value);\n    }\n    if (hasAsyncTo) {\n      resolve(runAsync(props.to, props, this._state, this));\n    } else if (started) {\n      this._start();\n    } else if (isAnimating(this) && !hasToChanged) {\n      this._pendingCalls.add(resolve);\n    } else {\n      resolve(getNoopResult(value));\n    }\n  }\n  /** Update the `animation.to` value, which might be a `FluidValue` */\n  _focus(value) {\n    const anim = this.animation;\n    if (value !== anim.to) {\n      if ((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidObservers)(this)) {\n        this._detach();\n      }\n      anim.to = value;\n      if ((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidObservers)(this)) {\n        this._attach();\n      }\n    }\n  }\n  _attach() {\n    let priority = 0;\n    const { to: to2 } = this.animation;\n    if ((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(to2)) {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.addFluidObserver)(to2, this);\n      if (isFrameValue(to2)) {\n        priority = to2.priority + 1;\n      }\n    }\n    this.priority = priority;\n  }\n  _detach() {\n    const { to: to2 } = this.animation;\n    if ((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(to2)) {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.removeFluidObserver)(to2, this);\n    }\n  }\n  /**\n   * Update the current value from outside the frameloop,\n   * and return the `Animated` node.\n   */\n  _set(arg, idle = true) {\n    const value = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(arg);\n    if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(value)) {\n      const oldNode = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this);\n      if (!oldNode || !(0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(value, oldNode.getValue())) {\n        const nodeType = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimatedType)(value);\n        if (!oldNode || oldNode.constructor != nodeType) {\n          (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.setAnimated)(this, nodeType.create(value));\n        } else {\n          oldNode.setValue(value);\n        }\n        if (oldNode) {\n          _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates(() => {\n            this._onChange(value, idle);\n          });\n        }\n      }\n    }\n    return (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this);\n  }\n  _onStart() {\n    const anim = this.animation;\n    if (!anim.changed) {\n      anim.changed = true;\n      sendEvent(\n        this,\n        \"onStart\",\n        getFinishedResult(this, checkFinished(this, anim.to)),\n        this\n      );\n    }\n  }\n  _onChange(value, idle) {\n    if (!idle) {\n      this._onStart();\n      callProp(this.animation.onChange, value, this);\n    }\n    callProp(this.defaultProps.onChange, value, this);\n    super._onChange(value, idle);\n  }\n  // This method resets the animation state (even if already animating) to\n  // ensure the latest from/to range is used, and it also ensures this spring\n  // is added to the frameloop.\n  _start() {\n    const anim = this.animation;\n    (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this).reset((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(anim.to));\n    if (!anim.immediate) {\n      anim.fromValues = anim.values.map((node) => node.lastPosition);\n    }\n    if (!isAnimating(this)) {\n      setActiveBit(this, true);\n      if (!isPaused(this)) {\n        this._resume();\n      }\n    }\n  }\n  _resume() {\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.skipAnimation) {\n      this.finish();\n    } else {\n      _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.frameLoop.start(this);\n    }\n  }\n  /**\n   * Exit the frameloop and notify `onRest` listeners.\n   *\n   * Always wrap `_stop` calls with `batchedUpdates`.\n   */\n  _stop(goal, cancel) {\n    if (isAnimating(this)) {\n      setActiveBit(this, false);\n      const anim = this.animation;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(anim.values, (node) => {\n        node.done = true;\n      });\n      if (anim.toValues) {\n        anim.onChange = anim.onPause = anim.onResume = void 0;\n      }\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.callFluidObservers)(this, {\n        type: \"idle\",\n        parent: this\n      });\n      const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal ?? anim.to));\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flushCalls)(this._pendingCalls, result);\n      if (anim.changed) {\n        anim.changed = false;\n        sendEvent(this, \"onRest\", result, this);\n      }\n    }\n  }\n};\nfunction checkFinished(target, to2) {\n  const goal = computeGoal(to2);\n  const value = computeGoal(target.get());\n  return (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(value, goal);\n}\nfunction createLoopUpdate(props, loop = props.loop, to2 = props.to) {\n  const loopRet = callProp(loop);\n  if (loopRet) {\n    const overrides = loopRet !== true && inferTo(loopRet);\n    const reverse = (overrides || props).reverse;\n    const reset = !overrides || overrides.reset;\n    return createUpdate({\n      ...props,\n      loop,\n      // Avoid updating default props when looping.\n      default: false,\n      // Never loop the `pause` prop.\n      pause: void 0,\n      // For the \"reverse\" prop to loop as expected, the \"to\" prop\n      // must be undefined. The \"reverse\" prop is ignored when the\n      // \"to\" prop is an array or function.\n      to: !reverse || isAsyncTo(to2) ? to2 : void 0,\n      // Ignore the \"from\" prop except on reset.\n      from: reset ? props.from : void 0,\n      reset,\n      // The \"loop\" prop can return a \"useSpring\" props object to\n      // override any of the original props.\n      ...overrides\n    });\n  }\n}\nfunction createUpdate(props) {\n  const { to: to2, from } = props = inferTo(props);\n  const keys = /* @__PURE__ */ new Set();\n  if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(to2))\n    findDefined(to2, keys);\n  if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(from))\n    findDefined(from, keys);\n  props.keys = keys.size ? Array.from(keys) : null;\n  return props;\n}\nfunction declareUpdate(props) {\n  const update2 = createUpdate(props);\n  if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(update2.default)) {\n    update2.default = getDefaultProps(update2);\n  }\n  return update2;\n}\nfunction findDefined(values, keys) {\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(values, (value, key) => value != null && keys.add(key));\n}\nvar ACTIVE_EVENTS = [\n  \"onStart\",\n  \"onRest\",\n  \"onChange\",\n  \"onPause\",\n  \"onResume\"\n];\nfunction mergeActiveFn(target, props, type) {\n  target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;\n}\nfunction sendEvent(target, type, ...args) {\n  target.animation[type]?.(...args);\n  target.defaultProps[type]?.(...args);\n}\n\n// src/Controller.ts\n\nvar BATCHED_EVENTS = [\"onStart\", \"onChange\", \"onRest\"];\nvar nextId2 = 1;\nvar Controller = class {\n  constructor(props, flush3) {\n    this.id = nextId2++;\n    /** The animated values */\n    this.springs = {};\n    /** The queue of props passed to the `update` method. */\n    this.queue = [];\n    /** The counter for tracking `scheduleProps` calls */\n    this._lastAsyncId = 0;\n    /** The values currently being animated */\n    this._active = /* @__PURE__ */ new Set();\n    /** The values that changed recently */\n    this._changed = /* @__PURE__ */ new Set();\n    /** Equals false when `onStart` listeners can be called */\n    this._started = false;\n    /** State used by the `runAsync` function */\n    this._state = {\n      paused: false,\n      pauseQueue: /* @__PURE__ */ new Set(),\n      resumeQueue: /* @__PURE__ */ new Set(),\n      timeouts: /* @__PURE__ */ new Set()\n    };\n    /** The event queues that are flushed once per frame maximum */\n    this._events = {\n      onStart: /* @__PURE__ */ new Map(),\n      onChange: /* @__PURE__ */ new Map(),\n      onRest: /* @__PURE__ */ new Map()\n    };\n    this._onFrame = this._onFrame.bind(this);\n    if (flush3) {\n      this._flush = flush3;\n    }\n    if (props) {\n      this.start({ default: true, ...props });\n    }\n  }\n  /**\n   * Equals `true` when no spring values are in the frameloop, and\n   * no async animation is currently active.\n   */\n  get idle() {\n    return !this._state.asyncTo && Object.values(this.springs).every((spring) => {\n      return spring.idle && !spring.isDelayed && !spring.isPaused;\n    });\n  }\n  get item() {\n    return this._item;\n  }\n  set item(item) {\n    this._item = item;\n  }\n  /** Get the current values of our springs */\n  get() {\n    const values = {};\n    this.each((spring, key) => values[key] = spring.get());\n    return values;\n  }\n  /** Set the current values without animating. */\n  set(values) {\n    for (const key in values) {\n      const value = values[key];\n      if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(value)) {\n        this.springs[key].set(value);\n      }\n    }\n  }\n  /** Push an update onto the queue of each value. */\n  update(props) {\n    if (props) {\n      this.queue.push(createUpdate(props));\n    }\n    return this;\n  }\n  /**\n   * Start the queued animations for every spring, and resolve the returned\n   * promise once all queued animations have finished or been cancelled.\n   *\n   * When you pass a queue (instead of nothing), that queue is used instead of\n   * the queued animations added with the `update` method, which are left alone.\n   */\n  start(props) {\n    let { queue } = this;\n    if (props) {\n      queue = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(props).map(createUpdate);\n    } else {\n      this.queue = [];\n    }\n    if (this._flush) {\n      return this._flush(this, queue);\n    }\n    prepareKeys(this, queue);\n    return flushUpdateQueue(this, queue);\n  }\n  /** @internal */\n  stop(arg, keys) {\n    if (arg !== !!arg) {\n      keys = arg;\n    }\n    if (keys) {\n      const springs = this.springs;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(keys), (key) => springs[key].stop(!!arg));\n    } else {\n      stopAsync(this._state, this._lastAsyncId);\n      this.each((spring) => spring.stop(!!arg));\n    }\n    return this;\n  }\n  /** Freeze the active animation in time */\n  pause(keys) {\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(keys)) {\n      this.start({ pause: true });\n    } else {\n      const springs = this.springs;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(keys), (key) => springs[key].pause());\n    }\n    return this;\n  }\n  /** Resume the animation if paused. */\n  resume(keys) {\n    if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(keys)) {\n      this.start({ pause: false });\n    } else {\n      const springs = this.springs;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(keys), (key) => springs[key].resume());\n    }\n    return this;\n  }\n  /** Call a function once per spring value */\n  each(iterator) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(this.springs, iterator);\n  }\n  /** @internal Called at the end of every animation frame */\n  _onFrame() {\n    const { onStart, onChange, onRest } = this._events;\n    const active = this._active.size > 0;\n    const changed = this._changed.size > 0;\n    if (active && !this._started || changed && !this._started) {\n      this._started = true;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flush)(onStart, ([onStart2, result]) => {\n        result.value = this.get();\n        onStart2(result, this, this._item);\n      });\n    }\n    const idle = !active && this._started;\n    const values = changed || idle && onRest.size ? this.get() : null;\n    if (changed && onChange.size) {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flush)(onChange, ([onChange2, result]) => {\n        result.value = values;\n        onChange2(result, this, this._item);\n      });\n    }\n    if (idle) {\n      this._started = false;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flush)(onRest, ([onRest2, result]) => {\n        result.value = values;\n        onRest2(result, this, this._item);\n      });\n    }\n  }\n  /** @internal */\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      this._changed.add(event.parent);\n      if (!event.idle) {\n        this._active.add(event.parent);\n      }\n    } else if (event.type == \"idle\") {\n      this._active.delete(event.parent);\n    } else\n      return;\n    _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.onFrame(this._onFrame);\n  }\n};\nfunction flushUpdateQueue(ctrl, queue) {\n  return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(\n    (results) => getCombinedResult(ctrl, results)\n  );\n}\nasync function flushUpdate(ctrl, props, isLoop) {\n  const { keys, to: to2, from, loop, onRest, onResolve } = props;\n  const defaults2 = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(props.default) && props.default;\n  if (loop) {\n    props.loop = false;\n  }\n  if (to2 === false)\n    props.to = null;\n  if (from === false)\n    props.from = null;\n  const asyncTo = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(to2) || _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(to2) ? to2 : void 0;\n  if (asyncTo) {\n    props.to = void 0;\n    props.onRest = void 0;\n    if (defaults2) {\n      defaults2.onRest = void 0;\n    }\n  } else {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(BATCHED_EVENTS, (key) => {\n      const handler = props[key];\n      if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(handler)) {\n        const queue = ctrl[\"_events\"][key];\n        props[key] = ({ finished, cancelled }) => {\n          const result2 = queue.get(handler);\n          if (result2) {\n            if (!finished)\n              result2.finished = false;\n            if (cancelled)\n              result2.cancelled = true;\n          } else {\n            queue.set(handler, {\n              value: null,\n              finished: finished || false,\n              cancelled: cancelled || false\n            });\n          }\n        };\n        if (defaults2) {\n          defaults2[key] = props[key];\n        }\n      }\n    });\n  }\n  const state = ctrl[\"_state\"];\n  if (props.pause === !state.paused) {\n    state.paused = props.pause;\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.flushCalls)(props.pause ? state.pauseQueue : state.resumeQueue);\n  } else if (state.paused) {\n    props.pause = true;\n  }\n  const promises = (keys || Object.keys(ctrl.springs)).map(\n    (key) => ctrl.springs[key].start(props)\n  );\n  const cancel = props.cancel === true || getDefaultProp(props, \"cancel\") === true;\n  if (asyncTo || cancel && state.asyncId) {\n    promises.push(\n      scheduleProps(++ctrl[\"_lastAsyncId\"], {\n        props,\n        state,\n        actions: {\n          pause: _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n          resume: _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.noop,\n          start(props2, resolve) {\n            if (cancel) {\n              stopAsync(state, ctrl[\"_lastAsyncId\"]);\n              resolve(getCancelledResult(ctrl));\n            } else {\n              props2.onRest = onRest;\n              resolve(\n                runAsync(\n                  asyncTo,\n                  props2,\n                  state,\n                  ctrl\n                )\n              );\n            }\n          }\n        }\n      })\n    );\n  }\n  if (state.paused) {\n    await new Promise((resume) => {\n      state.resumeQueue.add(resume);\n    });\n  }\n  const result = getCombinedResult(ctrl, await Promise.all(promises));\n  if (loop && result.finished && !(isLoop && result.noop)) {\n    const nextProps = createLoopUpdate(props, loop, to2);\n    if (nextProps) {\n      prepareKeys(ctrl, [nextProps]);\n      return flushUpdate(ctrl, nextProps, true);\n    }\n  }\n  if (onResolve) {\n    _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));\n  }\n  return result;\n}\nfunction getSprings(ctrl, props) {\n  const springs = { ...ctrl.springs };\n  if (props) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(props), (props2) => {\n      if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props2.keys)) {\n        props2 = createUpdate(props2);\n      }\n      if (!_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(props2.to)) {\n        props2 = { ...props2, to: void 0 };\n      }\n      prepareSprings(springs, props2, (key) => {\n        return createSpring(key);\n      });\n    });\n  }\n  setSprings(ctrl, springs);\n  return springs;\n}\nfunction setSprings(ctrl, springs) {\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.eachProp)(springs, (spring, key) => {\n    if (!ctrl.springs[key]) {\n      ctrl.springs[key] = spring;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.addFluidObserver)(spring, ctrl);\n    }\n  });\n}\nfunction createSpring(key, observer) {\n  const spring = new SpringValue();\n  spring.key = key;\n  if (observer) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.addFluidObserver)(spring, observer);\n  }\n  return spring;\n}\nfunction prepareSprings(springs, props, create) {\n  if (props.keys) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(props.keys, (key) => {\n      const spring = springs[key] || (springs[key] = create(key));\n      spring[\"_prepareNode\"](props);\n    });\n  }\n}\nfunction prepareKeys(ctrl, queue) {\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(queue, (props) => {\n    prepareSprings(ctrl.springs, props, (key) => {\n      return createSpring(key, ctrl);\n    });\n  });\n}\n\n// src/SpringContext.tsx\n\n\n\nvar SpringContext = ({\n  children,\n  ...props\n}) => {\n  const inherited = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ctx);\n  const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;\n  props = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useMemoOne)(() => ({ pause, immediate }), [pause, immediate]);\n  const { Provider } = ctx;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Provider, { value: props }, children);\n};\nvar ctx = makeContext(SpringContext, {});\nSpringContext.Provider = ctx.Provider;\nSpringContext.Consumer = ctx.Consumer;\nfunction makeContext(target, init) {\n  Object.assign(target, react__WEBPACK_IMPORTED_MODULE_1__.createContext(init));\n  target.Provider._context = target;\n  target.Consumer._context = target;\n  return target;\n}\n\n// src/SpringRef.ts\n\nvar SpringRef = () => {\n  const current = [];\n  const SpringRef2 = function(props) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.deprecateDirectCall)();\n    const results = [];\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(current, (ctrl, i) => {\n      if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update2 = _getProps(props, ctrl, i);\n        if (update2) {\n          results.push(ctrl.start(update2));\n        }\n      }\n    });\n    return results;\n  };\n  SpringRef2.current = current;\n  SpringRef2.add = function(ctrl) {\n    if (!current.includes(ctrl)) {\n      current.push(ctrl);\n    }\n  };\n  SpringRef2.delete = function(ctrl) {\n    const i = current.indexOf(ctrl);\n    if (~i)\n      current.splice(i, 1);\n  };\n  SpringRef2.pause = function() {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(current, (ctrl) => ctrl.pause(...arguments));\n    return this;\n  };\n  SpringRef2.resume = function() {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(current, (ctrl) => ctrl.resume(...arguments));\n    return this;\n  };\n  SpringRef2.set = function(values) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(current, (ctrl, i) => {\n      const update2 = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(values) ? values(i, ctrl) : values;\n      if (update2) {\n        ctrl.set(update2);\n      }\n    });\n  };\n  SpringRef2.start = function(props) {\n    const results = [];\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(current, (ctrl, i) => {\n      if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(props)) {\n        results.push(ctrl.start());\n      } else {\n        const update2 = this._getProps(props, ctrl, i);\n        if (update2) {\n          results.push(ctrl.start(update2));\n        }\n      }\n    });\n    return results;\n  };\n  SpringRef2.stop = function() {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(current, (ctrl) => ctrl.stop(...arguments));\n    return this;\n  };\n  SpringRef2.update = function(props) {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));\n    return this;\n  };\n  const _getProps = function(arg, ctrl, index) {\n    return _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(arg) ? arg(index, ctrl) : arg;\n  };\n  SpringRef2._getProps = _getProps;\n  return SpringRef2;\n};\n\n// src/hooks/useSprings.ts\nfunction useSprings(length, props, deps) {\n  const propsFn = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(props) && props;\n  if (propsFn && !deps)\n    deps = [];\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,\n    []\n  );\n  const layoutId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n  const forceUpdate = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useForceUpdate)();\n  const state = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => ({\n      ctrls: [],\n      queue: [],\n      flush(ctrl, updates2) {\n        const springs2 = getSprings(ctrl, updates2);\n        const canFlushSync = layoutId.current > 0 && !state.queue.length && !Object.keys(springs2).some((key) => !ctrl.springs[key]);\n        return canFlushSync ? flushUpdateQueue(ctrl, updates2) : new Promise((resolve) => {\n          setSprings(ctrl, springs2);\n          state.queue.push(() => {\n            resolve(flushUpdateQueue(ctrl, updates2));\n          });\n          forceUpdate();\n        });\n      }\n    }),\n    []\n  );\n  const ctrls = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)([...state.ctrls]);\n  const updates = [];\n  const prevLength = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.usePrev)(length) || 0;\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(ctrls.current.slice(length, prevLength), (ctrl) => {\n      detachRefs(ctrl, ref);\n      ctrl.stop(true);\n    });\n    ctrls.current.length = length;\n    declareUpdates(prevLength, length);\n  }, [length]);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n    declareUpdates(0, Math.min(prevLength, length));\n  }, deps);\n  function declareUpdates(startIndex, endIndex) {\n    for (let i = startIndex; i < endIndex; i++) {\n      const ctrl = ctrls.current[i] || (ctrls.current[i] = new Controller(null, state.flush));\n      const update2 = propsFn ? propsFn(i, ctrl) : props[i];\n      if (update2) {\n        updates[i] = declareUpdate(update2);\n      }\n    }\n  }\n  const springs = ctrls.current.map((ctrl, i) => getSprings(ctrl, updates[i]));\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SpringContext);\n  const prevContext = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.usePrev)(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n    layoutId.current++;\n    state.ctrls = ctrls.current;\n    const { queue } = state;\n    if (queue.length) {\n      state.queue = [];\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(queue, (cb) => cb());\n    }\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(ctrls.current, (ctrl, i) => {\n      ref?.add(ctrl);\n      if (hasContext) {\n        ctrl.start({ default: context });\n      }\n      const update2 = updates[i];\n      if (update2) {\n        replaceRef(ctrl, update2.ref);\n        if (ctrl.ref) {\n          ctrl.queue.push(update2);\n        } else {\n          ctrl.start(update2);\n        }\n      }\n    });\n  });\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useOnce)(() => () => {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(state.ctrls, (ctrl) => ctrl.stop(true));\n  });\n  const values = springs.map((x) => ({ ...x }));\n  return ref ? [values, ref] : values;\n}\n\n// src/hooks/useSpring.ts\nfunction useSpring(props, deps) {\n  const isFn = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(props);\n  const [[values], ref] = useSprings(\n    1,\n    isFn ? props : [props],\n    isFn ? deps || [] : deps\n  );\n  return isFn || arguments.length == 2 ? [values, ref] : values;\n}\n\n// src/hooks/useSpringRef.ts\n\nvar initSpringRef = () => SpringRef();\nvar useSpringRef = () => (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initSpringRef)[0];\n\n// src/hooks/useSpringValue.ts\n\nvar useSpringValue = (initial, props) => {\n  const springValue = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useConstant)(() => new SpringValue(initial, props));\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useOnce)(() => () => {\n    springValue.stop();\n  });\n  return springValue;\n};\n\n// src/hooks/useTrail.ts\n\nfunction useTrail(length, propsArg, deps) {\n  const propsFn = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(propsArg) && propsArg;\n  if (propsFn && !deps)\n    deps = [];\n  let reverse = true;\n  let passedRef = void 0;\n  const result = useSprings(\n    length,\n    (i, ctrl) => {\n      const props = propsFn ? propsFn(i, ctrl) : propsArg;\n      passedRef = props.ref;\n      reverse = reverse && props.reverse;\n      return props;\n    },\n    // Ensure the props function is called when no deps exist.\n    // This works around the 3 argument rule.\n    deps || [{}]\n  );\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(result[1].current, (ctrl, i) => {\n      const parent = result[1].current[i + (reverse ? 1 : -1)];\n      replaceRef(ctrl, passedRef);\n      if (ctrl.ref) {\n        if (parent) {\n          ctrl.update({ to: parent.springs });\n        }\n        return;\n      }\n      if (parent) {\n        ctrl.start({ to: parent.springs });\n      } else {\n        ctrl.start();\n      }\n    });\n  }, deps);\n  if (propsFn || arguments.length == 3) {\n    const ref = passedRef ?? result[1];\n    ref[\"_getProps\"] = (propsArg2, ctrl, i) => {\n      const props = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(propsArg2) ? propsArg2(i, ctrl) : propsArg2;\n      if (props) {\n        const parent = ref.current[i + (props.reverse ? 1 : -1)];\n        if (parent)\n          props.to = parent.springs;\n        return props;\n      }\n    };\n    return result;\n  }\n  return result[0];\n}\n\n// src/hooks/useTransition.tsx\n\n\n\nfunction useTransition(data, props, deps) {\n  const propsFn = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(props) && props;\n  const {\n    reset,\n    sort,\n    trail = 0,\n    expires = true,\n    exitBeforeEnter = false,\n    onDestroyed,\n    ref: propsRef,\n    config: propsConfig\n  } = propsFn ? propsFn() : props;\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(\n    () => propsFn || arguments.length == 3 ? SpringRef() : void 0,\n    []\n  );\n  const items = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(data);\n  const transitions = [];\n  const usedTransitions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  const prevTransitions = reset ? null : usedTransitions.current;\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n    usedTransitions.current = transitions;\n  });\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useOnce)(() => {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(transitions, (t) => {\n      ref?.add(t.ctrl);\n      t.ctrl.ref = ref;\n    });\n    return () => {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(usedTransitions.current, (t) => {\n        if (t.expired) {\n          clearTimeout(t.expirationId);\n        }\n        detachRefs(t.ctrl, ref);\n        t.ctrl.stop(true);\n      });\n    };\n  });\n  const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);\n  const expired = reset && usedTransitions.current || [];\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(\n    () => (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(expired, ({ ctrl, item, key }) => {\n      detachRefs(ctrl, ref);\n      callProp(onDestroyed, item, key);\n    })\n  );\n  const reused = [];\n  if (prevTransitions)\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(prevTransitions, (t, i) => {\n      if (t.expired) {\n        clearTimeout(t.expirationId);\n        expired.push(t);\n      } else {\n        i = reused[i] = keys.indexOf(t.key);\n        if (~i)\n          transitions[i] = t;\n      }\n    });\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(items, (item, i) => {\n    if (!transitions[i]) {\n      transitions[i] = {\n        key: keys[i],\n        item,\n        phase: \"mount\" /* MOUNT */,\n        ctrl: new Controller()\n      };\n      transitions[i].ctrl.item = item;\n    }\n  });\n  if (reused.length) {\n    let i = -1;\n    const { leave } = propsFn ? propsFn() : props;\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(reused, (keyIndex, prevIndex) => {\n      const t = prevTransitions[prevIndex];\n      if (~keyIndex) {\n        i = transitions.indexOf(t);\n        transitions[i] = { ...t, item: items[keyIndex] };\n      } else if (leave) {\n        transitions.splice(++i, 0, t);\n      }\n    });\n  }\n  if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(sort)) {\n    transitions.sort((a, b) => sort(a.item, b.item));\n  }\n  let delay = -trail;\n  const forceUpdate = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useForceUpdate)();\n  const defaultProps = getDefaultProps(props);\n  const changes = /* @__PURE__ */ new Map();\n  const exitingTransitions = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(/* @__PURE__ */ new Map());\n  const forceChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(transitions, (t, i) => {\n    const key = t.key;\n    const prevPhase = t.phase;\n    const p = propsFn ? propsFn() : props;\n    let to2;\n    let phase;\n    const propsDelay = callProp(p.delay || 0, key);\n    if (prevPhase == \"mount\" /* MOUNT */) {\n      to2 = p.enter;\n      phase = \"enter\" /* ENTER */;\n    } else {\n      const isLeave = keys.indexOf(key) < 0;\n      if (prevPhase != \"leave\" /* LEAVE */) {\n        if (isLeave) {\n          to2 = p.leave;\n          phase = \"leave\" /* LEAVE */;\n        } else if (to2 = p.update) {\n          phase = \"update\" /* UPDATE */;\n        } else\n          return;\n      } else if (!isLeave) {\n        to2 = p.enter;\n        phase = \"enter\" /* ENTER */;\n      } else\n        return;\n    }\n    to2 = callProp(to2, t.item, i);\n    to2 = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.obj(to2) ? inferTo(to2) : { to: to2 };\n    if (!to2.config) {\n      const config2 = propsConfig || defaultProps.config;\n      to2.config = callProp(config2, t.item, i, phase);\n    }\n    delay += trail;\n    const payload = {\n      ...defaultProps,\n      // we need to add our props.delay value you here.\n      delay: propsDelay + delay,\n      ref: propsRef,\n      immediate: p.immediate,\n      // This prevents implied resets.\n      reset: false,\n      // Merge any phase-specific props.\n      ...to2\n    };\n    if (phase == \"enter\" /* ENTER */ && _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(payload.from)) {\n      const p2 = propsFn ? propsFn() : props;\n      const from = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(p2.initial) || prevTransitions ? p2.from : p2.initial;\n      payload.from = callProp(from, t.item, i);\n    }\n    const { onResolve } = payload;\n    payload.onResolve = (result) => {\n      callProp(onResolve, result);\n      const transitions2 = usedTransitions.current;\n      const t2 = transitions2.find((t3) => t3.key === key);\n      if (!t2)\n        return;\n      if (result.cancelled && t2.phase != \"update\" /* UPDATE */) {\n        return;\n      }\n      if (t2.ctrl.idle) {\n        const idle = transitions2.every((t3) => t3.ctrl.idle);\n        if (t2.phase == \"leave\" /* LEAVE */) {\n          const expiry = callProp(expires, t2.item);\n          if (expiry !== false) {\n            const expiryMs = expiry === true ? 0 : expiry;\n            t2.expired = true;\n            if (!idle && expiryMs > 0) {\n              if (expiryMs <= 2147483647)\n                t2.expirationId = setTimeout(forceUpdate, expiryMs);\n              return;\n            }\n          }\n        }\n        if (idle && transitions2.some((t3) => t3.expired)) {\n          exitingTransitions.current.delete(t2);\n          if (exitBeforeEnter) {\n            forceChange.current = true;\n          }\n          forceUpdate();\n        }\n      }\n    };\n    const springs = getSprings(t.ctrl, payload);\n    if (phase === \"leave\" /* LEAVE */ && exitBeforeEnter) {\n      exitingTransitions.current.set(t, { phase, springs, payload });\n    } else {\n      changes.set(t, { phase, springs, payload });\n    }\n  });\n  const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(SpringContext);\n  const prevContext = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.usePrev)(context);\n  const hasContext = context !== prevContext && hasProps(context);\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n    if (hasContext) {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(transitions, (t) => {\n        t.ctrl.start({ default: context });\n      });\n    }\n  }, [context]);\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(changes, (_, t) => {\n    if (exitingTransitions.current.size) {\n      const ind = transitions.findIndex((state) => state.key === t.key);\n      transitions.splice(ind, 1);\n    }\n  });\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(\n    () => {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(\n        exitingTransitions.current.size ? exitingTransitions.current : changes,\n        ({ phase, payload }, t) => {\n          const { ctrl } = t;\n          t.phase = phase;\n          ref?.add(ctrl);\n          if (hasContext && phase == \"enter\" /* ENTER */) {\n            ctrl.start({ default: context });\n          }\n          if (payload) {\n            replaceRef(ctrl, payload.ref);\n            if ((ctrl.ref || ref) && !forceChange.current) {\n              ctrl.update(payload);\n            } else {\n              ctrl.start(payload);\n              if (forceChange.current) {\n                forceChange.current = false;\n              }\n            }\n          }\n        }\n      );\n    },\n    reset ? void 0 : deps\n  );\n  const renderTransitions = (render) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, transitions.map((t, i) => {\n    const { springs } = changes.get(t) || t.ctrl;\n    const elem = render({ ...springs }, t.item, t, i);\n    return elem && elem.type ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      elem.type,\n      {\n        ...elem.props,\n        key: _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.str(t.key) || _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.num(t.key) ? t.key : t.ctrl.id,\n        ref: elem.ref\n      }\n    ) : elem;\n  }));\n  return ref ? [renderTransitions, ref] : renderTransitions;\n}\nvar nextKey = 1;\nfunction getKeys(items, { key, keys = key }, prevTransitions) {\n  if (keys === null) {\n    const reused = /* @__PURE__ */ new Set();\n    return items.map((item) => {\n      const t = prevTransitions && prevTransitions.find(\n        (t2) => t2.item === item && t2.phase !== \"leave\" /* LEAVE */ && !reused.has(t2)\n      );\n      if (t) {\n        reused.add(t);\n        return t.key;\n      }\n      return nextKey++;\n    });\n  }\n  return _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.und(keys) ? items : _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(keys) ? items.map(keys) : (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(keys);\n}\n\n// src/hooks/useScroll.ts\n\nvar useScroll = ({\n  container,\n  ...springOptions\n} = {}) => {\n  const [scrollValues, api] = useSpring(\n    () => ({\n      scrollX: 0,\n      scrollY: 0,\n      scrollXProgress: 0,\n      scrollYProgress: 0,\n      ...springOptions\n    }),\n    []\n  );\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n    const cleanupScroll = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.onScroll)(\n      ({ x, y }) => {\n        api.start({\n          scrollX: x.current,\n          scrollXProgress: x.progress,\n          scrollY: y.current,\n          scrollYProgress: y.progress\n        });\n      },\n      { container: container?.current || void 0 }\n    );\n    return () => {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(Object.values(scrollValues), (value) => value.stop());\n      cleanupScroll();\n    };\n  }, []);\n  return scrollValues;\n};\n\n// src/hooks/useResize.ts\n\nvar useResize = ({\n  container,\n  ...springOptions\n}) => {\n  const [sizeValues, api] = useSpring(\n    () => ({\n      width: 0,\n      height: 0,\n      ...springOptions\n    }),\n    []\n  );\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n    const cleanupScroll = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.onResize)(\n      ({ width, height }) => {\n        api.start({\n          width,\n          height,\n          immediate: sizeValues.width.get() === 0 || sizeValues.height.get() === 0\n        });\n      },\n      { container: container?.current || void 0 }\n    );\n    return () => {\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)(Object.values(sizeValues), (value) => value.stop());\n      cleanupScroll();\n    };\n  }, []);\n  return sizeValues;\n};\n\n// src/hooks/useInView.ts\n\n\nvar defaultThresholdOptions = {\n  any: 0,\n  all: 1\n};\nfunction useInView(props, args) {\n  const [isInView, setIsInView] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  const propsFn = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(props) && props;\n  const springsProps = propsFn ? propsFn() : {};\n  const { to: to2 = {}, from = {}, ...restSpringProps } = springsProps;\n  const intersectionArguments = propsFn ? args : props;\n  const [springs, api] = useSpring(() => ({ from, ...restSpringProps }), []);\n  (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect)(() => {\n    const element = ref.current;\n    const {\n      root,\n      once,\n      amount = \"any\",\n      ...restArgs\n    } = intersectionArguments ?? {};\n    if (!element || once && isInView || typeof IntersectionObserver === \"undefined\")\n      return;\n    const activeIntersections = /* @__PURE__ */ new WeakMap();\n    const onEnter = () => {\n      if (to2) {\n        api.start(to2);\n      }\n      setIsInView(true);\n      const cleanup = () => {\n        if (from) {\n          api.start(from);\n        }\n        setIsInView(false);\n      };\n      return once ? void 0 : cleanup;\n    };\n    const handleIntersection = (entries) => {\n      entries.forEach((entry) => {\n        const onLeave = activeIntersections.get(entry.target);\n        if (entry.isIntersecting === Boolean(onLeave)) {\n          return;\n        }\n        if (entry.isIntersecting) {\n          const newOnLeave = onEnter();\n          if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(newOnLeave)) {\n            activeIntersections.set(entry.target, newOnLeave);\n          } else {\n            observer.unobserve(entry.target);\n          }\n        } else if (onLeave) {\n          onLeave();\n          activeIntersections.delete(entry.target);\n        }\n      });\n    };\n    const observer = new IntersectionObserver(handleIntersection, {\n      root: root && root.current || void 0,\n      threshold: typeof amount === \"number\" || Array.isArray(amount) ? amount : defaultThresholdOptions[amount],\n      ...restArgs\n    });\n    observer.observe(element);\n    return () => observer.unobserve(element);\n  }, [intersectionArguments]);\n  if (propsFn) {\n    return [ref, springs];\n  }\n  return [ref, isInView];\n}\n\n// src/components/Spring.tsx\nfunction Spring({ children, ...props }) {\n  return children(useSpring(props));\n}\n\n// src/components/Trail.tsx\n\nfunction Trail({\n  items,\n  children,\n  ...props\n}) {\n  const trails = useTrail(items.length, props);\n  return items.map((item, index) => {\n    const result = children(item, index);\n    return _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.fun(result) ? result(trails[index]) : result;\n  });\n}\n\n// src/components/Transition.tsx\nfunction Transition({\n  items,\n  children,\n  ...props\n}) {\n  return useTransition(items, props)(children);\n}\n\n// src/interpolate.ts\n\n\n// src/Interpolation.ts\n\n\nvar Interpolation = class extends FrameValue {\n  constructor(source, args) {\n    super();\n    this.source = source;\n    /** Equals false when in the frameloop */\n    this.idle = true;\n    /** The inputs which are currently animating */\n    this._active = /* @__PURE__ */ new Set();\n    this.calc = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.createInterpolator)(...args);\n    const value = this._get();\n    const nodeType = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimatedType)(value);\n    (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.setAnimated)(this, nodeType.create(value));\n  }\n  advance(_dt) {\n    const value = this._get();\n    const oldValue = this.get();\n    if (!(0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.isEqual)(value, oldValue)) {\n      (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getAnimated)(this).setValue(value);\n      this._onChange(value, this.idle);\n    }\n    if (!this.idle && checkIdle(this._active)) {\n      becomeIdle(this);\n    }\n  }\n  _get() {\n    const inputs = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.is.arr(this.source) ? this.source.map(_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue) : (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.getFluidValue)(this.source));\n    return this.calc(...inputs);\n  }\n  _start() {\n    if (this.idle && !checkIdle(this._active)) {\n      this.idle = false;\n      (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)((0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getPayload)(this), (node) => {\n        node.done = false;\n      });\n      if (_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.skipAnimation) {\n        _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates(() => this.advance());\n        becomeIdle(this);\n      } else {\n        _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.frameLoop.start(this);\n      }\n    }\n  }\n  // Observe our sources only when we're observed.\n  _attach() {\n    let priority = 1;\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.source), (source) => {\n      if ((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(source)) {\n        (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.addFluidObserver)(source, this);\n      }\n      if (isFrameValue(source)) {\n        if (!source.idle) {\n          this._active.add(source);\n        }\n        priority = Math.max(priority, source.priority + 1);\n      }\n    });\n    this.priority = priority;\n    this._start();\n  }\n  // Stop observing our sources once we have no observers.\n  _detach() {\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.source), (source) => {\n      if ((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.hasFluidValue)(source)) {\n        (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.removeFluidObserver)(source, this);\n      }\n    });\n    this._active.clear();\n    becomeIdle(this);\n  }\n  /** @internal */\n  eventObserved(event) {\n    if (event.type == \"change\") {\n      if (event.idle) {\n        this.advance();\n      } else {\n        this._active.add(event.parent);\n        this._start();\n      }\n    } else if (event.type == \"idle\") {\n      this._active.delete(event.parent);\n    } else if (event.type == \"priority\") {\n      this.priority = (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.toArray)(this.source).reduce(\n        (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),\n        0\n      );\n    }\n  }\n};\nfunction isIdle(source) {\n  return source.idle !== false;\n}\nfunction checkIdle(active) {\n  return !active.size || Array.from(active).every(isIdle);\n}\nfunction becomeIdle(self) {\n  if (!self.idle) {\n    self.idle = true;\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.each)((0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.getPayload)(self), (node) => {\n      node.done = true;\n    });\n    (0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.callFluidObservers)(self, {\n      type: \"idle\",\n      parent: self\n    });\n  }\n}\n\n// src/interpolate.ts\nvar to = (source, ...args) => new Interpolation(source, args);\nvar interpolate = (source, ...args) => ((0,_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.deprecateInterpolate)(), new Interpolation(source, args));\n\n// src/globals.ts\n\n_react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.Globals.assign({\n  createStringInterpolator: _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.createStringInterpolator,\n  to: (source, args) => new Interpolation(source, args)\n});\nvar update = _react_spring_shared__WEBPACK_IMPORTED_MODULE_0__.frameLoop.advance;\n\n// src/index.ts\n\n\n\n//# sourceMappingURL=react-spring_core.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL2NvcmUvZGlzdC9yZWFjdC1zcHJpbmdfY29yZS5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDdUU7O0FBRXZFO0FBUThCO0FBQzlCO0FBQ0EsU0FBUyxvREFBRTtBQUNYO0FBQ0Esc0VBQXNFLG9EQUFFLDJCQUEyQiw2REFBTztBQUMxRyxpQ0FBaUMsb0RBQUU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQUU7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw4REFBUTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLElBQUksOERBQVE7QUFDWjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVLG1FQUFhO0FBQ3ZCLFNBQVMsb0RBQUUsdUNBQXVDLHNFQUFnQixVQUFVLHlEQUFDO0FBQzdFO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLG9EQUFFLGFBQWEsb0RBQUUsYUFBYSxvREFBRTtBQUN6QztBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBEQUFNLENBQUMsa0VBQVc7QUFDdEI7QUFDQSxLQUFLO0FBQ0wsSUFBSSx3RUFBbUI7QUFDdkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsMEVBQXFCOztBQUU3RDtBQUs4QjtBQUM5Qix5REFBTztBQUNQLDBCQUEwQjtBQUMxQjtBQUNBLENBQUM7QUFDRCxhQUFhLDJEQUFVOztBQUV2QjtBQU04QjtBQUNNO0FBZ0NsQztBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL2NvcmUvZGlzdC9yZWFjdC1zcHJpbmdfY29yZS5tb2Rlcm4ubWpzPzgyZDUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2hvb2tzL3VzZUNoYWluLnRzXG5pbXBvcnQgeyBlYWNoLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG5cbi8vIHNyYy9oZWxwZXJzLnRzXG5pbXBvcnQge1xuICBpcyxcbiAgdG9BcnJheSxcbiAgZWFjaFByb3AsXG4gIGdldEZsdWlkVmFsdWUsXG4gIGlzQW5pbWF0ZWRTdHJpbmcsXG4gIEdsb2JhbHMgYXMgR1xufSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcbmZ1bmN0aW9uIGNhbGxQcm9wKHZhbHVlLCAuLi5hcmdzKSB7XG4gIHJldHVybiBpcy5mdW4odmFsdWUpID8gdmFsdWUoLi4uYXJncykgOiB2YWx1ZTtcbn1cbnZhciBtYXRjaFByb3AgPSAodmFsdWUsIGtleSkgPT4gdmFsdWUgPT09IHRydWUgfHwgISEoa2V5ICYmIHZhbHVlICYmIChpcy5mdW4odmFsdWUpID8gdmFsdWUoa2V5KSA6IHRvQXJyYXkodmFsdWUpLmluY2x1ZGVzKGtleSkpKTtcbnZhciByZXNvbHZlUHJvcCA9IChwcm9wLCBrZXkpID0+IGlzLm9iaihwcm9wKSA/IGtleSAmJiBwcm9wW2tleV0gOiBwcm9wO1xudmFyIGdldERlZmF1bHRQcm9wID0gKHByb3BzLCBrZXkpID0+IHByb3BzLmRlZmF1bHQgPT09IHRydWUgPyBwcm9wc1trZXldIDogcHJvcHMuZGVmYXVsdCA/IHByb3BzLmRlZmF1bHRba2V5XSA6IHZvaWQgMDtcbnZhciBub29wVHJhbnNmb3JtID0gKHZhbHVlKSA9PiB2YWx1ZTtcbnZhciBnZXREZWZhdWx0UHJvcHMgPSAocHJvcHMsIHRyYW5zZm9ybSA9IG5vb3BUcmFuc2Zvcm0pID0+IHtcbiAgbGV0IGtleXMgPSBERUZBVUxUX1BST1BTO1xuICBpZiAocHJvcHMuZGVmYXVsdCAmJiBwcm9wcy5kZWZhdWx0ICE9PSB0cnVlKSB7XG4gICAgcHJvcHMgPSBwcm9wcy5kZWZhdWx0O1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcyk7XG4gIH1cbiAgY29uc3QgZGVmYXVsdHMyID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRyYW5zZm9ybShwcm9wc1trZXldLCBrZXkpO1xuICAgIGlmICghaXMudW5kKHZhbHVlKSkge1xuICAgICAgZGVmYXVsdHMyW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlZmF1bHRzMjtcbn07XG52YXIgREVGQVVMVF9QUk9QUyA9IFtcbiAgXCJjb25maWdcIixcbiAgXCJvblByb3BzXCIsXG4gIFwib25TdGFydFwiLFxuICBcIm9uQ2hhbmdlXCIsXG4gIFwib25QYXVzZVwiLFxuICBcIm9uUmVzdW1lXCIsXG4gIFwib25SZXN0XCJcbl07XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNvbmZpZzogMSxcbiAgZnJvbTogMSxcbiAgdG86IDEsXG4gIHJlZjogMSxcbiAgbG9vcDogMSxcbiAgcmVzZXQ6IDEsXG4gIHBhdXNlOiAxLFxuICBjYW5jZWw6IDEsXG4gIHJldmVyc2U6IDEsXG4gIGltbWVkaWF0ZTogMSxcbiAgZGVmYXVsdDogMSxcbiAgZGVsYXk6IDEsXG4gIG9uUHJvcHM6IDEsXG4gIG9uU3RhcnQ6IDEsXG4gIG9uQ2hhbmdlOiAxLFxuICBvblBhdXNlOiAxLFxuICBvblJlc3VtZTogMSxcbiAgb25SZXN0OiAxLFxuICBvblJlc29sdmU6IDEsXG4gIC8vIFRyYW5zaXRpb24gcHJvcHNcbiAgaXRlbXM6IDEsXG4gIHRyYWlsOiAxLFxuICBzb3J0OiAxLFxuICBleHBpcmVzOiAxLFxuICBpbml0aWFsOiAxLFxuICBlbnRlcjogMSxcbiAgdXBkYXRlOiAxLFxuICBsZWF2ZTogMSxcbiAgY2hpbGRyZW46IDEsXG4gIG9uRGVzdHJveWVkOiAxLFxuICAvLyBJbnRlcm5hbCBwcm9wc1xuICBrZXlzOiAxLFxuICBjYWxsSWQ6IDEsXG4gIHBhcmVudElkOiAxXG59O1xuZnVuY3Rpb24gZ2V0Rm9yd2FyZFByb3BzKHByb3BzKSB7XG4gIGNvbnN0IGZvcndhcmQgPSB7fTtcbiAgbGV0IGNvdW50ID0gMDtcbiAgZWFjaFByb3AocHJvcHMsICh2YWx1ZSwgcHJvcCkgPT4ge1xuICAgIGlmICghUkVTRVJWRURfUFJPUFNbcHJvcF0pIHtcbiAgICAgIGZvcndhcmRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgIGNvdW50Kys7XG4gICAgfVxuICB9KTtcbiAgaWYgKGNvdW50KSB7XG4gICAgcmV0dXJuIGZvcndhcmQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGluZmVyVG8ocHJvcHMpIHtcbiAgY29uc3QgdG8yID0gZ2V0Rm9yd2FyZFByb3BzKHByb3BzKTtcbiAgaWYgKHRvMikge1xuICAgIGNvbnN0IG91dCA9IHsgdG86IHRvMiB9O1xuICAgIGVhY2hQcm9wKHByb3BzLCAodmFsLCBrZXkpID0+IGtleSBpbiB0bzIgfHwgKG91dFtrZXldID0gdmFsKSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICByZXR1cm4geyAuLi5wcm9wcyB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUdvYWwodmFsdWUpIHtcbiAgdmFsdWUgPSBnZXRGbHVpZFZhbHVlKHZhbHVlKTtcbiAgcmV0dXJuIGlzLmFycih2YWx1ZSkgPyB2YWx1ZS5tYXAoY29tcHV0ZUdvYWwpIDogaXNBbmltYXRlZFN0cmluZyh2YWx1ZSkgPyBHLmNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcih7XG4gICAgcmFuZ2U6IFswLCAxXSxcbiAgICBvdXRwdXQ6IFt2YWx1ZSwgdmFsdWVdXG4gIH0pKDEpIDogdmFsdWU7XG59XG5mdW5jdGlvbiBoYXNQcm9wcyhwcm9wcykge1xuICBmb3IgKGNvbnN0IF8gaW4gcHJvcHMpXG4gICAgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzQXN5bmNUbyh0bzIpIHtcbiAgcmV0dXJuIGlzLmZ1bih0bzIpIHx8IGlzLmFycih0bzIpICYmIGlzLm9iaih0bzJbMF0pO1xufVxuZnVuY3Rpb24gZGV0YWNoUmVmcyhjdHJsLCByZWYpIHtcbiAgY3RybC5yZWY/LmRlbGV0ZShjdHJsKTtcbiAgcmVmPy5kZWxldGUoY3RybCk7XG59XG5mdW5jdGlvbiByZXBsYWNlUmVmKGN0cmwsIHJlZikge1xuICBpZiAocmVmICYmIGN0cmwucmVmICE9PSByZWYpIHtcbiAgICBjdHJsLnJlZj8uZGVsZXRlKGN0cmwpO1xuICAgIHJlZi5hZGQoY3RybCk7XG4gICAgY3RybC5yZWYgPSByZWY7XG4gIH1cbn1cblxuLy8gc3JjL2hvb2tzL3VzZUNoYWluLnRzXG5mdW5jdGlvbiB1c2VDaGFpbihyZWZzLCB0aW1lU3RlcHMsIHRpbWVGcmFtZSA9IDFlMykge1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICBpZiAodGltZVN0ZXBzKSB7XG4gICAgICBsZXQgcHJldkRlbGF5ID0gMDtcbiAgICAgIGVhY2gocmVmcywgKHJlZiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBjb250cm9sbGVycyA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY29udHJvbGxlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgbGV0IGRlbGF5ID0gdGltZUZyYW1lICogdGltZVN0ZXBzW2ldO1xuICAgICAgICAgIGlmIChpc05hTihkZWxheSkpXG4gICAgICAgICAgICBkZWxheSA9IHByZXZEZWxheTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBwcmV2RGVsYXkgPSBkZWxheTtcbiAgICAgICAgICBlYWNoKGNvbnRyb2xsZXJzLCAoY3RybCkgPT4ge1xuICAgICAgICAgICAgZWFjaChjdHJsLnF1ZXVlLCAocHJvcHMpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbWVtb2l6ZWREZWxheVByb3AgPSBwcm9wcy5kZWxheTtcbiAgICAgICAgICAgICAgcHJvcHMuZGVsYXkgPSAoa2V5KSA9PiBkZWxheSArIGNhbGxQcm9wKG1lbW9pemVkRGVsYXlQcm9wIHx8IDAsIGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZWYuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICBlYWNoKHJlZnMsIChyZWYpID0+IHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlcnMgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXJzLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHF1ZXVlcyA9IGNvbnRyb2xsZXJzLm1hcCgoY3RybCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcSA9IGN0cmwucXVldWU7XG4gICAgICAgICAgICBjdHJsLnF1ZXVlID0gW107XG4gICAgICAgICAgICByZXR1cm4gcTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwID0gcC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGVhY2goXG4gICAgICAgICAgICAgIGNvbnRyb2xsZXJzLFxuICAgICAgICAgICAgICAoY3RybCwgaSkgPT4gZWFjaChxdWV1ZXNbaV0gfHwgW10sICh1cGRhdGUyKSA9PiBjdHJsLnF1ZXVlLnB1c2godXBkYXRlMikpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlZi5zdGFydCgpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZVNwcmluZy50c1xuaW1wb3J0IHsgaXMgYXMgaXM5IH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG5cbi8vIHNyYy9ob29rcy91c2VTcHJpbmdzLnRzXG5pbXBvcnQgeyB1c2VDb250ZXh0IGFzIHVzZUNvbnRleHQyLCB1c2VNZW1vLCB1c2VSZWYgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIGlzIGFzIGlzOCxcbiAgZWFjaCBhcyBlYWNoNSxcbiAgdXNlUHJldixcbiAgdXNlT25jZSxcbiAgdXNlRm9yY2VVcGRhdGUsXG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDJcbn0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG5cbi8vIHNyYy9TcHJpbmdWYWx1ZS50c1xuaW1wb3J0IHtcbiAgaXMgYXMgaXM1LFxuICByYWYgYXMgcmFmMyxcbiAgZWFjaCBhcyBlYWNoMixcbiAgaXNFcXVhbCxcbiAgdG9BcnJheSBhcyB0b0FycmF5MixcbiAgZWFjaFByb3AgYXMgZWFjaFByb3AzLFxuICBmcmFtZUxvb3AgYXMgZnJhbWVMb29wMixcbiAgZmx1c2hDYWxscyxcbiAgZ2V0Rmx1aWRWYWx1ZSBhcyBnZXRGbHVpZFZhbHVlMixcbiAgaXNBbmltYXRlZFN0cmluZyBhcyBpc0FuaW1hdGVkU3RyaW5nMixcbiAgR2xvYmFscyBhcyBHNSxcbiAgY2FsbEZsdWlkT2JzZXJ2ZXJzIGFzIGNhbGxGbHVpZE9ic2VydmVyczIsXG4gIGhhc0ZsdWlkVmFsdWUsXG4gIGFkZEZsdWlkT2JzZXJ2ZXIsXG4gIHJlbW92ZUZsdWlkT2JzZXJ2ZXIsXG4gIGdldEZsdWlkT2JzZXJ2ZXJzXG59IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xuaW1wb3J0IHtcbiAgQW5pbWF0ZWRWYWx1ZSxcbiAgQW5pbWF0ZWRTdHJpbmcsXG4gIGdldFBheWxvYWQsXG4gIGdldEFuaW1hdGVkIGFzIGdldEFuaW1hdGVkMixcbiAgc2V0QW5pbWF0ZWQsXG4gIGdldEFuaW1hdGVkVHlwZVxufSBmcm9tIFwiQHJlYWN0LXNwcmluZy9hbmltYXRlZFwiO1xuXG4vLyBzcmMvQW5pbWF0aW9uQ29uZmlnLnRzXG5pbXBvcnQgeyBpcyBhcyBpczIsIGVhc2luZ3MgfSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcblxuLy8gc3JjL2NvbnN0YW50cy50c1xudmFyIGNvbmZpZyA9IHtcbiAgZGVmYXVsdDogeyB0ZW5zaW9uOiAxNzAsIGZyaWN0aW9uOiAyNiB9LFxuICBnZW50bGU6IHsgdGVuc2lvbjogMTIwLCBmcmljdGlvbjogMTQgfSxcbiAgd29iYmx5OiB7IHRlbnNpb246IDE4MCwgZnJpY3Rpb246IDEyIH0sXG4gIHN0aWZmOiB7IHRlbnNpb246IDIxMCwgZnJpY3Rpb246IDIwIH0sXG4gIHNsb3c6IHsgdGVuc2lvbjogMjgwLCBmcmljdGlvbjogNjAgfSxcbiAgbW9sYXNzZXM6IHsgdGVuc2lvbjogMjgwLCBmcmljdGlvbjogMTIwIH1cbn07XG5cbi8vIHNyYy9BbmltYXRpb25Db25maWcudHNcbnZhciBkZWZhdWx0cyA9IHtcbiAgLi4uY29uZmlnLmRlZmF1bHQsXG4gIG1hc3M6IDEsXG4gIGRhbXBpbmc6IDEsXG4gIGVhc2luZzogZWFzaW5ncy5saW5lYXIsXG4gIGNsYW1wOiBmYWxzZVxufTtcbnZhciBBbmltYXRpb25Db25maWcgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIHZlbG9jaXR5IG9mIG9uZSBvciBtb3JlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKi9cbiAgICB0aGlzLnZlbG9jaXR5ID0gMDtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRlZmF1bHRzKTtcbiAgfVxufTtcbmZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzIsIG5ld0NvbmZpZywgZGVmYXVsdENvbmZpZykge1xuICBpZiAoZGVmYXVsdENvbmZpZykge1xuICAgIGRlZmF1bHRDb25maWcgPSB7IC4uLmRlZmF1bHRDb25maWcgfTtcbiAgICBzYW5pdGl6ZUNvbmZpZyhkZWZhdWx0Q29uZmlnLCBuZXdDb25maWcpO1xuICAgIG5ld0NvbmZpZyA9IHsgLi4uZGVmYXVsdENvbmZpZywgLi4ubmV3Q29uZmlnIH07XG4gIH1cbiAgc2FuaXRpemVDb25maWcoY29uZmlnMiwgbmV3Q29uZmlnKTtcbiAgT2JqZWN0LmFzc2lnbihjb25maWcyLCBuZXdDb25maWcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBkZWZhdWx0cykge1xuICAgIGlmIChjb25maWcyW2tleV0gPT0gbnVsbCkge1xuICAgICAgY29uZmlnMltrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICB9XG4gIH1cbiAgbGV0IHsgZnJlcXVlbmN5LCBkYW1waW5nIH0gPSBjb25maWcyO1xuICBjb25zdCB7IG1hc3MgfSA9IGNvbmZpZzI7XG4gIGlmICghaXMyLnVuZChmcmVxdWVuY3kpKSB7XG4gICAgaWYgKGZyZXF1ZW5jeSA8IDAuMDEpXG4gICAgICBmcmVxdWVuY3kgPSAwLjAxO1xuICAgIGlmIChkYW1waW5nIDwgMClcbiAgICAgIGRhbXBpbmcgPSAwO1xuICAgIGNvbmZpZzIudGVuc2lvbiA9IE1hdGgucG93KDIgKiBNYXRoLlBJIC8gZnJlcXVlbmN5LCAyKSAqIG1hc3M7XG4gICAgY29uZmlnMi5mcmljdGlvbiA9IDQgKiBNYXRoLlBJICogZGFtcGluZyAqIG1hc3MgLyBmcmVxdWVuY3k7XG4gIH1cbiAgcmV0dXJuIGNvbmZpZzI7XG59XG5mdW5jdGlvbiBzYW5pdGl6ZUNvbmZpZyhjb25maWcyLCBwcm9wcykge1xuICBpZiAoIWlzMi51bmQocHJvcHMuZGVjYXkpKSB7XG4gICAgY29uZmlnMi5kdXJhdGlvbiA9IHZvaWQgMDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpc1RlbnNpb25Db25maWcgPSAhaXMyLnVuZChwcm9wcy50ZW5zaW9uKSB8fCAhaXMyLnVuZChwcm9wcy5mcmljdGlvbik7XG4gICAgaWYgKGlzVGVuc2lvbkNvbmZpZyB8fCAhaXMyLnVuZChwcm9wcy5mcmVxdWVuY3kpIHx8ICFpczIudW5kKHByb3BzLmRhbXBpbmcpIHx8ICFpczIudW5kKHByb3BzLm1hc3MpKSB7XG4gICAgICBjb25maWcyLmR1cmF0aW9uID0gdm9pZCAwO1xuICAgICAgY29uZmlnMi5kZWNheSA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKGlzVGVuc2lvbkNvbmZpZykge1xuICAgICAgY29uZmlnMi5mcmVxdWVuY3kgPSB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9BbmltYXRpb24udHNcbnZhciBlbXB0eUFycmF5ID0gW107XG52YXIgQW5pbWF0aW9uID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICB0aGlzLnZhbHVlcyA9IGVtcHR5QXJyYXk7XG4gICAgdGhpcy50b1ZhbHVlcyA9IG51bGw7XG4gICAgdGhpcy5mcm9tVmFsdWVzID0gZW1wdHlBcnJheTtcbiAgICB0aGlzLmNvbmZpZyA9IG5ldyBBbmltYXRpb25Db25maWcoKTtcbiAgICB0aGlzLmltbWVkaWF0ZSA9IGZhbHNlO1xuICB9XG59O1xuXG4vLyBzcmMvc2NoZWR1bGVQcm9wcy50c1xuaW1wb3J0IHsgaXMgYXMgaXMzLCByYWYsIEdsb2JhbHMgYXMgRzIgfSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcbmZ1bmN0aW9uIHNjaGVkdWxlUHJvcHMoY2FsbElkLCB7IGtleSwgcHJvcHMsIGRlZmF1bHRQcm9wcywgc3RhdGUsIGFjdGlvbnMgfSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGxldCBkZWxheTtcbiAgICBsZXQgdGltZW91dDtcbiAgICBsZXQgY2FuY2VsID0gbWF0Y2hQcm9wKHByb3BzLmNhbmNlbCA/PyBkZWZhdWx0UHJvcHM/LmNhbmNlbCwga2V5KTtcbiAgICBpZiAoY2FuY2VsKSB7XG4gICAgICBvblN0YXJ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXMzLnVuZChwcm9wcy5wYXVzZSkpIHtcbiAgICAgICAgc3RhdGUucGF1c2VkID0gbWF0Y2hQcm9wKHByb3BzLnBhdXNlLCBrZXkpO1xuICAgICAgfVxuICAgICAgbGV0IHBhdXNlID0gZGVmYXVsdFByb3BzPy5wYXVzZTtcbiAgICAgIGlmIChwYXVzZSAhPT0gdHJ1ZSkge1xuICAgICAgICBwYXVzZSA9IHN0YXRlLnBhdXNlZCB8fCBtYXRjaFByb3AocGF1c2UsIGtleSk7XG4gICAgICB9XG4gICAgICBkZWxheSA9IGNhbGxQcm9wKHByb3BzLmRlbGF5IHx8IDAsIGtleSk7XG4gICAgICBpZiAocGF1c2UpIHtcbiAgICAgICAgc3RhdGUucmVzdW1lUXVldWUuYWRkKG9uUmVzdW1lKTtcbiAgICAgICAgYWN0aW9ucy5wYXVzZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWN0aW9ucy5yZXN1bWUoKTtcbiAgICAgICAgb25SZXN1bWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25QYXVzZSgpIHtcbiAgICAgIHN0YXRlLnJlc3VtZVF1ZXVlLmFkZChvblJlc3VtZSk7XG4gICAgICBzdGF0ZS50aW1lb3V0cy5kZWxldGUodGltZW91dCk7XG4gICAgICB0aW1lb3V0LmNhbmNlbCgpO1xuICAgICAgZGVsYXkgPSB0aW1lb3V0LnRpbWUgLSByYWYubm93KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG9uUmVzdW1lKCkge1xuICAgICAgaWYgKGRlbGF5ID4gMCAmJiAhRzIuc2tpcEFuaW1hdGlvbikge1xuICAgICAgICBzdGF0ZS5kZWxheWVkID0gdHJ1ZTtcbiAgICAgICAgdGltZW91dCA9IHJhZi5zZXRUaW1lb3V0KG9uU3RhcnQsIGRlbGF5KTtcbiAgICAgICAgc3RhdGUucGF1c2VRdWV1ZS5hZGQob25QYXVzZSk7XG4gICAgICAgIHN0YXRlLnRpbWVvdXRzLmFkZCh0aW1lb3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uU3RhcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25TdGFydCgpIHtcbiAgICAgIGlmIChzdGF0ZS5kZWxheWVkKSB7XG4gICAgICAgIHN0YXRlLmRlbGF5ZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLnBhdXNlUXVldWUuZGVsZXRlKG9uUGF1c2UpO1xuICAgICAgc3RhdGUudGltZW91dHMuZGVsZXRlKHRpbWVvdXQpO1xuICAgICAgaWYgKGNhbGxJZCA8PSAoc3RhdGUuY2FuY2VsSWQgfHwgMCkpIHtcbiAgICAgICAgY2FuY2VsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGFjdGlvbnMuc3RhcnQoeyAuLi5wcm9wcywgY2FsbElkLCBjYW5jZWwgfSwgcmVzb2x2ZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL3J1bkFzeW5jLnRzXG5pbXBvcnQge1xuICBpcyBhcyBpczQsXG4gIHJhZiBhcyByYWYyLFxuICBmbHVzaCxcbiAgZWFjaFByb3AgYXMgZWFjaFByb3AyLFxuICBHbG9iYWxzIGFzIEczXG59IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xuXG4vLyBzcmMvQW5pbWF0aW9uUmVzdWx0LnRzXG52YXIgZ2V0Q29tYmluZWRSZXN1bHQgPSAodGFyZ2V0LCByZXN1bHRzKSA9PiByZXN1bHRzLmxlbmd0aCA9PSAxID8gcmVzdWx0c1swXSA6IHJlc3VsdHMuc29tZSgocmVzdWx0KSA9PiByZXN1bHQuY2FuY2VsbGVkKSA/IGdldENhbmNlbGxlZFJlc3VsdCh0YXJnZXQuZ2V0KCkpIDogcmVzdWx0cy5ldmVyeSgocmVzdWx0KSA9PiByZXN1bHQubm9vcCkgPyBnZXROb29wUmVzdWx0KHRhcmdldC5nZXQoKSkgOiBnZXRGaW5pc2hlZFJlc3VsdChcbiAgdGFyZ2V0LmdldCgpLFxuICByZXN1bHRzLmV2ZXJ5KChyZXN1bHQpID0+IHJlc3VsdC5maW5pc2hlZClcbik7XG52YXIgZ2V0Tm9vcFJlc3VsdCA9ICh2YWx1ZSkgPT4gKHtcbiAgdmFsdWUsXG4gIG5vb3A6IHRydWUsXG4gIGZpbmlzaGVkOiB0cnVlLFxuICBjYW5jZWxsZWQ6IGZhbHNlXG59KTtcbnZhciBnZXRGaW5pc2hlZFJlc3VsdCA9ICh2YWx1ZSwgZmluaXNoZWQsIGNhbmNlbGxlZCA9IGZhbHNlKSA9PiAoe1xuICB2YWx1ZSxcbiAgZmluaXNoZWQsXG4gIGNhbmNlbGxlZFxufSk7XG52YXIgZ2V0Q2FuY2VsbGVkUmVzdWx0ID0gKHZhbHVlKSA9PiAoe1xuICB2YWx1ZSxcbiAgY2FuY2VsbGVkOiB0cnVlLFxuICBmaW5pc2hlZDogZmFsc2Vcbn0pO1xuXG4vLyBzcmMvcnVuQXN5bmMudHNcbmZ1bmN0aW9uIHJ1bkFzeW5jKHRvMiwgcHJvcHMsIHN0YXRlLCB0YXJnZXQpIHtcbiAgY29uc3QgeyBjYWxsSWQsIHBhcmVudElkLCBvblJlc3QgfSA9IHByb3BzO1xuICBjb25zdCB7IGFzeW5jVG86IHByZXZUbywgcHJvbWlzZTogcHJldlByb21pc2UgfSA9IHN0YXRlO1xuICBpZiAoIXBhcmVudElkICYmIHRvMiA9PT0gcHJldlRvICYmICFwcm9wcy5yZXNldCkge1xuICAgIHJldHVybiBwcmV2UHJvbWlzZTtcbiAgfVxuICByZXR1cm4gc3RhdGUucHJvbWlzZSA9IChhc3luYyAoKSA9PiB7XG4gICAgc3RhdGUuYXN5bmNJZCA9IGNhbGxJZDtcbiAgICBzdGF0ZS5hc3luY1RvID0gdG8yO1xuICAgIGNvbnN0IGRlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcyhcbiAgICAgIHByb3BzLFxuICAgICAgKHZhbHVlLCBrZXkpID0+IChcbiAgICAgICAgLy8gVGhlIGBvblJlc3RgIHByb3AgaXMgb25seSBjYWxsZWQgd2hlbiB0aGUgYHJ1bkFzeW5jYCBwcm9taXNlIGlzIHJlc29sdmVkLlxuICAgICAgICBrZXkgPT09IFwib25SZXN0XCIgPyB2b2lkIDAgOiB2YWx1ZVxuICAgICAgKVxuICAgICk7XG4gICAgbGV0IHByZXZlbnRCYWlsO1xuICAgIGxldCBiYWlsO1xuICAgIGNvbnN0IGJhaWxQcm9taXNlID0gbmV3IFByb21pc2UoXG4gICAgICAocmVzb2x2ZSwgcmVqZWN0KSA9PiAocHJldmVudEJhaWwgPSByZXNvbHZlLCBiYWlsID0gcmVqZWN0KVxuICAgICk7XG4gICAgY29uc3QgYmFpbElmRW5kZWQgPSAoYmFpbFNpZ25hbCkgPT4ge1xuICAgICAgY29uc3QgYmFpbFJlc3VsdCA9IChcbiAgICAgICAgLy8gVGhlIGBjYW5jZWxgIHByb3Agb3IgYHN0b3BgIG1ldGhvZCB3YXMgdXNlZC5cbiAgICAgICAgY2FsbElkIDw9IChzdGF0ZS5jYW5jZWxJZCB8fCAwKSAmJiBnZXRDYW5jZWxsZWRSZXN1bHQodGFyZ2V0KSB8fCAvLyBUaGUgYXN5bmMgYHRvYCBwcm9wIHdhcyByZXBsYWNlZC5cbiAgICAgICAgY2FsbElkICE9PSBzdGF0ZS5hc3luY0lkICYmIGdldEZpbmlzaGVkUmVzdWx0KHRhcmdldCwgZmFsc2UpXG4gICAgICApO1xuICAgICAgaWYgKGJhaWxSZXN1bHQpIHtcbiAgICAgICAgYmFpbFNpZ25hbC5yZXN1bHQgPSBiYWlsUmVzdWx0O1xuICAgICAgICBiYWlsKGJhaWxTaWduYWwpO1xuICAgICAgICB0aHJvdyBiYWlsU2lnbmFsO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgYW5pbWF0ZSA9IChhcmcxLCBhcmcyKSA9PiB7XG4gICAgICBjb25zdCBiYWlsU2lnbmFsID0gbmV3IEJhaWxTaWduYWwoKTtcbiAgICAgIGNvbnN0IHNraXBBbmltYXRpb25TaWduYWwgPSBuZXcgU2tpcEFuaW1hdGlvblNpZ25hbCgpO1xuICAgICAgcmV0dXJuIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChHMy5za2lwQW5pbWF0aW9uKSB7XG4gICAgICAgICAgc3RvcEFzeW5jKHN0YXRlKTtcbiAgICAgICAgICBza2lwQW5pbWF0aW9uU2lnbmFsLnJlc3VsdCA9IGdldEZpbmlzaGVkUmVzdWx0KHRhcmdldCwgZmFsc2UpO1xuICAgICAgICAgIGJhaWwoc2tpcEFuaW1hdGlvblNpZ25hbCk7XG4gICAgICAgICAgdGhyb3cgc2tpcEFuaW1hdGlvblNpZ25hbDtcbiAgICAgICAgfVxuICAgICAgICBiYWlsSWZFbmRlZChiYWlsU2lnbmFsKTtcbiAgICAgICAgY29uc3QgcHJvcHMyID0gaXM0Lm9iaihhcmcxKSA/IHsgLi4uYXJnMSB9IDogeyAuLi5hcmcyLCB0bzogYXJnMSB9O1xuICAgICAgICBwcm9wczIucGFyZW50SWQgPSBjYWxsSWQ7XG4gICAgICAgIGVhY2hQcm9wMihkZWZhdWx0UHJvcHMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgaWYgKGlzNC51bmQocHJvcHMyW2tleV0pKSB7XG4gICAgICAgICAgICBwcm9wczJba2V5XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdDIgPSBhd2FpdCB0YXJnZXQuc3RhcnQocHJvcHMyKTtcbiAgICAgICAgYmFpbElmRW5kZWQoYmFpbFNpZ25hbCk7XG4gICAgICAgIGlmIChzdGF0ZS5wYXVzZWQpIHtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzdW1lKSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5yZXN1bWVRdWV1ZS5hZGQocmVzdW1lKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MjtcbiAgICAgIH0pKCk7XG4gICAgfTtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGlmIChHMy5za2lwQW5pbWF0aW9uKSB7XG4gICAgICBzdG9wQXN5bmMoc3RhdGUpO1xuICAgICAgcmV0dXJuIGdldEZpbmlzaGVkUmVzdWx0KHRhcmdldCwgZmFsc2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IGFuaW1hdGluZztcbiAgICAgIGlmIChpczQuYXJyKHRvMikpIHtcbiAgICAgICAgYW5pbWF0aW5nID0gKGFzeW5jIChxdWV1ZSkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgcHJvcHMyIG9mIHF1ZXVlKSB7XG4gICAgICAgICAgICBhd2FpdCBhbmltYXRlKHByb3BzMik7XG4gICAgICAgICAgfVxuICAgICAgICB9KSh0bzIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0aW5nID0gUHJvbWlzZS5yZXNvbHZlKHRvMihhbmltYXRlLCB0YXJnZXQuc3RvcC5iaW5kKHRhcmdldCkpKTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFthbmltYXRpbmcudGhlbihwcmV2ZW50QmFpbCksIGJhaWxQcm9taXNlXSk7XG4gICAgICByZXN1bHQgPSBnZXRGaW5pc2hlZFJlc3VsdCh0YXJnZXQuZ2V0KCksIHRydWUsIGZhbHNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBCYWlsU2lnbmFsKSB7XG4gICAgICAgIHJlc3VsdCA9IGVyci5yZXN1bHQ7XG4gICAgICB9IGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIFNraXBBbmltYXRpb25TaWduYWwpIHtcbiAgICAgICAgcmVzdWx0ID0gZXJyLnJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKGNhbGxJZCA9PSBzdGF0ZS5hc3luY0lkKSB7XG4gICAgICAgIHN0YXRlLmFzeW5jSWQgPSBwYXJlbnRJZDtcbiAgICAgICAgc3RhdGUuYXN5bmNUbyA9IHBhcmVudElkID8gcHJldlRvIDogdm9pZCAwO1xuICAgICAgICBzdGF0ZS5wcm9taXNlID0gcGFyZW50SWQgPyBwcmV2UHJvbWlzZSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzNC5mdW4ob25SZXN0KSkge1xuICAgICAgcmFmMi5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIG9uUmVzdChyZXN1bHQsIHRhcmdldCwgdGFyZ2V0Lml0ZW0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBzdG9wQXN5bmMoc3RhdGUsIGNhbmNlbElkKSB7XG4gIGZsdXNoKHN0YXRlLnRpbWVvdXRzLCAodCkgPT4gdC5jYW5jZWwoKSk7XG4gIHN0YXRlLnBhdXNlUXVldWUuY2xlYXIoKTtcbiAgc3RhdGUucmVzdW1lUXVldWUuY2xlYXIoKTtcbiAgc3RhdGUuYXN5bmNJZCA9IHN0YXRlLmFzeW5jVG8gPSBzdGF0ZS5wcm9taXNlID0gdm9pZCAwO1xuICBpZiAoY2FuY2VsSWQpXG4gICAgc3RhdGUuY2FuY2VsSWQgPSBjYW5jZWxJZDtcbn1cbnZhciBCYWlsU2lnbmFsID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFxuICAgICAgXCJBbiBhc3luYyBhbmltYXRpb24gaGFzIGJlZW4gaW50ZXJydXB0ZWQuIFlvdSBzZWUgdGhpcyBlcnJvciBiZWNhdXNlIHlvdSBmb3Jnb3QgdG8gdXNlIGBhd2FpdGAgb3IgYC5jYXRjaCguLi4pYCBvbiBpdHMgcmV0dXJuZWQgcHJvbWlzZS5cIlxuICAgICk7XG4gIH1cbn07XG52YXIgU2tpcEFuaW1hdGlvblNpZ25hbCA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIlNraXBBbmltYXRpb25TaWduYWxcIik7XG4gIH1cbn07XG5cbi8vIHNyYy9GcmFtZVZhbHVlLnRzXG5pbXBvcnQge1xuICBkZXByZWNhdGVJbnRlcnBvbGF0ZSxcbiAgZnJhbWVMb29wLFxuICBGbHVpZFZhbHVlIGFzIEZsdWlkVmFsdWUyLFxuICBHbG9iYWxzIGFzIEc0LFxuICBjYWxsRmx1aWRPYnNlcnZlcnNcbn0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG5pbXBvcnQgeyBnZXRBbmltYXRlZCB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL2FuaW1hdGVkXCI7XG52YXIgaXNGcmFtZVZhbHVlID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEZyYW1lVmFsdWU7XG52YXIgbmV4dElkID0gMTtcbnZhciBGcmFtZVZhbHVlID0gY2xhc3MgZXh0ZW5kcyBGbHVpZFZhbHVlMiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5pZCA9IG5leHRJZCsrO1xuICAgIHRoaXMuX3ByaW9yaXR5ID0gMDtcbiAgfVxuICBnZXQgcHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByaW9yaXR5O1xuICB9XG4gIHNldCBwcmlvcml0eShwcmlvcml0eSkge1xuICAgIGlmICh0aGlzLl9wcmlvcml0eSAhPSBwcmlvcml0eSkge1xuICAgICAgdGhpcy5fcHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICAgIHRoaXMuX29uUHJpb3JpdHlDaGFuZ2UocHJpb3JpdHkpO1xuICAgIH1cbiAgfVxuICAvKiogR2V0IHRoZSBjdXJyZW50IHZhbHVlICovXG4gIGdldCgpIHtcbiAgICBjb25zdCBub2RlID0gZ2V0QW5pbWF0ZWQodGhpcyk7XG4gICAgcmV0dXJuIG5vZGUgJiYgbm9kZS5nZXRWYWx1ZSgpO1xuICB9XG4gIC8qKiBDcmVhdGUgYSBzcHJpbmcgdGhhdCBtYXBzIG91ciB2YWx1ZSB0byBhbm90aGVyIHZhbHVlICovXG4gIHRvKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gRzQudG8odGhpcywgYXJncyk7XG4gIH1cbiAgLyoqIEBkZXByZWNhdGVkIFVzZSB0aGUgYHRvYCBtZXRob2QgaW5zdGVhZC4gKi9cbiAgaW50ZXJwb2xhdGUoLi4uYXJncykge1xuICAgIGRlcHJlY2F0ZUludGVycG9sYXRlKCk7XG4gICAgcmV0dXJuIEc0LnRvKHRoaXMsIGFyZ3MpO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoKTtcbiAgfVxuICBvYnNlcnZlckFkZGVkKGNvdW50KSB7XG4gICAgaWYgKGNvdW50ID09IDEpXG4gICAgICB0aGlzLl9hdHRhY2goKTtcbiAgfVxuICBvYnNlcnZlclJlbW92ZWQoY291bnQpIHtcbiAgICBpZiAoY291bnQgPT0gMClcbiAgICAgIHRoaXMuX2RldGFjaCgpO1xuICB9XG4gIC8qKiBDYWxsZWQgd2hlbiB0aGUgZmlyc3QgY2hpbGQgaXMgYWRkZWQuICovXG4gIF9hdHRhY2goKSB7XG4gIH1cbiAgLyoqIENhbGxlZCB3aGVuIHRoZSBsYXN0IGNoaWxkIGlzIHJlbW92ZWQuICovXG4gIF9kZXRhY2goKSB7XG4gIH1cbiAgLyoqIFRlbGwgb3VyIGNoaWxkcmVuIGFib3V0IG91ciBuZXcgdmFsdWUgKi9cbiAgX29uQ2hhbmdlKHZhbHVlLCBpZGxlID0gZmFsc2UpIHtcbiAgICBjYWxsRmx1aWRPYnNlcnZlcnModGhpcywge1xuICAgICAgdHlwZTogXCJjaGFuZ2VcIixcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIHZhbHVlLFxuICAgICAgaWRsZVxuICAgIH0pO1xuICB9XG4gIC8qKiBUZWxsIG91ciBjaGlsZHJlbiBhYm91dCBvdXIgbmV3IHByaW9yaXR5ICovXG4gIF9vblByaW9yaXR5Q2hhbmdlKHByaW9yaXR5KSB7XG4gICAgaWYgKCF0aGlzLmlkbGUpIHtcbiAgICAgIGZyYW1lTG9vcC5zb3J0KHRoaXMpO1xuICAgIH1cbiAgICBjYWxsRmx1aWRPYnNlcnZlcnModGhpcywge1xuICAgICAgdHlwZTogXCJwcmlvcml0eVwiLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgcHJpb3JpdHlcbiAgICB9KTtcbiAgfVxufTtcblxuLy8gc3JjL1NwcmluZ1BoYXNlLnRzXG52YXIgJFAgPSBTeW1ib2wuZm9yKFwiU3ByaW5nUGhhc2VcIik7XG52YXIgSEFTX0FOSU1BVEVEID0gMTtcbnZhciBJU19BTklNQVRJTkcgPSAyO1xudmFyIElTX1BBVVNFRCA9IDQ7XG52YXIgaGFzQW5pbWF0ZWQgPSAodGFyZ2V0KSA9PiAodGFyZ2V0WyRQXSAmIEhBU19BTklNQVRFRCkgPiAwO1xudmFyIGlzQW5pbWF0aW5nID0gKHRhcmdldCkgPT4gKHRhcmdldFskUF0gJiBJU19BTklNQVRJTkcpID4gMDtcbnZhciBpc1BhdXNlZCA9ICh0YXJnZXQpID0+ICh0YXJnZXRbJFBdICYgSVNfUEFVU0VEKSA+IDA7XG52YXIgc2V0QWN0aXZlQml0ID0gKHRhcmdldCwgYWN0aXZlKSA9PiBhY3RpdmUgPyB0YXJnZXRbJFBdIHw9IElTX0FOSU1BVElORyB8IEhBU19BTklNQVRFRCA6IHRhcmdldFskUF0gJj0gfklTX0FOSU1BVElORztcbnZhciBzZXRQYXVzZWRCaXQgPSAodGFyZ2V0LCBwYXVzZWQpID0+IHBhdXNlZCA/IHRhcmdldFskUF0gfD0gSVNfUEFVU0VEIDogdGFyZ2V0WyRQXSAmPSB+SVNfUEFVU0VEO1xuXG4vLyBzcmMvU3ByaW5nVmFsdWUudHNcbnZhciBTcHJpbmdWYWx1ZSA9IGNsYXNzIGV4dGVuZHMgRnJhbWVWYWx1ZSB7XG4gIGNvbnN0cnVjdG9yKGFyZzEsIGFyZzIpIHtcbiAgICBzdXBlcigpO1xuICAgIC8qKiBUaGUgYW5pbWF0aW9uIHN0YXRlICovXG4gICAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCk7XG4gICAgLyoqIFNvbWUgcHJvcHMgaGF2ZSBjdXN0b21pemFibGUgZGVmYXVsdCB2YWx1ZXMgKi9cbiAgICB0aGlzLmRlZmF1bHRQcm9wcyA9IHt9O1xuICAgIC8qKiBUaGUgc3RhdGUgZm9yIGBydW5Bc3luY2AgY2FsbHMgKi9cbiAgICB0aGlzLl9zdGF0ZSA9IHtcbiAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICBkZWxheWVkOiBmYWxzZSxcbiAgICAgIHBhdXNlUXVldWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICByZXN1bWVRdWV1ZTogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICAgIHRpbWVvdXRzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG4gICAgfTtcbiAgICAvKiogVGhlIHByb21pc2UgcmVzb2x2ZXJzIG9mIHBlbmRpbmcgYHN0YXJ0YCBjYWxscyAqL1xuICAgIHRoaXMuX3BlbmRpbmdDYWxscyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgLyoqIFRoZSBjb3VudGVyIGZvciB0cmFja2luZyBgc2NoZWR1bGVQcm9wc2AgY2FsbHMgKi9cbiAgICB0aGlzLl9sYXN0Q2FsbElkID0gMDtcbiAgICAvKiogVGhlIGxhc3QgYHNjaGVkdWxlUHJvcHNgIGNhbGwgdGhhdCBjaGFuZ2VkIHRoZSBgdG9gIHByb3AgKi9cbiAgICB0aGlzLl9sYXN0VG9JZCA9IDA7XG4gICAgdGhpcy5fbWVtb2l6ZWREdXJhdGlvbiA9IDA7XG4gICAgaWYgKCFpczUudW5kKGFyZzEpIHx8ICFpczUudW5kKGFyZzIpKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IGlzNS5vYmooYXJnMSkgPyB7IC4uLmFyZzEgfSA6IHsgLi4uYXJnMiwgZnJvbTogYXJnMSB9O1xuICAgICAgaWYgKGlzNS51bmQocHJvcHMuZGVmYXVsdCkpIHtcbiAgICAgICAgcHJvcHMuZGVmYXVsdCA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXJ0KHByb3BzKTtcbiAgICB9XG4gIH1cbiAgLyoqIEVxdWFscyB0cnVlIHdoZW4gbm90IGFkdmFuY2luZyBvbiBlYWNoIGZyYW1lLiAqL1xuICBnZXQgaWRsZSgpIHtcbiAgICByZXR1cm4gIShpc0FuaW1hdGluZyh0aGlzKSB8fCB0aGlzLl9zdGF0ZS5hc3luY1RvKSB8fCBpc1BhdXNlZCh0aGlzKTtcbiAgfVxuICBnZXQgZ29hbCgpIHtcbiAgICByZXR1cm4gZ2V0Rmx1aWRWYWx1ZTIodGhpcy5hbmltYXRpb24udG8pO1xuICB9XG4gIGdldCB2ZWxvY2l0eSgpIHtcbiAgICBjb25zdCBub2RlID0gZ2V0QW5pbWF0ZWQyKHRoaXMpO1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQW5pbWF0ZWRWYWx1ZSA/IG5vZGUubGFzdFZlbG9jaXR5IHx8IDAgOiBub2RlLmdldFBheWxvYWQoKS5tYXAoKG5vZGUyKSA9PiBub2RlMi5sYXN0VmVsb2NpdHkgfHwgMCk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgdGhpcyB2YWx1ZSBoYXMgYmVlbiBhbmltYXRlZCBhdCBsZWFzdCBvbmNlLlxuICAgKi9cbiAgZ2V0IGhhc0FuaW1hdGVkKCkge1xuICAgIHJldHVybiBoYXNBbmltYXRlZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogV2hlbiB0cnVlLCB0aGlzIHZhbHVlIGhhcyBhbiB1bmZpbmlzaGVkIGFuaW1hdGlvbixcbiAgICogd2hpY2ggaXMgZWl0aGVyIGFjdGl2ZSBvciBwYXVzZWQuXG4gICAqL1xuICBnZXQgaXNBbmltYXRpbmcoKSB7XG4gICAgcmV0dXJuIGlzQW5pbWF0aW5nKHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIGFsbCBjdXJyZW50IGFuZCBmdXR1cmUgYW5pbWF0aW9ucyBhcmUgcGF1c2VkLlxuICAgKi9cbiAgZ2V0IGlzUGF1c2VkKCkge1xuICAgIHJldHVybiBpc1BhdXNlZCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICpcbiAgICpcbiAgICovXG4gIGdldCBpc0RlbGF5ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLmRlbGF5ZWQ7XG4gIH1cbiAgLyoqIEFkdmFuY2UgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGJ5IGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyAqL1xuICBhZHZhbmNlKGR0KSB7XG4gICAgbGV0IGlkbGUgPSB0cnVlO1xuICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgY29uc3QgYW5pbSA9IHRoaXMuYW5pbWF0aW9uO1xuICAgIGxldCB7IHRvVmFsdWVzIH0gPSBhbmltO1xuICAgIGNvbnN0IHsgY29uZmlnOiBjb25maWcyIH0gPSBhbmltO1xuICAgIGNvbnN0IHBheWxvYWQgPSBnZXRQYXlsb2FkKGFuaW0udG8pO1xuICAgIGlmICghcGF5bG9hZCAmJiBoYXNGbHVpZFZhbHVlKGFuaW0udG8pKSB7XG4gICAgICB0b1ZhbHVlcyA9IHRvQXJyYXkyKGdldEZsdWlkVmFsdWUyKGFuaW0udG8pKTtcbiAgICB9XG4gICAgYW5pbS52YWx1ZXMuZm9yRWFjaCgobm9kZTIsIGkpID0+IHtcbiAgICAgIGlmIChub2RlMi5kb25lKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB0bzIgPSAoXG4gICAgICAgIC8vIEFuaW1hdGVkIHN0cmluZ3MgYWx3YXlzIGdvIGZyb20gMCB0byAxLlxuICAgICAgICBub2RlMi5jb25zdHJ1Y3RvciA9PSBBbmltYXRlZFN0cmluZyA/IDEgOiBwYXlsb2FkID8gcGF5bG9hZFtpXS5sYXN0UG9zaXRpb24gOiB0b1ZhbHVlc1tpXVxuICAgICAgKTtcbiAgICAgIGxldCBmaW5pc2hlZCA9IGFuaW0uaW1tZWRpYXRlO1xuICAgICAgbGV0IHBvc2l0aW9uID0gdG8yO1xuICAgICAgaWYgKCFmaW5pc2hlZCkge1xuICAgICAgICBwb3NpdGlvbiA9IG5vZGUyLmxhc3RQb3NpdGlvbjtcbiAgICAgICAgaWYgKGNvbmZpZzIudGVuc2lvbiA8PSAwKSB7XG4gICAgICAgICAgbm9kZTIuZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBlbGFwc2VkID0gbm9kZTIuZWxhcHNlZFRpbWUgKz0gZHQ7XG4gICAgICAgIGNvbnN0IGZyb20gPSBhbmltLmZyb21WYWx1ZXNbaV07XG4gICAgICAgIGNvbnN0IHYwID0gbm9kZTIudjAgIT0gbnVsbCA/IG5vZGUyLnYwIDogbm9kZTIudjAgPSBpczUuYXJyKGNvbmZpZzIudmVsb2NpdHkpID8gY29uZmlnMi52ZWxvY2l0eVtpXSA6IGNvbmZpZzIudmVsb2NpdHk7XG4gICAgICAgIGxldCB2ZWxvY2l0eTtcbiAgICAgICAgY29uc3QgcHJlY2lzaW9uID0gY29uZmlnMi5wcmVjaXNpb24gfHwgKGZyb20gPT0gdG8yID8gNWUtMyA6IE1hdGgubWluKDEsIE1hdGguYWJzKHRvMiAtIGZyb20pICogMWUtMykpO1xuICAgICAgICBpZiAoIWlzNS51bmQoY29uZmlnMi5kdXJhdGlvbikpIHtcbiAgICAgICAgICBsZXQgcCA9IDE7XG4gICAgICAgICAgaWYgKGNvbmZpZzIuZHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWVtb2l6ZWREdXJhdGlvbiAhPT0gY29uZmlnMi5kdXJhdGlvbikge1xuICAgICAgICAgICAgICB0aGlzLl9tZW1vaXplZER1cmF0aW9uID0gY29uZmlnMi5kdXJhdGlvbjtcbiAgICAgICAgICAgICAgaWYgKG5vZGUyLmR1cmF0aW9uUHJvZ3Jlc3MgPiAwKSB7XG4gICAgICAgICAgICAgICAgbm9kZTIuZWxhcHNlZFRpbWUgPSBjb25maWcyLmR1cmF0aW9uICogbm9kZTIuZHVyYXRpb25Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICBlbGFwc2VkID0gbm9kZTIuZWxhcHNlZFRpbWUgKz0gZHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSAoY29uZmlnMi5wcm9ncmVzcyB8fCAwKSArIGVsYXBzZWQgLyB0aGlzLl9tZW1vaXplZER1cmF0aW9uO1xuICAgICAgICAgICAgcCA9IHAgPiAxID8gMSA6IHAgPCAwID8gMCA6IHA7XG4gICAgICAgICAgICBub2RlMi5kdXJhdGlvblByb2dyZXNzID0gcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9zaXRpb24gPSBmcm9tICsgY29uZmlnMi5lYXNpbmcocCkgKiAodG8yIC0gZnJvbSk7XG4gICAgICAgICAgdmVsb2NpdHkgPSAocG9zaXRpb24gLSBub2RlMi5sYXN0UG9zaXRpb24pIC8gZHQ7XG4gICAgICAgICAgZmluaXNoZWQgPSBwID09IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnMi5kZWNheSkge1xuICAgICAgICAgIGNvbnN0IGRlY2F5ID0gY29uZmlnMi5kZWNheSA9PT0gdHJ1ZSA/IDAuOTk4IDogY29uZmlnMi5kZWNheTtcbiAgICAgICAgICBjb25zdCBlID0gTWF0aC5leHAoLSgxIC0gZGVjYXkpICogZWxhcHNlZCk7XG4gICAgICAgICAgcG9zaXRpb24gPSBmcm9tICsgdjAgLyAoMSAtIGRlY2F5KSAqICgxIC0gZSk7XG4gICAgICAgICAgZmluaXNoZWQgPSBNYXRoLmFicyhub2RlMi5sYXN0UG9zaXRpb24gLSBwb3NpdGlvbikgPD0gcHJlY2lzaW9uO1xuICAgICAgICAgIHZlbG9jaXR5ID0gdjAgKiBlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZlbG9jaXR5ID0gbm9kZTIubGFzdFZlbG9jaXR5ID09IG51bGwgPyB2MCA6IG5vZGUyLmxhc3RWZWxvY2l0eTtcbiAgICAgICAgICBjb25zdCByZXN0VmVsb2NpdHkgPSBjb25maWcyLnJlc3RWZWxvY2l0eSB8fCBwcmVjaXNpb24gLyAxMDtcbiAgICAgICAgICBjb25zdCBib3VuY2VGYWN0b3IgPSBjb25maWcyLmNsYW1wID8gMCA6IGNvbmZpZzIuYm91bmNlO1xuICAgICAgICAgIGNvbnN0IGNhbkJvdW5jZSA9ICFpczUudW5kKGJvdW5jZUZhY3Rvcik7XG4gICAgICAgICAgY29uc3QgaXNHcm93aW5nID0gZnJvbSA9PSB0bzIgPyBub2RlMi52MCA+IDAgOiBmcm9tIDwgdG8yO1xuICAgICAgICAgIGxldCBpc01vdmluZztcbiAgICAgICAgICBsZXQgaXNCb3VuY2luZyA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHN0ZXAgPSAxO1xuICAgICAgICAgIGNvbnN0IG51bVN0ZXBzID0gTWF0aC5jZWlsKGR0IC8gc3RlcCk7XG4gICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBudW1TdGVwczsgKytuKSB7XG4gICAgICAgICAgICBpc01vdmluZyA9IE1hdGguYWJzKHZlbG9jaXR5KSA+IHJlc3RWZWxvY2l0eTtcbiAgICAgICAgICAgIGlmICghaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgZmluaXNoZWQgPSBNYXRoLmFicyh0bzIgLSBwb3NpdGlvbikgPD0gcHJlY2lzaW9uO1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhbkJvdW5jZSkge1xuICAgICAgICAgICAgICBpc0JvdW5jaW5nID0gcG9zaXRpb24gPT0gdG8yIHx8IHBvc2l0aW9uID4gdG8yID09IGlzR3Jvd2luZztcbiAgICAgICAgICAgICAgaWYgKGlzQm91bmNpbmcpIHtcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IC12ZWxvY2l0eSAqIGJvdW5jZUZhY3RvcjtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRvMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3ByaW5nRm9yY2UgPSAtY29uZmlnMi50ZW5zaW9uICogMWUtNiAqIChwb3NpdGlvbiAtIHRvMik7XG4gICAgICAgICAgICBjb25zdCBkYW1waW5nRm9yY2UgPSAtY29uZmlnMi5mcmljdGlvbiAqIDFlLTMgKiB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGFjY2VsZXJhdGlvbiA9IChzcHJpbmdGb3JjZSArIGRhbXBpbmdGb3JjZSkgLyBjb25maWcyLm1hc3M7XG4gICAgICAgICAgICB2ZWxvY2l0eSA9IHZlbG9jaXR5ICsgYWNjZWxlcmF0aW9uICogc3RlcDtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gKyB2ZWxvY2l0eSAqIHN0ZXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUyLmxhc3RWZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHBvc2l0aW9uKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihgR290IE5hTiB3aGlsZSBhbmltYXRpbmc6YCwgdGhpcyk7XG4gICAgICAgICAgZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGF5bG9hZCAmJiAhcGF5bG9hZFtpXS5kb25lKSB7XG4gICAgICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgbm9kZTIuZG9uZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZGxlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAobm9kZTIuc2V0VmFsdWUocG9zaXRpb24sIGNvbmZpZzIucm91bmQpKSB7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG5vZGUgPSBnZXRBbmltYXRlZDIodGhpcyk7XG4gICAgY29uc3QgY3VyclZhbCA9IG5vZGUuZ2V0VmFsdWUoKTtcbiAgICBpZiAoaWRsZSkge1xuICAgICAgY29uc3QgZmluYWxWYWwgPSBnZXRGbHVpZFZhbHVlMihhbmltLnRvKTtcbiAgICAgIGlmICgoY3VyclZhbCAhPT0gZmluYWxWYWwgfHwgY2hhbmdlZCkgJiYgIWNvbmZpZzIuZGVjYXkpIHtcbiAgICAgICAgbm9kZS5zZXRWYWx1ZShmaW5hbFZhbCk7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlKGZpbmFsVmFsKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hhbmdlZCAmJiBjb25maWcyLmRlY2F5KSB7XG4gICAgICAgIHRoaXMuX29uQ2hhbmdlKGN1cnJWYWwpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc3RvcCgpO1xuICAgIH0gZWxzZSBpZiAoY2hhbmdlZCkge1xuICAgICAgdGhpcy5fb25DaGFuZ2UoY3VyclZhbCk7XG4gICAgfVxuICB9XG4gIC8qKiBTZXQgdGhlIGN1cnJlbnQgdmFsdWUsIHdoaWxlIHN0b3BwaW5nIHRoZSBjdXJyZW50IGFuaW1hdGlvbiAqL1xuICBzZXQodmFsdWUpIHtcbiAgICByYWYzLmJhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIHRoaXMuX2ZvY3VzKHZhbHVlKTtcbiAgICAgIHRoaXMuX3NldCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEZyZWV6ZSB0aGUgYWN0aXZlIGFuaW1hdGlvbiBpbiB0aW1lLCBhcyB3ZWxsIGFzIGFueSB1cGRhdGVzIG1lcmdlZFxuICAgKiBiZWZvcmUgYHJlc3VtZWAgaXMgY2FsbGVkLlxuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgdGhpcy5fdXBkYXRlKHsgcGF1c2U6IHRydWUgfSk7XG4gIH1cbiAgLyoqIFJlc3VtZSB0aGUgYW5pbWF0aW9uIGlmIHBhdXNlZC4gKi9cbiAgcmVzdW1lKCkge1xuICAgIHRoaXMuX3VwZGF0ZSh7IHBhdXNlOiBmYWxzZSB9KTtcbiAgfVxuICAvKiogU2tpcCB0byB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbi4gKi9cbiAgZmluaXNoKCkge1xuICAgIGlmIChpc0FuaW1hdGluZyh0aGlzKSkge1xuICAgICAgY29uc3QgeyB0bzogdG8yLCBjb25maWc6IGNvbmZpZzIgfSA9IHRoaXMuYW5pbWF0aW9uO1xuICAgICAgcmFmMy5iYXRjaGVkVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIHRoaXMuX29uU3RhcnQoKTtcbiAgICAgICAgaWYgKCFjb25maWcyLmRlY2F5KSB7XG4gICAgICAgICAgdGhpcy5fc2V0KHRvMiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0b3AoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogUHVzaCBwcm9wcyBpbnRvIHRoZSBwZW5kaW5nIHF1ZXVlLiAqL1xuICB1cGRhdGUocHJvcHMpIHtcbiAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWUgfHwgKHRoaXMucXVldWUgPSBbXSk7XG4gICAgcXVldWUucHVzaChwcm9wcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgc3RhcnQodG8yLCBhcmcyKSB7XG4gICAgbGV0IHF1ZXVlO1xuICAgIGlmICghaXM1LnVuZCh0bzIpKSB7XG4gICAgICBxdWV1ZSA9IFtpczUub2JqKHRvMikgPyB0bzIgOiB7IC4uLmFyZzIsIHRvOiB0bzIgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHF1ZXVlID0gdGhpcy5xdWV1ZSB8fCBbXTtcbiAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFxuICAgICAgcXVldWUubWFwKChwcm9wcykgPT4ge1xuICAgICAgICBjb25zdCB1cCA9IHRoaXMuX3VwZGF0ZShwcm9wcyk7XG4gICAgICAgIHJldHVybiB1cDtcbiAgICAgIH0pXG4gICAgKS50aGVuKChyZXN1bHRzKSA9PiBnZXRDb21iaW5lZFJlc3VsdCh0aGlzLCByZXN1bHRzKSk7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3AgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLCBhbmQgY2FuY2VsIGFueSBkZWxheWVkIHVwZGF0ZXMuXG4gICAqXG4gICAqIFBhc3MgYHRydWVgIHRvIGNhbGwgYG9uUmVzdGAgd2l0aCBgY2FuY2VsbGVkOiB0cnVlYC5cbiAgICovXG4gIHN0b3AoY2FuY2VsKSB7XG4gICAgY29uc3QgeyB0bzogdG8yIH0gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICB0aGlzLl9mb2N1cyh0aGlzLmdldCgpKTtcbiAgICBzdG9wQXN5bmModGhpcy5fc3RhdGUsIGNhbmNlbCAmJiB0aGlzLl9sYXN0Q2FsbElkKTtcbiAgICByYWYzLmJhdGNoZWRVcGRhdGVzKCgpID0+IHRoaXMuX3N0b3AodG8yLCBjYW5jZWwpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKiogUmVzdGFydCB0aGUgYW5pbWF0aW9uLiAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLl91cGRhdGUoeyByZXNldDogdHJ1ZSB9KTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGV2ZW50T2JzZXJ2ZWQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PSBcImNoYW5nZVwiKSB7XG4gICAgICB0aGlzLl9zdGFydCgpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PSBcInByaW9yaXR5XCIpIHtcbiAgICAgIHRoaXMucHJpb3JpdHkgPSBldmVudC5wcmlvcml0eSArIDE7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgYHRvYCBhbmQgYGZyb21gIHJhbmdlIGZyb20gdGhlIGdpdmVuIGBwcm9wc2Agb2JqZWN0LlxuICAgKlxuICAgKiBUaGlzIGFsc28gZW5zdXJlcyB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBhdmFpbGFibGUgdG8gYW5pbWF0ZWQgY29tcG9uZW50c1xuICAgKiBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICovXG4gIF9wcmVwYXJlTm9kZShwcm9wcykge1xuICAgIGNvbnN0IGtleSA9IHRoaXMua2V5IHx8IFwiXCI7XG4gICAgbGV0IHsgdG86IHRvMiwgZnJvbSB9ID0gcHJvcHM7XG4gICAgdG8yID0gaXM1Lm9iaih0bzIpID8gdG8yW2tleV0gOiB0bzI7XG4gICAgaWYgKHRvMiA9PSBudWxsIHx8IGlzQXN5bmNUbyh0bzIpKSB7XG4gICAgICB0bzIgPSB2b2lkIDA7XG4gICAgfVxuICAgIGZyb20gPSBpczUub2JqKGZyb20pID8gZnJvbVtrZXldIDogZnJvbTtcbiAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICBmcm9tID0gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHsgdG86IHRvMiwgZnJvbSB9O1xuICAgIGlmICghaGFzQW5pbWF0ZWQodGhpcykpIHtcbiAgICAgIGlmIChwcm9wcy5yZXZlcnNlKVxuICAgICAgICBbdG8yLCBmcm9tXSA9IFtmcm9tLCB0bzJdO1xuICAgICAgZnJvbSA9IGdldEZsdWlkVmFsdWUyKGZyb20pO1xuICAgICAgaWYgKCFpczUudW5kKGZyb20pKSB7XG4gICAgICAgIHRoaXMuX3NldChmcm9tKTtcbiAgICAgIH0gZWxzZSBpZiAoIWdldEFuaW1hdGVkMih0aGlzKSkge1xuICAgICAgICB0aGlzLl9zZXQodG8yKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xuICB9XG4gIC8qKiBFdmVyeSB1cGRhdGUgaXMgcHJvY2Vzc2VkIGJ5IHRoaXMgbWV0aG9kIGJlZm9yZSBtZXJnaW5nLiAqL1xuICBfdXBkYXRlKHsgLi4ucHJvcHMgfSwgaXNMb29wKSB7XG4gICAgY29uc3QgeyBrZXksIGRlZmF1bHRQcm9wcyB9ID0gdGhpcztcbiAgICBpZiAocHJvcHMuZGVmYXVsdClcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgICAgZ2V0RGVmYXVsdFByb3BzKFxuICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICh2YWx1ZSwgcHJvcCkgPT4gL15vbi8udGVzdChwcm9wKSA/IHJlc29sdmVQcm9wKHZhbHVlLCBrZXkpIDogdmFsdWVcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICBtZXJnZUFjdGl2ZUZuKHRoaXMsIHByb3BzLCBcIm9uUHJvcHNcIik7XG4gICAgc2VuZEV2ZW50KHRoaXMsIFwib25Qcm9wc1wiLCBwcm9wcywgdGhpcyk7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLl9wcmVwYXJlTm9kZShwcm9wcyk7XG4gICAgaWYgKE9iamVjdC5pc0Zyb3plbih0aGlzKSkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIFwiQ2Fubm90IGFuaW1hdGUgYSBgU3ByaW5nVmFsdWVgIG9iamVjdCB0aGF0IGlzIGZyb3plbi4gRGlkIHlvdSBmb3JnZXQgdG8gcGFzcyB5b3VyIGNvbXBvbmVudCB0byBgYW5pbWF0ZWQoLi4uKWAgYmVmb3JlIGFuaW1hdGluZyBpdHMgcHJvcHM/XCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgcmV0dXJuIHNjaGVkdWxlUHJvcHMoKyt0aGlzLl9sYXN0Q2FsbElkLCB7XG4gICAgICBrZXksXG4gICAgICBwcm9wcyxcbiAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgIHN0YXRlLFxuICAgICAgYWN0aW9uczoge1xuICAgICAgICBwYXVzZTogKCkgPT4ge1xuICAgICAgICAgIGlmICghaXNQYXVzZWQodGhpcykpIHtcbiAgICAgICAgICAgIHNldFBhdXNlZEJpdCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIGZsdXNoQ2FsbHMoc3RhdGUucGF1c2VRdWV1ZSk7XG4gICAgICAgICAgICBzZW5kRXZlbnQoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIFwib25QYXVzZVwiLFxuICAgICAgICAgICAgICBnZXRGaW5pc2hlZFJlc3VsdCh0aGlzLCBjaGVja0ZpbmlzaGVkKHRoaXMsIHRoaXMuYW5pbWF0aW9uLnRvKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXN1bWU6ICgpID0+IHtcbiAgICAgICAgICBpZiAoaXNQYXVzZWQodGhpcykpIHtcbiAgICAgICAgICAgIHNldFBhdXNlZEJpdCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAoaXNBbmltYXRpbmcodGhpcykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcmVzdW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmbHVzaENhbGxzKHN0YXRlLnJlc3VtZVF1ZXVlKTtcbiAgICAgICAgICAgIHNlbmRFdmVudChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgXCJvblJlc3VtZVwiLFxuICAgICAgICAgICAgICBnZXRGaW5pc2hlZFJlc3VsdCh0aGlzLCBjaGVja0ZpbmlzaGVkKHRoaXMsIHRoaXMuYW5pbWF0aW9uLnRvKSksXG4gICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdGFydDogdGhpcy5fbWVyZ2UuYmluZCh0aGlzLCByYW5nZSlcbiAgICAgIH1cbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIGlmIChwcm9wcy5sb29wICYmIHJlc3VsdC5maW5pc2hlZCAmJiAhKGlzTG9vcCAmJiByZXN1bHQubm9vcCkpIHtcbiAgICAgICAgY29uc3QgbmV4dFByb3BzID0gY3JlYXRlTG9vcFVwZGF0ZShwcm9wcyk7XG4gICAgICAgIGlmIChuZXh0UHJvcHMpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fdXBkYXRlKG5leHRQcm9wcywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqIE1lcmdlIHByb3BzIGludG8gdGhlIGN1cnJlbnQgYW5pbWF0aW9uICovXG4gIF9tZXJnZShyYW5nZSwgcHJvcHMsIHJlc29sdmUpIHtcbiAgICBpZiAocHJvcHMuY2FuY2VsKSB7XG4gICAgICB0aGlzLnN0b3AodHJ1ZSk7XG4gICAgICByZXR1cm4gcmVzb2x2ZShnZXRDYW5jZWxsZWRSZXN1bHQodGhpcykpO1xuICAgIH1cbiAgICBjb25zdCBoYXNUb1Byb3AgPSAhaXM1LnVuZChyYW5nZS50byk7XG4gICAgY29uc3QgaGFzRnJvbVByb3AgPSAhaXM1LnVuZChyYW5nZS5mcm9tKTtcbiAgICBpZiAoaGFzVG9Qcm9wIHx8IGhhc0Zyb21Qcm9wKSB7XG4gICAgICBpZiAocHJvcHMuY2FsbElkID4gdGhpcy5fbGFzdFRvSWQpIHtcbiAgICAgICAgdGhpcy5fbGFzdFRvSWQgPSBwcm9wcy5jYWxsSWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShnZXRDYW5jZWxsZWRSZXN1bHQodGhpcykpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGtleSwgZGVmYXVsdFByb3BzLCBhbmltYXRpb246IGFuaW0gfSA9IHRoaXM7XG4gICAgY29uc3QgeyB0bzogcHJldlRvLCBmcm9tOiBwcmV2RnJvbSB9ID0gYW5pbTtcbiAgICBsZXQgeyB0bzogdG8yID0gcHJldlRvLCBmcm9tID0gcHJldkZyb20gfSA9IHJhbmdlO1xuICAgIGlmIChoYXNGcm9tUHJvcCAmJiAhaGFzVG9Qcm9wICYmICghcHJvcHMuZGVmYXVsdCB8fCBpczUudW5kKHRvMikpKSB7XG4gICAgICB0bzIgPSBmcm9tO1xuICAgIH1cbiAgICBpZiAocHJvcHMucmV2ZXJzZSlcbiAgICAgIFt0bzIsIGZyb21dID0gW2Zyb20sIHRvMl07XG4gICAgY29uc3QgaGFzRnJvbUNoYW5nZWQgPSAhaXNFcXVhbChmcm9tLCBwcmV2RnJvbSk7XG4gICAgaWYgKGhhc0Zyb21DaGFuZ2VkKSB7XG4gICAgICBhbmltLmZyb20gPSBmcm9tO1xuICAgIH1cbiAgICBmcm9tID0gZ2V0Rmx1aWRWYWx1ZTIoZnJvbSk7XG4gICAgY29uc3QgaGFzVG9DaGFuZ2VkID0gIWlzRXF1YWwodG8yLCBwcmV2VG8pO1xuICAgIGlmIChoYXNUb0NoYW5nZWQpIHtcbiAgICAgIHRoaXMuX2ZvY3VzKHRvMik7XG4gICAgfVxuICAgIGNvbnN0IGhhc0FzeW5jVG8gPSBpc0FzeW5jVG8ocHJvcHMudG8pO1xuICAgIGNvbnN0IHsgY29uZmlnOiBjb25maWcyIH0gPSBhbmltO1xuICAgIGNvbnN0IHsgZGVjYXksIHZlbG9jaXR5IH0gPSBjb25maWcyO1xuICAgIGlmIChoYXNUb1Byb3AgfHwgaGFzRnJvbVByb3ApIHtcbiAgICAgIGNvbmZpZzIudmVsb2NpdHkgPSAwO1xuICAgIH1cbiAgICBpZiAocHJvcHMuY29uZmlnICYmICFoYXNBc3luY1RvKSB7XG4gICAgICBtZXJnZUNvbmZpZyhcbiAgICAgICAgY29uZmlnMixcbiAgICAgICAgY2FsbFByb3AocHJvcHMuY29uZmlnLCBrZXkpLFxuICAgICAgICAvLyBBdm9pZCBjYWxsaW5nIHRoZSBzYW1lIFwiY29uZmlnXCIgcHJvcCB0d2ljZS5cbiAgICAgICAgcHJvcHMuY29uZmlnICE9PSBkZWZhdWx0UHJvcHMuY29uZmlnID8gY2FsbFByb3AoZGVmYXVsdFByb3BzLmNvbmZpZywga2V5KSA6IHZvaWQgMFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSBnZXRBbmltYXRlZDIodGhpcyk7XG4gICAgaWYgKCFub2RlIHx8IGlzNS51bmQodG8yKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmUoZ2V0RmluaXNoZWRSZXN1bHQodGhpcywgdHJ1ZSkpO1xuICAgIH1cbiAgICBjb25zdCByZXNldCA9IChcbiAgICAgIC8vIFdoZW4gYHJlc2V0YCBpcyB1bmRlZmluZWQsIHRoZSBgZnJvbWAgcHJvcCBpbXBsaWVzIGByZXNldDogdHJ1ZWAsXG4gICAgICAvLyBleGNlcHQgZm9yIGRlY2xhcmF0aXZlIHVwZGF0ZXMuIFdoZW4gYHJlc2V0YCBpcyBkZWZpbmVkLCB0aGVyZVxuICAgICAgLy8gbXVzdCBleGlzdCBhIHZhbHVlIHRvIGFuaW1hdGUgZnJvbS5cbiAgICAgIGlzNS51bmQocHJvcHMucmVzZXQpID8gaGFzRnJvbVByb3AgJiYgIXByb3BzLmRlZmF1bHQgOiAhaXM1LnVuZChmcm9tKSAmJiBtYXRjaFByb3AocHJvcHMucmVzZXQsIGtleSlcbiAgICApO1xuICAgIGNvbnN0IHZhbHVlID0gcmVzZXQgPyBmcm9tIDogdGhpcy5nZXQoKTtcbiAgICBjb25zdCBnb2FsID0gY29tcHV0ZUdvYWwodG8yKTtcbiAgICBjb25zdCBpc0FuaW1hdGFibGUgPSBpczUubnVtKGdvYWwpIHx8IGlzNS5hcnIoZ29hbCkgfHwgaXNBbmltYXRlZFN0cmluZzIoZ29hbCk7XG4gICAgY29uc3QgaW1tZWRpYXRlID0gIWhhc0FzeW5jVG8gJiYgKCFpc0FuaW1hdGFibGUgfHwgbWF0Y2hQcm9wKGRlZmF1bHRQcm9wcy5pbW1lZGlhdGUgfHwgcHJvcHMuaW1tZWRpYXRlLCBrZXkpKTtcbiAgICBpZiAoaGFzVG9DaGFuZ2VkKSB7XG4gICAgICBjb25zdCBub2RlVHlwZSA9IGdldEFuaW1hdGVkVHlwZSh0bzIpO1xuICAgICAgaWYgKG5vZGVUeXBlICE9PSBub2RlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmIChpbW1lZGlhdGUpIHtcbiAgICAgICAgICBub2RlID0gdGhpcy5fc2V0KGdvYWwpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aHJvdyBFcnJvcihcbiAgICAgICAgICAgIGBDYW5ub3QgYW5pbWF0ZSBiZXR3ZWVuICR7bm9kZS5jb25zdHJ1Y3Rvci5uYW1lfSBhbmQgJHtub2RlVHlwZS5uYW1lfSwgYXMgdGhlIFwidG9cIiBwcm9wIHN1Z2dlc3RzYFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGdvYWxUeXBlID0gbm9kZS5jb25zdHJ1Y3RvcjtcbiAgICBsZXQgc3RhcnRlZCA9IGhhc0ZsdWlkVmFsdWUodG8yKTtcbiAgICBsZXQgZmluaXNoZWQgPSBmYWxzZTtcbiAgICBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGNvbnN0IGhhc1ZhbHVlQ2hhbmdlZCA9IHJlc2V0IHx8ICFoYXNBbmltYXRlZCh0aGlzKSAmJiBoYXNGcm9tQ2hhbmdlZDtcbiAgICAgIGlmIChoYXNUb0NoYW5nZWQgfHwgaGFzVmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgIGZpbmlzaGVkID0gaXNFcXVhbChjb21wdXRlR29hbCh2YWx1ZSksIGdvYWwpO1xuICAgICAgICBzdGFydGVkID0gIWZpbmlzaGVkO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VxdWFsKGFuaW0uaW1tZWRpYXRlLCBpbW1lZGlhdGUpICYmICFpbW1lZGlhdGUgfHwgIWlzRXF1YWwoY29uZmlnMi5kZWNheSwgZGVjYXkpIHx8ICFpc0VxdWFsKGNvbmZpZzIudmVsb2NpdHksIHZlbG9jaXR5KSkge1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZpbmlzaGVkICYmIGlzQW5pbWF0aW5nKHRoaXMpKSB7XG4gICAgICBpZiAoYW5pbS5jaGFuZ2VkICYmICFyZXNldCkge1xuICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgICAgdGhpcy5fc3RvcChwcmV2VG8pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWhhc0FzeW5jVG8pIHtcbiAgICAgIGlmIChzdGFydGVkIHx8IGhhc0ZsdWlkVmFsdWUocHJldlRvKSkge1xuICAgICAgICBhbmltLnZhbHVlcyA9IG5vZGUuZ2V0UGF5bG9hZCgpO1xuICAgICAgICBhbmltLnRvVmFsdWVzID0gaGFzRmx1aWRWYWx1ZSh0bzIpID8gbnVsbCA6IGdvYWxUeXBlID09IEFuaW1hdGVkU3RyaW5nID8gWzFdIDogdG9BcnJheTIoZ29hbCk7XG4gICAgICB9XG4gICAgICBpZiAoYW5pbS5pbW1lZGlhdGUgIT0gaW1tZWRpYXRlKSB7XG4gICAgICAgIGFuaW0uaW1tZWRpYXRlID0gaW1tZWRpYXRlO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSAmJiAhcmVzZXQpIHtcbiAgICAgICAgICB0aGlzLl9zZXQocHJldlRvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHN0YXJ0ZWQpIHtcbiAgICAgICAgY29uc3QgeyBvblJlc3QgfSA9IGFuaW07XG4gICAgICAgIGVhY2gyKEFDVElWRV9FVkVOVFMsICh0eXBlKSA9PiBtZXJnZUFjdGl2ZUZuKHRoaXMsIHByb3BzLCB0eXBlKSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGdldEZpbmlzaGVkUmVzdWx0KHRoaXMsIGNoZWNrRmluaXNoZWQodGhpcywgcHJldlRvKSk7XG4gICAgICAgIGZsdXNoQ2FsbHModGhpcy5fcGVuZGluZ0NhbGxzLCByZXN1bHQpO1xuICAgICAgICB0aGlzLl9wZW5kaW5nQ2FsbHMuYWRkKHJlc29sdmUpO1xuICAgICAgICBpZiAoYW5pbS5jaGFuZ2VkKVxuICAgICAgICAgIHJhZjMuYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgYW5pbS5jaGFuZ2VkID0gIXJlc2V0O1xuICAgICAgICAgICAgb25SZXN0Py4ocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgICAgIGlmIChyZXNldCkge1xuICAgICAgICAgICAgICBjYWxsUHJvcChkZWZhdWx0UHJvcHMub25SZXN0LCByZXN1bHQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYW5pbS5vblN0YXJ0Py4ocmVzdWx0LCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICB0aGlzLl9zZXQodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaGFzQXN5bmNUbykge1xuICAgICAgcmVzb2x2ZShydW5Bc3luYyhwcm9wcy50bywgcHJvcHMsIHRoaXMuX3N0YXRlLCB0aGlzKSk7XG4gICAgfSBlbHNlIGlmIChzdGFydGVkKSB7XG4gICAgICB0aGlzLl9zdGFydCgpO1xuICAgIH0gZWxzZSBpZiAoaXNBbmltYXRpbmcodGhpcykgJiYgIWhhc1RvQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fcGVuZGluZ0NhbGxzLmFkZChyZXNvbHZlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShnZXROb29wUmVzdWx0KHZhbHVlKSk7XG4gICAgfVxuICB9XG4gIC8qKiBVcGRhdGUgdGhlIGBhbmltYXRpb24udG9gIHZhbHVlLCB3aGljaCBtaWdodCBiZSBhIGBGbHVpZFZhbHVlYCAqL1xuICBfZm9jdXModmFsdWUpIHtcbiAgICBjb25zdCBhbmltID0gdGhpcy5hbmltYXRpb247XG4gICAgaWYgKHZhbHVlICE9PSBhbmltLnRvKSB7XG4gICAgICBpZiAoZ2V0Rmx1aWRPYnNlcnZlcnModGhpcykpIHtcbiAgICAgICAgdGhpcy5fZGV0YWNoKCk7XG4gICAgICB9XG4gICAgICBhbmltLnRvID0gdmFsdWU7XG4gICAgICBpZiAoZ2V0Rmx1aWRPYnNlcnZlcnModGhpcykpIHtcbiAgICAgICAgdGhpcy5fYXR0YWNoKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9hdHRhY2goKSB7XG4gICAgbGV0IHByaW9yaXR5ID0gMDtcbiAgICBjb25zdCB7IHRvOiB0bzIgfSA9IHRoaXMuYW5pbWF0aW9uO1xuICAgIGlmIChoYXNGbHVpZFZhbHVlKHRvMikpIHtcbiAgICAgIGFkZEZsdWlkT2JzZXJ2ZXIodG8yLCB0aGlzKTtcbiAgICAgIGlmIChpc0ZyYW1lVmFsdWUodG8yKSkge1xuICAgICAgICBwcmlvcml0eSA9IHRvMi5wcmlvcml0eSArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgfVxuICBfZGV0YWNoKCkge1xuICAgIGNvbnN0IHsgdG86IHRvMiB9ID0gdGhpcy5hbmltYXRpb247XG4gICAgaWYgKGhhc0ZsdWlkVmFsdWUodG8yKSkge1xuICAgICAgcmVtb3ZlRmx1aWRPYnNlcnZlcih0bzIsIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogVXBkYXRlIHRoZSBjdXJyZW50IHZhbHVlIGZyb20gb3V0c2lkZSB0aGUgZnJhbWVsb29wLFxuICAgKiBhbmQgcmV0dXJuIHRoZSBgQW5pbWF0ZWRgIG5vZGUuXG4gICAqL1xuICBfc2V0KGFyZywgaWRsZSA9IHRydWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldEZsdWlkVmFsdWUyKGFyZyk7XG4gICAgaWYgKCFpczUudW5kKHZhbHVlKSkge1xuICAgICAgY29uc3Qgb2xkTm9kZSA9IGdldEFuaW1hdGVkMih0aGlzKTtcbiAgICAgIGlmICghb2xkTm9kZSB8fCAhaXNFcXVhbCh2YWx1ZSwgb2xkTm9kZS5nZXRWYWx1ZSgpKSkge1xuICAgICAgICBjb25zdCBub2RlVHlwZSA9IGdldEFuaW1hdGVkVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICghb2xkTm9kZSB8fCBvbGROb2RlLmNvbnN0cnVjdG9yICE9IG5vZGVUeXBlKSB7XG4gICAgICAgICAgc2V0QW5pbWF0ZWQodGhpcywgbm9kZVR5cGUuY3JlYXRlKHZhbHVlKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2xkTm9kZS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9sZE5vZGUpIHtcbiAgICAgICAgICByYWYzLmJhdGNoZWRVcGRhdGVzKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX29uQ2hhbmdlKHZhbHVlLCBpZGxlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZ2V0QW5pbWF0ZWQyKHRoaXMpO1xuICB9XG4gIF9vblN0YXJ0KCkge1xuICAgIGNvbnN0IGFuaW0gPSB0aGlzLmFuaW1hdGlvbjtcbiAgICBpZiAoIWFuaW0uY2hhbmdlZCkge1xuICAgICAgYW5pbS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHNlbmRFdmVudChcbiAgICAgICAgdGhpcyxcbiAgICAgICAgXCJvblN0YXJ0XCIsXG4gICAgICAgIGdldEZpbmlzaGVkUmVzdWx0KHRoaXMsIGNoZWNrRmluaXNoZWQodGhpcywgYW5pbS50bykpLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICBfb25DaGFuZ2UodmFsdWUsIGlkbGUpIHtcbiAgICBpZiAoIWlkbGUpIHtcbiAgICAgIHRoaXMuX29uU3RhcnQoKTtcbiAgICAgIGNhbGxQcm9wKHRoaXMuYW5pbWF0aW9uLm9uQ2hhbmdlLCB2YWx1ZSwgdGhpcyk7XG4gICAgfVxuICAgIGNhbGxQcm9wKHRoaXMuZGVmYXVsdFByb3BzLm9uQ2hhbmdlLCB2YWx1ZSwgdGhpcyk7XG4gICAgc3VwZXIuX29uQ2hhbmdlKHZhbHVlLCBpZGxlKTtcbiAgfVxuICAvLyBUaGlzIG1ldGhvZCByZXNldHMgdGhlIGFuaW1hdGlvbiBzdGF0ZSAoZXZlbiBpZiBhbHJlYWR5IGFuaW1hdGluZykgdG9cbiAgLy8gZW5zdXJlIHRoZSBsYXRlc3QgZnJvbS90byByYW5nZSBpcyB1c2VkLCBhbmQgaXQgYWxzbyBlbnN1cmVzIHRoaXMgc3ByaW5nXG4gIC8vIGlzIGFkZGVkIHRvIHRoZSBmcmFtZWxvb3AuXG4gIF9zdGFydCgpIHtcbiAgICBjb25zdCBhbmltID0gdGhpcy5hbmltYXRpb247XG4gICAgZ2V0QW5pbWF0ZWQyKHRoaXMpLnJlc2V0KGdldEZsdWlkVmFsdWUyKGFuaW0udG8pKTtcbiAgICBpZiAoIWFuaW0uaW1tZWRpYXRlKSB7XG4gICAgICBhbmltLmZyb21WYWx1ZXMgPSBhbmltLnZhbHVlcy5tYXAoKG5vZGUpID0+IG5vZGUubGFzdFBvc2l0aW9uKTtcbiAgICB9XG4gICAgaWYgKCFpc0FuaW1hdGluZyh0aGlzKSkge1xuICAgICAgc2V0QWN0aXZlQml0KHRoaXMsIHRydWUpO1xuICAgICAgaWYgKCFpc1BhdXNlZCh0aGlzKSkge1xuICAgICAgICB0aGlzLl9yZXN1bWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgX3Jlc3VtZSgpIHtcbiAgICBpZiAoRzUuc2tpcEFuaW1hdGlvbikge1xuICAgICAgdGhpcy5maW5pc2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJhbWVMb29wMi5zdGFydCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4aXQgdGhlIGZyYW1lbG9vcCBhbmQgbm90aWZ5IGBvblJlc3RgIGxpc3RlbmVycy5cbiAgICpcbiAgICogQWx3YXlzIHdyYXAgYF9zdG9wYCBjYWxscyB3aXRoIGBiYXRjaGVkVXBkYXRlc2AuXG4gICAqL1xuICBfc3RvcChnb2FsLCBjYW5jZWwpIHtcbiAgICBpZiAoaXNBbmltYXRpbmcodGhpcykpIHtcbiAgICAgIHNldEFjdGl2ZUJpdCh0aGlzLCBmYWxzZSk7XG4gICAgICBjb25zdCBhbmltID0gdGhpcy5hbmltYXRpb247XG4gICAgICBlYWNoMihhbmltLnZhbHVlcywgKG5vZGUpID0+IHtcbiAgICAgICAgbm9kZS5kb25lID0gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGFuaW0udG9WYWx1ZXMpIHtcbiAgICAgICAgYW5pbS5vbkNoYW5nZSA9IGFuaW0ub25QYXVzZSA9IGFuaW0ub25SZXN1bWUgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgICBjYWxsRmx1aWRPYnNlcnZlcnMyKHRoaXMsIHtcbiAgICAgICAgdHlwZTogXCJpZGxlXCIsXG4gICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBjYW5jZWwgPyBnZXRDYW5jZWxsZWRSZXN1bHQodGhpcy5nZXQoKSkgOiBnZXRGaW5pc2hlZFJlc3VsdCh0aGlzLmdldCgpLCBjaGVja0ZpbmlzaGVkKHRoaXMsIGdvYWwgPz8gYW5pbS50bykpO1xuICAgICAgZmx1c2hDYWxscyh0aGlzLl9wZW5kaW5nQ2FsbHMsIHJlc3VsdCk7XG4gICAgICBpZiAoYW5pbS5jaGFuZ2VkKSB7XG4gICAgICAgIGFuaW0uY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICBzZW5kRXZlbnQodGhpcywgXCJvblJlc3RcIiwgcmVzdWx0LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjaGVja0ZpbmlzaGVkKHRhcmdldCwgdG8yKSB7XG4gIGNvbnN0IGdvYWwgPSBjb21wdXRlR29hbCh0bzIpO1xuICBjb25zdCB2YWx1ZSA9IGNvbXB1dGVHb2FsKHRhcmdldC5nZXQoKSk7XG4gIHJldHVybiBpc0VxdWFsKHZhbHVlLCBnb2FsKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxvb3BVcGRhdGUocHJvcHMsIGxvb3AgPSBwcm9wcy5sb29wLCB0bzIgPSBwcm9wcy50bykge1xuICBjb25zdCBsb29wUmV0ID0gY2FsbFByb3AobG9vcCk7XG4gIGlmIChsb29wUmV0KSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVzID0gbG9vcFJldCAhPT0gdHJ1ZSAmJiBpbmZlclRvKGxvb3BSZXQpO1xuICAgIGNvbnN0IHJldmVyc2UgPSAob3ZlcnJpZGVzIHx8IHByb3BzKS5yZXZlcnNlO1xuICAgIGNvbnN0IHJlc2V0ID0gIW92ZXJyaWRlcyB8fCBvdmVycmlkZXMucmVzZXQ7XG4gICAgcmV0dXJuIGNyZWF0ZVVwZGF0ZSh7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIGxvb3AsXG4gICAgICAvLyBBdm9pZCB1cGRhdGluZyBkZWZhdWx0IHByb3BzIHdoZW4gbG9vcGluZy5cbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgLy8gTmV2ZXIgbG9vcCB0aGUgYHBhdXNlYCBwcm9wLlxuICAgICAgcGF1c2U6IHZvaWQgMCxcbiAgICAgIC8vIEZvciB0aGUgXCJyZXZlcnNlXCIgcHJvcCB0byBsb29wIGFzIGV4cGVjdGVkLCB0aGUgXCJ0b1wiIHByb3BcbiAgICAgIC8vIG11c3QgYmUgdW5kZWZpbmVkLiBUaGUgXCJyZXZlcnNlXCIgcHJvcCBpcyBpZ25vcmVkIHdoZW4gdGhlXG4gICAgICAvLyBcInRvXCIgcHJvcCBpcyBhbiBhcnJheSBvciBmdW5jdGlvbi5cbiAgICAgIHRvOiAhcmV2ZXJzZSB8fCBpc0FzeW5jVG8odG8yKSA/IHRvMiA6IHZvaWQgMCxcbiAgICAgIC8vIElnbm9yZSB0aGUgXCJmcm9tXCIgcHJvcCBleGNlcHQgb24gcmVzZXQuXG4gICAgICBmcm9tOiByZXNldCA/IHByb3BzLmZyb20gOiB2b2lkIDAsXG4gICAgICByZXNldCxcbiAgICAgIC8vIFRoZSBcImxvb3BcIiBwcm9wIGNhbiByZXR1cm4gYSBcInVzZVNwcmluZ1wiIHByb3BzIG9iamVjdCB0b1xuICAgICAgLy8gb3ZlcnJpZGUgYW55IG9mIHRoZSBvcmlnaW5hbCBwcm9wcy5cbiAgICAgIC4uLm92ZXJyaWRlc1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVVcGRhdGUocHJvcHMpIHtcbiAgY29uc3QgeyB0bzogdG8yLCBmcm9tIH0gPSBwcm9wcyA9IGluZmVyVG8ocHJvcHMpO1xuICBjb25zdCBrZXlzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgaWYgKGlzNS5vYmoodG8yKSlcbiAgICBmaW5kRGVmaW5lZCh0bzIsIGtleXMpO1xuICBpZiAoaXM1Lm9iaihmcm9tKSlcbiAgICBmaW5kRGVmaW5lZChmcm9tLCBrZXlzKTtcbiAgcHJvcHMua2V5cyA9IGtleXMuc2l6ZSA/IEFycmF5LmZyb20oa2V5cykgOiBudWxsO1xuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBkZWNsYXJlVXBkYXRlKHByb3BzKSB7XG4gIGNvbnN0IHVwZGF0ZTIgPSBjcmVhdGVVcGRhdGUocHJvcHMpO1xuICBpZiAoaXM1LnVuZCh1cGRhdGUyLmRlZmF1bHQpKSB7XG4gICAgdXBkYXRlMi5kZWZhdWx0ID0gZ2V0RGVmYXVsdFByb3BzKHVwZGF0ZTIpO1xuICB9XG4gIHJldHVybiB1cGRhdGUyO1xufVxuZnVuY3Rpb24gZmluZERlZmluZWQodmFsdWVzLCBrZXlzKSB7XG4gIGVhY2hQcm9wMyh2YWx1ZXMsICh2YWx1ZSwga2V5KSA9PiB2YWx1ZSAhPSBudWxsICYmIGtleXMuYWRkKGtleSkpO1xufVxudmFyIEFDVElWRV9FVkVOVFMgPSBbXG4gIFwib25TdGFydFwiLFxuICBcIm9uUmVzdFwiLFxuICBcIm9uQ2hhbmdlXCIsXG4gIFwib25QYXVzZVwiLFxuICBcIm9uUmVzdW1lXCJcbl07XG5mdW5jdGlvbiBtZXJnZUFjdGl2ZUZuKHRhcmdldCwgcHJvcHMsIHR5cGUpIHtcbiAgdGFyZ2V0LmFuaW1hdGlvblt0eXBlXSA9IHByb3BzW3R5cGVdICE9PSBnZXREZWZhdWx0UHJvcChwcm9wcywgdHlwZSkgPyByZXNvbHZlUHJvcChwcm9wc1t0eXBlXSwgdGFyZ2V0LmtleSkgOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBzZW5kRXZlbnQodGFyZ2V0LCB0eXBlLCAuLi5hcmdzKSB7XG4gIHRhcmdldC5hbmltYXRpb25bdHlwZV0/LiguLi5hcmdzKTtcbiAgdGFyZ2V0LmRlZmF1bHRQcm9wc1t0eXBlXT8uKC4uLmFyZ3MpO1xufVxuXG4vLyBzcmMvQ29udHJvbGxlci50c1xuaW1wb3J0IHtcbiAgaXMgYXMgaXM2LFxuICByYWYgYXMgcmFmNCxcbiAgZWFjaCBhcyBlYWNoMyxcbiAgbm9vcCxcbiAgZmx1c2ggYXMgZmx1c2gyLFxuICB0b0FycmF5IGFzIHRvQXJyYXkzLFxuICBlYWNoUHJvcCBhcyBlYWNoUHJvcDQsXG4gIGZsdXNoQ2FsbHMgYXMgZmx1c2hDYWxsczIsXG4gIGFkZEZsdWlkT2JzZXJ2ZXIgYXMgYWRkRmx1aWRPYnNlcnZlcjJcbn0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG52YXIgQkFUQ0hFRF9FVkVOVFMgPSBbXCJvblN0YXJ0XCIsIFwib25DaGFuZ2VcIiwgXCJvblJlc3RcIl07XG52YXIgbmV4dElkMiA9IDE7XG52YXIgQ29udHJvbGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IocHJvcHMsIGZsdXNoMykge1xuICAgIHRoaXMuaWQgPSBuZXh0SWQyKys7XG4gICAgLyoqIFRoZSBhbmltYXRlZCB2YWx1ZXMgKi9cbiAgICB0aGlzLnNwcmluZ3MgPSB7fTtcbiAgICAvKiogVGhlIHF1ZXVlIG9mIHByb3BzIHBhc3NlZCB0byB0aGUgYHVwZGF0ZWAgbWV0aG9kLiAqL1xuICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAvKiogVGhlIGNvdW50ZXIgZm9yIHRyYWNraW5nIGBzY2hlZHVsZVByb3BzYCBjYWxscyAqL1xuICAgIHRoaXMuX2xhc3RBc3luY0lkID0gMDtcbiAgICAvKiogVGhlIHZhbHVlcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQgKi9cbiAgICB0aGlzLl9hY3RpdmUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIC8qKiBUaGUgdmFsdWVzIHRoYXQgY2hhbmdlZCByZWNlbnRseSAqL1xuICAgIHRoaXMuX2NoYW5nZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIC8qKiBFcXVhbHMgZmFsc2Ugd2hlbiBgb25TdGFydGAgbGlzdGVuZXJzIGNhbiBiZSBjYWxsZWQgKi9cbiAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XG4gICAgLyoqIFN0YXRlIHVzZWQgYnkgdGhlIGBydW5Bc3luY2AgZnVuY3Rpb24gKi9cbiAgICB0aGlzLl9zdGF0ZSA9IHtcbiAgICAgIHBhdXNlZDogZmFsc2UsXG4gICAgICBwYXVzZVF1ZXVlOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgICAgcmVzdW1lUXVldWU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICB0aW1lb3V0czogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgIH07XG4gICAgLyoqIFRoZSBldmVudCBxdWV1ZXMgdGhhdCBhcmUgZmx1c2hlZCBvbmNlIHBlciBmcmFtZSBtYXhpbXVtICovXG4gICAgdGhpcy5fZXZlbnRzID0ge1xuICAgICAgb25TdGFydDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIG9uQ2hhbmdlOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgb25SZXN0OiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gICAgfTtcbiAgICB0aGlzLl9vbkZyYW1lID0gdGhpcy5fb25GcmFtZS5iaW5kKHRoaXMpO1xuICAgIGlmIChmbHVzaDMpIHtcbiAgICAgIHRoaXMuX2ZsdXNoID0gZmx1c2gzO1xuICAgIH1cbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHRoaXMuc3RhcnQoeyBkZWZhdWx0OiB0cnVlLCAuLi5wcm9wcyB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEVxdWFscyBgdHJ1ZWAgd2hlbiBubyBzcHJpbmcgdmFsdWVzIGFyZSBpbiB0aGUgZnJhbWVsb29wLCBhbmRcbiAgICogbm8gYXN5bmMgYW5pbWF0aW9uIGlzIGN1cnJlbnRseSBhY3RpdmUuXG4gICAqL1xuICBnZXQgaWRsZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuX3N0YXRlLmFzeW5jVG8gJiYgT2JqZWN0LnZhbHVlcyh0aGlzLnNwcmluZ3MpLmV2ZXJ5KChzcHJpbmcpID0+IHtcbiAgICAgIHJldHVybiBzcHJpbmcuaWRsZSAmJiAhc3ByaW5nLmlzRGVsYXllZCAmJiAhc3ByaW5nLmlzUGF1c2VkO1xuICAgIH0pO1xuICB9XG4gIGdldCBpdGVtKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtO1xuICB9XG4gIHNldCBpdGVtKGl0ZW0pIHtcbiAgICB0aGlzLl9pdGVtID0gaXRlbTtcbiAgfVxuICAvKiogR2V0IHRoZSBjdXJyZW50IHZhbHVlcyBvZiBvdXIgc3ByaW5ncyAqL1xuICBnZXQoKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgdGhpcy5lYWNoKChzcHJpbmcsIGtleSkgPT4gdmFsdWVzW2tleV0gPSBzcHJpbmcuZ2V0KCkpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cbiAgLyoqIFNldCB0aGUgY3VycmVudCB2YWx1ZXMgd2l0aG91dCBhbmltYXRpbmcuICovXG4gIHNldCh2YWx1ZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgICBpZiAoIWlzNi51bmQodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuc3ByaW5nc1trZXldLnNldCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKiBQdXNoIGFuIHVwZGF0ZSBvbnRvIHRoZSBxdWV1ZSBvZiBlYWNoIHZhbHVlLiAqL1xuICB1cGRhdGUocHJvcHMpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHRoaXMucXVldWUucHVzaChjcmVhdGVVcGRhdGUocHJvcHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IHRoZSBxdWV1ZWQgYW5pbWF0aW9ucyBmb3IgZXZlcnkgc3ByaW5nLCBhbmQgcmVzb2x2ZSB0aGUgcmV0dXJuZWRcbiAgICogcHJvbWlzZSBvbmNlIGFsbCBxdWV1ZWQgYW5pbWF0aW9ucyBoYXZlIGZpbmlzaGVkIG9yIGJlZW4gY2FuY2VsbGVkLlxuICAgKlxuICAgKiBXaGVuIHlvdSBwYXNzIGEgcXVldWUgKGluc3RlYWQgb2Ygbm90aGluZyksIHRoYXQgcXVldWUgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAqIHRoZSBxdWV1ZWQgYW5pbWF0aW9ucyBhZGRlZCB3aXRoIHRoZSBgdXBkYXRlYCBtZXRob2QsIHdoaWNoIGFyZSBsZWZ0IGFsb25lLlxuICAgKi9cbiAgc3RhcnQocHJvcHMpIHtcbiAgICBsZXQgeyBxdWV1ZSB9ID0gdGhpcztcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIHF1ZXVlID0gdG9BcnJheTMocHJvcHMpLm1hcChjcmVhdGVVcGRhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnF1ZXVlID0gW107XG4gICAgfVxuICAgIGlmICh0aGlzLl9mbHVzaCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZsdXNoKHRoaXMsIHF1ZXVlKTtcbiAgICB9XG4gICAgcHJlcGFyZUtleXModGhpcywgcXVldWUpO1xuICAgIHJldHVybiBmbHVzaFVwZGF0ZVF1ZXVlKHRoaXMsIHF1ZXVlKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHN0b3AoYXJnLCBrZXlzKSB7XG4gICAgaWYgKGFyZyAhPT0gISFhcmcpIHtcbiAgICAgIGtleXMgPSBhcmc7XG4gICAgfVxuICAgIGlmIChrZXlzKSB7XG4gICAgICBjb25zdCBzcHJpbmdzID0gdGhpcy5zcHJpbmdzO1xuICAgICAgZWFjaDModG9BcnJheTMoa2V5cyksIChrZXkpID0+IHNwcmluZ3Nba2V5XS5zdG9wKCEhYXJnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3BBc3luYyh0aGlzLl9zdGF0ZSwgdGhpcy5fbGFzdEFzeW5jSWQpO1xuICAgICAgdGhpcy5lYWNoKChzcHJpbmcpID0+IHNwcmluZy5zdG9wKCEhYXJnKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBGcmVlemUgdGhlIGFjdGl2ZSBhbmltYXRpb24gaW4gdGltZSAqL1xuICBwYXVzZShrZXlzKSB7XG4gICAgaWYgKGlzNi51bmQoa2V5cykpIHtcbiAgICAgIHRoaXMuc3RhcnQoeyBwYXVzZTogdHJ1ZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgc3ByaW5ncyA9IHRoaXMuc3ByaW5ncztcbiAgICAgIGVhY2gzKHRvQXJyYXkzKGtleXMpLCAoa2V5KSA9PiBzcHJpbmdzW2tleV0ucGF1c2UoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKiBSZXN1bWUgdGhlIGFuaW1hdGlvbiBpZiBwYXVzZWQuICovXG4gIHJlc3VtZShrZXlzKSB7XG4gICAgaWYgKGlzNi51bmQoa2V5cykpIHtcbiAgICAgIHRoaXMuc3RhcnQoeyBwYXVzZTogZmFsc2UgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNwcmluZ3MgPSB0aGlzLnNwcmluZ3M7XG4gICAgICBlYWNoMyh0b0FycmF5MyhrZXlzKSwgKGtleSkgPT4gc3ByaW5nc1trZXldLnJlc3VtZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqIENhbGwgYSBmdW5jdGlvbiBvbmNlIHBlciBzcHJpbmcgdmFsdWUgKi9cbiAgZWFjaChpdGVyYXRvcikge1xuICAgIGVhY2hQcm9wNCh0aGlzLnNwcmluZ3MsIGl0ZXJhdG9yKTtcbiAgfVxuICAvKiogQGludGVybmFsIENhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGFuaW1hdGlvbiBmcmFtZSAqL1xuICBfb25GcmFtZSgpIHtcbiAgICBjb25zdCB7IG9uU3RhcnQsIG9uQ2hhbmdlLCBvblJlc3QgfSA9IHRoaXMuX2V2ZW50cztcbiAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmUuc2l6ZSA+IDA7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMuX2NoYW5nZWQuc2l6ZSA+IDA7XG4gICAgaWYgKGFjdGl2ZSAmJiAhdGhpcy5fc3RhcnRlZCB8fCBjaGFuZ2VkICYmICF0aGlzLl9zdGFydGVkKSB7XG4gICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcbiAgICAgIGZsdXNoMihvblN0YXJ0LCAoW29uU3RhcnQyLCByZXN1bHRdKSA9PiB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIG9uU3RhcnQyKHJlc3VsdCwgdGhpcywgdGhpcy5faXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgaWRsZSA9ICFhY3RpdmUgJiYgdGhpcy5fc3RhcnRlZDtcbiAgICBjb25zdCB2YWx1ZXMgPSBjaGFuZ2VkIHx8IGlkbGUgJiYgb25SZXN0LnNpemUgPyB0aGlzLmdldCgpIDogbnVsbDtcbiAgICBpZiAoY2hhbmdlZCAmJiBvbkNoYW5nZS5zaXplKSB7XG4gICAgICBmbHVzaDIob25DaGFuZ2UsIChbb25DaGFuZ2UyLCByZXN1bHRdKSA9PiB7XG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IHZhbHVlcztcbiAgICAgICAgb25DaGFuZ2UyKHJlc3VsdCwgdGhpcywgdGhpcy5faXRlbSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGlkbGUpIHtcbiAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIGZsdXNoMihvblJlc3QsIChbb25SZXN0MiwgcmVzdWx0XSkgPT4ge1xuICAgICAgICByZXN1bHQudmFsdWUgPSB2YWx1ZXM7XG4gICAgICAgIG9uUmVzdDIocmVzdWx0LCB0aGlzLCB0aGlzLl9pdGVtKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGV2ZW50T2JzZXJ2ZWQoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZSA9PSBcImNoYW5nZVwiKSB7XG4gICAgICB0aGlzLl9jaGFuZ2VkLmFkZChldmVudC5wYXJlbnQpO1xuICAgICAgaWYgKCFldmVudC5pZGxlKSB7XG4gICAgICAgIHRoaXMuX2FjdGl2ZS5hZGQoZXZlbnQucGFyZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT0gXCJpZGxlXCIpIHtcbiAgICAgIHRoaXMuX2FjdGl2ZS5kZWxldGUoZXZlbnQucGFyZW50KTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybjtcbiAgICByYWY0Lm9uRnJhbWUodGhpcy5fb25GcmFtZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBmbHVzaFVwZGF0ZVF1ZXVlKGN0cmwsIHF1ZXVlKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChxdWV1ZS5tYXAoKHByb3BzKSA9PiBmbHVzaFVwZGF0ZShjdHJsLCBwcm9wcykpKS50aGVuKFxuICAgIChyZXN1bHRzKSA9PiBnZXRDb21iaW5lZFJlc3VsdChjdHJsLCByZXN1bHRzKVxuICApO1xufVxuYXN5bmMgZnVuY3Rpb24gZmx1c2hVcGRhdGUoY3RybCwgcHJvcHMsIGlzTG9vcCkge1xuICBjb25zdCB7IGtleXMsIHRvOiB0bzIsIGZyb20sIGxvb3AsIG9uUmVzdCwgb25SZXNvbHZlIH0gPSBwcm9wcztcbiAgY29uc3QgZGVmYXVsdHMyID0gaXM2Lm9iaihwcm9wcy5kZWZhdWx0KSAmJiBwcm9wcy5kZWZhdWx0O1xuICBpZiAobG9vcCkge1xuICAgIHByb3BzLmxvb3AgPSBmYWxzZTtcbiAgfVxuICBpZiAodG8yID09PSBmYWxzZSlcbiAgICBwcm9wcy50byA9IG51bGw7XG4gIGlmIChmcm9tID09PSBmYWxzZSlcbiAgICBwcm9wcy5mcm9tID0gbnVsbDtcbiAgY29uc3QgYXN5bmNUbyA9IGlzNi5hcnIodG8yKSB8fCBpczYuZnVuKHRvMikgPyB0bzIgOiB2b2lkIDA7XG4gIGlmIChhc3luY1RvKSB7XG4gICAgcHJvcHMudG8gPSB2b2lkIDA7XG4gICAgcHJvcHMub25SZXN0ID0gdm9pZCAwO1xuICAgIGlmIChkZWZhdWx0czIpIHtcbiAgICAgIGRlZmF1bHRzMi5vblJlc3QgPSB2b2lkIDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGVhY2gzKEJBVENIRURfRVZFTlRTLCAoa2V5KSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gcHJvcHNba2V5XTtcbiAgICAgIGlmIChpczYuZnVuKGhhbmRsZXIpKSB7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gY3RybFtcIl9ldmVudHNcIl1ba2V5XTtcbiAgICAgICAgcHJvcHNba2V5XSA9ICh7IGZpbmlzaGVkLCBjYW5jZWxsZWQgfSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdDIgPSBxdWV1ZS5nZXQoaGFuZGxlcik7XG4gICAgICAgICAgaWYgKHJlc3VsdDIpIHtcbiAgICAgICAgICAgIGlmICghZmluaXNoZWQpXG4gICAgICAgICAgICAgIHJlc3VsdDIuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpXG4gICAgICAgICAgICAgIHJlc3VsdDIuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcXVldWUuc2V0KGhhbmRsZXIsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgICAgICAgIGZpbmlzaGVkOiBmaW5pc2hlZCB8fCBmYWxzZSxcbiAgICAgICAgICAgICAgY2FuY2VsbGVkOiBjYW5jZWxsZWQgfHwgZmFsc2VcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRlZmF1bHRzMikge1xuICAgICAgICAgIGRlZmF1bHRzMltrZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHN0YXRlID0gY3RybFtcIl9zdGF0ZVwiXTtcbiAgaWYgKHByb3BzLnBhdXNlID09PSAhc3RhdGUucGF1c2VkKSB7XG4gICAgc3RhdGUucGF1c2VkID0gcHJvcHMucGF1c2U7XG4gICAgZmx1c2hDYWxsczIocHJvcHMucGF1c2UgPyBzdGF0ZS5wYXVzZVF1ZXVlIDogc3RhdGUucmVzdW1lUXVldWUpO1xuICB9IGVsc2UgaWYgKHN0YXRlLnBhdXNlZCkge1xuICAgIHByb3BzLnBhdXNlID0gdHJ1ZTtcbiAgfVxuICBjb25zdCBwcm9taXNlcyA9IChrZXlzIHx8IE9iamVjdC5rZXlzKGN0cmwuc3ByaW5ncykpLm1hcChcbiAgICAoa2V5KSA9PiBjdHJsLnNwcmluZ3Nba2V5XS5zdGFydChwcm9wcylcbiAgKTtcbiAgY29uc3QgY2FuY2VsID0gcHJvcHMuY2FuY2VsID09PSB0cnVlIHx8IGdldERlZmF1bHRQcm9wKHByb3BzLCBcImNhbmNlbFwiKSA9PT0gdHJ1ZTtcbiAgaWYgKGFzeW5jVG8gfHwgY2FuY2VsICYmIHN0YXRlLmFzeW5jSWQpIHtcbiAgICBwcm9taXNlcy5wdXNoKFxuICAgICAgc2NoZWR1bGVQcm9wcygrK2N0cmxbXCJfbGFzdEFzeW5jSWRcIl0sIHtcbiAgICAgICAgcHJvcHMsXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBhY3Rpb25zOiB7XG4gICAgICAgICAgcGF1c2U6IG5vb3AsXG4gICAgICAgICAgcmVzdW1lOiBub29wLFxuICAgICAgICAgIHN0YXJ0KHByb3BzMiwgcmVzb2x2ZSkge1xuICAgICAgICAgICAgaWYgKGNhbmNlbCkge1xuICAgICAgICAgICAgICBzdG9wQXN5bmMoc3RhdGUsIGN0cmxbXCJfbGFzdEFzeW5jSWRcIl0pO1xuICAgICAgICAgICAgICByZXNvbHZlKGdldENhbmNlbGxlZFJlc3VsdChjdHJsKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9wczIub25SZXN0ID0gb25SZXN0O1xuICAgICAgICAgICAgICByZXNvbHZlKFxuICAgICAgICAgICAgICAgIHJ1bkFzeW5jKFxuICAgICAgICAgICAgICAgICAgYXN5bmNUbyxcbiAgICAgICAgICAgICAgICAgIHByb3BzMixcbiAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgY3RybFxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBpZiAoc3RhdGUucGF1c2VkKSB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc3VtZSkgPT4ge1xuICAgICAgc3RhdGUucmVzdW1lUXVldWUuYWRkKHJlc3VtZSk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0gZ2V0Q29tYmluZWRSZXN1bHQoY3RybCwgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpKTtcbiAgaWYgKGxvb3AgJiYgcmVzdWx0LmZpbmlzaGVkICYmICEoaXNMb29wICYmIHJlc3VsdC5ub29wKSkge1xuICAgIGNvbnN0IG5leHRQcm9wcyA9IGNyZWF0ZUxvb3BVcGRhdGUocHJvcHMsIGxvb3AsIHRvMik7XG4gICAgaWYgKG5leHRQcm9wcykge1xuICAgICAgcHJlcGFyZUtleXMoY3RybCwgW25leHRQcm9wc10pO1xuICAgICAgcmV0dXJuIGZsdXNoVXBkYXRlKGN0cmwsIG5leHRQcm9wcywgdHJ1ZSk7XG4gICAgfVxuICB9XG4gIGlmIChvblJlc29sdmUpIHtcbiAgICByYWY0LmJhdGNoZWRVcGRhdGVzKCgpID0+IG9uUmVzb2x2ZShyZXN1bHQsIGN0cmwsIGN0cmwuaXRlbSkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRTcHJpbmdzKGN0cmwsIHByb3BzKSB7XG4gIGNvbnN0IHNwcmluZ3MgPSB7IC4uLmN0cmwuc3ByaW5ncyB9O1xuICBpZiAocHJvcHMpIHtcbiAgICBlYWNoMyh0b0FycmF5Myhwcm9wcyksIChwcm9wczIpID0+IHtcbiAgICAgIGlmIChpczYudW5kKHByb3BzMi5rZXlzKSkge1xuICAgICAgICBwcm9wczIgPSBjcmVhdGVVcGRhdGUocHJvcHMyKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXM2Lm9iaihwcm9wczIudG8pKSB7XG4gICAgICAgIHByb3BzMiA9IHsgLi4ucHJvcHMyLCB0bzogdm9pZCAwIH07XG4gICAgICB9XG4gICAgICBwcmVwYXJlU3ByaW5ncyhzcHJpbmdzLCBwcm9wczIsIChrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVNwcmluZyhrZXkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0U3ByaW5ncyhjdHJsLCBzcHJpbmdzKTtcbiAgcmV0dXJuIHNwcmluZ3M7XG59XG5mdW5jdGlvbiBzZXRTcHJpbmdzKGN0cmwsIHNwcmluZ3MpIHtcbiAgZWFjaFByb3A0KHNwcmluZ3MsIChzcHJpbmcsIGtleSkgPT4ge1xuICAgIGlmICghY3RybC5zcHJpbmdzW2tleV0pIHtcbiAgICAgIGN0cmwuc3ByaW5nc1trZXldID0gc3ByaW5nO1xuICAgICAgYWRkRmx1aWRPYnNlcnZlcjIoc3ByaW5nLCBjdHJsKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlU3ByaW5nKGtleSwgb2JzZXJ2ZXIpIHtcbiAgY29uc3Qgc3ByaW5nID0gbmV3IFNwcmluZ1ZhbHVlKCk7XG4gIHNwcmluZy5rZXkgPSBrZXk7XG4gIGlmIChvYnNlcnZlcikge1xuICAgIGFkZEZsdWlkT2JzZXJ2ZXIyKHNwcmluZywgb2JzZXJ2ZXIpO1xuICB9XG4gIHJldHVybiBzcHJpbmc7XG59XG5mdW5jdGlvbiBwcmVwYXJlU3ByaW5ncyhzcHJpbmdzLCBwcm9wcywgY3JlYXRlKSB7XG4gIGlmIChwcm9wcy5rZXlzKSB7XG4gICAgZWFjaDMocHJvcHMua2V5cywgKGtleSkgPT4ge1xuICAgICAgY29uc3Qgc3ByaW5nID0gc3ByaW5nc1trZXldIHx8IChzcHJpbmdzW2tleV0gPSBjcmVhdGUoa2V5KSk7XG4gICAgICBzcHJpbmdbXCJfcHJlcGFyZU5vZGVcIl0ocHJvcHMpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlS2V5cyhjdHJsLCBxdWV1ZSkge1xuICBlYWNoMyhxdWV1ZSwgKHByb3BzKSA9PiB7XG4gICAgcHJlcGFyZVNwcmluZ3MoY3RybC5zcHJpbmdzLCBwcm9wcywgKGtleSkgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZVNwcmluZyhrZXksIGN0cmwpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuLy8gc3JjL1NwcmluZ0NvbnRleHQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IHVzZU1lbW9PbmUgfSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcbnZhciBTcHJpbmdDb250ZXh0ID0gKHtcbiAgY2hpbGRyZW4sXG4gIC4uLnByb3BzXG59KSA9PiB7XG4gIGNvbnN0IGluaGVyaXRlZCA9IHVzZUNvbnRleHQoY3R4KTtcbiAgY29uc3QgcGF1c2UgPSBwcm9wcy5wYXVzZSB8fCAhIWluaGVyaXRlZC5wYXVzZSwgaW1tZWRpYXRlID0gcHJvcHMuaW1tZWRpYXRlIHx8ICEhaW5oZXJpdGVkLmltbWVkaWF0ZTtcbiAgcHJvcHMgPSB1c2VNZW1vT25lKCgpID0+ICh7IHBhdXNlLCBpbW1lZGlhdGUgfSksIFtwYXVzZSwgaW1tZWRpYXRlXSk7XG4gIGNvbnN0IHsgUHJvdmlkZXIgfSA9IGN0eDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBSZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7IHZhbHVlOiBwcm9wcyB9LCBjaGlsZHJlbik7XG59O1xudmFyIGN0eCA9IG1ha2VDb250ZXh0KFNwcmluZ0NvbnRleHQsIHt9KTtcblNwcmluZ0NvbnRleHQuUHJvdmlkZXIgPSBjdHguUHJvdmlkZXI7XG5TcHJpbmdDb250ZXh0LkNvbnN1bWVyID0gY3R4LkNvbnN1bWVyO1xuZnVuY3Rpb24gbWFrZUNvbnRleHQodGFyZ2V0LCBpbml0KSB7XG4gIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBSZWFjdC5jcmVhdGVDb250ZXh0KGluaXQpKTtcbiAgdGFyZ2V0LlByb3ZpZGVyLl9jb250ZXh0ID0gdGFyZ2V0O1xuICB0YXJnZXQuQ29uc3VtZXIuX2NvbnRleHQgPSB0YXJnZXQ7XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIHNyYy9TcHJpbmdSZWYudHNcbmltcG9ydCB7IGVhY2ggYXMgZWFjaDQsIGlzIGFzIGlzNywgZGVwcmVjYXRlRGlyZWN0Q2FsbCB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xudmFyIFNwcmluZ1JlZiA9ICgpID0+IHtcbiAgY29uc3QgY3VycmVudCA9IFtdO1xuICBjb25zdCBTcHJpbmdSZWYyID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgICBkZXByZWNhdGVEaXJlY3RDYWxsKCk7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGVhY2g0KGN1cnJlbnQsIChjdHJsLCBpKSA9PiB7XG4gICAgICBpZiAoaXM3LnVuZChwcm9wcykpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKGN0cmwuc3RhcnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB1cGRhdGUyID0gX2dldFByb3BzKHByb3BzLCBjdHJsLCBpKTtcbiAgICAgICAgaWYgKHVwZGF0ZTIpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goY3RybC5zdGFydCh1cGRhdGUyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcbiAgU3ByaW5nUmVmMi5jdXJyZW50ID0gY3VycmVudDtcbiAgU3ByaW5nUmVmMi5hZGQgPSBmdW5jdGlvbihjdHJsKSB7XG4gICAgaWYgKCFjdXJyZW50LmluY2x1ZGVzKGN0cmwpKSB7XG4gICAgICBjdXJyZW50LnB1c2goY3RybCk7XG4gICAgfVxuICB9O1xuICBTcHJpbmdSZWYyLmRlbGV0ZSA9IGZ1bmN0aW9uKGN0cmwpIHtcbiAgICBjb25zdCBpID0gY3VycmVudC5pbmRleE9mKGN0cmwpO1xuICAgIGlmICh+aSlcbiAgICAgIGN1cnJlbnQuc3BsaWNlKGksIDEpO1xuICB9O1xuICBTcHJpbmdSZWYyLnBhdXNlID0gZnVuY3Rpb24oKSB7XG4gICAgZWFjaDQoY3VycmVudCwgKGN0cmwpID0+IGN0cmwucGF1c2UoLi4uYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIFNwcmluZ1JlZjIucmVzdW1lID0gZnVuY3Rpb24oKSB7XG4gICAgZWFjaDQoY3VycmVudCwgKGN0cmwpID0+IGN0cmwucmVzdW1lKC4uLmFyZ3VtZW50cykpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBTcHJpbmdSZWYyLnNldCA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICAgIGVhY2g0KGN1cnJlbnQsIChjdHJsLCBpKSA9PiB7XG4gICAgICBjb25zdCB1cGRhdGUyID0gaXM3LmZ1bih2YWx1ZXMpID8gdmFsdWVzKGksIGN0cmwpIDogdmFsdWVzO1xuICAgICAgaWYgKHVwZGF0ZTIpIHtcbiAgICAgICAgY3RybC5zZXQodXBkYXRlMik7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIFNwcmluZ1JlZjIuc3RhcnQgPSBmdW5jdGlvbihwcm9wcykge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBlYWNoNChjdXJyZW50LCAoY3RybCwgaSkgPT4ge1xuICAgICAgaWYgKGlzNy51bmQocHJvcHMpKSB7XG4gICAgICAgIHJlc3VsdHMucHVzaChjdHJsLnN0YXJ0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdXBkYXRlMiA9IHRoaXMuX2dldFByb3BzKHByb3BzLCBjdHJsLCBpKTtcbiAgICAgICAgaWYgKHVwZGF0ZTIpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goY3RybC5zdGFydCh1cGRhdGUyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcbiAgU3ByaW5nUmVmMi5zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZWFjaDQoY3VycmVudCwgKGN0cmwpID0+IGN0cmwuc3RvcCguLi5hcmd1bWVudHMpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgU3ByaW5nUmVmMi51cGRhdGUgPSBmdW5jdGlvbihwcm9wcykge1xuICAgIGVhY2g0KGN1cnJlbnQsIChjdHJsLCBpKSA9PiBjdHJsLnVwZGF0ZSh0aGlzLl9nZXRQcm9wcyhwcm9wcywgY3RybCwgaSkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgY29uc3QgX2dldFByb3BzID0gZnVuY3Rpb24oYXJnLCBjdHJsLCBpbmRleCkge1xuICAgIHJldHVybiBpczcuZnVuKGFyZykgPyBhcmcoaW5kZXgsIGN0cmwpIDogYXJnO1xuICB9O1xuICBTcHJpbmdSZWYyLl9nZXRQcm9wcyA9IF9nZXRQcm9wcztcbiAgcmV0dXJuIFNwcmluZ1JlZjI7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlU3ByaW5ncy50c1xuZnVuY3Rpb24gdXNlU3ByaW5ncyhsZW5ndGgsIHByb3BzLCBkZXBzKSB7XG4gIGNvbnN0IHByb3BzRm4gPSBpczguZnVuKHByb3BzKSAmJiBwcm9wcztcbiAgaWYgKHByb3BzRm4gJiYgIWRlcHMpXG4gICAgZGVwcyA9IFtdO1xuICBjb25zdCByZWYgPSB1c2VNZW1vKFxuICAgICgpID0+IHByb3BzRm4gfHwgYXJndW1lbnRzLmxlbmd0aCA9PSAzID8gU3ByaW5nUmVmKCkgOiB2b2lkIDAsXG4gICAgW11cbiAgKTtcbiAgY29uc3QgbGF5b3V0SWQgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgY29uc3Qgc3RhdGUgPSB1c2VNZW1vKFxuICAgICgpID0+ICh7XG4gICAgICBjdHJsczogW10sXG4gICAgICBxdWV1ZTogW10sXG4gICAgICBmbHVzaChjdHJsLCB1cGRhdGVzMikge1xuICAgICAgICBjb25zdCBzcHJpbmdzMiA9IGdldFNwcmluZ3MoY3RybCwgdXBkYXRlczIpO1xuICAgICAgICBjb25zdCBjYW5GbHVzaFN5bmMgPSBsYXlvdXRJZC5jdXJyZW50ID4gMCAmJiAhc3RhdGUucXVldWUubGVuZ3RoICYmICFPYmplY3Qua2V5cyhzcHJpbmdzMikuc29tZSgoa2V5KSA9PiAhY3RybC5zcHJpbmdzW2tleV0pO1xuICAgICAgICByZXR1cm4gY2FuRmx1c2hTeW5jID8gZmx1c2hVcGRhdGVRdWV1ZShjdHJsLCB1cGRhdGVzMikgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgIHNldFNwcmluZ3MoY3RybCwgc3ByaW5nczIpO1xuICAgICAgICAgIHN0YXRlLnF1ZXVlLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgcmVzb2x2ZShmbHVzaFVwZGF0ZVF1ZXVlKGN0cmwsIHVwZGF0ZXMyKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSksXG4gICAgW11cbiAgKTtcbiAgY29uc3QgY3RybHMgPSB1c2VSZWYoWy4uLnN0YXRlLmN0cmxzXSk7XG4gIGNvbnN0IHVwZGF0ZXMgPSBbXTtcbiAgY29uc3QgcHJldkxlbmd0aCA9IHVzZVByZXYobGVuZ3RoKSB8fCAwO1xuICB1c2VNZW1vKCgpID0+IHtcbiAgICBlYWNoNShjdHJscy5jdXJyZW50LnNsaWNlKGxlbmd0aCwgcHJldkxlbmd0aCksIChjdHJsKSA9PiB7XG4gICAgICBkZXRhY2hSZWZzKGN0cmwsIHJlZik7XG4gICAgICBjdHJsLnN0b3AodHJ1ZSk7XG4gICAgfSk7XG4gICAgY3RybHMuY3VycmVudC5sZW5ndGggPSBsZW5ndGg7XG4gICAgZGVjbGFyZVVwZGF0ZXMocHJldkxlbmd0aCwgbGVuZ3RoKTtcbiAgfSwgW2xlbmd0aF0pO1xuICB1c2VNZW1vKCgpID0+IHtcbiAgICBkZWNsYXJlVXBkYXRlcygwLCBNYXRoLm1pbihwcmV2TGVuZ3RoLCBsZW5ndGgpKTtcbiAgfSwgZGVwcyk7XG4gIGZ1bmN0aW9uIGRlY2xhcmVVcGRhdGVzKHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKSB7XG4gICAgICBjb25zdCBjdHJsID0gY3RybHMuY3VycmVudFtpXSB8fCAoY3RybHMuY3VycmVudFtpXSA9IG5ldyBDb250cm9sbGVyKG51bGwsIHN0YXRlLmZsdXNoKSk7XG4gICAgICBjb25zdCB1cGRhdGUyID0gcHJvcHNGbiA/IHByb3BzRm4oaSwgY3RybCkgOiBwcm9wc1tpXTtcbiAgICAgIGlmICh1cGRhdGUyKSB7XG4gICAgICAgIHVwZGF0ZXNbaV0gPSBkZWNsYXJlVXBkYXRlKHVwZGF0ZTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzcHJpbmdzID0gY3RybHMuY3VycmVudC5tYXAoKGN0cmwsIGkpID0+IGdldFNwcmluZ3MoY3RybCwgdXBkYXRlc1tpXSkpO1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDIoU3ByaW5nQ29udGV4dCk7XG4gIGNvbnN0IHByZXZDb250ZXh0ID0gdXNlUHJldihjb250ZXh0KTtcbiAgY29uc3QgaGFzQ29udGV4dCA9IGNvbnRleHQgIT09IHByZXZDb250ZXh0ICYmIGhhc1Byb3BzKGNvbnRleHQpO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0MigoKSA9PiB7XG4gICAgbGF5b3V0SWQuY3VycmVudCsrO1xuICAgIHN0YXRlLmN0cmxzID0gY3RybHMuY3VycmVudDtcbiAgICBjb25zdCB7IHF1ZXVlIH0gPSBzdGF0ZTtcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5xdWV1ZSA9IFtdO1xuICAgICAgZWFjaDUocXVldWUsIChjYikgPT4gY2IoKSk7XG4gICAgfVxuICAgIGVhY2g1KGN0cmxzLmN1cnJlbnQsIChjdHJsLCBpKSA9PiB7XG4gICAgICByZWY/LmFkZChjdHJsKTtcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGN0cmwuc3RhcnQoeyBkZWZhdWx0OiBjb250ZXh0IH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdXBkYXRlMiA9IHVwZGF0ZXNbaV07XG4gICAgICBpZiAodXBkYXRlMikge1xuICAgICAgICByZXBsYWNlUmVmKGN0cmwsIHVwZGF0ZTIucmVmKTtcbiAgICAgICAgaWYgKGN0cmwucmVmKSB7XG4gICAgICAgICAgY3RybC5xdWV1ZS5wdXNoKHVwZGF0ZTIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN0cmwuc3RhcnQodXBkYXRlMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHVzZU9uY2UoKCkgPT4gKCkgPT4ge1xuICAgIGVhY2g1KHN0YXRlLmN0cmxzLCAoY3RybCkgPT4gY3RybC5zdG9wKHRydWUpKTtcbiAgfSk7XG4gIGNvbnN0IHZhbHVlcyA9IHNwcmluZ3MubWFwKCh4KSA9PiAoeyAuLi54IH0pKTtcbiAgcmV0dXJuIHJlZiA/IFt2YWx1ZXMsIHJlZl0gOiB2YWx1ZXM7XG59XG5cbi8vIHNyYy9ob29rcy91c2VTcHJpbmcudHNcbmZ1bmN0aW9uIHVzZVNwcmluZyhwcm9wcywgZGVwcykge1xuICBjb25zdCBpc0ZuID0gaXM5LmZ1bihwcm9wcyk7XG4gIGNvbnN0IFtbdmFsdWVzXSwgcmVmXSA9IHVzZVNwcmluZ3MoXG4gICAgMSxcbiAgICBpc0ZuID8gcHJvcHMgOiBbcHJvcHNdLFxuICAgIGlzRm4gPyBkZXBzIHx8IFtdIDogZGVwc1xuICApO1xuICByZXR1cm4gaXNGbiB8fCBhcmd1bWVudHMubGVuZ3RoID09IDIgPyBbdmFsdWVzLCByZWZdIDogdmFsdWVzO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlU3ByaW5nUmVmLnRzXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIGluaXRTcHJpbmdSZWYgPSAoKSA9PiBTcHJpbmdSZWYoKTtcbnZhciB1c2VTcHJpbmdSZWYgPSAoKSA9PiB1c2VTdGF0ZShpbml0U3ByaW5nUmVmKVswXTtcblxuLy8gc3JjL2hvb2tzL3VzZVNwcmluZ1ZhbHVlLnRzXG5pbXBvcnQgeyB1c2VDb25zdGFudCwgdXNlT25jZSBhcyB1c2VPbmNlMiB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xudmFyIHVzZVNwcmluZ1ZhbHVlID0gKGluaXRpYWwsIHByb3BzKSA9PiB7XG4gIGNvbnN0IHNwcmluZ1ZhbHVlID0gdXNlQ29uc3RhbnQoKCkgPT4gbmV3IFNwcmluZ1ZhbHVlKGluaXRpYWwsIHByb3BzKSk7XG4gIHVzZU9uY2UyKCgpID0+ICgpID0+IHtcbiAgICBzcHJpbmdWYWx1ZS5zdG9wKCk7XG4gIH0pO1xuICByZXR1cm4gc3ByaW5nVmFsdWU7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlVHJhaWwudHNcbmltcG9ydCB7IGVhY2ggYXMgZWFjaDYsIGlzIGFzIGlzMTAsIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDMgfSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcbmZ1bmN0aW9uIHVzZVRyYWlsKGxlbmd0aCwgcHJvcHNBcmcsIGRlcHMpIHtcbiAgY29uc3QgcHJvcHNGbiA9IGlzMTAuZnVuKHByb3BzQXJnKSAmJiBwcm9wc0FyZztcbiAgaWYgKHByb3BzRm4gJiYgIWRlcHMpXG4gICAgZGVwcyA9IFtdO1xuICBsZXQgcmV2ZXJzZSA9IHRydWU7XG4gIGxldCBwYXNzZWRSZWYgPSB2b2lkIDA7XG4gIGNvbnN0IHJlc3VsdCA9IHVzZVNwcmluZ3MoXG4gICAgbGVuZ3RoLFxuICAgIChpLCBjdHJsKSA9PiB7XG4gICAgICBjb25zdCBwcm9wcyA9IHByb3BzRm4gPyBwcm9wc0ZuKGksIGN0cmwpIDogcHJvcHNBcmc7XG4gICAgICBwYXNzZWRSZWYgPSBwcm9wcy5yZWY7XG4gICAgICByZXZlcnNlID0gcmV2ZXJzZSAmJiBwcm9wcy5yZXZlcnNlO1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH0sXG4gICAgLy8gRW5zdXJlIHRoZSBwcm9wcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbiBubyBkZXBzIGV4aXN0LlxuICAgIC8vIFRoaXMgd29ya3MgYXJvdW5kIHRoZSAzIGFyZ3VtZW50IHJ1bGUuXG4gICAgZGVwcyB8fCBbe31dXG4gICk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QzKCgpID0+IHtcbiAgICBlYWNoNihyZXN1bHRbMV0uY3VycmVudCwgKGN0cmwsIGkpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHJlc3VsdFsxXS5jdXJyZW50W2kgKyAocmV2ZXJzZSA/IDEgOiAtMSldO1xuICAgICAgcmVwbGFjZVJlZihjdHJsLCBwYXNzZWRSZWYpO1xuICAgICAgaWYgKGN0cmwucmVmKSB7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICBjdHJsLnVwZGF0ZSh7IHRvOiBwYXJlbnQuc3ByaW5ncyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgIGN0cmwuc3RhcnQoeyB0bzogcGFyZW50LnNwcmluZ3MgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHJsLnN0YXJ0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sIGRlcHMpO1xuICBpZiAocHJvcHNGbiB8fCBhcmd1bWVudHMubGVuZ3RoID09IDMpIHtcbiAgICBjb25zdCByZWYgPSBwYXNzZWRSZWYgPz8gcmVzdWx0WzFdO1xuICAgIHJlZltcIl9nZXRQcm9wc1wiXSA9IChwcm9wc0FyZzIsIGN0cmwsIGkpID0+IHtcbiAgICAgIGNvbnN0IHByb3BzID0gaXMxMC5mdW4ocHJvcHNBcmcyKSA/IHByb3BzQXJnMihpLCBjdHJsKSA6IHByb3BzQXJnMjtcbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSByZWYuY3VycmVudFtpICsgKHByb3BzLnJldmVyc2UgPyAxIDogLTEpXTtcbiAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICBwcm9wcy50byA9IHBhcmVudC5zcHJpbmdzO1xuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHRbMF07XG59XG5cbi8vIHNyYy9ob29rcy91c2VUcmFuc2l0aW9uLnRzeFxuaW1wb3J0ICogYXMgUmVhY3QyIGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCBhcyB1c2VDb250ZXh0MywgdXNlUmVmIGFzIHVzZVJlZjIsIHVzZU1lbW8gYXMgdXNlTWVtbzIgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7XG4gIGlzIGFzIGlzMTEsXG4gIHRvQXJyYXkgYXMgdG9BcnJheTQsXG4gIHVzZUZvcmNlVXBkYXRlIGFzIHVzZUZvcmNlVXBkYXRlMixcbiAgdXNlT25jZSBhcyB1c2VPbmNlMyxcbiAgdXNlUHJldiBhcyB1c2VQcmV2MixcbiAgZWFjaCBhcyBlYWNoNyxcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0NFxufSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcbmZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oZGF0YSwgcHJvcHMsIGRlcHMpIHtcbiAgY29uc3QgcHJvcHNGbiA9IGlzMTEuZnVuKHByb3BzKSAmJiBwcm9wcztcbiAgY29uc3Qge1xuICAgIHJlc2V0LFxuICAgIHNvcnQsXG4gICAgdHJhaWwgPSAwLFxuICAgIGV4cGlyZXMgPSB0cnVlLFxuICAgIGV4aXRCZWZvcmVFbnRlciA9IGZhbHNlLFxuICAgIG9uRGVzdHJveWVkLFxuICAgIHJlZjogcHJvcHNSZWYsXG4gICAgY29uZmlnOiBwcm9wc0NvbmZpZ1xuICB9ID0gcHJvcHNGbiA/IHByb3BzRm4oKSA6IHByb3BzO1xuICBjb25zdCByZWYgPSB1c2VNZW1vMihcbiAgICAoKSA9PiBwcm9wc0ZuIHx8IGFyZ3VtZW50cy5sZW5ndGggPT0gMyA/IFNwcmluZ1JlZigpIDogdm9pZCAwLFxuICAgIFtdXG4gICk7XG4gIGNvbnN0IGl0ZW1zID0gdG9BcnJheTQoZGF0YSk7XG4gIGNvbnN0IHRyYW5zaXRpb25zID0gW107XG4gIGNvbnN0IHVzZWRUcmFuc2l0aW9ucyA9IHVzZVJlZjIobnVsbCk7XG4gIGNvbnN0IHByZXZUcmFuc2l0aW9ucyA9IHJlc2V0ID8gbnVsbCA6IHVzZWRUcmFuc2l0aW9ucy5jdXJyZW50O1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0NCgoKSA9PiB7XG4gICAgdXNlZFRyYW5zaXRpb25zLmN1cnJlbnQgPSB0cmFuc2l0aW9ucztcbiAgfSk7XG4gIHVzZU9uY2UzKCgpID0+IHtcbiAgICBlYWNoNyh0cmFuc2l0aW9ucywgKHQpID0+IHtcbiAgICAgIHJlZj8uYWRkKHQuY3RybCk7XG4gICAgICB0LmN0cmwucmVmID0gcmVmO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBlYWNoNyh1c2VkVHJhbnNpdGlvbnMuY3VycmVudCwgKHQpID0+IHtcbiAgICAgICAgaWYgKHQuZXhwaXJlZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0LmV4cGlyYXRpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgZGV0YWNoUmVmcyh0LmN0cmwsIHJlZik7XG4gICAgICAgIHQuY3RybC5zdG9wKHRydWUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSk7XG4gIGNvbnN0IGtleXMgPSBnZXRLZXlzKGl0ZW1zLCBwcm9wc0ZuID8gcHJvcHNGbigpIDogcHJvcHMsIHByZXZUcmFuc2l0aW9ucyk7XG4gIGNvbnN0IGV4cGlyZWQgPSByZXNldCAmJiB1c2VkVHJhbnNpdGlvbnMuY3VycmVudCB8fCBbXTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDQoXG4gICAgKCkgPT4gZWFjaDcoZXhwaXJlZCwgKHsgY3RybCwgaXRlbSwga2V5IH0pID0+IHtcbiAgICAgIGRldGFjaFJlZnMoY3RybCwgcmVmKTtcbiAgICAgIGNhbGxQcm9wKG9uRGVzdHJveWVkLCBpdGVtLCBrZXkpO1xuICAgIH0pXG4gICk7XG4gIGNvbnN0IHJldXNlZCA9IFtdO1xuICBpZiAocHJldlRyYW5zaXRpb25zKVxuICAgIGVhY2g3KHByZXZUcmFuc2l0aW9ucywgKHQsIGkpID0+IHtcbiAgICAgIGlmICh0LmV4cGlyZWQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHQuZXhwaXJhdGlvbklkKTtcbiAgICAgICAgZXhwaXJlZC5wdXNoKHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaSA9IHJldXNlZFtpXSA9IGtleXMuaW5kZXhPZih0LmtleSk7XG4gICAgICAgIGlmICh+aSlcbiAgICAgICAgICB0cmFuc2l0aW9uc1tpXSA9IHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIGVhY2g3KGl0ZW1zLCAoaXRlbSwgaSkgPT4ge1xuICAgIGlmICghdHJhbnNpdGlvbnNbaV0pIHtcbiAgICAgIHRyYW5zaXRpb25zW2ldID0ge1xuICAgICAgICBrZXk6IGtleXNbaV0sXG4gICAgICAgIGl0ZW0sXG4gICAgICAgIHBoYXNlOiBcIm1vdW50XCIgLyogTU9VTlQgKi8sXG4gICAgICAgIGN0cmw6IG5ldyBDb250cm9sbGVyKClcbiAgICAgIH07XG4gICAgICB0cmFuc2l0aW9uc1tpXS5jdHJsLml0ZW0gPSBpdGVtO1xuICAgIH1cbiAgfSk7XG4gIGlmIChyZXVzZWQubGVuZ3RoKSB7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBjb25zdCB7IGxlYXZlIH0gPSBwcm9wc0ZuID8gcHJvcHNGbigpIDogcHJvcHM7XG4gICAgZWFjaDcocmV1c2VkLCAoa2V5SW5kZXgsIHByZXZJbmRleCkgPT4ge1xuICAgICAgY29uc3QgdCA9IHByZXZUcmFuc2l0aW9uc1twcmV2SW5kZXhdO1xuICAgICAgaWYgKH5rZXlJbmRleCkge1xuICAgICAgICBpID0gdHJhbnNpdGlvbnMuaW5kZXhPZih0KTtcbiAgICAgICAgdHJhbnNpdGlvbnNbaV0gPSB7IC4uLnQsIGl0ZW06IGl0ZW1zW2tleUluZGV4XSB9O1xuICAgICAgfSBlbHNlIGlmIChsZWF2ZSkge1xuICAgICAgICB0cmFuc2l0aW9ucy5zcGxpY2UoKytpLCAwLCB0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoaXMxMS5mdW4oc29ydCkpIHtcbiAgICB0cmFuc2l0aW9ucy5zb3J0KChhLCBiKSA9PiBzb3J0KGEuaXRlbSwgYi5pdGVtKSk7XG4gIH1cbiAgbGV0IGRlbGF5ID0gLXRyYWlsO1xuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlMigpO1xuICBjb25zdCBkZWZhdWx0UHJvcHMgPSBnZXREZWZhdWx0UHJvcHMocHJvcHMpO1xuICBjb25zdCBjaGFuZ2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgY29uc3QgZXhpdGluZ1RyYW5zaXRpb25zID0gdXNlUmVmMigvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgY29uc3QgZm9yY2VDaGFuZ2UgPSB1c2VSZWYyKGZhbHNlKTtcbiAgZWFjaDcodHJhbnNpdGlvbnMsICh0LCBpKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gdC5rZXk7XG4gICAgY29uc3QgcHJldlBoYXNlID0gdC5waGFzZTtcbiAgICBjb25zdCBwID0gcHJvcHNGbiA/IHByb3BzRm4oKSA6IHByb3BzO1xuICAgIGxldCB0bzI7XG4gICAgbGV0IHBoYXNlO1xuICAgIGNvbnN0IHByb3BzRGVsYXkgPSBjYWxsUHJvcChwLmRlbGF5IHx8IDAsIGtleSk7XG4gICAgaWYgKHByZXZQaGFzZSA9PSBcIm1vdW50XCIgLyogTU9VTlQgKi8pIHtcbiAgICAgIHRvMiA9IHAuZW50ZXI7XG4gICAgICBwaGFzZSA9IFwiZW50ZXJcIiAvKiBFTlRFUiAqLztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaXNMZWF2ZSA9IGtleXMuaW5kZXhPZihrZXkpIDwgMDtcbiAgICAgIGlmIChwcmV2UGhhc2UgIT0gXCJsZWF2ZVwiIC8qIExFQVZFICovKSB7XG4gICAgICAgIGlmIChpc0xlYXZlKSB7XG4gICAgICAgICAgdG8yID0gcC5sZWF2ZTtcbiAgICAgICAgICBwaGFzZSA9IFwibGVhdmVcIiAvKiBMRUFWRSAqLztcbiAgICAgICAgfSBlbHNlIGlmICh0bzIgPSBwLnVwZGF0ZSkge1xuICAgICAgICAgIHBoYXNlID0gXCJ1cGRhdGVcIiAvKiBVUERBVEUgKi87XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAoIWlzTGVhdmUpIHtcbiAgICAgICAgdG8yID0gcC5lbnRlcjtcbiAgICAgICAgcGhhc2UgPSBcImVudGVyXCIgLyogRU5URVIgKi87XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0bzIgPSBjYWxsUHJvcCh0bzIsIHQuaXRlbSwgaSk7XG4gICAgdG8yID0gaXMxMS5vYmoodG8yKSA/IGluZmVyVG8odG8yKSA6IHsgdG86IHRvMiB9O1xuICAgIGlmICghdG8yLmNvbmZpZykge1xuICAgICAgY29uc3QgY29uZmlnMiA9IHByb3BzQ29uZmlnIHx8IGRlZmF1bHRQcm9wcy5jb25maWc7XG4gICAgICB0bzIuY29uZmlnID0gY2FsbFByb3AoY29uZmlnMiwgdC5pdGVtLCBpLCBwaGFzZSk7XG4gICAgfVxuICAgIGRlbGF5ICs9IHRyYWlsO1xuICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAuLi5kZWZhdWx0UHJvcHMsXG4gICAgICAvLyB3ZSBuZWVkIHRvIGFkZCBvdXIgcHJvcHMuZGVsYXkgdmFsdWUgeW91IGhlcmUuXG4gICAgICBkZWxheTogcHJvcHNEZWxheSArIGRlbGF5LFxuICAgICAgcmVmOiBwcm9wc1JlZixcbiAgICAgIGltbWVkaWF0ZTogcC5pbW1lZGlhdGUsXG4gICAgICAvLyBUaGlzIHByZXZlbnRzIGltcGxpZWQgcmVzZXRzLlxuICAgICAgcmVzZXQ6IGZhbHNlLFxuICAgICAgLy8gTWVyZ2UgYW55IHBoYXNlLXNwZWNpZmljIHByb3BzLlxuICAgICAgLi4udG8yXG4gICAgfTtcbiAgICBpZiAocGhhc2UgPT0gXCJlbnRlclwiIC8qIEVOVEVSICovICYmIGlzMTEudW5kKHBheWxvYWQuZnJvbSkpIHtcbiAgICAgIGNvbnN0IHAyID0gcHJvcHNGbiA/IHByb3BzRm4oKSA6IHByb3BzO1xuICAgICAgY29uc3QgZnJvbSA9IGlzMTEudW5kKHAyLmluaXRpYWwpIHx8IHByZXZUcmFuc2l0aW9ucyA/IHAyLmZyb20gOiBwMi5pbml0aWFsO1xuICAgICAgcGF5bG9hZC5mcm9tID0gY2FsbFByb3AoZnJvbSwgdC5pdGVtLCBpKTtcbiAgICB9XG4gICAgY29uc3QgeyBvblJlc29sdmUgfSA9IHBheWxvYWQ7XG4gICAgcGF5bG9hZC5vblJlc29sdmUgPSAocmVzdWx0KSA9PiB7XG4gICAgICBjYWxsUHJvcChvblJlc29sdmUsIHJlc3VsdCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uczIgPSB1c2VkVHJhbnNpdGlvbnMuY3VycmVudDtcbiAgICAgIGNvbnN0IHQyID0gdHJhbnNpdGlvbnMyLmZpbmQoKHQzKSA9PiB0My5rZXkgPT09IGtleSk7XG4gICAgICBpZiAoIXQyKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAocmVzdWx0LmNhbmNlbGxlZCAmJiB0Mi5waGFzZSAhPSBcInVwZGF0ZVwiIC8qIFVQREFURSAqLykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodDIuY3RybC5pZGxlKSB7XG4gICAgICAgIGNvbnN0IGlkbGUgPSB0cmFuc2l0aW9uczIuZXZlcnkoKHQzKSA9PiB0My5jdHJsLmlkbGUpO1xuICAgICAgICBpZiAodDIucGhhc2UgPT0gXCJsZWF2ZVwiIC8qIExFQVZFICovKSB7XG4gICAgICAgICAgY29uc3QgZXhwaXJ5ID0gY2FsbFByb3AoZXhwaXJlcywgdDIuaXRlbSk7XG4gICAgICAgICAgaWYgKGV4cGlyeSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGlyeU1zID0gZXhwaXJ5ID09PSB0cnVlID8gMCA6IGV4cGlyeTtcbiAgICAgICAgICAgIHQyLmV4cGlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFpZGxlICYmIGV4cGlyeU1zID4gMCkge1xuICAgICAgICAgICAgICBpZiAoZXhwaXJ5TXMgPD0gMjE0NzQ4MzY0NylcbiAgICAgICAgICAgICAgICB0Mi5leHBpcmF0aW9uSWQgPSBzZXRUaW1lb3V0KGZvcmNlVXBkYXRlLCBleHBpcnlNcyk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkbGUgJiYgdHJhbnNpdGlvbnMyLnNvbWUoKHQzKSA9PiB0My5leHBpcmVkKSkge1xuICAgICAgICAgIGV4aXRpbmdUcmFuc2l0aW9ucy5jdXJyZW50LmRlbGV0ZSh0Mik7XG4gICAgICAgICAgaWYgKGV4aXRCZWZvcmVFbnRlcikge1xuICAgICAgICAgICAgZm9yY2VDaGFuZ2UuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNwcmluZ3MgPSBnZXRTcHJpbmdzKHQuY3RybCwgcGF5bG9hZCk7XG4gICAgaWYgKHBoYXNlID09PSBcImxlYXZlXCIgLyogTEVBVkUgKi8gJiYgZXhpdEJlZm9yZUVudGVyKSB7XG4gICAgICBleGl0aW5nVHJhbnNpdGlvbnMuY3VycmVudC5zZXQodCwgeyBwaGFzZSwgc3ByaW5ncywgcGF5bG9hZCB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2hhbmdlcy5zZXQodCwgeyBwaGFzZSwgc3ByaW5ncywgcGF5bG9hZCB9KTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjb250ZXh0ID0gdXNlQ29udGV4dDMoU3ByaW5nQ29udGV4dCk7XG4gIGNvbnN0IHByZXZDb250ZXh0ID0gdXNlUHJldjIoY29udGV4dCk7XG4gIGNvbnN0IGhhc0NvbnRleHQgPSBjb250ZXh0ICE9PSBwcmV2Q29udGV4dCAmJiBoYXNQcm9wcyhjb250ZXh0KTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDQoKCkgPT4ge1xuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBlYWNoNyh0cmFuc2l0aW9ucywgKHQpID0+IHtcbiAgICAgICAgdC5jdHJsLnN0YXJ0KHsgZGVmYXVsdDogY29udGV4dCB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwgW2NvbnRleHRdKTtcbiAgZWFjaDcoY2hhbmdlcywgKF8sIHQpID0+IHtcbiAgICBpZiAoZXhpdGluZ1RyYW5zaXRpb25zLmN1cnJlbnQuc2l6ZSkge1xuICAgICAgY29uc3QgaW5kID0gdHJhbnNpdGlvbnMuZmluZEluZGV4KChzdGF0ZSkgPT4gc3RhdGUua2V5ID09PSB0LmtleSk7XG4gICAgICB0cmFuc2l0aW9ucy5zcGxpY2UoaW5kLCAxKTtcbiAgICB9XG4gIH0pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0NChcbiAgICAoKSA9PiB7XG4gICAgICBlYWNoNyhcbiAgICAgICAgZXhpdGluZ1RyYW5zaXRpb25zLmN1cnJlbnQuc2l6ZSA/IGV4aXRpbmdUcmFuc2l0aW9ucy5jdXJyZW50IDogY2hhbmdlcyxcbiAgICAgICAgKHsgcGhhc2UsIHBheWxvYWQgfSwgdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHsgY3RybCB9ID0gdDtcbiAgICAgICAgICB0LnBoYXNlID0gcGhhc2U7XG4gICAgICAgICAgcmVmPy5hZGQoY3RybCk7XG4gICAgICAgICAgaWYgKGhhc0NvbnRleHQgJiYgcGhhc2UgPT0gXCJlbnRlclwiIC8qIEVOVEVSICovKSB7XG4gICAgICAgICAgICBjdHJsLnN0YXJ0KHsgZGVmYXVsdDogY29udGV4dCB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBheWxvYWQpIHtcbiAgICAgICAgICAgIHJlcGxhY2VSZWYoY3RybCwgcGF5bG9hZC5yZWYpO1xuICAgICAgICAgICAgaWYgKChjdHJsLnJlZiB8fCByZWYpICYmICFmb3JjZUNoYW5nZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgIGN0cmwudXBkYXRlKHBheWxvYWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3RybC5zdGFydChwYXlsb2FkKTtcbiAgICAgICAgICAgICAgaWYgKGZvcmNlQ2hhbmdlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBmb3JjZUNoYW5nZS5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgfSxcbiAgICByZXNldCA/IHZvaWQgMCA6IGRlcHNcbiAgKTtcbiAgY29uc3QgcmVuZGVyVHJhbnNpdGlvbnMgPSAocmVuZGVyKSA9PiAvKiBAX19QVVJFX18gKi8gUmVhY3QyLmNyZWF0ZUVsZW1lbnQoUmVhY3QyLkZyYWdtZW50LCBudWxsLCB0cmFuc2l0aW9ucy5tYXAoKHQsIGkpID0+IHtcbiAgICBjb25zdCB7IHNwcmluZ3MgfSA9IGNoYW5nZXMuZ2V0KHQpIHx8IHQuY3RybDtcbiAgICBjb25zdCBlbGVtID0gcmVuZGVyKHsgLi4uc3ByaW5ncyB9LCB0Lml0ZW0sIHQsIGkpO1xuICAgIHJldHVybiBlbGVtICYmIGVsZW0udHlwZSA/IC8qIEBfX1BVUkVfXyAqLyBSZWFjdDIuY3JlYXRlRWxlbWVudChcbiAgICAgIGVsZW0udHlwZSxcbiAgICAgIHtcbiAgICAgICAgLi4uZWxlbS5wcm9wcyxcbiAgICAgICAga2V5OiBpczExLnN0cih0LmtleSkgfHwgaXMxMS5udW0odC5rZXkpID8gdC5rZXkgOiB0LmN0cmwuaWQsXG4gICAgICAgIHJlZjogZWxlbS5yZWZcbiAgICAgIH1cbiAgICApIDogZWxlbTtcbiAgfSkpO1xuICByZXR1cm4gcmVmID8gW3JlbmRlclRyYW5zaXRpb25zLCByZWZdIDogcmVuZGVyVHJhbnNpdGlvbnM7XG59XG52YXIgbmV4dEtleSA9IDE7XG5mdW5jdGlvbiBnZXRLZXlzKGl0ZW1zLCB7IGtleSwga2V5cyA9IGtleSB9LCBwcmV2VHJhbnNpdGlvbnMpIHtcbiAgaWYgKGtleXMgPT09IG51bGwpIHtcbiAgICBjb25zdCByZXVzZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IHQgPSBwcmV2VHJhbnNpdGlvbnMgJiYgcHJldlRyYW5zaXRpb25zLmZpbmQoXG4gICAgICAgICh0MikgPT4gdDIuaXRlbSA9PT0gaXRlbSAmJiB0Mi5waGFzZSAhPT0gXCJsZWF2ZVwiIC8qIExFQVZFICovICYmICFyZXVzZWQuaGFzKHQyKVxuICAgICAgKTtcbiAgICAgIGlmICh0KSB7XG4gICAgICAgIHJldXNlZC5hZGQodCk7XG4gICAgICAgIHJldHVybiB0LmtleTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0S2V5Kys7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGlzMTEudW5kKGtleXMpID8gaXRlbXMgOiBpczExLmZ1bihrZXlzKSA/IGl0ZW1zLm1hcChrZXlzKSA6IHRvQXJyYXk0KGtleXMpO1xufVxuXG4vLyBzcmMvaG9va3MvdXNlU2Nyb2xsLnRzXG5pbXBvcnQgeyBlYWNoIGFzIGVhY2g4LCBvblNjcm9sbCwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0NSB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xudmFyIHVzZVNjcm9sbCA9ICh7XG4gIGNvbnRhaW5lcixcbiAgLi4uc3ByaW5nT3B0aW9uc1xufSA9IHt9KSA9PiB7XG4gIGNvbnN0IFtzY3JvbGxWYWx1ZXMsIGFwaV0gPSB1c2VTcHJpbmcoXG4gICAgKCkgPT4gKHtcbiAgICAgIHNjcm9sbFg6IDAsXG4gICAgICBzY3JvbGxZOiAwLFxuICAgICAgc2Nyb2xsWFByb2dyZXNzOiAwLFxuICAgICAgc2Nyb2xsWVByb2dyZXNzOiAwLFxuICAgICAgLi4uc3ByaW5nT3B0aW9uc1xuICAgIH0pLFxuICAgIFtdXG4gICk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q1KCgpID0+IHtcbiAgICBjb25zdCBjbGVhbnVwU2Nyb2xsID0gb25TY3JvbGwoXG4gICAgICAoeyB4LCB5IH0pID0+IHtcbiAgICAgICAgYXBpLnN0YXJ0KHtcbiAgICAgICAgICBzY3JvbGxYOiB4LmN1cnJlbnQsXG4gICAgICAgICAgc2Nyb2xsWFByb2dyZXNzOiB4LnByb2dyZXNzLFxuICAgICAgICAgIHNjcm9sbFk6IHkuY3VycmVudCxcbiAgICAgICAgICBzY3JvbGxZUHJvZ3Jlc3M6IHkucHJvZ3Jlc3NcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgeyBjb250YWluZXI6IGNvbnRhaW5lcj8uY3VycmVudCB8fCB2b2lkIDAgfVxuICAgICk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGVhY2g4KE9iamVjdC52YWx1ZXMoc2Nyb2xsVmFsdWVzKSwgKHZhbHVlKSA9PiB2YWx1ZS5zdG9wKCkpO1xuICAgICAgY2xlYW51cFNjcm9sbCgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHNjcm9sbFZhbHVlcztcbn07XG5cbi8vIHNyYy9ob29rcy91c2VSZXNpemUudHNcbmltcG9ydCB7IG9uUmVzaXplLCBlYWNoIGFzIGVhY2g5LCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGFzIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q2IH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG52YXIgdXNlUmVzaXplID0gKHtcbiAgY29udGFpbmVyLFxuICAuLi5zcHJpbmdPcHRpb25zXG59KSA9PiB7XG4gIGNvbnN0IFtzaXplVmFsdWVzLCBhcGldID0gdXNlU3ByaW5nKFxuICAgICgpID0+ICh7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIC4uLnNwcmluZ09wdGlvbnNcbiAgICB9KSxcbiAgICBbXVxuICApO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0NigoKSA9PiB7XG4gICAgY29uc3QgY2xlYW51cFNjcm9sbCA9IG9uUmVzaXplKFxuICAgICAgKHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XG4gICAgICAgIGFwaS5zdGFydCh7XG4gICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGltbWVkaWF0ZTogc2l6ZVZhbHVlcy53aWR0aC5nZXQoKSA9PT0gMCB8fCBzaXplVmFsdWVzLmhlaWdodC5nZXQoKSA9PT0gMFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICB7IGNvbnRhaW5lcjogY29udGFpbmVyPy5jdXJyZW50IHx8IHZvaWQgMCB9XG4gICAgKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZWFjaDkoT2JqZWN0LnZhbHVlcyhzaXplVmFsdWVzKSwgKHZhbHVlKSA9PiB2YWx1ZS5zdG9wKCkpO1xuICAgICAgY2xlYW51cFNjcm9sbCgpO1xuICAgIH07XG4gIH0sIFtdKTtcbiAgcmV0dXJuIHNpemVWYWx1ZXM7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlSW5WaWV3LnRzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmMywgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBpcyBhcyBpczEyLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IGFzIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3Q3IH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG52YXIgZGVmYXVsdFRocmVzaG9sZE9wdGlvbnMgPSB7XG4gIGFueTogMCxcbiAgYWxsOiAxXG59O1xuZnVuY3Rpb24gdXNlSW5WaWV3KHByb3BzLCBhcmdzKSB7XG4gIGNvbnN0IFtpc0luVmlldywgc2V0SXNJblZpZXddID0gdXNlU3RhdGUyKGZhbHNlKTtcbiAgY29uc3QgcmVmID0gdXNlUmVmMygpO1xuICBjb25zdCBwcm9wc0ZuID0gaXMxMi5mdW4ocHJvcHMpICYmIHByb3BzO1xuICBjb25zdCBzcHJpbmdzUHJvcHMgPSBwcm9wc0ZuID8gcHJvcHNGbigpIDoge307XG4gIGNvbnN0IHsgdG86IHRvMiA9IHt9LCBmcm9tID0ge30sIC4uLnJlc3RTcHJpbmdQcm9wcyB9ID0gc3ByaW5nc1Byb3BzO1xuICBjb25zdCBpbnRlcnNlY3Rpb25Bcmd1bWVudHMgPSBwcm9wc0ZuID8gYXJncyA6IHByb3BzO1xuICBjb25zdCBbc3ByaW5ncywgYXBpXSA9IHVzZVNwcmluZygoKSA9PiAoeyBmcm9tLCAuLi5yZXN0U3ByaW5nUHJvcHMgfSksIFtdKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDcoKCkgPT4ge1xuICAgIGNvbnN0IGVsZW1lbnQgPSByZWYuY3VycmVudDtcbiAgICBjb25zdCB7XG4gICAgICByb290LFxuICAgICAgb25jZSxcbiAgICAgIGFtb3VudCA9IFwiYW55XCIsXG4gICAgICAuLi5yZXN0QXJnc1xuICAgIH0gPSBpbnRlcnNlY3Rpb25Bcmd1bWVudHMgPz8ge307XG4gICAgaWYgKCFlbGVtZW50IHx8IG9uY2UgJiYgaXNJblZpZXcgfHwgdHlwZW9mIEludGVyc2VjdGlvbk9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFjdGl2ZUludGVyc2VjdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgICBjb25zdCBvbkVudGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRvMikge1xuICAgICAgICBhcGkuc3RhcnQodG8yKTtcbiAgICAgIH1cbiAgICAgIHNldElzSW5WaWV3KHRydWUpO1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGZyb20pIHtcbiAgICAgICAgICBhcGkuc3RhcnQoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SXNJblZpZXcoZmFsc2UpO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBvbmNlID8gdm9pZCAwIDogY2xlYW51cDtcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZUludGVyc2VjdGlvbiA9IChlbnRyaWVzKSA9PiB7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgIGNvbnN0IG9uTGVhdmUgPSBhY3RpdmVJbnRlcnNlY3Rpb25zLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcgPT09IEJvb2xlYW4ob25MZWF2ZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgY29uc3QgbmV3T25MZWF2ZSA9IG9uRW50ZXIoKTtcbiAgICAgICAgICBpZiAoaXMxMi5mdW4obmV3T25MZWF2ZSkpIHtcbiAgICAgICAgICAgIGFjdGl2ZUludGVyc2VjdGlvbnMuc2V0KGVudHJ5LnRhcmdldCwgbmV3T25MZWF2ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9ic2VydmVyLnVub2JzZXJ2ZShlbnRyeS50YXJnZXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvbkxlYXZlKSB7XG4gICAgICAgICAgb25MZWF2ZSgpO1xuICAgICAgICAgIGFjdGl2ZUludGVyc2VjdGlvbnMuZGVsZXRlKGVudHJ5LnRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaGFuZGxlSW50ZXJzZWN0aW9uLCB7XG4gICAgICByb290OiByb290ICYmIHJvb3QuY3VycmVudCB8fCB2b2lkIDAsXG4gICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheShhbW91bnQpID8gYW1vdW50IDogZGVmYXVsdFRocmVzaG9sZE9wdGlvbnNbYW1vdW50XSxcbiAgICAgIC4uLnJlc3RBcmdzXG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICB9LCBbaW50ZXJzZWN0aW9uQXJndW1lbnRzXSk7XG4gIGlmIChwcm9wc0ZuKSB7XG4gICAgcmV0dXJuIFtyZWYsIHNwcmluZ3NdO1xuICB9XG4gIHJldHVybiBbcmVmLCBpc0luVmlld107XG59XG5cbi8vIHNyYy9jb21wb25lbnRzL1NwcmluZy50c3hcbmZ1bmN0aW9uIFNwcmluZyh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9KSB7XG4gIHJldHVybiBjaGlsZHJlbih1c2VTcHJpbmcocHJvcHMpKTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvVHJhaWwudHN4XG5pbXBvcnQgeyBpcyBhcyBpczEzIH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG5mdW5jdGlvbiBUcmFpbCh7XG4gIGl0ZW1zLFxuICBjaGlsZHJlbixcbiAgLi4ucHJvcHNcbn0pIHtcbiAgY29uc3QgdHJhaWxzID0gdXNlVHJhaWwoaXRlbXMubGVuZ3RoLCBwcm9wcyk7XG4gIHJldHVybiBpdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gY2hpbGRyZW4oaXRlbSwgaW5kZXgpO1xuICAgIHJldHVybiBpczEzLmZ1bihyZXN1bHQpID8gcmVzdWx0KHRyYWlsc1tpbmRleF0pIDogcmVzdWx0O1xuICB9KTtcbn1cblxuLy8gc3JjL2NvbXBvbmVudHMvVHJhbnNpdGlvbi50c3hcbmZ1bmN0aW9uIFRyYW5zaXRpb24oe1xuICBpdGVtcyxcbiAgY2hpbGRyZW4sXG4gIC4uLnByb3BzXG59KSB7XG4gIHJldHVybiB1c2VUcmFuc2l0aW9uKGl0ZW1zLCBwcm9wcykoY2hpbGRyZW4pO1xufVxuXG4vLyBzcmMvaW50ZXJwb2xhdGUudHNcbmltcG9ydCB7IGRlcHJlY2F0ZUludGVycG9sYXRlIGFzIGRlcHJlY2F0ZUludGVycG9sYXRlMiB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xuXG4vLyBzcmMvSW50ZXJwb2xhdGlvbi50c1xuaW1wb3J0IHtcbiAgaXMgYXMgaXMxNCxcbiAgcmFmIGFzIHJhZjUsXG4gIGVhY2ggYXMgZWFjaDEwLFxuICBpc0VxdWFsIGFzIGlzRXF1YWwyLFxuICB0b0FycmF5IGFzIHRvQXJyYXk1LFxuICBmcmFtZUxvb3AgYXMgZnJhbWVMb29wMyxcbiAgZ2V0Rmx1aWRWYWx1ZSBhcyBnZXRGbHVpZFZhbHVlMyxcbiAgY3JlYXRlSW50ZXJwb2xhdG9yLFxuICBHbG9iYWxzIGFzIEc2LFxuICBjYWxsRmx1aWRPYnNlcnZlcnMgYXMgY2FsbEZsdWlkT2JzZXJ2ZXJzMyxcbiAgYWRkRmx1aWRPYnNlcnZlciBhcyBhZGRGbHVpZE9ic2VydmVyMyxcbiAgcmVtb3ZlRmx1aWRPYnNlcnZlciBhcyByZW1vdmVGbHVpZE9ic2VydmVyMixcbiAgaGFzRmx1aWRWYWx1ZSBhcyBoYXNGbHVpZFZhbHVlMlxufSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcbmltcG9ydCB7XG4gIGdldEFuaW1hdGVkIGFzIGdldEFuaW1hdGVkMyxcbiAgc2V0QW5pbWF0ZWQgYXMgc2V0QW5pbWF0ZWQyLFxuICBnZXRBbmltYXRlZFR5cGUgYXMgZ2V0QW5pbWF0ZWRUeXBlMixcbiAgZ2V0UGF5bG9hZCBhcyBnZXRQYXlsb2FkMlxufSBmcm9tIFwiQHJlYWN0LXNwcmluZy9hbmltYXRlZFwiO1xudmFyIEludGVycG9sYXRpb24gPSBjbGFzcyBleHRlbmRzIEZyYW1lVmFsdWUge1xuICBjb25zdHJ1Y3Rvcihzb3VyY2UsIGFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIC8qKiBFcXVhbHMgZmFsc2Ugd2hlbiBpbiB0aGUgZnJhbWVsb29wICovXG4gICAgdGhpcy5pZGxlID0gdHJ1ZTtcbiAgICAvKiogVGhlIGlucHV0cyB3aGljaCBhcmUgY3VycmVudGx5IGFuaW1hdGluZyAqL1xuICAgIHRoaXMuX2FjdGl2ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5jYWxjID0gY3JlYXRlSW50ZXJwb2xhdG9yKC4uLmFyZ3MpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0KCk7XG4gICAgY29uc3Qgbm9kZVR5cGUgPSBnZXRBbmltYXRlZFR5cGUyKHZhbHVlKTtcbiAgICBzZXRBbmltYXRlZDIodGhpcywgbm9kZVR5cGUuY3JlYXRlKHZhbHVlKSk7XG4gIH1cbiAgYWR2YW5jZShfZHQpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2dldCgpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoIWlzRXF1YWwyKHZhbHVlLCBvbGRWYWx1ZSkpIHtcbiAgICAgIGdldEFuaW1hdGVkMyh0aGlzKS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICB0aGlzLl9vbkNoYW5nZSh2YWx1ZSwgdGhpcy5pZGxlKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlkbGUgJiYgY2hlY2tJZGxlKHRoaXMuX2FjdGl2ZSkpIHtcbiAgICAgIGJlY29tZUlkbGUodGhpcyk7XG4gICAgfVxuICB9XG4gIF9nZXQoKSB7XG4gICAgY29uc3QgaW5wdXRzID0gaXMxNC5hcnIodGhpcy5zb3VyY2UpID8gdGhpcy5zb3VyY2UubWFwKGdldEZsdWlkVmFsdWUzKSA6IHRvQXJyYXk1KGdldEZsdWlkVmFsdWUzKHRoaXMuc291cmNlKSk7XG4gICAgcmV0dXJuIHRoaXMuY2FsYyguLi5pbnB1dHMpO1xuICB9XG4gIF9zdGFydCgpIHtcbiAgICBpZiAodGhpcy5pZGxlICYmICFjaGVja0lkbGUodGhpcy5fYWN0aXZlKSkge1xuICAgICAgdGhpcy5pZGxlID0gZmFsc2U7XG4gICAgICBlYWNoMTAoZ2V0UGF5bG9hZDIodGhpcyksIChub2RlKSA9PiB7XG4gICAgICAgIG5vZGUuZG9uZSA9IGZhbHNlO1xuICAgICAgfSk7XG4gICAgICBpZiAoRzYuc2tpcEFuaW1hdGlvbikge1xuICAgICAgICByYWY1LmJhdGNoZWRVcGRhdGVzKCgpID0+IHRoaXMuYWR2YW5jZSgpKTtcbiAgICAgICAgYmVjb21lSWRsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYW1lTG9vcDMuc3RhcnQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIE9ic2VydmUgb3VyIHNvdXJjZXMgb25seSB3aGVuIHdlJ3JlIG9ic2VydmVkLlxuICBfYXR0YWNoKCkge1xuICAgIGxldCBwcmlvcml0eSA9IDE7XG4gICAgZWFjaDEwKHRvQXJyYXk1KHRoaXMuc291cmNlKSwgKHNvdXJjZSkgPT4ge1xuICAgICAgaWYgKGhhc0ZsdWlkVmFsdWUyKHNvdXJjZSkpIHtcbiAgICAgICAgYWRkRmx1aWRPYnNlcnZlcjMoc291cmNlLCB0aGlzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZyYW1lVmFsdWUoc291cmNlKSkge1xuICAgICAgICBpZiAoIXNvdXJjZS5pZGxlKSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZlLmFkZChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHByaW9yaXR5ID0gTWF0aC5tYXgocHJpb3JpdHksIHNvdXJjZS5wcmlvcml0eSArIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgICB0aGlzLl9zdGFydCgpO1xuICB9XG4gIC8vIFN0b3Agb2JzZXJ2aW5nIG91ciBzb3VyY2VzIG9uY2Ugd2UgaGF2ZSBubyBvYnNlcnZlcnMuXG4gIF9kZXRhY2goKSB7XG4gICAgZWFjaDEwKHRvQXJyYXk1KHRoaXMuc291cmNlKSwgKHNvdXJjZSkgPT4ge1xuICAgICAgaWYgKGhhc0ZsdWlkVmFsdWUyKHNvdXJjZSkpIHtcbiAgICAgICAgcmVtb3ZlRmx1aWRPYnNlcnZlcjIoc291cmNlLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLl9hY3RpdmUuY2xlYXIoKTtcbiAgICBiZWNvbWVJZGxlKHRoaXMpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZXZlbnRPYnNlcnZlZChldmVudCkge1xuICAgIGlmIChldmVudC50eXBlID09IFwiY2hhbmdlXCIpIHtcbiAgICAgIGlmIChldmVudC5pZGxlKSB7XG4gICAgICAgIHRoaXMuYWR2YW5jZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWN0aXZlLmFkZChldmVudC5wYXJlbnQpO1xuICAgICAgICB0aGlzLl9zdGFydCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PSBcImlkbGVcIikge1xuICAgICAgdGhpcy5fYWN0aXZlLmRlbGV0ZShldmVudC5wYXJlbnQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PSBcInByaW9yaXR5XCIpIHtcbiAgICAgIHRoaXMucHJpb3JpdHkgPSB0b0FycmF5NSh0aGlzLnNvdXJjZSkucmVkdWNlKFxuICAgICAgICAoaGlnaGVzdCwgcGFyZW50KSA9PiBNYXRoLm1heChoaWdoZXN0LCAoaXNGcmFtZVZhbHVlKHBhcmVudCkgPyBwYXJlbnQucHJpb3JpdHkgOiAwKSArIDEpLFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIGlzSWRsZShzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZS5pZGxlICE9PSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSWRsZShhY3RpdmUpIHtcbiAgcmV0dXJuICFhY3RpdmUuc2l6ZSB8fCBBcnJheS5mcm9tKGFjdGl2ZSkuZXZlcnkoaXNJZGxlKTtcbn1cbmZ1bmN0aW9uIGJlY29tZUlkbGUoc2VsZikge1xuICBpZiAoIXNlbGYuaWRsZSkge1xuICAgIHNlbGYuaWRsZSA9IHRydWU7XG4gICAgZWFjaDEwKGdldFBheWxvYWQyKHNlbGYpLCAobm9kZSkgPT4ge1xuICAgICAgbm9kZS5kb25lID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBjYWxsRmx1aWRPYnNlcnZlcnMzKHNlbGYsIHtcbiAgICAgIHR5cGU6IFwiaWRsZVwiLFxuICAgICAgcGFyZW50OiBzZWxmXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2ludGVycG9sYXRlLnRzXG52YXIgdG8gPSAoc291cmNlLCAuLi5hcmdzKSA9PiBuZXcgSW50ZXJwb2xhdGlvbihzb3VyY2UsIGFyZ3MpO1xudmFyIGludGVycG9sYXRlID0gKHNvdXJjZSwgLi4uYXJncykgPT4gKGRlcHJlY2F0ZUludGVycG9sYXRlMigpLCBuZXcgSW50ZXJwb2xhdGlvbihzb3VyY2UsIGFyZ3MpKTtcblxuLy8gc3JjL2dsb2JhbHMudHNcbmltcG9ydCB7XG4gIEdsb2JhbHMsXG4gIGZyYW1lTG9vcCBhcyBmcmFtZUxvb3A0LFxuICBjcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3Jcbn0gZnJvbSBcIkByZWFjdC1zcHJpbmcvc2hhcmVkXCI7XG5HbG9iYWxzLmFzc2lnbih7XG4gIGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcixcbiAgdG86IChzb3VyY2UsIGFyZ3MpID0+IG5ldyBJbnRlcnBvbGF0aW9uKHNvdXJjZSwgYXJncylcbn0pO1xudmFyIHVwZGF0ZSA9IGZyYW1lTG9vcDQuYWR2YW5jZTtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQge1xuICBjcmVhdGVJbnRlcnBvbGF0b3IgYXMgY3JlYXRlSW50ZXJwb2xhdG9yMixcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0OCxcbiAgdXNlUmVkdWNlZE1vdGlvbixcbiAgZWFzaW5ncyBhcyBlYXNpbmdzMlxufSBmcm9tIFwiQHJlYWN0LXNwcmluZy9zaGFyZWRcIjtcbmV4cG9ydCAqIGZyb20gXCJAcmVhY3Qtc3ByaW5nL3R5cGVzXCI7XG5leHBvcnQge1xuICBCYWlsU2lnbmFsLFxuICBDb250cm9sbGVyLFxuICBGcmFtZVZhbHVlLFxuICBHbG9iYWxzLFxuICBJbnRlcnBvbGF0aW9uLFxuICBTcHJpbmcsXG4gIFNwcmluZ0NvbnRleHQsXG4gIFNwcmluZ1JlZixcbiAgU3ByaW5nVmFsdWUsXG4gIFRyYWlsLFxuICBUcmFuc2l0aW9uLFxuICBjb25maWcsXG4gIGNyZWF0ZUludGVycG9sYXRvcjIgYXMgY3JlYXRlSW50ZXJwb2xhdG9yLFxuICBlYXNpbmdzMiBhcyBlYXNpbmdzLFxuICBpbmZlclRvLFxuICBpbnRlcnBvbGF0ZSxcbiAgdG8sXG4gIHVwZGF0ZSxcbiAgdXNlQ2hhaW4sXG4gIHVzZUluVmlldyxcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDggYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCxcbiAgdXNlUmVkdWNlZE1vdGlvbixcbiAgdXNlUmVzaXplLFxuICB1c2VTY3JvbGwsXG4gIHVzZVNwcmluZyxcbiAgdXNlU3ByaW5nUmVmLFxuICB1c2VTcHJpbmdWYWx1ZSxcbiAgdXNlU3ByaW5ncyxcbiAgdXNlVHJhaWwsXG4gIHVzZVRyYW5zaXRpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1zcHJpbmdfY29yZS5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-spring/core/dist/react-spring_core.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __raf: function() { return /* binding */ __raf; },\n/* harmony export */   raf: function() { return /* binding */ raf; }\n/* harmony export */ });\n// src/index.ts\nvar updateQueue = makeQueue();\nvar raf = (fn) => schedule(fn, updateQueue);\nvar writeQueue = makeQueue();\nraf.write = (fn) => schedule(fn, writeQueue);\nvar onStartQueue = makeQueue();\nraf.onStart = (fn) => schedule(fn, onStartQueue);\nvar onFrameQueue = makeQueue();\nraf.onFrame = (fn) => schedule(fn, onFrameQueue);\nvar onFinishQueue = makeQueue();\nraf.onFinish = (fn) => schedule(fn, onFinishQueue);\nvar timeouts = [];\nraf.setTimeout = (handler, ms) => {\n  const time = raf.now() + ms;\n  const cancel = () => {\n    const i = timeouts.findIndex((t) => t.cancel == cancel);\n    if (~i)\n      timeouts.splice(i, 1);\n    pendingCount -= ~i ? 1 : 0;\n  };\n  const timeout = { time, handler, cancel };\n  timeouts.splice(findTimeout(time), 0, timeout);\n  pendingCount += 1;\n  start();\n  return timeout;\n};\nvar findTimeout = (time) => ~(~timeouts.findIndex((t) => t.time > time) || ~timeouts.length);\nraf.cancel = (fn) => {\n  onStartQueue.delete(fn);\n  onFrameQueue.delete(fn);\n  onFinishQueue.delete(fn);\n  updateQueue.delete(fn);\n  writeQueue.delete(fn);\n};\nraf.sync = (fn) => {\n  sync = true;\n  raf.batchedUpdates(fn);\n  sync = false;\n};\nraf.throttle = (fn) => {\n  let lastArgs;\n  function queuedFn() {\n    try {\n      fn(...lastArgs);\n    } finally {\n      lastArgs = null;\n    }\n  }\n  function throttled(...args) {\n    lastArgs = args;\n    raf.onStart(queuedFn);\n  }\n  throttled.handler = fn;\n  throttled.cancel = () => {\n    onStartQueue.delete(queuedFn);\n    lastArgs = null;\n  };\n  return throttled;\n};\nvar nativeRaf = typeof window != \"undefined\" ? window.requestAnimationFrame : (\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  () => {\n  }\n);\nraf.use = (impl) => nativeRaf = impl;\nraf.now = typeof performance != \"undefined\" ? () => performance.now() : Date.now;\nraf.batchedUpdates = (fn) => fn();\nraf.catch = console.error;\nraf.frameLoop = \"always\";\nraf.advance = () => {\n  if (raf.frameLoop !== \"demand\") {\n    console.warn(\n      \"Cannot call the manual advancement of rafz whilst frameLoop is not set as demand\"\n    );\n  } else {\n    update();\n  }\n};\nvar ts = -1;\nvar pendingCount = 0;\nvar sync = false;\nfunction schedule(fn, queue) {\n  if (sync) {\n    queue.delete(fn);\n    fn(0);\n  } else {\n    queue.add(fn);\n    start();\n  }\n}\nfunction start() {\n  if (ts < 0) {\n    ts = 0;\n    if (raf.frameLoop !== \"demand\") {\n      nativeRaf(loop);\n    }\n  }\n}\nfunction stop() {\n  ts = -1;\n}\nfunction loop() {\n  if (~ts) {\n    nativeRaf(loop);\n    raf.batchedUpdates(update);\n  }\n}\nfunction update() {\n  const prevTs = ts;\n  ts = raf.now();\n  const count = findTimeout(ts);\n  if (count) {\n    eachSafely(timeouts.splice(0, count), (t) => t.handler());\n    pendingCount -= count;\n  }\n  if (!pendingCount) {\n    stop();\n    return;\n  }\n  onStartQueue.flush();\n  updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);\n  onFrameQueue.flush();\n  writeQueue.flush();\n  onFinishQueue.flush();\n}\nfunction makeQueue() {\n  let next = /* @__PURE__ */ new Set();\n  let current = next;\n  return {\n    add(fn) {\n      pendingCount += current == next && !next.has(fn) ? 1 : 0;\n      next.add(fn);\n    },\n    delete(fn) {\n      pendingCount -= current == next && next.has(fn) ? 1 : 0;\n      return next.delete(fn);\n    },\n    flush(arg) {\n      if (current.size) {\n        next = /* @__PURE__ */ new Set();\n        pendingCount -= current.size;\n        eachSafely(current, (fn) => fn(arg) && next.add(fn));\n        pendingCount += next.size;\n        current = next;\n      }\n    }\n  };\n}\nfunction eachSafely(values, each) {\n  values.forEach((value) => {\n    try {\n      each(value);\n    } catch (e) {\n      raf.catch(e);\n    }\n  });\n}\nvar __raf = {\n  /** The number of pending tasks */\n  count() {\n    return pendingCount;\n  },\n  /** Whether there's a raf update loop running */\n  isRunning() {\n    return ts >= 0;\n  },\n  /** Clear internal state. Never call from update loop! */\n  clear() {\n    ts = -1;\n    timeouts = [];\n    onStartQueue = makeQueue();\n    updateQueue = makeQueue();\n    onFrameQueue = makeQueue();\n    writeQueue = makeQueue();\n    onFinishQueue = makeQueue();\n    pendingCount = 0;\n  }\n};\n\n//# sourceMappingURL=react-spring_rafz.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3JhZnovZGlzdC9yZWFjdC1zcHJpbmdfcmFmei5tb2Rlcm4ubWpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvcmFmei9kaXN0L3JlYWN0LXNwcmluZ19yYWZ6Lm1vZGVybi5tanM/MWQwMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbnZhciB1cGRhdGVRdWV1ZSA9IG1ha2VRdWV1ZSgpO1xudmFyIHJhZiA9IChmbikgPT4gc2NoZWR1bGUoZm4sIHVwZGF0ZVF1ZXVlKTtcbnZhciB3cml0ZVF1ZXVlID0gbWFrZVF1ZXVlKCk7XG5yYWYud3JpdGUgPSAoZm4pID0+IHNjaGVkdWxlKGZuLCB3cml0ZVF1ZXVlKTtcbnZhciBvblN0YXJ0UXVldWUgPSBtYWtlUXVldWUoKTtcbnJhZi5vblN0YXJ0ID0gKGZuKSA9PiBzY2hlZHVsZShmbiwgb25TdGFydFF1ZXVlKTtcbnZhciBvbkZyYW1lUXVldWUgPSBtYWtlUXVldWUoKTtcbnJhZi5vbkZyYW1lID0gKGZuKSA9PiBzY2hlZHVsZShmbiwgb25GcmFtZVF1ZXVlKTtcbnZhciBvbkZpbmlzaFF1ZXVlID0gbWFrZVF1ZXVlKCk7XG5yYWYub25GaW5pc2ggPSAoZm4pID0+IHNjaGVkdWxlKGZuLCBvbkZpbmlzaFF1ZXVlKTtcbnZhciB0aW1lb3V0cyA9IFtdO1xucmFmLnNldFRpbWVvdXQgPSAoaGFuZGxlciwgbXMpID0+IHtcbiAgY29uc3QgdGltZSA9IHJhZi5ub3coKSArIG1zO1xuICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgY29uc3QgaSA9IHRpbWVvdXRzLmZpbmRJbmRleCgodCkgPT4gdC5jYW5jZWwgPT0gY2FuY2VsKTtcbiAgICBpZiAofmkpXG4gICAgICB0aW1lb3V0cy5zcGxpY2UoaSwgMSk7XG4gICAgcGVuZGluZ0NvdW50IC09IH5pID8gMSA6IDA7XG4gIH07XG4gIGNvbnN0IHRpbWVvdXQgPSB7IHRpbWUsIGhhbmRsZXIsIGNhbmNlbCB9O1xuICB0aW1lb3V0cy5zcGxpY2UoZmluZFRpbWVvdXQodGltZSksIDAsIHRpbWVvdXQpO1xuICBwZW5kaW5nQ291bnQgKz0gMTtcbiAgc3RhcnQoKTtcbiAgcmV0dXJuIHRpbWVvdXQ7XG59O1xudmFyIGZpbmRUaW1lb3V0ID0gKHRpbWUpID0+IH4ofnRpbWVvdXRzLmZpbmRJbmRleCgodCkgPT4gdC50aW1lID4gdGltZSkgfHwgfnRpbWVvdXRzLmxlbmd0aCk7XG5yYWYuY2FuY2VsID0gKGZuKSA9PiB7XG4gIG9uU3RhcnRRdWV1ZS5kZWxldGUoZm4pO1xuICBvbkZyYW1lUXVldWUuZGVsZXRlKGZuKTtcbiAgb25GaW5pc2hRdWV1ZS5kZWxldGUoZm4pO1xuICB1cGRhdGVRdWV1ZS5kZWxldGUoZm4pO1xuICB3cml0ZVF1ZXVlLmRlbGV0ZShmbik7XG59O1xucmFmLnN5bmMgPSAoZm4pID0+IHtcbiAgc3luYyA9IHRydWU7XG4gIHJhZi5iYXRjaGVkVXBkYXRlcyhmbik7XG4gIHN5bmMgPSBmYWxzZTtcbn07XG5yYWYudGhyb3R0bGUgPSAoZm4pID0+IHtcbiAgbGV0IGxhc3RBcmdzO1xuICBmdW5jdGlvbiBxdWV1ZWRGbigpIHtcbiAgICB0cnkge1xuICAgICAgZm4oLi4ubGFzdEFyZ3MpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBsYXN0QXJncyA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRocm90dGxlZCguLi5hcmdzKSB7XG4gICAgbGFzdEFyZ3MgPSBhcmdzO1xuICAgIHJhZi5vblN0YXJ0KHF1ZXVlZEZuKTtcbiAgfVxuICB0aHJvdHRsZWQuaGFuZGxlciA9IGZuO1xuICB0aHJvdHRsZWQuY2FuY2VsID0gKCkgPT4ge1xuICAgIG9uU3RhcnRRdWV1ZS5kZWxldGUocXVldWVkRm4pO1xuICAgIGxhc3RBcmdzID0gbnVsbDtcbiAgfTtcbiAgcmV0dXJuIHRocm90dGxlZDtcbn07XG52YXIgbmF0aXZlUmFmID0gdHlwZW9mIHdpbmRvdyAhPSBcInVuZGVmaW5lZFwiID8gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA6IChcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAoKSA9PiB7XG4gIH1cbik7XG5yYWYudXNlID0gKGltcGwpID0+IG5hdGl2ZVJhZiA9IGltcGw7XG5yYWYubm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9IFwidW5kZWZpbmVkXCIgPyAoKSA9PiBwZXJmb3JtYW5jZS5ub3coKSA6IERhdGUubm93O1xucmFmLmJhdGNoZWRVcGRhdGVzID0gKGZuKSA9PiBmbigpO1xucmFmLmNhdGNoID0gY29uc29sZS5lcnJvcjtcbnJhZi5mcmFtZUxvb3AgPSBcImFsd2F5c1wiO1xucmFmLmFkdmFuY2UgPSAoKSA9PiB7XG4gIGlmIChyYWYuZnJhbWVMb29wICE9PSBcImRlbWFuZFwiKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgXCJDYW5ub3QgY2FsbCB0aGUgbWFudWFsIGFkdmFuY2VtZW50IG9mIHJhZnogd2hpbHN0IGZyYW1lTG9vcCBpcyBub3Qgc2V0IGFzIGRlbWFuZFwiXG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUoKTtcbiAgfVxufTtcbnZhciB0cyA9IC0xO1xudmFyIHBlbmRpbmdDb3VudCA9IDA7XG52YXIgc3luYyA9IGZhbHNlO1xuZnVuY3Rpb24gc2NoZWR1bGUoZm4sIHF1ZXVlKSB7XG4gIGlmIChzeW5jKSB7XG4gICAgcXVldWUuZGVsZXRlKGZuKTtcbiAgICBmbigwKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZS5hZGQoZm4pO1xuICAgIHN0YXJ0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHN0YXJ0KCkge1xuICBpZiAodHMgPCAwKSB7XG4gICAgdHMgPSAwO1xuICAgIGlmIChyYWYuZnJhbWVMb29wICE9PSBcImRlbWFuZFwiKSB7XG4gICAgICBuYXRpdmVSYWYobG9vcCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdG9wKCkge1xuICB0cyA9IC0xO1xufVxuZnVuY3Rpb24gbG9vcCgpIHtcbiAgaWYgKH50cykge1xuICAgIG5hdGl2ZVJhZihsb29wKTtcbiAgICByYWYuYmF0Y2hlZFVwZGF0ZXModXBkYXRlKTtcbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlKCkge1xuICBjb25zdCBwcmV2VHMgPSB0cztcbiAgdHMgPSByYWYubm93KCk7XG4gIGNvbnN0IGNvdW50ID0gZmluZFRpbWVvdXQodHMpO1xuICBpZiAoY291bnQpIHtcbiAgICBlYWNoU2FmZWx5KHRpbWVvdXRzLnNwbGljZSgwLCBjb3VudCksICh0KSA9PiB0LmhhbmRsZXIoKSk7XG4gICAgcGVuZGluZ0NvdW50IC09IGNvdW50O1xuICB9XG4gIGlmICghcGVuZGluZ0NvdW50KSB7XG4gICAgc3RvcCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBvblN0YXJ0UXVldWUuZmx1c2goKTtcbiAgdXBkYXRlUXVldWUuZmx1c2gocHJldlRzID8gTWF0aC5taW4oNjQsIHRzIC0gcHJldlRzKSA6IDE2LjY2Nyk7XG4gIG9uRnJhbWVRdWV1ZS5mbHVzaCgpO1xuICB3cml0ZVF1ZXVlLmZsdXNoKCk7XG4gIG9uRmluaXNoUXVldWUuZmx1c2goKTtcbn1cbmZ1bmN0aW9uIG1ha2VRdWV1ZSgpIHtcbiAgbGV0IG5leHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgY3VycmVudCA9IG5leHQ7XG4gIHJldHVybiB7XG4gICAgYWRkKGZuKSB7XG4gICAgICBwZW5kaW5nQ291bnQgKz0gY3VycmVudCA9PSBuZXh0ICYmICFuZXh0LmhhcyhmbikgPyAxIDogMDtcbiAgICAgIG5leHQuYWRkKGZuKTtcbiAgICB9LFxuICAgIGRlbGV0ZShmbikge1xuICAgICAgcGVuZGluZ0NvdW50IC09IGN1cnJlbnQgPT0gbmV4dCAmJiBuZXh0LmhhcyhmbikgPyAxIDogMDtcbiAgICAgIHJldHVybiBuZXh0LmRlbGV0ZShmbik7XG4gICAgfSxcbiAgICBmbHVzaChhcmcpIHtcbiAgICAgIGlmIChjdXJyZW50LnNpemUpIHtcbiAgICAgICAgbmV4dCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICAgIHBlbmRpbmdDb3VudCAtPSBjdXJyZW50LnNpemU7XG4gICAgICAgIGVhY2hTYWZlbHkoY3VycmVudCwgKGZuKSA9PiBmbihhcmcpICYmIG5leHQuYWRkKGZuKSk7XG4gICAgICAgIHBlbmRpbmdDb3VudCArPSBuZXh0LnNpemU7XG4gICAgICAgIGN1cnJlbnQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGVhY2hTYWZlbHkodmFsdWVzLCBlYWNoKSB7XG4gIHZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBlYWNoKHZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByYWYuY2F0Y2goZSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBfX3JhZiA9IHtcbiAgLyoqIFRoZSBudW1iZXIgb2YgcGVuZGluZyB0YXNrcyAqL1xuICBjb3VudCgpIHtcbiAgICByZXR1cm4gcGVuZGluZ0NvdW50O1xuICB9LFxuICAvKiogV2hldGhlciB0aGVyZSdzIGEgcmFmIHVwZGF0ZSBsb29wIHJ1bm5pbmcgKi9cbiAgaXNSdW5uaW5nKCkge1xuICAgIHJldHVybiB0cyA+PSAwO1xuICB9LFxuICAvKiogQ2xlYXIgaW50ZXJuYWwgc3RhdGUuIE5ldmVyIGNhbGwgZnJvbSB1cGRhdGUgbG9vcCEgKi9cbiAgY2xlYXIoKSB7XG4gICAgdHMgPSAtMTtcbiAgICB0aW1lb3V0cyA9IFtdO1xuICAgIG9uU3RhcnRRdWV1ZSA9IG1ha2VRdWV1ZSgpO1xuICAgIHVwZGF0ZVF1ZXVlID0gbWFrZVF1ZXVlKCk7XG4gICAgb25GcmFtZVF1ZXVlID0gbWFrZVF1ZXVlKCk7XG4gICAgd3JpdGVRdWV1ZSA9IG1ha2VRdWV1ZSgpO1xuICAgIG9uRmluaXNoUXVldWUgPSBtYWtlUXVldWUoKTtcbiAgICBwZW5kaW5nQ291bnQgPSAwO1xuICB9XG59O1xuZXhwb3J0IHtcbiAgX19yYWYsXG4gIHJhZlxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXNwcmluZ19yYWZ6Lm1vZGVybi5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs":
/*!*******************************************************************************!*\
  !*** ./node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FluidValue: function() { return /* binding */ FluidValue; },\n/* harmony export */   Globals: function() { return /* binding */ globals_exports; },\n/* harmony export */   addFluidObserver: function() { return /* binding */ addFluidObserver; },\n/* harmony export */   callFluidObserver: function() { return /* binding */ callFluidObserver; },\n/* harmony export */   callFluidObservers: function() { return /* binding */ callFluidObservers; },\n/* harmony export */   clamp: function() { return /* binding */ clamp; },\n/* harmony export */   colorToRgba: function() { return /* binding */ colorToRgba; },\n/* harmony export */   colors: function() { return /* binding */ colors2; },\n/* harmony export */   createInterpolator: function() { return /* binding */ createInterpolator; },\n/* harmony export */   createStringInterpolator: function() { return /* binding */ createStringInterpolator2; },\n/* harmony export */   defineHidden: function() { return /* binding */ defineHidden; },\n/* harmony export */   deprecateDirectCall: function() { return /* binding */ deprecateDirectCall; },\n/* harmony export */   deprecateInterpolate: function() { return /* binding */ deprecateInterpolate; },\n/* harmony export */   each: function() { return /* binding */ each; },\n/* harmony export */   eachProp: function() { return /* binding */ eachProp; },\n/* harmony export */   easings: function() { return /* binding */ easings; },\n/* harmony export */   flush: function() { return /* binding */ flush; },\n/* harmony export */   flushCalls: function() { return /* binding */ flushCalls; },\n/* harmony export */   frameLoop: function() { return /* binding */ frameLoop; },\n/* harmony export */   getFluidObservers: function() { return /* binding */ getFluidObservers; },\n/* harmony export */   getFluidValue: function() { return /* binding */ getFluidValue; },\n/* harmony export */   hasFluidValue: function() { return /* binding */ hasFluidValue; },\n/* harmony export */   hex3: function() { return /* binding */ hex3; },\n/* harmony export */   hex4: function() { return /* binding */ hex4; },\n/* harmony export */   hex6: function() { return /* binding */ hex6; },\n/* harmony export */   hex8: function() { return /* binding */ hex8; },\n/* harmony export */   hsl: function() { return /* binding */ hsl; },\n/* harmony export */   hsla: function() { return /* binding */ hsla; },\n/* harmony export */   is: function() { return /* binding */ is; },\n/* harmony export */   isAnimatedString: function() { return /* binding */ isAnimatedString; },\n/* harmony export */   isEqual: function() { return /* binding */ isEqual; },\n/* harmony export */   isSSR: function() { return /* binding */ isSSR; },\n/* harmony export */   noop: function() { return /* binding */ noop; },\n/* harmony export */   onResize: function() { return /* binding */ onResize; },\n/* harmony export */   onScroll: function() { return /* binding */ onScroll; },\n/* harmony export */   once: function() { return /* binding */ once; },\n/* harmony export */   prefix: function() { return /* binding */ prefix; },\n/* harmony export */   raf: function() { return /* reexport safe */ _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf; },\n/* harmony export */   removeFluidObserver: function() { return /* binding */ removeFluidObserver; },\n/* harmony export */   rgb: function() { return /* binding */ rgb; },\n/* harmony export */   rgba: function() { return /* binding */ rgba; },\n/* harmony export */   setFluidGetter: function() { return /* binding */ setFluidGetter; },\n/* harmony export */   toArray: function() { return /* binding */ toArray; },\n/* harmony export */   useConstant: function() { return /* binding */ useConstant; },\n/* harmony export */   useForceUpdate: function() { return /* binding */ useForceUpdate; },\n/* harmony export */   useIsomorphicLayoutEffect: function() { return /* binding */ useIsomorphicLayoutEffect; },\n/* harmony export */   useMemoOne: function() { return /* binding */ useMemoOne; },\n/* harmony export */   useOnce: function() { return /* binding */ useOnce; },\n/* harmony export */   usePrev: function() { return /* binding */ usePrev; },\n/* harmony export */   useReducedMotion: function() { return /* binding */ useReducedMotion; }\n/* harmony export */ });\n/* harmony import */ var _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-spring/rafz */ \"(app-pages-browser)/./node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\n\n// src/globals.ts\nvar globals_exports = {};\n__export(globals_exports, {\n  assign: () => assign,\n  colors: () => colors,\n  createStringInterpolator: () => createStringInterpolator,\n  skipAnimation: () => skipAnimation,\n  to: () => to,\n  willAdvance: () => willAdvance\n});\n\n\n// src/helpers.ts\nfunction noop() {\n}\nvar defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });\nvar is = {\n  arr: Array.isArray,\n  obj: (a) => !!a && a.constructor.name === \"Object\",\n  fun: (a) => typeof a === \"function\",\n  str: (a) => typeof a === \"string\",\n  num: (a) => typeof a === \"number\",\n  und: (a) => a === void 0\n};\nfunction isEqual(a, b) {\n  if (is.arr(a)) {\n    if (!is.arr(b) || a.length !== b.length)\n      return false;\n    for (let i = 0; i < a.length; i++) {\n      if (a[i] !== b[i])\n        return false;\n    }\n    return true;\n  }\n  return a === b;\n}\nvar each = (obj, fn) => obj.forEach(fn);\nfunction eachProp(obj, fn, ctx) {\n  if (is.arr(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      fn.call(ctx, obj[i], `${i}`);\n    }\n    return;\n  }\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      fn.call(ctx, obj[key], key);\n    }\n  }\n}\nvar toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];\nfunction flush(queue, iterator) {\n  if (queue.size) {\n    const items = Array.from(queue);\n    queue.clear();\n    each(items, iterator);\n  }\n}\nvar flushCalls = (queue, ...args) => flush(queue, (fn) => fn(...args));\nvar isSSR = () => typeof window === \"undefined\" || !window.navigator || /ServerSideRendering|^Deno\\//.test(window.navigator.userAgent);\n\n// src/globals.ts\nvar createStringInterpolator;\nvar to;\nvar colors = null;\nvar skipAnimation = false;\nvar willAdvance = noop;\nvar assign = (globals) => {\n  if (globals.to)\n    to = globals.to;\n  if (globals.now)\n    _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf.now = globals.now;\n  if (globals.colors !== void 0)\n    colors = globals.colors;\n  if (globals.skipAnimation != null)\n    skipAnimation = globals.skipAnimation;\n  if (globals.createStringInterpolator)\n    createStringInterpolator = globals.createStringInterpolator;\n  if (globals.requestAnimationFrame)\n    _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf.use(globals.requestAnimationFrame);\n  if (globals.batchedUpdates)\n    _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf.batchedUpdates = globals.batchedUpdates;\n  if (globals.willAdvance)\n    willAdvance = globals.willAdvance;\n  if (globals.frameLoop)\n    _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf.frameLoop = globals.frameLoop;\n};\n\n// src/FrameLoop.ts\n\nvar startQueue = /* @__PURE__ */ new Set();\nvar currentFrame = [];\nvar prevFrame = [];\nvar priority = 0;\nvar frameLoop = {\n  get idle() {\n    return !startQueue.size && !currentFrame.length;\n  },\n  /** Advance the given animation on every frame until idle. */\n  start(animation) {\n    if (priority > animation.priority) {\n      startQueue.add(animation);\n      _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf.onStart(flushStartQueue);\n    } else {\n      startSafely(animation);\n      (0,_react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf)(advance);\n    }\n  },\n  /** Advance all animations by the given time. */\n  advance,\n  /** Call this when an animation's priority changes. */\n  sort(animation) {\n    if (priority) {\n      _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf.onFrame(() => frameLoop.sort(animation));\n    } else {\n      const prevIndex = currentFrame.indexOf(animation);\n      if (~prevIndex) {\n        currentFrame.splice(prevIndex, 1);\n        startUnsafely(animation);\n      }\n    }\n  },\n  /**\n   * Clear all animations. For testing purposes.\n   *\n   * ☠️ Never call this from within the frameloop.\n   */\n  clear() {\n    currentFrame = [];\n    startQueue.clear();\n  }\n};\nfunction flushStartQueue() {\n  startQueue.forEach(startSafely);\n  startQueue.clear();\n  (0,_react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf)(advance);\n}\nfunction startSafely(animation) {\n  if (!currentFrame.includes(animation))\n    startUnsafely(animation);\n}\nfunction startUnsafely(animation) {\n  currentFrame.splice(\n    findIndex(currentFrame, (other) => other.priority > animation.priority),\n    0,\n    animation\n  );\n}\nfunction advance(dt) {\n  const nextFrame = prevFrame;\n  for (let i = 0; i < currentFrame.length; i++) {\n    const animation = currentFrame[i];\n    priority = animation.priority;\n    if (!animation.idle) {\n      willAdvance(animation);\n      animation.advance(dt);\n      if (!animation.idle) {\n        nextFrame.push(animation);\n      }\n    }\n  }\n  priority = 0;\n  prevFrame = currentFrame;\n  prevFrame.length = 0;\n  currentFrame = nextFrame;\n  return currentFrame.length > 0;\n}\nfunction findIndex(arr, test) {\n  const index = arr.findIndex(test);\n  return index < 0 ? arr.length : index;\n}\n\n// src/clamp.ts\nvar clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\n// src/colors.ts\nvar colors2 = {\n  transparent: 0,\n  aliceblue: 4042850303,\n  antiquewhite: 4209760255,\n  aqua: 16777215,\n  aquamarine: 2147472639,\n  azure: 4043309055,\n  beige: 4126530815,\n  bisque: 4293182719,\n  black: 255,\n  blanchedalmond: 4293643775,\n  blue: 65535,\n  blueviolet: 2318131967,\n  brown: 2771004159,\n  burlywood: 3736635391,\n  burntsienna: 3934150143,\n  cadetblue: 1604231423,\n  chartreuse: 2147418367,\n  chocolate: 3530104575,\n  coral: 4286533887,\n  cornflowerblue: 1687547391,\n  cornsilk: 4294499583,\n  crimson: 3692313855,\n  cyan: 16777215,\n  darkblue: 35839,\n  darkcyan: 9145343,\n  darkgoldenrod: 3095792639,\n  darkgray: 2846468607,\n  darkgreen: 6553855,\n  darkgrey: 2846468607,\n  darkkhaki: 3182914559,\n  darkmagenta: 2332068863,\n  darkolivegreen: 1433087999,\n  darkorange: 4287365375,\n  darkorchid: 2570243327,\n  darkred: 2332033279,\n  darksalmon: 3918953215,\n  darkseagreen: 2411499519,\n  darkslateblue: 1211993087,\n  darkslategray: 793726975,\n  darkslategrey: 793726975,\n  darkturquoise: 13554175,\n  darkviolet: 2483082239,\n  deeppink: 4279538687,\n  deepskyblue: 12582911,\n  dimgray: 1768516095,\n  dimgrey: 1768516095,\n  dodgerblue: 512819199,\n  firebrick: 2988581631,\n  floralwhite: 4294635775,\n  forestgreen: 579543807,\n  fuchsia: 4278255615,\n  gainsboro: 3705462015,\n  ghostwhite: 4177068031,\n  gold: 4292280575,\n  goldenrod: 3668254975,\n  gray: 2155905279,\n  green: 8388863,\n  greenyellow: 2919182335,\n  grey: 2155905279,\n  honeydew: 4043305215,\n  hotpink: 4285117695,\n  indianred: 3445382399,\n  indigo: 1258324735,\n  ivory: 4294963455,\n  khaki: 4041641215,\n  lavender: 3873897215,\n  lavenderblush: 4293981695,\n  lawngreen: 2096890111,\n  lemonchiffon: 4294626815,\n  lightblue: 2916673279,\n  lightcoral: 4034953471,\n  lightcyan: 3774873599,\n  lightgoldenrodyellow: 4210742015,\n  lightgray: 3553874943,\n  lightgreen: 2431553791,\n  lightgrey: 3553874943,\n  lightpink: 4290167295,\n  lightsalmon: 4288707327,\n  lightseagreen: 548580095,\n  lightskyblue: 2278488831,\n  lightslategray: 2005441023,\n  lightslategrey: 2005441023,\n  lightsteelblue: 2965692159,\n  lightyellow: 4294959359,\n  lime: 16711935,\n  limegreen: 852308735,\n  linen: 4210091775,\n  magenta: 4278255615,\n  maroon: 2147483903,\n  mediumaquamarine: 1724754687,\n  mediumblue: 52735,\n  mediumorchid: 3126187007,\n  mediumpurple: 2473647103,\n  mediumseagreen: 1018393087,\n  mediumslateblue: 2070474495,\n  mediumspringgreen: 16423679,\n  mediumturquoise: 1221709055,\n  mediumvioletred: 3340076543,\n  midnightblue: 421097727,\n  mintcream: 4127193855,\n  mistyrose: 4293190143,\n  moccasin: 4293178879,\n  navajowhite: 4292783615,\n  navy: 33023,\n  oldlace: 4260751103,\n  olive: 2155872511,\n  olivedrab: 1804477439,\n  orange: 4289003775,\n  orangered: 4282712319,\n  orchid: 3664828159,\n  palegoldenrod: 4008225535,\n  palegreen: 2566625535,\n  paleturquoise: 2951671551,\n  palevioletred: 3681588223,\n  papayawhip: 4293907967,\n  peachpuff: 4292524543,\n  peru: 3448061951,\n  pink: 4290825215,\n  plum: 3718307327,\n  powderblue: 2967529215,\n  purple: 2147516671,\n  rebeccapurple: 1714657791,\n  red: 4278190335,\n  rosybrown: 3163525119,\n  royalblue: 1097458175,\n  saddlebrown: 2336560127,\n  salmon: 4202722047,\n  sandybrown: 4104413439,\n  seagreen: 780883967,\n  seashell: 4294307583,\n  sienna: 2689740287,\n  silver: 3233857791,\n  skyblue: 2278484991,\n  slateblue: 1784335871,\n  slategray: 1887473919,\n  slategrey: 1887473919,\n  snow: 4294638335,\n  springgreen: 16744447,\n  steelblue: 1182971135,\n  tan: 3535047935,\n  teal: 8421631,\n  thistle: 3636451583,\n  tomato: 4284696575,\n  turquoise: 1088475391,\n  violet: 4001558271,\n  wheat: 4125012991,\n  white: 4294967295,\n  whitesmoke: 4126537215,\n  yellow: 4294902015,\n  yellowgreen: 2597139199\n};\n\n// src/colorMatchers.ts\nvar NUMBER = \"[-+]?\\\\d*\\\\.?\\\\d+\";\nvar PERCENTAGE = NUMBER + \"%\";\nfunction call(...parts) {\n  return \"\\\\(\\\\s*(\" + parts.join(\")\\\\s*,\\\\s*(\") + \")\\\\s*\\\\)\";\n}\nvar rgb = new RegExp(\"rgb\" + call(NUMBER, NUMBER, NUMBER));\nvar rgba = new RegExp(\"rgba\" + call(NUMBER, NUMBER, NUMBER, NUMBER));\nvar hsl = new RegExp(\"hsl\" + call(NUMBER, PERCENTAGE, PERCENTAGE));\nvar hsla = new RegExp(\n  \"hsla\" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)\n);\nvar hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\nvar hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\nvar hex6 = /^#([0-9a-fA-F]{6})$/;\nvar hex8 = /^#([0-9a-fA-F]{8})$/;\n\n// src/normalizeColor.ts\nfunction normalizeColor(color) {\n  let match;\n  if (typeof color === \"number\") {\n    return color >>> 0 === color && color >= 0 && color <= 4294967295 ? color : null;\n  }\n  if (match = hex6.exec(color))\n    return parseInt(match[1] + \"ff\", 16) >>> 0;\n  if (colors && colors[color] !== void 0) {\n    return colors[color];\n  }\n  if (match = rgb.exec(color)) {\n    return (parse255(match[1]) << 24 | // r\n    parse255(match[2]) << 16 | // g\n    parse255(match[3]) << 8 | // b\n    255) >>> // a\n    0;\n  }\n  if (match = rgba.exec(color)) {\n    return (parse255(match[1]) << 24 | // r\n    parse255(match[2]) << 16 | // g\n    parse255(match[3]) << 8 | // b\n    parse1(match[4])) >>> // a\n    0;\n  }\n  if (match = hex3.exec(color)) {\n    return parseInt(\n      match[1] + match[1] + // r\n      match[2] + match[2] + // g\n      match[3] + match[3] + // b\n      \"ff\",\n      // a\n      16\n    ) >>> 0;\n  }\n  if (match = hex8.exec(color))\n    return parseInt(match[1], 16) >>> 0;\n  if (match = hex4.exec(color)) {\n    return parseInt(\n      match[1] + match[1] + // r\n      match[2] + match[2] + // g\n      match[3] + match[3] + // b\n      match[4] + match[4],\n      // a\n      16\n    ) >>> 0;\n  }\n  if (match = hsl.exec(color)) {\n    return (hslToRgb(\n      parse360(match[1]),\n      // h\n      parsePercentage(match[2]),\n      // s\n      parsePercentage(match[3])\n      // l\n    ) | 255) >>> // a\n    0;\n  }\n  if (match = hsla.exec(color)) {\n    return (hslToRgb(\n      parse360(match[1]),\n      // h\n      parsePercentage(match[2]),\n      // s\n      parsePercentage(match[3])\n      // l\n    ) | parse1(match[4])) >>> // a\n    0;\n  }\n  return null;\n}\nfunction hue2rgb(p, q, t) {\n  if (t < 0)\n    t += 1;\n  if (t > 1)\n    t -= 1;\n  if (t < 1 / 6)\n    return p + (q - p) * 6 * t;\n  if (t < 1 / 2)\n    return q;\n  if (t < 2 / 3)\n    return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\nfunction hslToRgb(h, s, l) {\n  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n  const p = 2 * l - q;\n  const r = hue2rgb(p, q, h + 1 / 3);\n  const g = hue2rgb(p, q, h);\n  const b = hue2rgb(p, q, h - 1 / 3);\n  return Math.round(r * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;\n}\nfunction parse255(str) {\n  const int = parseInt(str, 10);\n  if (int < 0)\n    return 0;\n  if (int > 255)\n    return 255;\n  return int;\n}\nfunction parse360(str) {\n  const int = parseFloat(str);\n  return (int % 360 + 360) % 360 / 360;\n}\nfunction parse1(str) {\n  const num = parseFloat(str);\n  if (num < 0)\n    return 0;\n  if (num > 1)\n    return 255;\n  return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n  const int = parseFloat(str);\n  if (int < 0)\n    return 0;\n  if (int > 100)\n    return 1;\n  return int / 100;\n}\n\n// src/colorToRgba.ts\nfunction colorToRgba(input) {\n  let int32Color = normalizeColor(input);\n  if (int32Color === null)\n    return input;\n  int32Color = int32Color || 0;\n  const r = (int32Color & 4278190080) >>> 24;\n  const g = (int32Color & 16711680) >>> 16;\n  const b = (int32Color & 65280) >>> 8;\n  const a = (int32Color & 255) / 255;\n  return `rgba(${r}, ${g}, ${b}, ${a})`;\n}\n\n// src/createInterpolator.ts\nvar createInterpolator = (range, output, extrapolate) => {\n  if (is.fun(range)) {\n    return range;\n  }\n  if (is.arr(range)) {\n    return createInterpolator({\n      range,\n      output,\n      extrapolate\n    });\n  }\n  if (is.str(range.output[0])) {\n    return createStringInterpolator(range);\n  }\n  const config = range;\n  const outputRange = config.output;\n  const inputRange = config.range || [0, 1];\n  const extrapolateLeft = config.extrapolateLeft || config.extrapolate || \"extend\";\n  const extrapolateRight = config.extrapolateRight || config.extrapolate || \"extend\";\n  const easing = config.easing || ((t) => t);\n  return (input) => {\n    const range2 = findRange(input, inputRange);\n    return interpolate(\n      input,\n      inputRange[range2],\n      inputRange[range2 + 1],\n      outputRange[range2],\n      outputRange[range2 + 1],\n      easing,\n      extrapolateLeft,\n      extrapolateRight,\n      config.map\n    );\n  };\n};\nfunction interpolate(input, inputMin, inputMax, outputMin, outputMax, easing, extrapolateLeft, extrapolateRight, map) {\n  let result = map ? map(input) : input;\n  if (result < inputMin) {\n    if (extrapolateLeft === \"identity\")\n      return result;\n    else if (extrapolateLeft === \"clamp\")\n      result = inputMin;\n  }\n  if (result > inputMax) {\n    if (extrapolateRight === \"identity\")\n      return result;\n    else if (extrapolateRight === \"clamp\")\n      result = inputMax;\n  }\n  if (outputMin === outputMax)\n    return outputMin;\n  if (inputMin === inputMax)\n    return input <= inputMin ? outputMin : outputMax;\n  if (inputMin === -Infinity)\n    result = -result;\n  else if (inputMax === Infinity)\n    result = result - inputMin;\n  else\n    result = (result - inputMin) / (inputMax - inputMin);\n  result = easing(result);\n  if (outputMin === -Infinity)\n    result = -result;\n  else if (outputMax === Infinity)\n    result = result + outputMin;\n  else\n    result = result * (outputMax - outputMin) + outputMin;\n  return result;\n}\nfunction findRange(input, inputRange) {\n  for (var i = 1; i < inputRange.length - 1; ++i)\n    if (inputRange[i] >= input)\n      break;\n  return i - 1;\n}\n\n// src/easings.ts\nvar steps = (steps2, direction = \"end\") => (progress2) => {\n  progress2 = direction === \"end\" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);\n  const expanded = progress2 * steps2;\n  const rounded = direction === \"end\" ? Math.floor(expanded) : Math.ceil(expanded);\n  return clamp(0, 1, rounded / steps2);\n};\nvar c1 = 1.70158;\nvar c2 = c1 * 1.525;\nvar c3 = c1 + 1;\nvar c4 = 2 * Math.PI / 3;\nvar c5 = 2 * Math.PI / 4.5;\nvar bounceOut = (x) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984375;\n  }\n};\nvar easings = {\n  linear: (x) => x,\n  easeInQuad: (x) => x * x,\n  easeOutQuad: (x) => 1 - (1 - x) * (1 - x),\n  easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,\n  easeInCubic: (x) => x * x * x,\n  easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),\n  easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,\n  easeInQuart: (x) => x * x * x * x,\n  easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),\n  easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,\n  easeInQuint: (x) => x * x * x * x * x,\n  easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),\n  easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,\n  easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),\n  easeOutSine: (x) => Math.sin(x * Math.PI / 2),\n  easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,\n  easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),\n  easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),\n  easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,\n  easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),\n  easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),\n  easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,\n  easeInBack: (x) => c3 * x * x * x - c1 * x * x,\n  easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),\n  easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,\n  easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),\n  easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,\n  easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,\n  easeInBounce: (x) => 1 - bounceOut(1 - x),\n  easeOutBounce: bounceOut,\n  easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,\n  steps\n};\n\n// src/fluids.ts\nvar $get = Symbol.for(\"FluidValue.get\");\nvar $observers = Symbol.for(\"FluidValue.observers\");\nvar hasFluidValue = (arg) => Boolean(arg && arg[$get]);\nvar getFluidValue = (arg) => arg && arg[$get] ? arg[$get]() : arg;\nvar getFluidObservers = (target) => target[$observers] || null;\nfunction callFluidObserver(observer2, event) {\n  if (observer2.eventObserved) {\n    observer2.eventObserved(event);\n  } else {\n    observer2(event);\n  }\n}\nfunction callFluidObservers(target, event) {\n  const observers = target[$observers];\n  if (observers) {\n    observers.forEach((observer2) => {\n      callFluidObserver(observer2, event);\n    });\n  }\n}\nvar FluidValue = class {\n  constructor(get) {\n    if (!get && !(get = this.get)) {\n      throw Error(\"Unknown getter\");\n    }\n    setFluidGetter(this, get);\n  }\n};\n$get, $observers;\nvar setFluidGetter = (target, get) => setHidden(target, $get, get);\nfunction addFluidObserver(target, observer2) {\n  if (target[$get]) {\n    let observers = target[$observers];\n    if (!observers) {\n      setHidden(target, $observers, observers = /* @__PURE__ */ new Set());\n    }\n    if (!observers.has(observer2)) {\n      observers.add(observer2);\n      if (target.observerAdded) {\n        target.observerAdded(observers.size, observer2);\n      }\n    }\n  }\n  return observer2;\n}\nfunction removeFluidObserver(target, observer2) {\n  const observers = target[$observers];\n  if (observers && observers.has(observer2)) {\n    const count = observers.size - 1;\n    if (count) {\n      observers.delete(observer2);\n    } else {\n      target[$observers] = null;\n    }\n    if (target.observerRemoved) {\n      target.observerRemoved(count, observer2);\n    }\n  }\n}\nvar setHidden = (target, key, value) => Object.defineProperty(target, key, {\n  value,\n  writable: true,\n  configurable: true\n});\n\n// src/regexs.ts\nvar numberRegex = /[+\\-]?(?:0|[1-9]\\d*)(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\\((-?\\d+%?[,\\s]+){2,3}\\s*[\\d\\.]+%?\\))/gi;\nvar unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, \"i\");\nvar rgbaRegex = /rgba\\(([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+), ([0-9\\.-]+)\\)/gi;\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\n\n// src/variableToRgba.ts\nvar variableToRgba = (input) => {\n  const [token, fallback] = parseCSSVariable(input);\n  if (!token || isSSR()) {\n    return input;\n  }\n  const value = window.getComputedStyle(document.documentElement).getPropertyValue(token);\n  if (value) {\n    return value.trim();\n  } else if (fallback && fallback.startsWith(\"--\")) {\n    const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);\n    if (value2) {\n      return value2;\n    } else {\n      return input;\n    }\n  } else if (fallback && cssVariableRegex.test(fallback)) {\n    return variableToRgba(fallback);\n  } else if (fallback) {\n    return fallback;\n  }\n  return input;\n};\nvar parseCSSVariable = (current) => {\n  const match = cssVariableRegex.exec(current);\n  if (!match)\n    return [,];\n  const [, token, fallback] = match;\n  return [token, fallback];\n};\n\n// src/stringInterpolation.ts\nvar namedColorRegex;\nvar rgbaRound = (_, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;\nvar createStringInterpolator2 = (config) => {\n  if (!namedColorRegex)\n    namedColorRegex = colors ? (\n      // match color names, ignore partial matches\n      new RegExp(`(${Object.keys(colors).join(\"|\")})(?!\\\\w)`, \"g\")\n    ) : (\n      // never match\n      /^\\b$/\n    );\n  const output = config.output.map((value) => {\n    return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);\n  });\n  const keyframes = output.map((value) => value.match(numberRegex).map(Number));\n  const outputRanges = keyframes[0].map(\n    (_, i) => keyframes.map((values) => {\n      if (!(i in values)) {\n        throw Error('The arity of each \"output\" value must be equal');\n      }\n      return values[i];\n    })\n  );\n  const interpolators = outputRanges.map(\n    (output2) => createInterpolator({ ...config, output: output2 })\n  );\n  return (input) => {\n    const missingUnit = !unitRegex.test(output[0]) && output.find((value) => unitRegex.test(value))?.replace(numberRegex, \"\");\n    let i = 0;\n    return output[0].replace(\n      numberRegex,\n      () => `${interpolators[i++](input)}${missingUnit || \"\"}`\n    ).replace(rgbaRegex, rgbaRound);\n  };\n};\n\n// src/deprecations.ts\nvar prefix = \"react-spring: \";\nvar once = (fn) => {\n  const func = fn;\n  let called = false;\n  if (typeof func != \"function\") {\n    throw new TypeError(`${prefix}once requires a function parameter`);\n  }\n  return (...args) => {\n    if (!called) {\n      func(...args);\n      called = true;\n    }\n  };\n};\nvar warnInterpolate = once(console.warn);\nfunction deprecateInterpolate() {\n  warnInterpolate(\n    `${prefix}The \"interpolate\" function is deprecated in v9 (use \"to\" instead)`\n  );\n}\nvar warnDirectCall = once(console.warn);\nfunction deprecateDirectCall() {\n  warnDirectCall(\n    `${prefix}Directly calling start instead of using the api object is deprecated in v9 (use \".start\" instead), this will be removed in later 0.X.0 versions`\n  );\n}\n\n// src/isAnimatedString.ts\nfunction isAnimatedString(value) {\n  return is.str(value) && (value[0] == \"#\" || /\\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR\n  !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));\n}\n\n// src/dom-events/scroll/index.ts\n\n\n// src/dom-events/resize/resizeElement.ts\nvar observer;\nvar resizeHandlers = /* @__PURE__ */ new WeakMap();\nvar handleObservation = (entries) => entries.forEach(({ target, contentRect }) => {\n  return resizeHandlers.get(target)?.forEach((handler) => handler(contentRect));\n});\nfunction resizeElement(handler, target) {\n  if (!observer) {\n    if (typeof ResizeObserver !== \"undefined\") {\n      observer = new ResizeObserver(handleObservation);\n    }\n  }\n  let elementHandlers = resizeHandlers.get(target);\n  if (!elementHandlers) {\n    elementHandlers = /* @__PURE__ */ new Set();\n    resizeHandlers.set(target, elementHandlers);\n  }\n  elementHandlers.add(handler);\n  if (observer) {\n    observer.observe(target);\n  }\n  return () => {\n    const elementHandlers2 = resizeHandlers.get(target);\n    if (!elementHandlers2)\n      return;\n    elementHandlers2.delete(handler);\n    if (!elementHandlers2.size && observer) {\n      observer.unobserve(target);\n    }\n  };\n}\n\n// src/dom-events/resize/resizeWindow.ts\nvar listeners = /* @__PURE__ */ new Set();\nvar cleanupWindowResizeHandler;\nvar createResizeHandler = () => {\n  const handleResize = () => {\n    listeners.forEach(\n      (callback) => callback({\n        width: window.innerWidth,\n        height: window.innerHeight\n      })\n    );\n  };\n  window.addEventListener(\"resize\", handleResize);\n  return () => {\n    window.removeEventListener(\"resize\", handleResize);\n  };\n};\nvar resizeWindow = (callback) => {\n  listeners.add(callback);\n  if (!cleanupWindowResizeHandler) {\n    cleanupWindowResizeHandler = createResizeHandler();\n  }\n  return () => {\n    listeners.delete(callback);\n    if (!listeners.size && cleanupWindowResizeHandler) {\n      cleanupWindowResizeHandler();\n      cleanupWindowResizeHandler = void 0;\n    }\n  };\n};\n\n// src/dom-events/resize/index.ts\nvar onResize = (callback, { container = document.documentElement } = {}) => {\n  if (container === document.documentElement) {\n    return resizeWindow(callback);\n  } else {\n    return resizeElement(callback, container);\n  }\n};\n\n// src/progress.ts\nvar progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\n// src/dom-events/scroll/ScrollHandler.ts\nvar SCROLL_KEYS = {\n  x: {\n    length: \"Width\",\n    position: \"Left\"\n  },\n  y: {\n    length: \"Height\",\n    position: \"Top\"\n  }\n};\nvar ScrollHandler = class {\n  constructor(callback, container) {\n    this.createAxis = () => ({\n      current: 0,\n      progress: 0,\n      scrollLength: 0\n    });\n    this.updateAxis = (axisName) => {\n      const axis = this.info[axisName];\n      const { length, position } = SCROLL_KEYS[axisName];\n      axis.current = this.container[`scroll${position}`];\n      axis.scrollLength = this.container[`scroll${length}`] - this.container[`client${length}`];\n      axis.progress = progress(0, axis.scrollLength, axis.current);\n    };\n    this.update = () => {\n      this.updateAxis(\"x\");\n      this.updateAxis(\"y\");\n    };\n    this.sendEvent = () => {\n      this.callback(this.info);\n    };\n    this.advance = () => {\n      this.update();\n      this.sendEvent();\n    };\n    this.callback = callback;\n    this.container = container;\n    this.info = {\n      time: 0,\n      x: this.createAxis(),\n      y: this.createAxis()\n    };\n  }\n};\n\n// src/dom-events/scroll/index.ts\nvar scrollListeners = /* @__PURE__ */ new WeakMap();\nvar resizeListeners = /* @__PURE__ */ new WeakMap();\nvar onScrollHandlers = /* @__PURE__ */ new WeakMap();\nvar getTarget = (container) => container === document.documentElement ? window : container;\nvar onScroll = (callback, { container = document.documentElement } = {}) => {\n  let containerHandlers = onScrollHandlers.get(container);\n  if (!containerHandlers) {\n    containerHandlers = /* @__PURE__ */ new Set();\n    onScrollHandlers.set(container, containerHandlers);\n  }\n  const containerHandler = new ScrollHandler(callback, container);\n  containerHandlers.add(containerHandler);\n  if (!scrollListeners.has(container)) {\n    const listener = () => {\n      containerHandlers?.forEach((handler) => handler.advance());\n      return true;\n    };\n    scrollListeners.set(container, listener);\n    const target = getTarget(container);\n    window.addEventListener(\"resize\", listener, { passive: true });\n    if (container !== document.documentElement) {\n      resizeListeners.set(container, onResize(listener, { container }));\n    }\n    target.addEventListener(\"scroll\", listener, { passive: true });\n  }\n  const animateScroll = scrollListeners.get(container);\n  (0,_react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf)(animateScroll);\n  return () => {\n    _react_spring_rafz__WEBPACK_IMPORTED_MODULE_0__.raf.cancel(animateScroll);\n    const containerHandlers2 = onScrollHandlers.get(container);\n    if (!containerHandlers2)\n      return;\n    containerHandlers2.delete(containerHandler);\n    if (containerHandlers2.size)\n      return;\n    const listener = scrollListeners.get(container);\n    scrollListeners.delete(container);\n    if (listener) {\n      getTarget(container).removeEventListener(\"scroll\", listener);\n      window.removeEventListener(\"resize\", listener);\n      resizeListeners.get(container)?.();\n    }\n  };\n};\n\n// src/hooks/useConstant.ts\n\nfunction useConstant(init) {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  if (ref.current === null) {\n    ref.current = init();\n  }\n  return ref.current;\n}\n\n// src/hooks/useForceUpdate.ts\n\n\n// src/hooks/useIsMounted.ts\n\n\n// src/hooks/useIsomorphicLayoutEffect.ts\n\nvar useIsomorphicLayoutEffect = isSSR() ? react__WEBPACK_IMPORTED_MODULE_1__.useEffect : react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect;\n\n// src/hooks/useIsMounted.ts\nvar useIsMounted = () => {\n  const isMounted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n  useIsomorphicLayoutEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n  return isMounted;\n};\n\n// src/hooks/useForceUpdate.ts\nfunction useForceUpdate() {\n  const update = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)()[1];\n  const isMounted = useIsMounted();\n  return () => {\n    if (isMounted.current) {\n      update(Math.random());\n    }\n  };\n}\n\n// src/hooks/useMemoOne.ts\n\nfunction useMemoOne(getResult, inputs) {\n  const [initial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\n    () => ({\n      inputs,\n      result: getResult()\n    })\n  );\n  const committed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  const prevCache = committed.current;\n  let cache = prevCache;\n  if (cache) {\n    const useCache = Boolean(\n      inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)\n    );\n    if (!useCache) {\n      cache = {\n        inputs,\n        result: getResult()\n      };\n    }\n  } else {\n    cache = initial;\n  }\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    committed.current = cache;\n    if (prevCache == initial) {\n      initial.inputs = initial.result = void 0;\n    }\n  }, [cache]);\n  return cache.result;\n}\nfunction areInputsEqual(next, prev) {\n  if (next.length !== prev.length) {\n    return false;\n  }\n  for (let i = 0; i < next.length; i++) {\n    if (next[i] !== prev[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// src/hooks/useOnce.ts\n\nvar useOnce = (effect) => (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(effect, emptyDeps);\nvar emptyDeps = [];\n\n// src/hooks/usePrev.ts\n\nfunction usePrev(value) {\n  const prevRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    prevRef.current = value;\n  });\n  return prevRef.current;\n}\n\n// src/hooks/useReducedMotion.ts\n\nvar useReducedMotion = () => {\n  const [reducedMotion, setReducedMotion] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n  useIsomorphicLayoutEffect(() => {\n    const mql = window.matchMedia(\"(prefers-reduced-motion)\");\n    const handleMediaChange = (e) => {\n      setReducedMotion(e.matches);\n      assign({\n        skipAnimation: e.matches\n      });\n    };\n    handleMediaChange(mql);\n    if (mql.addEventListener) {\n      mql.addEventListener(\"change\", handleMediaChange);\n    } else {\n      mql.addListener(handleMediaChange);\n    }\n    return () => {\n      if (mql.removeEventListener) {\n        mql.removeEventListener(\"change\", handleMediaChange);\n      } else {\n        mql.removeListener(handleMediaChange);\n      }\n    };\n  }, []);\n  return reducedMotion;\n};\n\n// src/index.ts\n\n\n//# sourceMappingURL=react-spring_shared.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3NoYXJlZC9kaXN0L3JlYWN0LXNwcmluZ19zaGFyZWQubW9kZXJuLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ3dDOztBQUV6QztBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsMkNBQTJDO0FBQ3JIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyw4QkFBOEIsRUFBRTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBLElBQUksbURBQUc7QUFDUDtBQUNBO0FBQ0E7QUFDQSxJQUFJLG1EQUFHO0FBQ1A7O0FBRUE7QUFDaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFJO0FBQ1YsTUFBTTtBQUNOO0FBQ0EsTUFBTSx1REFBSTtBQUNWO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLG1EQUFJO0FBQ1YsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsdURBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHlCQUF5QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDN0QsMkJBQTJCLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUU7QUFDN0UsMkJBQTJCLEVBQUU7QUFDN0IsMkJBQTJCLEVBQUU7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ2dEO0FBQ2hELDBCQUEwQixnREFBVTtBQUNwQzs7QUFFQTtBQUNtRTtBQUNuRTtBQUNBLGtCQUFrQiw2Q0FBTztBQUN6QixFQUFFLGdEQUFVO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUM4QztBQUM5QztBQUNBLDRDQUE0QywrQ0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNpRDtBQW9EL0M7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy9zaGFyZWQvZGlzdC9yZWFjdC1zcHJpbmdfc2hhcmVkLm1vZGVybi5tanM/ODY3ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZXhwb3J0ID0gKHRhcmdldCwgYWxsKSA9PiB7XG4gIGZvciAodmFyIG5hbWUgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUsIHsgZ2V0OiBhbGxbbmFtZV0sIGVudW1lcmFibGU6IHRydWUgfSk7XG59O1xuXG4vLyBzcmMvZ2xvYmFscy50c1xudmFyIGdsb2JhbHNfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQoZ2xvYmFsc19leHBvcnRzLCB7XG4gIGFzc2lnbjogKCkgPT4gYXNzaWduLFxuICBjb2xvcnM6ICgpID0+IGNvbG9ycyxcbiAgY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yOiAoKSA9PiBjcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IsXG4gIHNraXBBbmltYXRpb246ICgpID0+IHNraXBBbmltYXRpb24sXG4gIHRvOiAoKSA9PiB0byxcbiAgd2lsbEFkdmFuY2U6ICgpID0+IHdpbGxBZHZhbmNlXG59KTtcbmltcG9ydCB7IHJhZiB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3JhZnpcIjtcblxuLy8gc3JjL2hlbHBlcnMudHNcbmZ1bmN0aW9uIG5vb3AoKSB7XG59XG52YXIgZGVmaW5lSGlkZGVuID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xudmFyIGlzID0ge1xuICBhcnI6IEFycmF5LmlzQXJyYXksXG4gIG9iajogKGEpID0+ICEhYSAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09IFwiT2JqZWN0XCIsXG4gIGZ1bjogKGEpID0+IHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIsXG4gIHN0cjogKGEpID0+IHR5cGVvZiBhID09PSBcInN0cmluZ1wiLFxuICBudW06IChhKSA9PiB0eXBlb2YgYSA9PT0gXCJudW1iZXJcIixcbiAgdW5kOiAoYSkgPT4gYSA9PT0gdm9pZCAwXG59O1xuZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gIGlmIChpcy5hcnIoYSkpIHtcbiAgICBpZiAoIWlzLmFycihiKSB8fCBhLmxlbmd0aCAhPT0gYi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYSA9PT0gYjtcbn1cbnZhciBlYWNoID0gKG9iaiwgZm4pID0+IG9iai5mb3JFYWNoKGZuKTtcbmZ1bmN0aW9uIGVhY2hQcm9wKG9iaiwgZm4sIGN0eCkge1xuICBpZiAoaXMuYXJyKG9iaikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgZm4uY2FsbChjdHgsIG9ialtpXSwgYCR7aX1gKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgZm4uY2FsbChjdHgsIG9ialtrZXldLCBrZXkpO1xuICAgIH1cbiAgfVxufVxudmFyIHRvQXJyYXkgPSAoYSkgPT4gaXMudW5kKGEpID8gW10gOiBpcy5hcnIoYSkgPyBhIDogW2FdO1xuZnVuY3Rpb24gZmx1c2gocXVldWUsIGl0ZXJhdG9yKSB7XG4gIGlmIChxdWV1ZS5zaXplKSB7XG4gICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKHF1ZXVlKTtcbiAgICBxdWV1ZS5jbGVhcigpO1xuICAgIGVhY2goaXRlbXMsIGl0ZXJhdG9yKTtcbiAgfVxufVxudmFyIGZsdXNoQ2FsbHMgPSAocXVldWUsIC4uLmFyZ3MpID0+IGZsdXNoKHF1ZXVlLCAoZm4pID0+IGZuKC4uLmFyZ3MpKTtcbnZhciBpc1NTUiA9ICgpID0+IHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgfHwgIXdpbmRvdy5uYXZpZ2F0b3IgfHwgL1NlcnZlclNpZGVSZW5kZXJpbmd8XkRlbm9cXC8vLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vLyBzcmMvZ2xvYmFscy50c1xudmFyIGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcjtcbnZhciB0bztcbnZhciBjb2xvcnMgPSBudWxsO1xudmFyIHNraXBBbmltYXRpb24gPSBmYWxzZTtcbnZhciB3aWxsQWR2YW5jZSA9IG5vb3A7XG52YXIgYXNzaWduID0gKGdsb2JhbHMpID0+IHtcbiAgaWYgKGdsb2JhbHMudG8pXG4gICAgdG8gPSBnbG9iYWxzLnRvO1xuICBpZiAoZ2xvYmFscy5ub3cpXG4gICAgcmFmLm5vdyA9IGdsb2JhbHMubm93O1xuICBpZiAoZ2xvYmFscy5jb2xvcnMgIT09IHZvaWQgMClcbiAgICBjb2xvcnMgPSBnbG9iYWxzLmNvbG9ycztcbiAgaWYgKGdsb2JhbHMuc2tpcEFuaW1hdGlvbiAhPSBudWxsKVxuICAgIHNraXBBbmltYXRpb24gPSBnbG9iYWxzLnNraXBBbmltYXRpb247XG4gIGlmIChnbG9iYWxzLmNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcilcbiAgICBjcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IgPSBnbG9iYWxzLmNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcjtcbiAgaWYgKGdsb2JhbHMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKVxuICAgIHJhZi51c2UoZ2xvYmFscy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpO1xuICBpZiAoZ2xvYmFscy5iYXRjaGVkVXBkYXRlcylcbiAgICByYWYuYmF0Y2hlZFVwZGF0ZXMgPSBnbG9iYWxzLmJhdGNoZWRVcGRhdGVzO1xuICBpZiAoZ2xvYmFscy53aWxsQWR2YW5jZSlcbiAgICB3aWxsQWR2YW5jZSA9IGdsb2JhbHMud2lsbEFkdmFuY2U7XG4gIGlmIChnbG9iYWxzLmZyYW1lTG9vcClcbiAgICByYWYuZnJhbWVMb29wID0gZ2xvYmFscy5mcmFtZUxvb3A7XG59O1xuXG4vLyBzcmMvRnJhbWVMb29wLnRzXG5pbXBvcnQgeyByYWYgYXMgcmFmMiB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3JhZnpcIjtcbnZhciBzdGFydFF1ZXVlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBjdXJyZW50RnJhbWUgPSBbXTtcbnZhciBwcmV2RnJhbWUgPSBbXTtcbnZhciBwcmlvcml0eSA9IDA7XG52YXIgZnJhbWVMb29wID0ge1xuICBnZXQgaWRsZSgpIHtcbiAgICByZXR1cm4gIXN0YXJ0UXVldWUuc2l6ZSAmJiAhY3VycmVudEZyYW1lLmxlbmd0aDtcbiAgfSxcbiAgLyoqIEFkdmFuY2UgdGhlIGdpdmVuIGFuaW1hdGlvbiBvbiBldmVyeSBmcmFtZSB1bnRpbCBpZGxlLiAqL1xuICBzdGFydChhbmltYXRpb24pIHtcbiAgICBpZiAocHJpb3JpdHkgPiBhbmltYXRpb24ucHJpb3JpdHkpIHtcbiAgICAgIHN0YXJ0UXVldWUuYWRkKGFuaW1hdGlvbik7XG4gICAgICByYWYyLm9uU3RhcnQoZmx1c2hTdGFydFF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRTYWZlbHkoYW5pbWF0aW9uKTtcbiAgICAgIHJhZjIoYWR2YW5jZSk7XG4gICAgfVxuICB9LFxuICAvKiogQWR2YW5jZSBhbGwgYW5pbWF0aW9ucyBieSB0aGUgZ2l2ZW4gdGltZS4gKi9cbiAgYWR2YW5jZSxcbiAgLyoqIENhbGwgdGhpcyB3aGVuIGFuIGFuaW1hdGlvbidzIHByaW9yaXR5IGNoYW5nZXMuICovXG4gIHNvcnQoYW5pbWF0aW9uKSB7XG4gICAgaWYgKHByaW9yaXR5KSB7XG4gICAgICByYWYyLm9uRnJhbWUoKCkgPT4gZnJhbWVMb29wLnNvcnQoYW5pbWF0aW9uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHByZXZJbmRleCA9IGN1cnJlbnRGcmFtZS5pbmRleE9mKGFuaW1hdGlvbik7XG4gICAgICBpZiAofnByZXZJbmRleCkge1xuICAgICAgICBjdXJyZW50RnJhbWUuc3BsaWNlKHByZXZJbmRleCwgMSk7XG4gICAgICAgIHN0YXJ0VW5zYWZlbHkoYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBDbGVhciBhbGwgYW5pbWF0aW9ucy4gRm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAqXG4gICAqIOKYoO+4jyBOZXZlciBjYWxsIHRoaXMgZnJvbSB3aXRoaW4gdGhlIGZyYW1lbG9vcC5cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIGN1cnJlbnRGcmFtZSA9IFtdO1xuICAgIHN0YXJ0UXVldWUuY2xlYXIoKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGZsdXNoU3RhcnRRdWV1ZSgpIHtcbiAgc3RhcnRRdWV1ZS5mb3JFYWNoKHN0YXJ0U2FmZWx5KTtcbiAgc3RhcnRRdWV1ZS5jbGVhcigpO1xuICByYWYyKGFkdmFuY2UpO1xufVxuZnVuY3Rpb24gc3RhcnRTYWZlbHkoYW5pbWF0aW9uKSB7XG4gIGlmICghY3VycmVudEZyYW1lLmluY2x1ZGVzKGFuaW1hdGlvbikpXG4gICAgc3RhcnRVbnNhZmVseShhbmltYXRpb24pO1xufVxuZnVuY3Rpb24gc3RhcnRVbnNhZmVseShhbmltYXRpb24pIHtcbiAgY3VycmVudEZyYW1lLnNwbGljZShcbiAgICBmaW5kSW5kZXgoY3VycmVudEZyYW1lLCAob3RoZXIpID0+IG90aGVyLnByaW9yaXR5ID4gYW5pbWF0aW9uLnByaW9yaXR5KSxcbiAgICAwLFxuICAgIGFuaW1hdGlvblxuICApO1xufVxuZnVuY3Rpb24gYWR2YW5jZShkdCkge1xuICBjb25zdCBuZXh0RnJhbWUgPSBwcmV2RnJhbWU7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY3VycmVudEZyYW1lLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gY3VycmVudEZyYW1lW2ldO1xuICAgIHByaW9yaXR5ID0gYW5pbWF0aW9uLnByaW9yaXR5O1xuICAgIGlmICghYW5pbWF0aW9uLmlkbGUpIHtcbiAgICAgIHdpbGxBZHZhbmNlKGFuaW1hdGlvbik7XG4gICAgICBhbmltYXRpb24uYWR2YW5jZShkdCk7XG4gICAgICBpZiAoIWFuaW1hdGlvbi5pZGxlKSB7XG4gICAgICAgIG5leHRGcmFtZS5wdXNoKGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHByaW9yaXR5ID0gMDtcbiAgcHJldkZyYW1lID0gY3VycmVudEZyYW1lO1xuICBwcmV2RnJhbWUubGVuZ3RoID0gMDtcbiAgY3VycmVudEZyYW1lID0gbmV4dEZyYW1lO1xuICByZXR1cm4gY3VycmVudEZyYW1lLmxlbmd0aCA+IDA7XG59XG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCB0ZXN0KSB7XG4gIGNvbnN0IGluZGV4ID0gYXJyLmZpbmRJbmRleCh0ZXN0KTtcbiAgcmV0dXJuIGluZGV4IDwgMCA/IGFyci5sZW5ndGggOiBpbmRleDtcbn1cblxuLy8gc3JjL2NsYW1wLnRzXG52YXIgY2xhbXAgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG5cbi8vIHNyYy9jb2xvcnMudHNcbnZhciBjb2xvcnMyID0ge1xuICB0cmFuc3BhcmVudDogMCxcbiAgYWxpY2VibHVlOiA0MDQyODUwMzAzLFxuICBhbnRpcXVld2hpdGU6IDQyMDk3NjAyNTUsXG4gIGFxdWE6IDE2Nzc3MjE1LFxuICBhcXVhbWFyaW5lOiAyMTQ3NDcyNjM5LFxuICBhenVyZTogNDA0MzMwOTA1NSxcbiAgYmVpZ2U6IDQxMjY1MzA4MTUsXG4gIGJpc3F1ZTogNDI5MzE4MjcxOSxcbiAgYmxhY2s6IDI1NSxcbiAgYmxhbmNoZWRhbG1vbmQ6IDQyOTM2NDM3NzUsXG4gIGJsdWU6IDY1NTM1LFxuICBibHVldmlvbGV0OiAyMzE4MTMxOTY3LFxuICBicm93bjogMjc3MTAwNDE1OSxcbiAgYnVybHl3b29kOiAzNzM2NjM1MzkxLFxuICBidXJudHNpZW5uYTogMzkzNDE1MDE0MyxcbiAgY2FkZXRibHVlOiAxNjA0MjMxNDIzLFxuICBjaGFydHJldXNlOiAyMTQ3NDE4MzY3LFxuICBjaG9jb2xhdGU6IDM1MzAxMDQ1NzUsXG4gIGNvcmFsOiA0Mjg2NTMzODg3LFxuICBjb3JuZmxvd2VyYmx1ZTogMTY4NzU0NzM5MSxcbiAgY29ybnNpbGs6IDQyOTQ0OTk1ODMsXG4gIGNyaW1zb246IDM2OTIzMTM4NTUsXG4gIGN5YW46IDE2Nzc3MjE1LFxuICBkYXJrYmx1ZTogMzU4MzksXG4gIGRhcmtjeWFuOiA5MTQ1MzQzLFxuICBkYXJrZ29sZGVucm9kOiAzMDk1NzkyNjM5LFxuICBkYXJrZ3JheTogMjg0NjQ2ODYwNyxcbiAgZGFya2dyZWVuOiA2NTUzODU1LFxuICBkYXJrZ3JleTogMjg0NjQ2ODYwNyxcbiAgZGFya2toYWtpOiAzMTgyOTE0NTU5LFxuICBkYXJrbWFnZW50YTogMjMzMjA2ODg2MyxcbiAgZGFya29saXZlZ3JlZW46IDE0MzMwODc5OTksXG4gIGRhcmtvcmFuZ2U6IDQyODczNjUzNzUsXG4gIGRhcmtvcmNoaWQ6IDI1NzAyNDMzMjcsXG4gIGRhcmtyZWQ6IDIzMzIwMzMyNzksXG4gIGRhcmtzYWxtb246IDM5MTg5NTMyMTUsXG4gIGRhcmtzZWFncmVlbjogMjQxMTQ5OTUxOSxcbiAgZGFya3NsYXRlYmx1ZTogMTIxMTk5MzA4NyxcbiAgZGFya3NsYXRlZ3JheTogNzkzNzI2OTc1LFxuICBkYXJrc2xhdGVncmV5OiA3OTM3MjY5NzUsXG4gIGRhcmt0dXJxdW9pc2U6IDEzNTU0MTc1LFxuICBkYXJrdmlvbGV0OiAyNDgzMDgyMjM5LFxuICBkZWVwcGluazogNDI3OTUzODY4NyxcbiAgZGVlcHNreWJsdWU6IDEyNTgyOTExLFxuICBkaW1ncmF5OiAxNzY4NTE2MDk1LFxuICBkaW1ncmV5OiAxNzY4NTE2MDk1LFxuICBkb2RnZXJibHVlOiA1MTI4MTkxOTksXG4gIGZpcmVicmljazogMjk4ODU4MTYzMSxcbiAgZmxvcmFsd2hpdGU6IDQyOTQ2MzU3NzUsXG4gIGZvcmVzdGdyZWVuOiA1Nzk1NDM4MDcsXG4gIGZ1Y2hzaWE6IDQyNzgyNTU2MTUsXG4gIGdhaW5zYm9ybzogMzcwNTQ2MjAxNSxcbiAgZ2hvc3R3aGl0ZTogNDE3NzA2ODAzMSxcbiAgZ29sZDogNDI5MjI4MDU3NSxcbiAgZ29sZGVucm9kOiAzNjY4MjU0OTc1LFxuICBncmF5OiAyMTU1OTA1Mjc5LFxuICBncmVlbjogODM4ODg2MyxcbiAgZ3JlZW55ZWxsb3c6IDI5MTkxODIzMzUsXG4gIGdyZXk6IDIxNTU5MDUyNzksXG4gIGhvbmV5ZGV3OiA0MDQzMzA1MjE1LFxuICBob3RwaW5rOiA0Mjg1MTE3Njk1LFxuICBpbmRpYW5yZWQ6IDM0NDUzODIzOTksXG4gIGluZGlnbzogMTI1ODMyNDczNSxcbiAgaXZvcnk6IDQyOTQ5NjM0NTUsXG4gIGtoYWtpOiA0MDQxNjQxMjE1LFxuICBsYXZlbmRlcjogMzg3Mzg5NzIxNSxcbiAgbGF2ZW5kZXJibHVzaDogNDI5Mzk4MTY5NSxcbiAgbGF3bmdyZWVuOiAyMDk2ODkwMTExLFxuICBsZW1vbmNoaWZmb246IDQyOTQ2MjY4MTUsXG4gIGxpZ2h0Ymx1ZTogMjkxNjY3MzI3OSxcbiAgbGlnaHRjb3JhbDogNDAzNDk1MzQ3MSxcbiAgbGlnaHRjeWFuOiAzNzc0ODczNTk5LFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogNDIxMDc0MjAxNSxcbiAgbGlnaHRncmF5OiAzNTUzODc0OTQzLFxuICBsaWdodGdyZWVuOiAyNDMxNTUzNzkxLFxuICBsaWdodGdyZXk6IDM1NTM4NzQ5NDMsXG4gIGxpZ2h0cGluazogNDI5MDE2NzI5NSxcbiAgbGlnaHRzYWxtb246IDQyODg3MDczMjcsXG4gIGxpZ2h0c2VhZ3JlZW46IDU0ODU4MDA5NSxcbiAgbGlnaHRza3libHVlOiAyMjc4NDg4ODMxLFxuICBsaWdodHNsYXRlZ3JheTogMjAwNTQ0MTAyMyxcbiAgbGlnaHRzbGF0ZWdyZXk6IDIwMDU0NDEwMjMsXG4gIGxpZ2h0c3RlZWxibHVlOiAyOTY1NjkyMTU5LFxuICBsaWdodHllbGxvdzogNDI5NDk1OTM1OSxcbiAgbGltZTogMTY3MTE5MzUsXG4gIGxpbWVncmVlbjogODUyMzA4NzM1LFxuICBsaW5lbjogNDIxMDA5MTc3NSxcbiAgbWFnZW50YTogNDI3ODI1NTYxNSxcbiAgbWFyb29uOiAyMTQ3NDgzOTAzLFxuICBtZWRpdW1hcXVhbWFyaW5lOiAxNzI0NzU0Njg3LFxuICBtZWRpdW1ibHVlOiA1MjczNSxcbiAgbWVkaXVtb3JjaGlkOiAzMTI2MTg3MDA3LFxuICBtZWRpdW1wdXJwbGU6IDI0NzM2NDcxMDMsXG4gIG1lZGl1bXNlYWdyZWVuOiAxMDE4MzkzMDg3LFxuICBtZWRpdW1zbGF0ZWJsdWU6IDIwNzA0NzQ0OTUsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiAxNjQyMzY3OSxcbiAgbWVkaXVtdHVycXVvaXNlOiAxMjIxNzA5MDU1LFxuICBtZWRpdW12aW9sZXRyZWQ6IDMzNDAwNzY1NDMsXG4gIG1pZG5pZ2h0Ymx1ZTogNDIxMDk3NzI3LFxuICBtaW50Y3JlYW06IDQxMjcxOTM4NTUsXG4gIG1pc3R5cm9zZTogNDI5MzE5MDE0MyxcbiAgbW9jY2FzaW46IDQyOTMxNzg4NzksXG4gIG5hdmFqb3doaXRlOiA0MjkyNzgzNjE1LFxuICBuYXZ5OiAzMzAyMyxcbiAgb2xkbGFjZTogNDI2MDc1MTEwMyxcbiAgb2xpdmU6IDIxNTU4NzI1MTEsXG4gIG9saXZlZHJhYjogMTgwNDQ3NzQzOSxcbiAgb3JhbmdlOiA0Mjg5MDAzNzc1LFxuICBvcmFuZ2VyZWQ6IDQyODI3MTIzMTksXG4gIG9yY2hpZDogMzY2NDgyODE1OSxcbiAgcGFsZWdvbGRlbnJvZDogNDAwODIyNTUzNSxcbiAgcGFsZWdyZWVuOiAyNTY2NjI1NTM1LFxuICBwYWxldHVycXVvaXNlOiAyOTUxNjcxNTUxLFxuICBwYWxldmlvbGV0cmVkOiAzNjgxNTg4MjIzLFxuICBwYXBheWF3aGlwOiA0MjkzOTA3OTY3LFxuICBwZWFjaHB1ZmY6IDQyOTI1MjQ1NDMsXG4gIHBlcnU6IDM0NDgwNjE5NTEsXG4gIHBpbms6IDQyOTA4MjUyMTUsXG4gIHBsdW06IDM3MTgzMDczMjcsXG4gIHBvd2RlcmJsdWU6IDI5Njc1MjkyMTUsXG4gIHB1cnBsZTogMjE0NzUxNjY3MSxcbiAgcmViZWNjYXB1cnBsZTogMTcxNDY1Nzc5MSxcbiAgcmVkOiA0Mjc4MTkwMzM1LFxuICByb3N5YnJvd246IDMxNjM1MjUxMTksXG4gIHJveWFsYmx1ZTogMTA5NzQ1ODE3NSxcbiAgc2FkZGxlYnJvd246IDIzMzY1NjAxMjcsXG4gIHNhbG1vbjogNDIwMjcyMjA0NyxcbiAgc2FuZHlicm93bjogNDEwNDQxMzQzOSxcbiAgc2VhZ3JlZW46IDc4MDg4Mzk2NyxcbiAgc2Vhc2hlbGw6IDQyOTQzMDc1ODMsXG4gIHNpZW5uYTogMjY4OTc0MDI4NyxcbiAgc2lsdmVyOiAzMjMzODU3NzkxLFxuICBza3libHVlOiAyMjc4NDg0OTkxLFxuICBzbGF0ZWJsdWU6IDE3ODQzMzU4NzEsXG4gIHNsYXRlZ3JheTogMTg4NzQ3MzkxOSxcbiAgc2xhdGVncmV5OiAxODg3NDczOTE5LFxuICBzbm93OiA0Mjk0NjM4MzM1LFxuICBzcHJpbmdncmVlbjogMTY3NDQ0NDcsXG4gIHN0ZWVsYmx1ZTogMTE4Mjk3MTEzNSxcbiAgdGFuOiAzNTM1MDQ3OTM1LFxuICB0ZWFsOiA4NDIxNjMxLFxuICB0aGlzdGxlOiAzNjM2NDUxNTgzLFxuICB0b21hdG86IDQyODQ2OTY1NzUsXG4gIHR1cnF1b2lzZTogMTA4ODQ3NTM5MSxcbiAgdmlvbGV0OiA0MDAxNTU4MjcxLFxuICB3aGVhdDogNDEyNTAxMjk5MSxcbiAgd2hpdGU6IDQyOTQ5NjcyOTUsXG4gIHdoaXRlc21va2U6IDQxMjY1MzcyMTUsXG4gIHllbGxvdzogNDI5NDkwMjAxNSxcbiAgeWVsbG93Z3JlZW46IDI1OTcxMzkxOTlcbn07XG5cbi8vIHNyYy9jb2xvck1hdGNoZXJzLnRzXG52YXIgTlVNQkVSID0gXCJbLStdP1xcXFxkKlxcXFwuP1xcXFxkK1wiO1xudmFyIFBFUkNFTlRBR0UgPSBOVU1CRVIgKyBcIiVcIjtcbmZ1bmN0aW9uIGNhbGwoLi4ucGFydHMpIHtcbiAgcmV0dXJuIFwiXFxcXChcXFxccyooXCIgKyBwYXJ0cy5qb2luKFwiKVxcXFxzKixcXFxccyooXCIpICsgXCIpXFxcXHMqXFxcXClcIjtcbn1cbnZhciByZ2IgPSBuZXcgUmVnRXhwKFwicmdiXCIgKyBjYWxsKE5VTUJFUiwgTlVNQkVSLCBOVU1CRVIpKTtcbnZhciByZ2JhID0gbmV3IFJlZ0V4cChcInJnYmFcIiArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG52YXIgaHNsID0gbmV3IFJlZ0V4cChcImhzbFwiICsgY2FsbChOVU1CRVIsIFBFUkNFTlRBR0UsIFBFUkNFTlRBR0UpKTtcbnZhciBoc2xhID0gbmV3IFJlZ0V4cChcbiAgXCJoc2xhXCIgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSwgTlVNQkVSKVxuKTtcbnZhciBoZXgzID0gL14jKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC87XG52YXIgaGV4NCA9IC9eIyhbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbnZhciBoZXg2ID0gL14jKFswLTlhLWZBLUZdezZ9KSQvO1xudmFyIGhleDggPSAvXiMoWzAtOWEtZkEtRl17OH0pJC87XG5cbi8vIHNyYy9ub3JtYWxpemVDb2xvci50c1xuZnVuY3Rpb24gbm9ybWFsaXplQ29sb3IoY29sb3IpIHtcbiAgbGV0IG1hdGNoO1xuICBpZiAodHlwZW9mIGNvbG9yID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIGNvbG9yID4+PiAwID09PSBjb2xvciAmJiBjb2xvciA+PSAwICYmIGNvbG9yIDw9IDQyOTQ5NjcyOTUgPyBjb2xvciA6IG51bGw7XG4gIH1cbiAgaWYgKG1hdGNoID0gaGV4Ni5leGVjKGNvbG9yKSlcbiAgICByZXR1cm4gcGFyc2VJbnQobWF0Y2hbMV0gKyBcImZmXCIsIDE2KSA+Pj4gMDtcbiAgaWYgKGNvbG9ycyAmJiBjb2xvcnNbY29sb3JdICE9PSB2b2lkIDApIHtcbiAgICByZXR1cm4gY29sb3JzW2NvbG9yXTtcbiAgfVxuICBpZiAobWF0Y2ggPSByZ2IuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gKHBhcnNlMjU1KG1hdGNoWzFdKSA8PCAyNCB8IC8vIHJcbiAgICBwYXJzZTI1NShtYXRjaFsyXSkgPDwgMTYgfCAvLyBnXG4gICAgcGFyc2UyNTUobWF0Y2hbM10pIDw8IDggfCAvLyBiXG4gICAgMjU1KSA+Pj4gLy8gYVxuICAgIDA7XG4gIH1cbiAgaWYgKG1hdGNoID0gcmdiYS5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiAocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0IHwgLy8gclxuICAgIHBhcnNlMjU1KG1hdGNoWzJdKSA8PCAxNiB8IC8vIGdcbiAgICBwYXJzZTI1NShtYXRjaFszXSkgPDwgOCB8IC8vIGJcbiAgICBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gLy8gYVxuICAgIDA7XG4gIH1cbiAgaWYgKG1hdGNoID0gaGV4My5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiBwYXJzZUludChcbiAgICAgIG1hdGNoWzFdICsgbWF0Y2hbMV0gKyAvLyByXG4gICAgICBtYXRjaFsyXSArIG1hdGNoWzJdICsgLy8gZ1xuICAgICAgbWF0Y2hbM10gKyBtYXRjaFszXSArIC8vIGJcbiAgICAgIFwiZmZcIixcbiAgICAgIC8vIGFcbiAgICAgIDE2XG4gICAgKSA+Pj4gMDtcbiAgfVxuICBpZiAobWF0Y2ggPSBoZXg4LmV4ZWMoY29sb3IpKVxuICAgIHJldHVybiBwYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICBpZiAobWF0Y2ggPSBoZXg0LmV4ZWMoY29sb3IpKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KFxuICAgICAgbWF0Y2hbMV0gKyBtYXRjaFsxXSArIC8vIHJcbiAgICAgIG1hdGNoWzJdICsgbWF0Y2hbMl0gKyAvLyBnXG4gICAgICBtYXRjaFszXSArIG1hdGNoWzNdICsgLy8gYlxuICAgICAgbWF0Y2hbNF0gKyBtYXRjaFs0XSxcbiAgICAgIC8vIGFcbiAgICAgIDE2XG4gICAgKSA+Pj4gMDtcbiAgfVxuICBpZiAobWF0Y2ggPSBoc2wuZXhlYyhjb2xvcikpIHtcbiAgICByZXR1cm4gKGhzbFRvUmdiKFxuICAgICAgcGFyc2UzNjAobWF0Y2hbMV0pLFxuICAgICAgLy8gaFxuICAgICAgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSxcbiAgICAgIC8vIHNcbiAgICAgIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSlcbiAgICAgIC8vIGxcbiAgICApIHwgMjU1KSA+Pj4gLy8gYVxuICAgIDA7XG4gIH1cbiAgaWYgKG1hdGNoID0gaHNsYS5leGVjKGNvbG9yKSkge1xuICAgIHJldHVybiAoaHNsVG9SZ2IoXG4gICAgICBwYXJzZTM2MChtYXRjaFsxXSksXG4gICAgICAvLyBoXG4gICAgICBwYXJzZVBlcmNlbnRhZ2UobWF0Y2hbMl0pLFxuICAgICAgLy8gc1xuICAgICAgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKVxuICAgICAgLy8gbFxuICAgICkgfCBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gLy8gYVxuICAgIDA7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBodWUycmdiKHAsIHEsIHQpIHtcbiAgaWYgKHQgPCAwKVxuICAgIHQgKz0gMTtcbiAgaWYgKHQgPiAxKVxuICAgIHQgLT0gMTtcbiAgaWYgKHQgPCAxIC8gNilcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgaWYgKHQgPCAxIC8gMilcbiAgICByZXR1cm4gcTtcbiAgaWYgKHQgPCAyIC8gMylcbiAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gaHNsVG9SZ2IoaCwgcywgbCkge1xuICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgY29uc3QgcCA9IDIgKiBsIC0gcTtcbiAgY29uc3QgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgY29uc3QgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gIGNvbnN0IGIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gIHJldHVybiBNYXRoLnJvdW5kKHIgKiAyNTUpIDw8IDI0IHwgTWF0aC5yb3VuZChnICogMjU1KSA8PCAxNiB8IE1hdGgucm91bmQoYiAqIDI1NSkgPDwgODtcbn1cbmZ1bmN0aW9uIHBhcnNlMjU1KHN0cikge1xuICBjb25zdCBpbnQgPSBwYXJzZUludChzdHIsIDEwKTtcbiAgaWYgKGludCA8IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmIChpbnQgPiAyNTUpXG4gICAgcmV0dXJuIDI1NTtcbiAgcmV0dXJuIGludDtcbn1cbmZ1bmN0aW9uIHBhcnNlMzYwKHN0cikge1xuICBjb25zdCBpbnQgPSBwYXJzZUZsb2F0KHN0cik7XG4gIHJldHVybiAoaW50ICUgMzYwICsgMzYwKSAlIDM2MCAvIDM2MDtcbn1cbmZ1bmN0aW9uIHBhcnNlMShzdHIpIHtcbiAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChzdHIpO1xuICBpZiAobnVtIDwgMClcbiAgICByZXR1cm4gMDtcbiAgaWYgKG51bSA+IDEpXG4gICAgcmV0dXJuIDI1NTtcbiAgcmV0dXJuIE1hdGgucm91bmQobnVtICogMjU1KTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGVyY2VudGFnZShzdHIpIHtcbiAgY29uc3QgaW50ID0gcGFyc2VGbG9hdChzdHIpO1xuICBpZiAoaW50IDwgMClcbiAgICByZXR1cm4gMDtcbiAgaWYgKGludCA+IDEwMClcbiAgICByZXR1cm4gMTtcbiAgcmV0dXJuIGludCAvIDEwMDtcbn1cblxuLy8gc3JjL2NvbG9yVG9SZ2JhLnRzXG5mdW5jdGlvbiBjb2xvclRvUmdiYShpbnB1dCkge1xuICBsZXQgaW50MzJDb2xvciA9IG5vcm1hbGl6ZUNvbG9yKGlucHV0KTtcbiAgaWYgKGludDMyQ29sb3IgPT09IG51bGwpXG4gICAgcmV0dXJuIGlucHV0O1xuICBpbnQzMkNvbG9yID0gaW50MzJDb2xvciB8fCAwO1xuICBjb25zdCByID0gKGludDMyQ29sb3IgJiA0Mjc4MTkwMDgwKSA+Pj4gMjQ7XG4gIGNvbnN0IGcgPSAoaW50MzJDb2xvciAmIDE2NzExNjgwKSA+Pj4gMTY7XG4gIGNvbnN0IGIgPSAoaW50MzJDb2xvciAmIDY1MjgwKSA+Pj4gODtcbiAgY29uc3QgYSA9IChpbnQzMkNvbG9yICYgMjU1KSAvIDI1NTtcbiAgcmV0dXJuIGByZ2JhKCR7cn0sICR7Z30sICR7Yn0sICR7YX0pYDtcbn1cblxuLy8gc3JjL2NyZWF0ZUludGVycG9sYXRvci50c1xudmFyIGNyZWF0ZUludGVycG9sYXRvciA9IChyYW5nZSwgb3V0cHV0LCBleHRyYXBvbGF0ZSkgPT4ge1xuICBpZiAoaXMuZnVuKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZTtcbiAgfVxuICBpZiAoaXMuYXJyKHJhbmdlKSkge1xuICAgIHJldHVybiBjcmVhdGVJbnRlcnBvbGF0b3Ioe1xuICAgICAgcmFuZ2UsXG4gICAgICBvdXRwdXQsXG4gICAgICBleHRyYXBvbGF0ZVxuICAgIH0pO1xuICB9XG4gIGlmIChpcy5zdHIocmFuZ2Uub3V0cHV0WzBdKSkge1xuICAgIHJldHVybiBjcmVhdGVTdHJpbmdJbnRlcnBvbGF0b3IocmFuZ2UpO1xuICB9XG4gIGNvbnN0IGNvbmZpZyA9IHJhbmdlO1xuICBjb25zdCBvdXRwdXRSYW5nZSA9IGNvbmZpZy5vdXRwdXQ7XG4gIGNvbnN0IGlucHV0UmFuZ2UgPSBjb25maWcucmFuZ2UgfHwgWzAsIDFdO1xuICBjb25zdCBleHRyYXBvbGF0ZUxlZnQgPSBjb25maWcuZXh0cmFwb2xhdGVMZWZ0IHx8IGNvbmZpZy5leHRyYXBvbGF0ZSB8fCBcImV4dGVuZFwiO1xuICBjb25zdCBleHRyYXBvbGF0ZVJpZ2h0ID0gY29uZmlnLmV4dHJhcG9sYXRlUmlnaHQgfHwgY29uZmlnLmV4dHJhcG9sYXRlIHx8IFwiZXh0ZW5kXCI7XG4gIGNvbnN0IGVhc2luZyA9IGNvbmZpZy5lYXNpbmcgfHwgKCh0KSA9PiB0KTtcbiAgcmV0dXJuIChpbnB1dCkgPT4ge1xuICAgIGNvbnN0IHJhbmdlMiA9IGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSk7XG4gICAgcmV0dXJuIGludGVycG9sYXRlKFxuICAgICAgaW5wdXQsXG4gICAgICBpbnB1dFJhbmdlW3JhbmdlMl0sXG4gICAgICBpbnB1dFJhbmdlW3JhbmdlMiArIDFdLFxuICAgICAgb3V0cHV0UmFuZ2VbcmFuZ2UyXSxcbiAgICAgIG91dHB1dFJhbmdlW3JhbmdlMiArIDFdLFxuICAgICAgZWFzaW5nLFxuICAgICAgZXh0cmFwb2xhdGVMZWZ0LFxuICAgICAgZXh0cmFwb2xhdGVSaWdodCxcbiAgICAgIGNvbmZpZy5tYXBcbiAgICApO1xuICB9O1xufTtcbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBpbnB1dE1pbiwgaW5wdXRNYXgsIG91dHB1dE1pbiwgb3V0cHV0TWF4LCBlYXNpbmcsIGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgbWFwKSB7XG4gIGxldCByZXN1bHQgPSBtYXAgPyBtYXAoaW5wdXQpIDogaW5wdXQ7XG4gIGlmIChyZXN1bHQgPCBpbnB1dE1pbikge1xuICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09IFwiaWRlbnRpdHlcIilcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgZWxzZSBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSBcImNsYW1wXCIpXG4gICAgICByZXN1bHQgPSBpbnB1dE1pbjtcbiAgfVxuICBpZiAocmVzdWx0ID4gaW5wdXRNYXgpIHtcbiAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gXCJpZGVudGl0eVwiKVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBlbHNlIGlmIChleHRyYXBvbGF0ZVJpZ2h0ID09PSBcImNsYW1wXCIpXG4gICAgICByZXN1bHQgPSBpbnB1dE1heDtcbiAgfVxuICBpZiAob3V0cHV0TWluID09PSBvdXRwdXRNYXgpXG4gICAgcmV0dXJuIG91dHB1dE1pbjtcbiAgaWYgKGlucHV0TWluID09PSBpbnB1dE1heClcbiAgICByZXR1cm4gaW5wdXQgPD0gaW5wdXRNaW4gPyBvdXRwdXRNaW4gOiBvdXRwdXRNYXg7XG4gIGlmIChpbnB1dE1pbiA9PT0gLUluZmluaXR5KVxuICAgIHJlc3VsdCA9IC1yZXN1bHQ7XG4gIGVsc2UgaWYgKGlucHV0TWF4ID09PSBJbmZpbml0eSlcbiAgICByZXN1bHQgPSByZXN1bHQgLSBpbnB1dE1pbjtcbiAgZWxzZVxuICAgIHJlc3VsdCA9IChyZXN1bHQgLSBpbnB1dE1pbikgLyAoaW5wdXRNYXggLSBpbnB1dE1pbik7XG4gIHJlc3VsdCA9IGVhc2luZyhyZXN1bHQpO1xuICBpZiAob3V0cHV0TWluID09PSAtSW5maW5pdHkpXG4gICAgcmVzdWx0ID0gLXJlc3VsdDtcbiAgZWxzZSBpZiAob3V0cHV0TWF4ID09PSBJbmZpbml0eSlcbiAgICByZXN1bHQgPSByZXN1bHQgKyBvdXRwdXRNaW47XG4gIGVsc2VcbiAgICByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbmRSYW5nZShpbnB1dCwgaW5wdXRSYW5nZSkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKVxuICAgIGlmIChpbnB1dFJhbmdlW2ldID49IGlucHV0KVxuICAgICAgYnJlYWs7XG4gIHJldHVybiBpIC0gMTtcbn1cblxuLy8gc3JjL2Vhc2luZ3MudHNcbnZhciBzdGVwcyA9IChzdGVwczIsIGRpcmVjdGlvbiA9IFwiZW5kXCIpID0+IChwcm9ncmVzczIpID0+IHtcbiAgcHJvZ3Jlc3MyID0gZGlyZWN0aW9uID09PSBcImVuZFwiID8gTWF0aC5taW4ocHJvZ3Jlc3MyLCAwLjk5OSkgOiBNYXRoLm1heChwcm9ncmVzczIsIDFlLTMpO1xuICBjb25zdCBleHBhbmRlZCA9IHByb2dyZXNzMiAqIHN0ZXBzMjtcbiAgY29uc3Qgcm91bmRlZCA9IGRpcmVjdGlvbiA9PT0gXCJlbmRcIiA/IE1hdGguZmxvb3IoZXhwYW5kZWQpIDogTWF0aC5jZWlsKGV4cGFuZGVkKTtcbiAgcmV0dXJuIGNsYW1wKDAsIDEsIHJvdW5kZWQgLyBzdGVwczIpO1xufTtcbnZhciBjMSA9IDEuNzAxNTg7XG52YXIgYzIgPSBjMSAqIDEuNTI1O1xudmFyIGMzID0gYzEgKyAxO1xudmFyIGM0ID0gMiAqIE1hdGguUEkgLyAzO1xudmFyIGM1ID0gMiAqIE1hdGguUEkgLyA0LjU7XG52YXIgYm91bmNlT3V0ID0gKHgpID0+IHtcbiAgY29uc3QgbjEgPSA3LjU2MjU7XG4gIGNvbnN0IGQxID0gMi43NTtcbiAgaWYgKHggPCAxIC8gZDEpIHtcbiAgICByZXR1cm4gbjEgKiB4ICogeDtcbiAgfSBlbHNlIGlmICh4IDwgMiAvIGQxKSB7XG4gICAgcmV0dXJuIG4xICogKHggLT0gMS41IC8gZDEpICogeCArIDAuNzU7XG4gIH0gZWxzZSBpZiAoeCA8IDIuNSAvIGQxKSB7XG4gICAgcmV0dXJuIG4xICogKHggLT0gMi4yNSAvIGQxKSAqIHggKyAwLjkzNzU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG4xICogKHggLT0gMi42MjUgLyBkMSkgKiB4ICsgMC45ODQzNzU7XG4gIH1cbn07XG52YXIgZWFzaW5ncyA9IHtcbiAgbGluZWFyOiAoeCkgPT4geCxcbiAgZWFzZUluUXVhZDogKHgpID0+IHggKiB4LFxuICBlYXNlT3V0UXVhZDogKHgpID0+IDEgLSAoMSAtIHgpICogKDEgLSB4KSxcbiAgZWFzZUluT3V0UXVhZDogKHgpID0+IHggPCAwLjUgPyAyICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgMikgLyAyLFxuICBlYXNlSW5DdWJpYzogKHgpID0+IHggKiB4ICogeCxcbiAgZWFzZU91dEN1YmljOiAoeCkgPT4gMSAtIE1hdGgucG93KDEgLSB4LCAzKSxcbiAgZWFzZUluT3V0Q3ViaWM6ICh4KSA9PiB4IDwgMC41ID8gNCAqIHggKiB4ICogeCA6IDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCAzKSAvIDIsXG4gIGVhc2VJblF1YXJ0OiAoeCkgPT4geCAqIHggKiB4ICogeCxcbiAgZWFzZU91dFF1YXJ0OiAoeCkgPT4gMSAtIE1hdGgucG93KDEgLSB4LCA0KSxcbiAgZWFzZUluT3V0UXVhcnQ6ICh4KSA9PiB4IDwgMC41ID8gOCAqIHggKiB4ICogeCAqIHggOiAxIC0gTWF0aC5wb3coLTIgKiB4ICsgMiwgNCkgLyAyLFxuICBlYXNlSW5RdWludDogKHgpID0+IHggKiB4ICogeCAqIHggKiB4LFxuICBlYXNlT3V0UXVpbnQ6ICh4KSA9PiAxIC0gTWF0aC5wb3coMSAtIHgsIDUpLFxuICBlYXNlSW5PdXRRdWludDogKHgpID0+IHggPCAwLjUgPyAxNiAqIHggKiB4ICogeCAqIHggKiB4IDogMSAtIE1hdGgucG93KC0yICogeCArIDIsIDUpIC8gMixcbiAgZWFzZUluU2luZTogKHgpID0+IDEgLSBNYXRoLmNvcyh4ICogTWF0aC5QSSAvIDIpLFxuICBlYXNlT3V0U2luZTogKHgpID0+IE1hdGguc2luKHggKiBNYXRoLlBJIC8gMiksXG4gIGVhc2VJbk91dFNpbmU6ICh4KSA9PiAtKE1hdGguY29zKE1hdGguUEkgKiB4KSAtIDEpIC8gMixcbiAgZWFzZUluRXhwbzogKHgpID0+IHggPT09IDAgPyAwIDogTWF0aC5wb3coMiwgMTAgKiB4IC0gMTApLFxuICBlYXNlT3V0RXhwbzogKHgpID0+IHggPT09IDEgPyAxIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIHgpLFxuICBlYXNlSW5PdXRFeHBvOiAoeCkgPT4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6IHggPCAwLjUgPyBNYXRoLnBvdygyLCAyMCAqIHggLSAxMCkgLyAyIDogKDIgLSBNYXRoLnBvdygyLCAtMjAgKiB4ICsgMTApKSAvIDIsXG4gIGVhc2VJbkNpcmM6ICh4KSA9PiAxIC0gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdyh4LCAyKSksXG4gIGVhc2VPdXRDaXJjOiAoeCkgPT4gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdyh4IC0gMSwgMikpLFxuICBlYXNlSW5PdXRDaXJjOiAoeCkgPT4geCA8IDAuNSA/ICgxIC0gTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdygyICogeCwgMikpKSAvIDIgOiAoTWF0aC5zcXJ0KDEgLSBNYXRoLnBvdygtMiAqIHggKyAyLCAyKSkgKyAxKSAvIDIsXG4gIGVhc2VJbkJhY2s6ICh4KSA9PiBjMyAqIHggKiB4ICogeCAtIGMxICogeCAqIHgsXG4gIGVhc2VPdXRCYWNrOiAoeCkgPT4gMSArIGMzICogTWF0aC5wb3coeCAtIDEsIDMpICsgYzEgKiBNYXRoLnBvdyh4IC0gMSwgMiksXG4gIGVhc2VJbk91dEJhY2s6ICh4KSA9PiB4IDwgMC41ID8gTWF0aC5wb3coMiAqIHgsIDIpICogKChjMiArIDEpICogMiAqIHggLSBjMikgLyAyIDogKE1hdGgucG93KDIgKiB4IC0gMiwgMikgKiAoKGMyICsgMSkgKiAoeCAqIDIgLSAyKSArIGMyKSArIDIpIC8gMixcbiAgZWFzZUluRWxhc3RpYzogKHgpID0+IHggPT09IDAgPyAwIDogeCA9PT0gMSA/IDEgOiAtTWF0aC5wb3coMiwgMTAgKiB4IC0gMTApICogTWF0aC5zaW4oKHggKiAxMCAtIDEwLjc1KSAqIGM0KSxcbiAgZWFzZU91dEVsYXN0aWM6ICh4KSA9PiB4ID09PSAwID8gMCA6IHggPT09IDEgPyAxIDogTWF0aC5wb3coMiwgLTEwICogeCkgKiBNYXRoLnNpbigoeCAqIDEwIC0gMC43NSkgKiBjNCkgKyAxLFxuICBlYXNlSW5PdXRFbGFzdGljOiAoeCkgPT4geCA9PT0gMCA/IDAgOiB4ID09PSAxID8gMSA6IHggPCAwLjUgPyAtKE1hdGgucG93KDIsIDIwICogeCAtIDEwKSAqIE1hdGguc2luKCgyMCAqIHggLSAxMS4xMjUpICogYzUpKSAvIDIgOiBNYXRoLnBvdygyLCAtMjAgKiB4ICsgMTApICogTWF0aC5zaW4oKDIwICogeCAtIDExLjEyNSkgKiBjNSkgLyAyICsgMSxcbiAgZWFzZUluQm91bmNlOiAoeCkgPT4gMSAtIGJvdW5jZU91dCgxIC0geCksXG4gIGVhc2VPdXRCb3VuY2U6IGJvdW5jZU91dCxcbiAgZWFzZUluT3V0Qm91bmNlOiAoeCkgPT4geCA8IDAuNSA/ICgxIC0gYm91bmNlT3V0KDEgLSAyICogeCkpIC8gMiA6ICgxICsgYm91bmNlT3V0KDIgKiB4IC0gMSkpIC8gMixcbiAgc3RlcHNcbn07XG5cbi8vIHNyYy9mbHVpZHMudHNcbnZhciAkZ2V0ID0gU3ltYm9sLmZvcihcIkZsdWlkVmFsdWUuZ2V0XCIpO1xudmFyICRvYnNlcnZlcnMgPSBTeW1ib2wuZm9yKFwiRmx1aWRWYWx1ZS5vYnNlcnZlcnNcIik7XG52YXIgaGFzRmx1aWRWYWx1ZSA9IChhcmcpID0+IEJvb2xlYW4oYXJnICYmIGFyZ1skZ2V0XSk7XG52YXIgZ2V0Rmx1aWRWYWx1ZSA9IChhcmcpID0+IGFyZyAmJiBhcmdbJGdldF0gPyBhcmdbJGdldF0oKSA6IGFyZztcbnZhciBnZXRGbHVpZE9ic2VydmVycyA9ICh0YXJnZXQpID0+IHRhcmdldFskb2JzZXJ2ZXJzXSB8fCBudWxsO1xuZnVuY3Rpb24gY2FsbEZsdWlkT2JzZXJ2ZXIob2JzZXJ2ZXIyLCBldmVudCkge1xuICBpZiAob2JzZXJ2ZXIyLmV2ZW50T2JzZXJ2ZWQpIHtcbiAgICBvYnNlcnZlcjIuZXZlbnRPYnNlcnZlZChldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgb2JzZXJ2ZXIyKGV2ZW50KTtcbiAgfVxufVxuZnVuY3Rpb24gY2FsbEZsdWlkT2JzZXJ2ZXJzKHRhcmdldCwgZXZlbnQpIHtcbiAgY29uc3Qgb2JzZXJ2ZXJzID0gdGFyZ2V0WyRvYnNlcnZlcnNdO1xuICBpZiAob2JzZXJ2ZXJzKSB7XG4gICAgb2JzZXJ2ZXJzLmZvckVhY2goKG9ic2VydmVyMikgPT4ge1xuICAgICAgY2FsbEZsdWlkT2JzZXJ2ZXIob2JzZXJ2ZXIyLCBldmVudCk7XG4gICAgfSk7XG4gIH1cbn1cbnZhciBGbHVpZFZhbHVlID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihnZXQpIHtcbiAgICBpZiAoIWdldCAmJiAhKGdldCA9IHRoaXMuZ2V0KSkge1xuICAgICAgdGhyb3cgRXJyb3IoXCJVbmtub3duIGdldHRlclwiKTtcbiAgICB9XG4gICAgc2V0Rmx1aWRHZXR0ZXIodGhpcywgZ2V0KTtcbiAgfVxufTtcbiRnZXQsICRvYnNlcnZlcnM7XG52YXIgc2V0Rmx1aWRHZXR0ZXIgPSAodGFyZ2V0LCBnZXQpID0+IHNldEhpZGRlbih0YXJnZXQsICRnZXQsIGdldCk7XG5mdW5jdGlvbiBhZGRGbHVpZE9ic2VydmVyKHRhcmdldCwgb2JzZXJ2ZXIyKSB7XG4gIGlmICh0YXJnZXRbJGdldF0pIHtcbiAgICBsZXQgb2JzZXJ2ZXJzID0gdGFyZ2V0WyRvYnNlcnZlcnNdO1xuICAgIGlmICghb2JzZXJ2ZXJzKSB7XG4gICAgICBzZXRIaWRkZW4odGFyZ2V0LCAkb2JzZXJ2ZXJzLCBvYnNlcnZlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICB9XG4gICAgaWYgKCFvYnNlcnZlcnMuaGFzKG9ic2VydmVyMikpIHtcbiAgICAgIG9ic2VydmVycy5hZGQob2JzZXJ2ZXIyKTtcbiAgICAgIGlmICh0YXJnZXQub2JzZXJ2ZXJBZGRlZCkge1xuICAgICAgICB0YXJnZXQub2JzZXJ2ZXJBZGRlZChvYnNlcnZlcnMuc2l6ZSwgb2JzZXJ2ZXIyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9ic2VydmVyMjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUZsdWlkT2JzZXJ2ZXIodGFyZ2V0LCBvYnNlcnZlcjIpIHtcbiAgY29uc3Qgb2JzZXJ2ZXJzID0gdGFyZ2V0WyRvYnNlcnZlcnNdO1xuICBpZiAob2JzZXJ2ZXJzICYmIG9ic2VydmVycy5oYXMob2JzZXJ2ZXIyKSkge1xuICAgIGNvbnN0IGNvdW50ID0gb2JzZXJ2ZXJzLnNpemUgLSAxO1xuICAgIGlmIChjb3VudCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShvYnNlcnZlcjIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXRbJG9ic2VydmVyc10gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0Lm9ic2VydmVyUmVtb3ZlZCkge1xuICAgICAgdGFyZ2V0Lm9ic2VydmVyUmVtb3ZlZChjb3VudCwgb2JzZXJ2ZXIyKTtcbiAgICB9XG4gIH1cbn1cbnZhciBzZXRIaWRkZW4gPSAodGFyZ2V0LCBrZXksIHZhbHVlKSA9PiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHtcbiAgdmFsdWUsXG4gIHdyaXRhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWVcbn0pO1xuXG4vLyBzcmMvcmVnZXhzLnRzXG52YXIgbnVtYmVyUmVnZXggPSAvWytcXC1dPyg/OjB8WzEtOV1cXGQqKSg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG52YXIgY29sb3JSZWdleCA9IC8oIyg/OlswLTlhLWZdezJ9KXsyLDR9fCgjWzAtOWEtZl17M30pfChyZ2J8aHNsKWE/XFwoKC0/XFxkKyU/WyxcXHNdKyl7MiwzfVxccypbXFxkXFwuXSslP1xcKSkvZ2k7XG52YXIgdW5pdFJlZ2V4ID0gbmV3IFJlZ0V4cChgKCR7bnVtYmVyUmVnZXguc291cmNlfSkoJXxbYS16XSspYCwgXCJpXCIpO1xudmFyIHJnYmFSZWdleCA9IC9yZ2JhXFwoKFswLTlcXC4tXSspLCAoWzAtOVxcLi1dKyksIChbMC05XFwuLV0rKSwgKFswLTlcXC4tXSspXFwpL2dpO1xudmFyIGNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoKC0tW2EtekEtWjAtOS1fXSspLD8gPyhbYS16QS1aMC05ICgpJSMuLC1dKyk/XFwpLztcblxuLy8gc3JjL3ZhcmlhYmxlVG9SZ2JhLnRzXG52YXIgdmFyaWFibGVUb1JnYmEgPSAoaW5wdXQpID0+IHtcbiAgY29uc3QgW3Rva2VuLCBmYWxsYmFja10gPSBwYXJzZUNTU1ZhcmlhYmxlKGlucHV0KTtcbiAgaWYgKCF0b2tlbiB8fCBpc1NTUigpKSB7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9XG4gIGNvbnN0IHZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHRva2VuKTtcbiAgaWYgKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChmYWxsYmFjayAmJiBmYWxsYmFjay5zdGFydHNXaXRoKFwiLS1cIikpIHtcbiAgICBjb25zdCB2YWx1ZTIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoZmFsbGJhY2spO1xuICAgIGlmICh2YWx1ZTIpIHtcbiAgICAgIHJldHVybiB2YWx1ZTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbnB1dDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZmFsbGJhY2sgJiYgY3NzVmFyaWFibGVSZWdleC50ZXN0KGZhbGxiYWNrKSkge1xuICAgIHJldHVybiB2YXJpYWJsZVRvUmdiYShmYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoZmFsbGJhY2spIHtcbiAgICByZXR1cm4gZmFsbGJhY2s7XG4gIH1cbiAgcmV0dXJuIGlucHV0O1xufTtcbnZhciBwYXJzZUNTU1ZhcmlhYmxlID0gKGN1cnJlbnQpID0+IHtcbiAgY29uc3QgbWF0Y2ggPSBjc3NWYXJpYWJsZVJlZ2V4LmV4ZWMoY3VycmVudCk7XG4gIGlmICghbWF0Y2gpXG4gICAgcmV0dXJuIFssXTtcbiAgY29uc3QgWywgdG9rZW4sIGZhbGxiYWNrXSA9IG1hdGNoO1xuICByZXR1cm4gW3Rva2VuLCBmYWxsYmFja107XG59O1xuXG4vLyBzcmMvc3RyaW5nSW50ZXJwb2xhdGlvbi50c1xudmFyIG5hbWVkQ29sb3JSZWdleDtcbnZhciByZ2JhUm91bmQgPSAoXywgcDEsIHAyLCBwMywgcDQpID0+IGByZ2JhKCR7TWF0aC5yb3VuZChwMSl9LCAke01hdGgucm91bmQocDIpfSwgJHtNYXRoLnJvdW5kKHAzKX0sICR7cDR9KWA7XG52YXIgY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yMiA9IChjb25maWcpID0+IHtcbiAgaWYgKCFuYW1lZENvbG9yUmVnZXgpXG4gICAgbmFtZWRDb2xvclJlZ2V4ID0gY29sb3JzID8gKFxuICAgICAgLy8gbWF0Y2ggY29sb3IgbmFtZXMsIGlnbm9yZSBwYXJ0aWFsIG1hdGNoZXNcbiAgICAgIG5ldyBSZWdFeHAoYCgke09iamVjdC5rZXlzKGNvbG9ycykuam9pbihcInxcIil9KSg/IVxcXFx3KWAsIFwiZ1wiKVxuICAgICkgOiAoXG4gICAgICAvLyBuZXZlciBtYXRjaFxuICAgICAgL15cXGIkL1xuICAgICk7XG4gIGNvbnN0IG91dHB1dCA9IGNvbmZpZy5vdXRwdXQubWFwKCh2YWx1ZSkgPT4ge1xuICAgIHJldHVybiBnZXRGbHVpZFZhbHVlKHZhbHVlKS5yZXBsYWNlKGNzc1ZhcmlhYmxlUmVnZXgsIHZhcmlhYmxlVG9SZ2JhKS5yZXBsYWNlKGNvbG9yUmVnZXgsIGNvbG9yVG9SZ2JhKS5yZXBsYWNlKG5hbWVkQ29sb3JSZWdleCwgY29sb3JUb1JnYmEpO1xuICB9KTtcbiAgY29uc3Qga2V5ZnJhbWVzID0gb3V0cHV0Lm1hcCgodmFsdWUpID0+IHZhbHVlLm1hdGNoKG51bWJlclJlZ2V4KS5tYXAoTnVtYmVyKSk7XG4gIGNvbnN0IG91dHB1dFJhbmdlcyA9IGtleWZyYW1lc1swXS5tYXAoXG4gICAgKF8sIGkpID0+IGtleWZyYW1lcy5tYXAoKHZhbHVlcykgPT4ge1xuICAgICAgaWYgKCEoaSBpbiB2YWx1ZXMpKSB7XG4gICAgICAgIHRocm93IEVycm9yKCdUaGUgYXJpdHkgb2YgZWFjaCBcIm91dHB1dFwiIHZhbHVlIG11c3QgYmUgZXF1YWwnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZXNbaV07XG4gICAgfSlcbiAgKTtcbiAgY29uc3QgaW50ZXJwb2xhdG9ycyA9IG91dHB1dFJhbmdlcy5tYXAoXG4gICAgKG91dHB1dDIpID0+IGNyZWF0ZUludGVycG9sYXRvcih7IC4uLmNvbmZpZywgb3V0cHV0OiBvdXRwdXQyIH0pXG4gICk7XG4gIHJldHVybiAoaW5wdXQpID0+IHtcbiAgICBjb25zdCBtaXNzaW5nVW5pdCA9ICF1bml0UmVnZXgudGVzdChvdXRwdXRbMF0pICYmIG91dHB1dC5maW5kKCh2YWx1ZSkgPT4gdW5pdFJlZ2V4LnRlc3QodmFsdWUpKT8ucmVwbGFjZShudW1iZXJSZWdleCwgXCJcIik7XG4gICAgbGV0IGkgPSAwO1xuICAgIHJldHVybiBvdXRwdXRbMF0ucmVwbGFjZShcbiAgICAgIG51bWJlclJlZ2V4LFxuICAgICAgKCkgPT4gYCR7aW50ZXJwb2xhdG9yc1tpKytdKGlucHV0KX0ke21pc3NpbmdVbml0IHx8IFwiXCJ9YFxuICAgICkucmVwbGFjZShyZ2JhUmVnZXgsIHJnYmFSb3VuZCk7XG4gIH07XG59O1xuXG4vLyBzcmMvZGVwcmVjYXRpb25zLnRzXG52YXIgcHJlZml4ID0gXCJyZWFjdC1zcHJpbmc6IFwiO1xudmFyIG9uY2UgPSAoZm4pID0+IHtcbiAgY29uc3QgZnVuYyA9IGZuO1xuICBsZXQgY2FsbGVkID0gZmFsc2U7XG4gIGlmICh0eXBlb2YgZnVuYyAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3ByZWZpeH1vbmNlIHJlcXVpcmVzIGEgZnVuY3Rpb24gcGFyYW1ldGVyYCk7XG4gIH1cbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGZ1bmMoLi4uYXJncyk7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbn07XG52YXIgd2FybkludGVycG9sYXRlID0gb25jZShjb25zb2xlLndhcm4pO1xuZnVuY3Rpb24gZGVwcmVjYXRlSW50ZXJwb2xhdGUoKSB7XG4gIHdhcm5JbnRlcnBvbGF0ZShcbiAgICBgJHtwcmVmaXh9VGhlIFwiaW50ZXJwb2xhdGVcIiBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIGluIHY5ICh1c2UgXCJ0b1wiIGluc3RlYWQpYFxuICApO1xufVxudmFyIHdhcm5EaXJlY3RDYWxsID0gb25jZShjb25zb2xlLndhcm4pO1xuZnVuY3Rpb24gZGVwcmVjYXRlRGlyZWN0Q2FsbCgpIHtcbiAgd2FybkRpcmVjdENhbGwoXG4gICAgYCR7cHJlZml4fURpcmVjdGx5IGNhbGxpbmcgc3RhcnQgaW5zdGVhZCBvZiB1c2luZyB0aGUgYXBpIG9iamVjdCBpcyBkZXByZWNhdGVkIGluIHY5ICh1c2UgXCIuc3RhcnRcIiBpbnN0ZWFkKSwgdGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gbGF0ZXIgMC5YLjAgdmVyc2lvbnNgXG4gICk7XG59XG5cbi8vIHNyYy9pc0FuaW1hdGVkU3RyaW5nLnRzXG5mdW5jdGlvbiBpc0FuaW1hdGVkU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBpcy5zdHIodmFsdWUpICYmICh2YWx1ZVswXSA9PSBcIiNcIiB8fCAvXFxkLy50ZXN0KHZhbHVlKSB8fCAvLyBEbyBub3QgaWRlbnRpZnkgYSBDU1MgdmFyaWFibGUgYXMgYW4gQW5pbWF0ZWRTdHJpbmcgaWYgaXRzIFNTUlxuICAhaXNTU1IoKSAmJiBjc3NWYXJpYWJsZVJlZ2V4LnRlc3QodmFsdWUpIHx8IHZhbHVlIGluIChjb2xvcnMgfHwge30pKTtcbn1cblxuLy8gc3JjL2RvbS1ldmVudHMvc2Nyb2xsL2luZGV4LnRzXG5pbXBvcnQgeyByYWYgYXMgcmFmMyB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3JhZnpcIjtcblxuLy8gc3JjL2RvbS1ldmVudHMvcmVzaXplL3Jlc2l6ZUVsZW1lbnQudHNcbnZhciBvYnNlcnZlcjtcbnZhciByZXNpemVIYW5kbGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGhhbmRsZU9ic2VydmF0aW9uID0gKGVudHJpZXMpID0+IGVudHJpZXMuZm9yRWFjaCgoeyB0YXJnZXQsIGNvbnRlbnRSZWN0IH0pID0+IHtcbiAgcmV0dXJuIHJlc2l6ZUhhbmRsZXJzLmdldCh0YXJnZXQpPy5mb3JFYWNoKChoYW5kbGVyKSA9PiBoYW5kbGVyKGNvbnRlbnRSZWN0KSk7XG59KTtcbmZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQoaGFuZGxlciwgdGFyZ2V0KSB7XG4gIGlmICghb2JzZXJ2ZXIpIHtcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihoYW5kbGVPYnNlcnZhdGlvbik7XG4gICAgfVxuICB9XG4gIGxldCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQodGFyZ2V0KTtcbiAgaWYgKCFlbGVtZW50SGFuZGxlcnMpIHtcbiAgICBlbGVtZW50SGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHJlc2l6ZUhhbmRsZXJzLnNldCh0YXJnZXQsIGVsZW1lbnRIYW5kbGVycyk7XG4gIH1cbiAgZWxlbWVudEhhbmRsZXJzLmFkZChoYW5kbGVyKTtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0YXJnZXQpO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudEhhbmRsZXJzMiA9IHJlc2l6ZUhhbmRsZXJzLmdldCh0YXJnZXQpO1xuICAgIGlmICghZWxlbWVudEhhbmRsZXJzMilcbiAgICAgIHJldHVybjtcbiAgICBlbGVtZW50SGFuZGxlcnMyLmRlbGV0ZShoYW5kbGVyKTtcbiAgICBpZiAoIWVsZW1lbnRIYW5kbGVyczIuc2l6ZSAmJiBvYnNlcnZlcikge1xuICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKHRhcmdldCk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvZG9tLWV2ZW50cy9yZXNpemUvcmVzaXplV2luZG93LnRzXG52YXIgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbnZhciBjbGVhbnVwV2luZG93UmVzaXplSGFuZGxlcjtcbnZhciBjcmVhdGVSZXNpemVIYW5kbGVyID0gKCkgPT4ge1xuICBjb25zdCBoYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goXG4gICAgICAoY2FsbGJhY2spID0+IGNhbGxiYWNrKHtcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgfSlcbiAgICApO1xuICB9O1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVSZXNpemUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVJlc2l6ZSk7XG4gIH07XG59O1xudmFyIHJlc2l6ZVdpbmRvdyA9IChjYWxsYmFjaykgPT4ge1xuICBsaXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcbiAgaWYgKCFjbGVhbnVwV2luZG93UmVzaXplSGFuZGxlcikge1xuICAgIGNsZWFudXBXaW5kb3dSZXNpemVIYW5kbGVyID0gY3JlYXRlUmVzaXplSGFuZGxlcigpO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGlzdGVuZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgaWYgKCFsaXN0ZW5lcnMuc2l6ZSAmJiBjbGVhbnVwV2luZG93UmVzaXplSGFuZGxlcikge1xuICAgICAgY2xlYW51cFdpbmRvd1Jlc2l6ZUhhbmRsZXIoKTtcbiAgICAgIGNsZWFudXBXaW5kb3dSZXNpemVIYW5kbGVyID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbn07XG5cbi8vIHNyYy9kb20tZXZlbnRzL3Jlc2l6ZS9pbmRleC50c1xudmFyIG9uUmVzaXplID0gKGNhbGxiYWNrLCB7IGNvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB9ID0ge30pID0+IHtcbiAgaWYgKGNvbnRhaW5lciA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgcmV0dXJuIHJlc2l6ZVdpbmRvdyhjYWxsYmFjayk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc2l6ZUVsZW1lbnQoY2FsbGJhY2ssIGNvbnRhaW5lcik7XG4gIH1cbn07XG5cbi8vIHNyYy9wcm9ncmVzcy50c1xudmFyIHByb2dyZXNzID0gKG1pbiwgbWF4LCB2YWx1ZSkgPT4gbWF4IC0gbWluID09PSAwID8gMSA6ICh2YWx1ZSAtIG1pbikgLyAobWF4IC0gbWluKTtcblxuLy8gc3JjL2RvbS1ldmVudHMvc2Nyb2xsL1Njcm9sbEhhbmRsZXIudHNcbnZhciBTQ1JPTExfS0VZUyA9IHtcbiAgeDoge1xuICAgIGxlbmd0aDogXCJXaWR0aFwiLFxuICAgIHBvc2l0aW9uOiBcIkxlZnRcIlxuICB9LFxuICB5OiB7XG4gICAgbGVuZ3RoOiBcIkhlaWdodFwiLFxuICAgIHBvc2l0aW9uOiBcIlRvcFwiXG4gIH1cbn07XG52YXIgU2Nyb2xsSGFuZGxlciA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoY2FsbGJhY2ssIGNvbnRhaW5lcikge1xuICAgIHRoaXMuY3JlYXRlQXhpcyA9ICgpID0+ICh7XG4gICAgICBjdXJyZW50OiAwLFxuICAgICAgcHJvZ3Jlc3M6IDAsXG4gICAgICBzY3JvbGxMZW5ndGg6IDBcbiAgICB9KTtcbiAgICB0aGlzLnVwZGF0ZUF4aXMgPSAoYXhpc05hbWUpID0+IHtcbiAgICAgIGNvbnN0IGF4aXMgPSB0aGlzLmluZm9bYXhpc05hbWVdO1xuICAgICAgY29uc3QgeyBsZW5ndGgsIHBvc2l0aW9uIH0gPSBTQ1JPTExfS0VZU1theGlzTmFtZV07XG4gICAgICBheGlzLmN1cnJlbnQgPSB0aGlzLmNvbnRhaW5lcltgc2Nyb2xsJHtwb3NpdGlvbn1gXTtcbiAgICAgIGF4aXMuc2Nyb2xsTGVuZ3RoID0gdGhpcy5jb250YWluZXJbYHNjcm9sbCR7bGVuZ3RofWBdIC0gdGhpcy5jb250YWluZXJbYGNsaWVudCR7bGVuZ3RofWBdO1xuICAgICAgYXhpcy5wcm9ncmVzcyA9IHByb2dyZXNzKDAsIGF4aXMuc2Nyb2xsTGVuZ3RoLCBheGlzLmN1cnJlbnQpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZUF4aXMoXCJ4XCIpO1xuICAgICAgdGhpcy51cGRhdGVBeGlzKFwieVwiKTtcbiAgICB9O1xuICAgIHRoaXMuc2VuZEV2ZW50ID0gKCkgPT4ge1xuICAgICAgdGhpcy5jYWxsYmFjayh0aGlzLmluZm8pO1xuICAgIH07XG4gICAgdGhpcy5hZHZhbmNlID0gKCkgPT4ge1xuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIHRoaXMuc2VuZEV2ZW50KCk7XG4gICAgfTtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5pbmZvID0ge1xuICAgICAgdGltZTogMCxcbiAgICAgIHg6IHRoaXMuY3JlYXRlQXhpcygpLFxuICAgICAgeTogdGhpcy5jcmVhdGVBeGlzKClcbiAgICB9O1xuICB9XG59O1xuXG4vLyBzcmMvZG9tLWV2ZW50cy9zY3JvbGwvaW5kZXgudHNcbnZhciBzY3JvbGxMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciByZXNpemVMaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbnZhciBvblNjcm9sbEhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG52YXIgZ2V0VGFyZ2V0ID0gKGNvbnRhaW5lcikgPT4gY29udGFpbmVyID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyB3aW5kb3cgOiBjb250YWluZXI7XG52YXIgb25TY3JvbGwgPSAoY2FsbGJhY2ssIHsgY29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IH0gPSB7fSkgPT4ge1xuICBsZXQgY29udGFpbmVySGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChjb250YWluZXIpO1xuICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzKSB7XG4gICAgY29udGFpbmVySGFuZGxlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIG9uU2Nyb2xsSGFuZGxlcnMuc2V0KGNvbnRhaW5lciwgY29udGFpbmVySGFuZGxlcnMpO1xuICB9XG4gIGNvbnN0IGNvbnRhaW5lckhhbmRsZXIgPSBuZXcgU2Nyb2xsSGFuZGxlcihjYWxsYmFjaywgY29udGFpbmVyKTtcbiAgY29udGFpbmVySGFuZGxlcnMuYWRkKGNvbnRhaW5lckhhbmRsZXIpO1xuICBpZiAoIXNjcm9sbExpc3RlbmVycy5oYXMoY29udGFpbmVyKSkge1xuICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgY29udGFpbmVySGFuZGxlcnM/LmZvckVhY2goKGhhbmRsZXIpID0+IGhhbmRsZXIuYWR2YW5jZSgpKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgc2Nyb2xsTGlzdGVuZXJzLnNldChjb250YWluZXIsIGxpc3RlbmVyKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXQoY29udGFpbmVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBsaXN0ZW5lciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgIGlmIChjb250YWluZXIgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmVzaXplTGlzdGVuZXJzLnNldChjb250YWluZXIsIG9uUmVzaXplKGxpc3RlbmVyLCB7IGNvbnRhaW5lciB9KSk7XG4gICAgfVxuICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGxpc3RlbmVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gIH1cbiAgY29uc3QgYW5pbWF0ZVNjcm9sbCA9IHNjcm9sbExpc3RlbmVycy5nZXQoY29udGFpbmVyKTtcbiAgcmFmMyhhbmltYXRlU2Nyb2xsKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByYWYzLmNhbmNlbChhbmltYXRlU2Nyb2xsKTtcbiAgICBjb25zdCBjb250YWluZXJIYW5kbGVyczIgPSBvblNjcm9sbEhhbmRsZXJzLmdldChjb250YWluZXIpO1xuICAgIGlmICghY29udGFpbmVySGFuZGxlcnMyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnRhaW5lckhhbmRsZXJzMi5kZWxldGUoY29udGFpbmVySGFuZGxlcik7XG4gICAgaWYgKGNvbnRhaW5lckhhbmRsZXJzMi5zaXplKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gc2Nyb2xsTGlzdGVuZXJzLmdldChjb250YWluZXIpO1xuICAgIHNjcm9sbExpc3RlbmVycy5kZWxldGUoY29udGFpbmVyKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGdldFRhcmdldChjb250YWluZXIpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbGlzdGVuZXIpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbGlzdGVuZXIpO1xuICAgICAgcmVzaXplTGlzdGVuZXJzLmdldChjb250YWluZXIpPy4oKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlQ29uc3RhbnQudHNcbmltcG9ydCB7IHVzZVJlZiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlQ29uc3RhbnQoaW5pdCkge1xuICBjb25zdCByZWYgPSB1c2VSZWYobnVsbCk7XG4gIGlmIChyZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHJlZi5jdXJyZW50ID0gaW5pdCgpO1xuICB9XG4gIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZUZvcmNlVXBkYXRlLnRzXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaG9va3MvdXNlSXNNb3VudGVkLnRzXG5pbXBvcnQgeyB1c2VSZWYgYXMgdXNlUmVmMiB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyBzcmMvaG9va3MvdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdC50c1xuaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbnZhciB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gaXNTU1IoKSA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcblxuLy8gc3JjL2hvb2tzL3VzZUlzTW91bnRlZC50c1xudmFyIHVzZUlzTW91bnRlZCA9ICgpID0+IHtcbiAgY29uc3QgaXNNb3VudGVkID0gdXNlUmVmMihmYWxzZSk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaXNNb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBpc01vdW50ZWQ7XG59O1xuXG4vLyBzcmMvaG9va3MvdXNlRm9yY2VVcGRhdGUudHNcbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICBjb25zdCB1cGRhdGUgPSB1c2VTdGF0ZSgpWzFdO1xuICBjb25zdCBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgIHVwZGF0ZShNYXRoLnJhbmRvbSgpKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9ob29rcy91c2VNZW1vT25lLnRzXG5pbXBvcnQgeyB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlUmVmIGFzIHVzZVJlZjMsIHVzZVN0YXRlIGFzIHVzZVN0YXRlMiB9IGZyb20gXCJyZWFjdFwiO1xuZnVuY3Rpb24gdXNlTWVtb09uZShnZXRSZXN1bHQsIGlucHV0cykge1xuICBjb25zdCBbaW5pdGlhbF0gPSB1c2VTdGF0ZTIoXG4gICAgKCkgPT4gKHtcbiAgICAgIGlucHV0cyxcbiAgICAgIHJlc3VsdDogZ2V0UmVzdWx0KClcbiAgICB9KVxuICApO1xuICBjb25zdCBjb21taXR0ZWQgPSB1c2VSZWYzKCk7XG4gIGNvbnN0IHByZXZDYWNoZSA9IGNvbW1pdHRlZC5jdXJyZW50O1xuICBsZXQgY2FjaGUgPSBwcmV2Q2FjaGU7XG4gIGlmIChjYWNoZSkge1xuICAgIGNvbnN0IHVzZUNhY2hlID0gQm9vbGVhbihcbiAgICAgIGlucHV0cyAmJiBjYWNoZS5pbnB1dHMgJiYgYXJlSW5wdXRzRXF1YWwoaW5wdXRzLCBjYWNoZS5pbnB1dHMpXG4gICAgKTtcbiAgICBpZiAoIXVzZUNhY2hlKSB7XG4gICAgICBjYWNoZSA9IHtcbiAgICAgICAgaW5wdXRzLFxuICAgICAgICByZXN1bHQ6IGdldFJlc3VsdCgpXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjYWNoZSA9IGluaXRpYWw7XG4gIH1cbiAgdXNlRWZmZWN0MigoKSA9PiB7XG4gICAgY29tbWl0dGVkLmN1cnJlbnQgPSBjYWNoZTtcbiAgICBpZiAocHJldkNhY2hlID09IGluaXRpYWwpIHtcbiAgICAgIGluaXRpYWwuaW5wdXRzID0gaW5pdGlhbC5yZXN1bHQgPSB2b2lkIDA7XG4gICAgfVxuICB9LCBbY2FjaGVdKTtcbiAgcmV0dXJuIGNhY2hlLnJlc3VsdDtcbn1cbmZ1bmN0aW9uIGFyZUlucHV0c0VxdWFsKG5leHQsIHByZXYpIHtcbiAgaWYgKG5leHQubGVuZ3RoICE9PSBwcmV2Lmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5leHQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobmV4dFtpXSAhPT0gcHJldltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZU9uY2UudHNcbmltcG9ydCB7IHVzZUVmZmVjdCBhcyB1c2VFZmZlY3QzIH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlT25jZSA9IChlZmZlY3QpID0+IHVzZUVmZmVjdDMoZWZmZWN0LCBlbXB0eURlcHMpO1xudmFyIGVtcHR5RGVwcyA9IFtdO1xuXG4vLyBzcmMvaG9va3MvdXNlUHJldi50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdDQsIHVzZVJlZiBhcyB1c2VSZWY0IH0gZnJvbSBcInJlYWN0XCI7XG5mdW5jdGlvbiB1c2VQcmV2KHZhbHVlKSB7XG4gIGNvbnN0IHByZXZSZWYgPSB1c2VSZWY0KCk7XG4gIHVzZUVmZmVjdDQoKCkgPT4ge1xuICAgIHByZXZSZWYuY3VycmVudCA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHByZXZSZWYuY3VycmVudDtcbn1cblxuLy8gc3JjL2hvb2tzL3VzZVJlZHVjZWRNb3Rpb24udHNcbmltcG9ydCB7IHVzZVN0YXRlIGFzIHVzZVN0YXRlMyB9IGZyb20gXCJyZWFjdFwiO1xudmFyIHVzZVJlZHVjZWRNb3Rpb24gPSAoKSA9PiB7XG4gIGNvbnN0IFtyZWR1Y2VkTW90aW9uLCBzZXRSZWR1Y2VkTW90aW9uXSA9IHVzZVN0YXRlMyhudWxsKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgbXFsID0gd2luZG93Lm1hdGNoTWVkaWEoXCIocHJlZmVycy1yZWR1Y2VkLW1vdGlvbilcIik7XG4gICAgY29uc3QgaGFuZGxlTWVkaWFDaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgc2V0UmVkdWNlZE1vdGlvbihlLm1hdGNoZXMpO1xuICAgICAgYXNzaWduKHtcbiAgICAgICAgc2tpcEFuaW1hdGlvbjogZS5tYXRjaGVzXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGhhbmRsZU1lZGlhQ2hhbmdlKG1xbCk7XG4gICAgaWYgKG1xbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICBtcWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVNZWRpYUNoYW5nZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1xbC5hZGRMaXN0ZW5lcihoYW5kbGVNZWRpYUNoYW5nZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAobXFsLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgbXFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgaGFuZGxlTWVkaWFDaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbXFsLnJlbW92ZUxpc3RlbmVyKGhhbmRsZU1lZGlhQ2hhbmdlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiByZWR1Y2VkTW90aW9uO1xufTtcblxuLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyByYWYgYXMgcmFmNCB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3JhZnpcIjtcbmV4cG9ydCB7XG4gIEZsdWlkVmFsdWUsXG4gIGdsb2JhbHNfZXhwb3J0cyBhcyBHbG9iYWxzLFxuICBhZGRGbHVpZE9ic2VydmVyLFxuICBjYWxsRmx1aWRPYnNlcnZlcixcbiAgY2FsbEZsdWlkT2JzZXJ2ZXJzLFxuICBjbGFtcCxcbiAgY29sb3JUb1JnYmEsXG4gIGNvbG9yczIgYXMgY29sb3JzLFxuICBjcmVhdGVJbnRlcnBvbGF0b3IsXG4gIGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcjIgYXMgY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yLFxuICBkZWZpbmVIaWRkZW4sXG4gIGRlcHJlY2F0ZURpcmVjdENhbGwsXG4gIGRlcHJlY2F0ZUludGVycG9sYXRlLFxuICBlYWNoLFxuICBlYWNoUHJvcCxcbiAgZWFzaW5ncyxcbiAgZmx1c2gsXG4gIGZsdXNoQ2FsbHMsXG4gIGZyYW1lTG9vcCxcbiAgZ2V0Rmx1aWRPYnNlcnZlcnMsXG4gIGdldEZsdWlkVmFsdWUsXG4gIGhhc0ZsdWlkVmFsdWUsXG4gIGhleDMsXG4gIGhleDQsXG4gIGhleDYsXG4gIGhleDgsXG4gIGhzbCxcbiAgaHNsYSxcbiAgaXMsXG4gIGlzQW5pbWF0ZWRTdHJpbmcsXG4gIGlzRXF1YWwsXG4gIGlzU1NSLFxuICBub29wLFxuICBvblJlc2l6ZSxcbiAgb25TY3JvbGwsXG4gIG9uY2UsXG4gIHByZWZpeCxcbiAgcmFmNCBhcyByYWYsXG4gIHJlbW92ZUZsdWlkT2JzZXJ2ZXIsXG4gIHJnYixcbiAgcmdiYSxcbiAgc2V0Rmx1aWRHZXR0ZXIsXG4gIHRvQXJyYXksXG4gIHVzZUNvbnN0YW50LFxuICB1c2VGb3JjZVVwZGF0ZSxcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCxcbiAgdXNlTWVtb09uZSxcbiAgdXNlT25jZSxcbiAgdXNlUHJldixcbiAgdXNlUmVkdWNlZE1vdGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXNwcmluZ19zaGFyZWQubW9kZXJuLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-spring/three/dist/react-spring_three.modern.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@react-spring/three/dist/react-spring_three.modern.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Any: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.Any; },\n/* harmony export */   BailSignal: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.BailSignal; },\n/* harmony export */   Controller: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.Controller; },\n/* harmony export */   FrameValue: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.FrameValue; },\n/* harmony export */   Globals: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.Globals; },\n/* harmony export */   Interpolation: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.Interpolation; },\n/* harmony export */   Spring: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.Spring; },\n/* harmony export */   SpringContext: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.SpringContext; },\n/* harmony export */   SpringRef: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.SpringRef; },\n/* harmony export */   SpringValue: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.SpringValue; },\n/* harmony export */   Trail: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.Trail; },\n/* harmony export */   Transition: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.Transition; },\n/* harmony export */   a: function() { return /* binding */ animated; },\n/* harmony export */   animated: function() { return /* binding */ animated; },\n/* harmony export */   config: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.config; },\n/* harmony export */   createInterpolator: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.createInterpolator; },\n/* harmony export */   easings: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.easings; },\n/* harmony export */   inferTo: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.inferTo; },\n/* harmony export */   interpolate: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.interpolate; },\n/* harmony export */   to: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.to; },\n/* harmony export */   update: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.update; },\n/* harmony export */   useChain: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useChain; },\n/* harmony export */   useInView: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useInView; },\n/* harmony export */   useIsomorphicLayoutEffect: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useIsomorphicLayoutEffect; },\n/* harmony export */   useReducedMotion: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useReducedMotion; },\n/* harmony export */   useResize: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useResize; },\n/* harmony export */   useScroll: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useScroll; },\n/* harmony export */   useSpring: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useSpring; },\n/* harmony export */   useSpringRef: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useSpringRef; },\n/* harmony export */   useSpringValue: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useSpringValue; },\n/* harmony export */   useSprings: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useSprings; },\n/* harmony export */   useTrail: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useTrail; },\n/* harmony export */   useTransition: function() { return /* reexport safe */ _react_spring_core__WEBPACK_IMPORTED_MODULE_0__.useTransition; }\n/* harmony export */ });\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(app-pages-browser)/./node_modules/@react-three/fiber/dist/events-776716bd.esm.js\");\n/* harmony import */ var _react_spring_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @react-spring/core */ \"(app-pages-browser)/./node_modules/@react-spring/core/dist/react-spring_core.modern.mjs\");\n/* harmony import */ var _react_spring_shared__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-spring/shared */ \"(app-pages-browser)/./node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs\");\n/* harmony import */ var _react_spring_animated__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-spring/animated */ \"(app-pages-browser)/./node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(app-pages-browser)/./node_modules/three/build/three.module.js\");\n// src/index.ts\n\n\n\n\n\n// src/primitives.ts\n\n\nvar primitives = [\"primitive\"].concat(\n  Object.keys(three__WEBPACK_IMPORTED_MODULE_3__).filter((key) => /^[A-Z]/.test(key)).map((key) => key[0].toLowerCase() + key.slice(1))\n);\n\n// src/index.ts\n\n_react_spring_core__WEBPACK_IMPORTED_MODULE_0__.Globals.assign({\n  createStringInterpolator: _react_spring_shared__WEBPACK_IMPORTED_MODULE_1__.createStringInterpolator,\n  colors: _react_spring_shared__WEBPACK_IMPORTED_MODULE_1__.colors,\n  frameLoop: \"demand\"\n});\n(0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.o)(() => {\n  _react_spring_shared__WEBPACK_IMPORTED_MODULE_1__.raf.advance();\n});\nvar host = (0,_react_spring_animated__WEBPACK_IMPORTED_MODULE_2__.createHost)(primitives, {\n  // @ts-expect-error r3f related\n  applyAnimatedValues: _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.k\n});\nvar animated = host.animated;\n\n//# sourceMappingURL=react-spring_three.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3RocmVlL2Rpc3QvcmVhY3Qtc3ByaW5nX3RocmVlLm1vZGVybi5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMyRDtBQUNkO0FBQ2dDO0FBQ3pCOztBQUVwRDtBQUMrQjtBQUNIO0FBQzVCO0FBQ0EsY0FBYyxrQ0FBSztBQUNuQjs7QUFFQTtBQUNtQztBQUNuQyx1REFBTztBQUNQLDBCQUEwQjtBQUMxQixRQUFRO0FBQ1I7QUFDQSxDQUFDO0FBQ0QscURBQVM7QUFDVCxFQUFFLHFEQUFHO0FBQ0wsQ0FBQztBQUNELFdBQVcsa0VBQVU7QUFDckI7QUFDQSx1QkFBdUIsaURBQVU7QUFDakMsQ0FBQztBQUNEO0FBSUU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXNwcmluZy90aHJlZS9kaXN0L3JlYWN0LXNwcmluZ190aHJlZS5tb2Rlcm4ubWpzP2I3NTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBhcHBseVByb3BzLCBhZGRFZmZlY3QgfSBmcm9tIFwiQHJlYWN0LXRocmVlL2ZpYmVyXCI7XG5pbXBvcnQgeyBHbG9iYWxzIH0gZnJvbSBcIkByZWFjdC1zcHJpbmcvY29yZVwiO1xuaW1wb3J0IHsgY3JlYXRlU3RyaW5nSW50ZXJwb2xhdG9yLCBjb2xvcnMsIHJhZiB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL3NoYXJlZFwiO1xuaW1wb3J0IHsgY3JlYXRlSG9zdCB9IGZyb20gXCJAcmVhY3Qtc3ByaW5nL2FuaW1hdGVkXCI7XG5cbi8vIHNyYy9wcmltaXRpdmVzLnRzXG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tIFwidGhyZWVcIjtcbmltcG9ydCBcIkByZWFjdC10aHJlZS9maWJlclwiO1xudmFyIHByaW1pdGl2ZXMgPSBbXCJwcmltaXRpdmVcIl0uY29uY2F0KFxuICBPYmplY3Qua2V5cyhUSFJFRSkuZmlsdGVyKChrZXkpID0+IC9eW0EtWl0vLnRlc3Qoa2V5KSkubWFwKChrZXkpID0+IGtleVswXS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpKVxuKTtcblxuLy8gc3JjL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwiQHJlYWN0LXNwcmluZy9jb3JlXCI7XG5HbG9iYWxzLmFzc2lnbih7XG4gIGNyZWF0ZVN0cmluZ0ludGVycG9sYXRvcixcbiAgY29sb3JzLFxuICBmcmFtZUxvb3A6IFwiZGVtYW5kXCJcbn0pO1xuYWRkRWZmZWN0KCgpID0+IHtcbiAgcmFmLmFkdmFuY2UoKTtcbn0pO1xudmFyIGhvc3QgPSBjcmVhdGVIb3N0KHByaW1pdGl2ZXMsIHtcbiAgLy8gQHRzLWV4cGVjdC1lcnJvciByM2YgcmVsYXRlZFxuICBhcHBseUFuaW1hdGVkVmFsdWVzOiBhcHBseVByb3BzXG59KTtcbnZhciBhbmltYXRlZCA9IGhvc3QuYW5pbWF0ZWQ7XG5leHBvcnQge1xuICBhbmltYXRlZCBhcyBhLFxuICBhbmltYXRlZFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXNwcmluZ190aHJlZS5tb2Rlcm4ubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-spring/three/dist/react-spring_three.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@react-spring/types/dist/react-spring_types.modern.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@react-spring/types/dist/react-spring_types.modern.mjs ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Any: function() { return /* binding */ Any; }\n/* harmony export */ });\n// src/utils.ts\nvar Any = class {\n};\n\n//# sourceMappingURL=react-spring_types.modern.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcmVhY3Qtc3ByaW5nL3R5cGVzL2Rpc3QvcmVhY3Qtc3ByaW5nX3R5cGVzLm1vZGVybi5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUdFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC1zcHJpbmcvdHlwZXMvZGlzdC9yZWFjdC1zcHJpbmdfdHlwZXMubW9kZXJuLm1qcz8wYzM0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy91dGlscy50c1xudmFyIEFueSA9IGNsYXNzIHtcbn07XG5leHBvcnQge1xuICBBbnlcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1zcHJpbmdfdHlwZXMubW9kZXJuLm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@react-spring/types/dist/react-spring_types.modern.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/bidi-js/dist/bidi.mjs":
/*!********************************************!*\
  !*** ./node_modules/bidi-js/dist/bidi.mjs ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nfunction bidiFactory() {\nvar bidi = (function (exports) {\n\n  // Bidi character types data, auto generated\n  var DATA = {\n    \"R\": \"13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73\",\n    \"EN\": \"1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9\",\n    \"ES\": \"17,2,6dp+1,f+1,av,16vr,mx+1,4o,2\",\n    \"ET\": \"z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj\",\n    \"AN\": \"16o+5,2j+9,2+1,35,ed,1ff2+9,87+u\",\n    \"CS\": \"18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b\",\n    \"B\": \"a,3,f+2,2v,690\",\n    \"S\": \"9,2,k\",\n    \"WS\": \"c,k,4f4,1vk+a,u,1j,335\",\n    \"ON\": \"x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i\",\n    \"BN\": \"0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1\",\n    \"NSM\": \"lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n\",\n    \"AL\": \"16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d\",\n    \"LRO\": \"6ct\",\n    \"RLO\": \"6cu\",\n    \"LRE\": \"6cq\",\n    \"RLE\": \"6cr\",\n    \"PDF\": \"6cs\",\n    \"LRI\": \"6ee\",\n    \"RLI\": \"6ef\",\n    \"FSI\": \"6eg\",\n    \"PDI\": \"6eh\"\n  };\n\n  var TYPES = {};\n  var TYPES_TO_NAMES = {};\n  TYPES.L = 1; //L is the default\n  TYPES_TO_NAMES[1] = 'L';\n  Object.keys(DATA).forEach(function (type, i) {\n    TYPES[type] = 1 << (i + 1);\n    TYPES_TO_NAMES[TYPES[type]] = type;\n  });\n  Object.freeze(TYPES);\n\n  var ISOLATE_INIT_TYPES = TYPES.LRI | TYPES.RLI | TYPES.FSI;\n  var STRONG_TYPES = TYPES.L | TYPES.R | TYPES.AL;\n  var NEUTRAL_ISOLATE_TYPES = TYPES.B | TYPES.S | TYPES.WS | TYPES.ON | TYPES.FSI | TYPES.LRI | TYPES.RLI | TYPES.PDI;\n  var BN_LIKE_TYPES = TYPES.BN | TYPES.RLE | TYPES.LRE | TYPES.RLO | TYPES.LRO | TYPES.PDF;\n  var TRAILING_TYPES = TYPES.S | TYPES.WS | TYPES.B | ISOLATE_INIT_TYPES | TYPES.PDI | BN_LIKE_TYPES;\n\n  var map = null;\n\n  function parseData () {\n    if (!map) {\n      //const start = performance.now()\n      map = new Map();\n      var loop = function ( type ) {\n        if (DATA.hasOwnProperty(type)) {\n          var lastCode = 0;\n          DATA[type].split(',').forEach(function (range) {\n            var ref = range.split('+');\n            var skip = ref[0];\n            var step = ref[1];\n            skip = parseInt(skip, 36);\n            step = step ? parseInt(step, 36) : 0;\n            map.set(lastCode += skip, TYPES[type]);\n            for (var i = 0; i < step; i++) {\n              map.set(++lastCode, TYPES[type]);\n            }\n          });\n        }\n      };\n\n      for (var type in DATA) loop( type );\n      //console.log(`char types parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  /**\n   * @param {string} char\n   * @return {number}\n   */\n  function getBidiCharType (char) {\n    parseData();\n    return map.get(char.codePointAt(0)) || TYPES.L\n  }\n\n  function getBidiCharTypeName(char) {\n    return TYPES_TO_NAMES[getBidiCharType(char)]\n  }\n\n  // Bidi bracket pairs data, auto generated\n  var data$1 = {\n    \"pairs\": \"14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1\",\n    \"canonical\": \"6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye\"\n  };\n\n  /**\n   * Parses an string that holds encoded codepoint mappings, e.g. for bracket pairs or\n   * mirroring characters, as encoded by scripts/generateBidiData.js. Returns an object\n   * holding the `map`, and optionally a `reverseMap` if `includeReverse:true`.\n   * @param {string} encodedString\n   * @param {boolean} includeReverse - true if you want reverseMap in the output\n   * @return {{map: Map<number, number>, reverseMap?: Map<number, number>}}\n   */\n  function parseCharacterMap (encodedString, includeReverse) {\n    var radix = 36;\n    var lastCode = 0;\n    var map = new Map();\n    var reverseMap = includeReverse && new Map();\n    var prevPair;\n    encodedString.split(',').forEach(function visit(entry) {\n      if (entry.indexOf('+') !== -1) {\n        for (var i = +entry; i--;) {\n          visit(prevPair);\n        }\n      } else {\n        prevPair = entry;\n        var ref = entry.split('>');\n        var a = ref[0];\n        var b = ref[1];\n        a = String.fromCodePoint(lastCode += parseInt(a, radix));\n        b = String.fromCodePoint(lastCode += parseInt(b, radix));\n        map.set(a, b);\n        includeReverse && reverseMap.set(b, a);\n      }\n    });\n    return { map: map, reverseMap: reverseMap }\n  }\n\n  var openToClose, closeToOpen, canonical;\n\n  function parse$1 () {\n    if (!openToClose) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data$1.pairs, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      openToClose = map;\n      closeToOpen = reverseMap;\n      canonical = parseCharacterMap(data$1.canonical, false).map;\n      //console.log(`brackets parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function openingToClosingBracket (char) {\n    parse$1();\n    return openToClose.get(char) || null\n  }\n\n  function closingToOpeningBracket (char) {\n    parse$1();\n    return closeToOpen.get(char) || null\n  }\n\n  function getCanonicalBracket (char) {\n    parse$1();\n    return canonical.get(char) || null\n  }\n\n  // Local type aliases\n  var TYPE_L = TYPES.L;\n  var TYPE_R = TYPES.R;\n  var TYPE_EN = TYPES.EN;\n  var TYPE_ES = TYPES.ES;\n  var TYPE_ET = TYPES.ET;\n  var TYPE_AN = TYPES.AN;\n  var TYPE_CS = TYPES.CS;\n  var TYPE_B = TYPES.B;\n  var TYPE_S = TYPES.S;\n  var TYPE_ON = TYPES.ON;\n  var TYPE_BN = TYPES.BN;\n  var TYPE_NSM = TYPES.NSM;\n  var TYPE_AL = TYPES.AL;\n  var TYPE_LRO = TYPES.LRO;\n  var TYPE_RLO = TYPES.RLO;\n  var TYPE_LRE = TYPES.LRE;\n  var TYPE_RLE = TYPES.RLE;\n  var TYPE_PDF = TYPES.PDF;\n  var TYPE_LRI = TYPES.LRI;\n  var TYPE_RLI = TYPES.RLI;\n  var TYPE_FSI = TYPES.FSI;\n  var TYPE_PDI = TYPES.PDI;\n\n  /**\n   * @typedef {object} GetEmbeddingLevelsResult\n   * @property {{start, end, level}[]} paragraphs\n   * @property {Uint8Array} levels\n   */\n\n  /**\n   * This function applies the Bidirectional Algorithm to a string, returning the resolved embedding levels\n   * in a single Uint8Array plus a list of objects holding each paragraph's start and end indices and resolved\n   * base embedding level.\n   *\n   * @param {string} string - The input string\n   * @param {\"ltr\"|\"rtl\"|\"auto\"} [baseDirection] - Use \"ltr\" or \"rtl\" to force a base paragraph direction,\n   *        otherwise a direction will be chosen automatically from each paragraph's contents.\n   * @return {GetEmbeddingLevelsResult}\n   */\n  function getEmbeddingLevels (string, baseDirection) {\n    var MAX_DEPTH = 125;\n\n    // Start by mapping all characters to their unicode type, as a bitmask integer\n    var charTypes = new Uint32Array(string.length);\n    for (var i = 0; i < string.length; i++) {\n      charTypes[i] = getBidiCharType(string[i]);\n    }\n\n    var charTypeCounts = new Map(); //will be cleared at start of each paragraph\n    function changeCharType(i, type) {\n      var oldType = charTypes[i];\n      charTypes[i] = type;\n      charTypeCounts.set(oldType, charTypeCounts.get(oldType) - 1);\n      if (oldType & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) - 1);\n      }\n      charTypeCounts.set(type, (charTypeCounts.get(type) || 0) + 1);\n      if (type & NEUTRAL_ISOLATE_TYPES) {\n        charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n      }\n    }\n\n    var embedLevels = new Uint8Array(string.length);\n    var isolationPairs = new Map(); //init->pdi and pdi->init\n\n    // === 3.3.1 The Paragraph Level ===\n    // 3.3.1 P1: Split the text into paragraphs\n    var paragraphs = []; // [{start, end, level}, ...]\n    var paragraph = null;\n    for (var i$1 = 0; i$1 < string.length; i$1++) {\n      if (!paragraph) {\n        paragraphs.push(paragraph = {\n          start: i$1,\n          end: string.length - 1,\n          // 3.3.1 P2-P3: Determine the paragraph level\n          level: baseDirection === 'rtl' ? 1 : baseDirection === 'ltr' ? 0 : determineAutoEmbedLevel(i$1, false)\n        });\n      }\n      if (charTypes[i$1] & TYPE_B) {\n        paragraph.end = i$1;\n        paragraph = null;\n      }\n    }\n\n    var FORMATTING_TYPES = TYPE_RLE | TYPE_LRE | TYPE_RLO | TYPE_LRO | ISOLATE_INIT_TYPES | TYPE_PDI | TYPE_PDF | TYPE_B;\n    var nextEven = function (n) { return n + ((n & 1) ? 1 : 2); };\n    var nextOdd = function (n) { return n + ((n & 1) ? 2 : 1); };\n\n    // Everything from here on will operate per paragraph.\n    for (var paraIdx = 0; paraIdx < paragraphs.length; paraIdx++) {\n      paragraph = paragraphs[paraIdx];\n      var statusStack = [{\n        _level: paragraph.level,\n        _override: 0, //0=neutral, 1=L, 2=R\n        _isolate: 0 //bool\n      }];\n      var stackTop = (void 0);\n      var overflowIsolateCount = 0;\n      var overflowEmbeddingCount = 0;\n      var validIsolateCount = 0;\n      charTypeCounts.clear();\n\n      // === 3.3.2 Explicit Levels and Directions ===\n      for (var i$2 = paragraph.start; i$2 <= paragraph.end; i$2++) {\n        var charType = charTypes[i$2];\n        stackTop = statusStack[statusStack.length - 1];\n\n        // Set initial counts\n        charTypeCounts.set(charType, (charTypeCounts.get(charType) || 0) + 1);\n        if (charType & NEUTRAL_ISOLATE_TYPES) {\n          charTypeCounts.set(NEUTRAL_ISOLATE_TYPES, (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES) || 0) + 1);\n        }\n\n        // Explicit Embeddings: 3.3.2 X2 - X3\n        if (charType & FORMATTING_TYPES) { //prefilter all formatters\n          if (charType & (TYPE_RLE | TYPE_LRE)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level = (charType === TYPE_RLE ? nextOdd : nextEven)(stackTop._level);\n            if (level <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level,\n                _override: 0,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Explicit Overrides: 3.3.2 X4 - X5\n          else if (charType & (TYPE_RLO | TYPE_LRO)) {\n            embedLevels[i$2] = stackTop._level; // 5.2\n            var level$1 = (charType === TYPE_RLO ? nextOdd : nextEven)(stackTop._level);\n            if (level$1 <= MAX_DEPTH && !overflowIsolateCount && !overflowEmbeddingCount) {\n              statusStack.push({\n                _level: level$1,\n                _override: (charType & TYPE_RLO) ? TYPE_R : TYPE_L,\n                _isolate: 0\n              });\n            } else if (!overflowIsolateCount) {\n              overflowEmbeddingCount++;\n            }\n          }\n\n          // Isolates: 3.3.2 X5a - X5c\n          else if (charType & ISOLATE_INIT_TYPES) {\n            // X5c - FSI becomes either RLI or LRI\n            if (charType & TYPE_FSI) {\n              charType = determineAutoEmbedLevel(i$2 + 1, true) === 1 ? TYPE_RLI : TYPE_LRI;\n            }\n\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n            var level$2 = (charType === TYPE_RLI ? nextOdd : nextEven)(stackTop._level);\n            if (level$2 <= MAX_DEPTH && overflowIsolateCount === 0 && overflowEmbeddingCount === 0) {\n              validIsolateCount++;\n              statusStack.push({\n                _level: level$2,\n                _override: 0,\n                _isolate: 1,\n                _isolInitIndex: i$2\n              });\n            } else {\n              overflowIsolateCount++;\n            }\n          }\n\n          // Terminating Isolates: 3.3.2 X6a\n          else if (charType & TYPE_PDI) {\n            if (overflowIsolateCount > 0) {\n              overflowIsolateCount--;\n            } else if (validIsolateCount > 0) {\n              overflowEmbeddingCount = 0;\n              while (!statusStack[statusStack.length - 1]._isolate) {\n                statusStack.pop();\n              }\n              // Add to isolation pairs bidirectional mapping:\n              var isolInitIndex = statusStack[statusStack.length - 1]._isolInitIndex;\n              if (isolInitIndex != null) {\n                isolationPairs.set(isolInitIndex, i$2);\n                isolationPairs.set(i$2, isolInitIndex);\n              }\n              statusStack.pop();\n              validIsolateCount--;\n            }\n            stackTop = statusStack[statusStack.length - 1];\n            embedLevels[i$2] = stackTop._level;\n            if (stackTop._override) {\n              changeCharType(i$2, stackTop._override);\n            }\n          }\n\n\n          // Terminating Embeddings and Overrides: 3.3.2 X7\n          else if (charType & TYPE_PDF) {\n            if (overflowIsolateCount === 0) {\n              if (overflowEmbeddingCount > 0) {\n                overflowEmbeddingCount--;\n              } else if (!stackTop._isolate && statusStack.length > 1) {\n                statusStack.pop();\n                stackTop = statusStack[statusStack.length - 1];\n              }\n            }\n            embedLevels[i$2] = stackTop._level; // 5.2\n          }\n\n          // End of Paragraph: 3.3.2 X8\n          else if (charType & TYPE_B) {\n            embedLevels[i$2] = paragraph.level;\n          }\n        }\n\n        // Non-formatting characters: 3.3.2 X6\n        else {\n          embedLevels[i$2] = stackTop._level;\n          // NOTE: This exclusion of BN seems to go against what section 5.2 says, but is required for test passage\n          if (stackTop._override && charType !== TYPE_BN) {\n            changeCharType(i$2, stackTop._override);\n          }\n        }\n      }\n\n      // === 3.3.3 Preparations for Implicit Processing ===\n\n      // Remove all RLE, LRE, RLO, LRO, PDF, and BN characters: 3.3.3 X9\n      // Note: Due to section 5.2, we won't remove them, but we'll use the BN_LIKE_TYPES bitset to\n      // easily ignore them all from here on out.\n\n      // 3.3.3 X10\n      // Compute the set of isolating run sequences as specified by BD13\n      var levelRuns = [];\n      var currentRun = null;\n      for (var i$3 = paragraph.start; i$3 <= paragraph.end; i$3++) {\n        var charType$1 = charTypes[i$3];\n        if (!(charType$1 & BN_LIKE_TYPES)) {\n          var lvl = embedLevels[i$3];\n          var isIsolInit = charType$1 & ISOLATE_INIT_TYPES;\n          var isPDI = charType$1 === TYPE_PDI;\n          if (currentRun && lvl === currentRun._level) {\n            currentRun._end = i$3;\n            currentRun._endsWithIsolInit = isIsolInit;\n          } else {\n            levelRuns.push(currentRun = {\n              _start: i$3,\n              _end: i$3,\n              _level: lvl,\n              _startsWithPDI: isPDI,\n              _endsWithIsolInit: isIsolInit\n            });\n          }\n        }\n      }\n      var isolatingRunSeqs = []; // [{seqIndices: [], sosType: L|R, eosType: L|R}]\n      for (var runIdx = 0; runIdx < levelRuns.length; runIdx++) {\n        var run = levelRuns[runIdx];\n        if (!run._startsWithPDI || (run._startsWithPDI && !isolationPairs.has(run._start))) {\n          var seqRuns = [currentRun = run];\n          for (var pdiIndex = (void 0); currentRun && currentRun._endsWithIsolInit && (pdiIndex = isolationPairs.get(currentRun._end)) != null;) {\n            for (var i$4 = runIdx + 1; i$4 < levelRuns.length; i$4++) {\n              if (levelRuns[i$4]._start === pdiIndex) {\n                seqRuns.push(currentRun = levelRuns[i$4]);\n                break\n              }\n            }\n          }\n          // build flat list of indices across all runs:\n          var seqIndices = [];\n          for (var i$5 = 0; i$5 < seqRuns.length; i$5++) {\n            var run$1 = seqRuns[i$5];\n            for (var j = run$1._start; j <= run$1._end; j++) {\n              seqIndices.push(j);\n            }\n          }\n          // determine the sos/eos types:\n          var firstLevel = embedLevels[seqIndices[0]];\n          var prevLevel = paragraph.level;\n          for (var i$6 = seqIndices[0] - 1; i$6 >= 0; i$6--) {\n            if (!(charTypes[i$6] & BN_LIKE_TYPES)) { //5.2\n              prevLevel = embedLevels[i$6];\n              break\n            }\n          }\n          var lastIndex = seqIndices[seqIndices.length - 1];\n          var lastLevel = embedLevels[lastIndex];\n          var nextLevel = paragraph.level;\n          if (!(charTypes[lastIndex] & ISOLATE_INIT_TYPES)) {\n            for (var i$7 = lastIndex + 1; i$7 <= paragraph.end; i$7++) {\n              if (!(charTypes[i$7] & BN_LIKE_TYPES)) { //5.2\n                nextLevel = embedLevels[i$7];\n                break\n              }\n            }\n          }\n          isolatingRunSeqs.push({\n            _seqIndices: seqIndices,\n            _sosType: Math.max(prevLevel, firstLevel) % 2 ? TYPE_R : TYPE_L,\n            _eosType: Math.max(nextLevel, lastLevel) % 2 ? TYPE_R : TYPE_L\n          });\n        }\n      }\n\n      // The next steps are done per isolating run sequence\n      for (var seqIdx = 0; seqIdx < isolatingRunSeqs.length; seqIdx++) {\n        var ref = isolatingRunSeqs[seqIdx];\n        var seqIndices$1 = ref._seqIndices;\n        var sosType = ref._sosType;\n        var eosType = ref._eosType;\n        /**\n         * All the level runs in an isolating run sequence have the same embedding level.\n         * \n         * DO NOT change any `embedLevels[i]` within the current scope.\n         */\n        var embedDirection = ((embedLevels[seqIndices$1[0]]) & 1) ? TYPE_R : TYPE_L;\n\n        // === 3.3.4 Resolving Weak Types ===\n\n        // W1 + 5.2. Search backward from each NSM to the first character in the isolating run sequence whose\n        // bidirectional type is not BN, and set the NSM to ON if it is an isolate initiator or PDI, and to its\n        // type otherwise. If the NSM is the first non-BN character, change the NSM to the type of sos.\n        if (charTypeCounts.get(TYPE_NSM)) {\n          for (var si = 0; si < seqIndices$1.length; si++) {\n            var i$8 = seqIndices$1[si];\n            if (charTypes[i$8] & TYPE_NSM) {\n              var prevType = sosType;\n              for (var sj = si - 1; sj >= 0; sj--) {\n                if (!(charTypes[seqIndices$1[sj]] & BN_LIKE_TYPES)) { //5.2 scan back to first non-BN\n                  prevType = charTypes[seqIndices$1[sj]];\n                  break\n                }\n              }\n              changeCharType(i$8, (prevType & (ISOLATE_INIT_TYPES | TYPE_PDI)) ? TYPE_ON : prevType);\n            }\n          }\n        }\n\n        // W2. Search backward from each instance of a European number until the first strong type (R, L, AL, or sos)\n        // is found. If an AL is found, change the type of the European number to Arabic number.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$1 = 0; si$1 < seqIndices$1.length; si$1++) {\n            var i$9 = seqIndices$1[si$1];\n            if (charTypes[i$9] & TYPE_EN) {\n              for (var sj$1 = si$1 - 1; sj$1 >= -1; sj$1--) {\n                var prevCharType = sj$1 === -1 ? sosType : charTypes[seqIndices$1[sj$1]];\n                if (prevCharType & STRONG_TYPES) {\n                  if (prevCharType === TYPE_AL) {\n                    changeCharType(i$9, TYPE_AN);\n                  }\n                  break\n                }\n              }\n            }\n          }\n        }\n\n        // W3. Change all ALs to R\n        if (charTypeCounts.get(TYPE_AL)) {\n          for (var si$2 = 0; si$2 < seqIndices$1.length; si$2++) {\n            var i$10 = seqIndices$1[si$2];\n            if (charTypes[i$10] & TYPE_AL) {\n              changeCharType(i$10, TYPE_R);\n            }\n          }\n        }\n\n        // W4. A single European separator between two European numbers changes to a European number. A single common\n        // separator between two numbers of the same type changes to that type.\n        if (charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$3 = 1; si$3 < seqIndices$1.length - 1; si$3++) {\n            var i$11 = seqIndices$1[si$3];\n            if (charTypes[i$11] & (TYPE_ES | TYPE_CS)) {\n              var prevType$1 = 0, nextType = 0;\n              for (var sj$2 = si$3 - 1; sj$2 >= 0; sj$2--) {\n                prevType$1 = charTypes[seqIndices$1[sj$2]];\n                if (!(prevType$1 & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              for (var sj$3 = si$3 + 1; sj$3 < seqIndices$1.length; sj$3++) {\n                nextType = charTypes[seqIndices$1[sj$3]];\n                if (!(nextType & BN_LIKE_TYPES)) { //5.2\n                  break\n                }\n              }\n              if (prevType$1 === nextType && (charTypes[i$11] === TYPE_ES ? prevType$1 === TYPE_EN : (prevType$1 & (TYPE_EN | TYPE_AN)))) {\n                changeCharType(i$11, prevType$1);\n              }\n            }\n          }\n        }\n\n        // W5. A sequence of European terminators adjacent to European numbers changes to all European numbers.\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$4 = 0; si$4 < seqIndices$1.length; si$4++) {\n            var i$12 = seqIndices$1[si$4];\n            if (charTypes[i$12] & TYPE_EN) {\n              for (var sj$4 = si$4 - 1; sj$4 >= 0 && (charTypes[seqIndices$1[sj$4]] & (TYPE_ET | BN_LIKE_TYPES)); sj$4--) {\n                changeCharType(seqIndices$1[sj$4], TYPE_EN);\n              }\n              for (si$4++; si$4 < seqIndices$1.length && (charTypes[seqIndices$1[si$4]] & (TYPE_ET | BN_LIKE_TYPES | TYPE_EN)); si$4++) {\n                if (charTypes[seqIndices$1[si$4]] !== TYPE_EN) {\n                  changeCharType(seqIndices$1[si$4], TYPE_EN);\n                }\n              }\n            }\n          }\n        }\n\n        // W6. Otherwise, separators and terminators change to Other Neutral.\n        if (charTypeCounts.get(TYPE_ET) || charTypeCounts.get(TYPE_ES) || charTypeCounts.get(TYPE_CS)) {\n          for (var si$5 = 0; si$5 < seqIndices$1.length; si$5++) {\n            var i$13 = seqIndices$1[si$5];\n            if (charTypes[i$13] & (TYPE_ET | TYPE_ES | TYPE_CS)) {\n              changeCharType(i$13, TYPE_ON);\n              // 5.2 transform adjacent BNs too:\n              for (var sj$5 = si$5 - 1; sj$5 >= 0 && (charTypes[seqIndices$1[sj$5]] & BN_LIKE_TYPES); sj$5--) {\n                changeCharType(seqIndices$1[sj$5], TYPE_ON);\n              }\n              for (var sj$6 = si$5 + 1; sj$6 < seqIndices$1.length && (charTypes[seqIndices$1[sj$6]] & BN_LIKE_TYPES); sj$6++) {\n                changeCharType(seqIndices$1[sj$6], TYPE_ON);\n              }\n            }\n          }\n        }\n\n        // W7. Search backward from each instance of a European number until the first strong type (R, L, or sos)\n        // is found. If an L is found, then change the type of the European number to L.\n        // NOTE: implemented in single forward pass for efficiency\n        if (charTypeCounts.get(TYPE_EN)) {\n          for (var si$6 = 0, prevStrongType = sosType; si$6 < seqIndices$1.length; si$6++) {\n            var i$14 = seqIndices$1[si$6];\n            var type = charTypes[i$14];\n            if (type & TYPE_EN) {\n              if (prevStrongType === TYPE_L) {\n                changeCharType(i$14, TYPE_L);\n              }\n            } else if (type & STRONG_TYPES) {\n              prevStrongType = type;\n            }\n          }\n        }\n\n        // === 3.3.5 Resolving Neutral and Isolate Formatting Types ===\n\n        if (charTypeCounts.get(NEUTRAL_ISOLATE_TYPES)) {\n          // N0. Process bracket pairs in an isolating run sequence sequentially in the logical order of the text\n          // positions of the opening paired brackets using the logic given below. Within this scope, bidirectional\n          // types EN and AN are treated as R.\n          var R_TYPES_FOR_N_STEPS = (TYPE_R | TYPE_EN | TYPE_AN);\n          var STRONG_TYPES_FOR_N_STEPS = R_TYPES_FOR_N_STEPS | TYPE_L;\n\n          // * Identify the bracket pairs in the current isolating run sequence according to BD16.\n          var bracketPairs = [];\n          {\n            var openerStack = [];\n            for (var si$7 = 0; si$7 < seqIndices$1.length; si$7++) {\n              // NOTE: for any potential bracket character we also test that it still carries a NI\n              // type, as that may have been changed earlier. This doesn't seem to be explicitly\n              // called out in the spec, but is required for passage of certain tests.\n              if (charTypes[seqIndices$1[si$7]] & NEUTRAL_ISOLATE_TYPES) {\n                var char = string[seqIndices$1[si$7]];\n                var oppositeBracket = (void 0);\n                // Opening bracket\n                if (openingToClosingBracket(char) !== null) {\n                  if (openerStack.length < 63) {\n                    openerStack.push({ char: char, seqIndex: si$7 });\n                  } else {\n                    break\n                  }\n                }\n                // Closing bracket\n                else if ((oppositeBracket = closingToOpeningBracket(char)) !== null) {\n                  for (var stackIdx = openerStack.length - 1; stackIdx >= 0; stackIdx--) {\n                    var stackChar = openerStack[stackIdx].char;\n                    if (stackChar === oppositeBracket ||\n                      stackChar === closingToOpeningBracket(getCanonicalBracket(char)) ||\n                      openingToClosingBracket(getCanonicalBracket(stackChar)) === char\n                    ) {\n                      bracketPairs.push([openerStack[stackIdx].seqIndex, si$7]);\n                      openerStack.length = stackIdx; //pop the matching bracket and all following\n                      break\n                    }\n                  }\n                }\n              }\n            }\n            bracketPairs.sort(function (a, b) { return a[0] - b[0]; });\n          }\n          // * For each bracket-pair element in the list of pairs of text positions\n          for (var pairIdx = 0; pairIdx < bracketPairs.length; pairIdx++) {\n            var ref$1 = bracketPairs[pairIdx];\n            var openSeqIdx = ref$1[0];\n            var closeSeqIdx = ref$1[1];\n            // a. Inspect the bidirectional types of the characters enclosed within the bracket pair.\n            // b. If any strong type (either L or R) matching the embedding direction is found, set the type for both\n            // brackets in the pair to match the embedding direction.\n            var foundStrongType = false;\n            var useStrongType = 0;\n            for (var si$8 = openSeqIdx + 1; si$8 < closeSeqIdx; si$8++) {\n              var i$15 = seqIndices$1[si$8];\n              if (charTypes[i$15] & STRONG_TYPES_FOR_N_STEPS) {\n                foundStrongType = true;\n                var lr = (charTypes[i$15] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                if (lr === embedDirection) {\n                  useStrongType = lr;\n                  break\n                }\n              }\n            }\n            // c. Otherwise, if there is a strong type it must be opposite the embedding direction. Therefore, test\n            // for an established context with a preceding strong type by checking backwards before the opening paired\n            // bracket until the first strong type (L, R, or sos) is found.\n            //    1. If the preceding strong type is also opposite the embedding direction, context is established, so\n            //    set the type for both brackets in the pair to that direction.\n            //    2. Otherwise set the type for both brackets in the pair to the embedding direction.\n            if (foundStrongType && !useStrongType) {\n              useStrongType = sosType;\n              for (var si$9 = openSeqIdx - 1; si$9 >= 0; si$9--) {\n                var i$16 = seqIndices$1[si$9];\n                if (charTypes[i$16] & STRONG_TYPES_FOR_N_STEPS) {\n                  var lr$1 = (charTypes[i$16] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  if (lr$1 !== embedDirection) {\n                    useStrongType = lr$1;\n                  } else {\n                    useStrongType = embedDirection;\n                  }\n                  break\n                }\n              }\n            }\n            if (useStrongType) {\n              charTypes[seqIndices$1[openSeqIdx]] = charTypes[seqIndices$1[closeSeqIdx]] = useStrongType;\n              // * Any number of characters that had original bidirectional character type NSM prior to the application\n              // of W1 that immediately follow a paired bracket which changed to L or R under N0 should change to match\n              // the type of their preceding bracket.\n              if (useStrongType !== embedDirection) {\n                for (var si$10 = openSeqIdx + 1; si$10 < seqIndices$1.length; si$10++) {\n                  if (!(charTypes[seqIndices$1[si$10]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$10]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$10]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n              if (useStrongType !== embedDirection) {\n                for (var si$11 = closeSeqIdx + 1; si$11 < seqIndices$1.length; si$11++) {\n                  if (!(charTypes[seqIndices$1[si$11]] & BN_LIKE_TYPES)) {\n                    if (getBidiCharType(string[seqIndices$1[si$11]]) & TYPE_NSM) {\n                      charTypes[seqIndices$1[si$11]] = useStrongType;\n                    }\n                    break\n                  }\n                }\n              }\n            }\n          }\n\n          // N1. A sequence of NIs takes the direction of the surrounding strong text if the text on both sides has the\n          // same direction.\n          // N2. Any remaining NIs take the embedding direction.\n          for (var si$12 = 0; si$12 < seqIndices$1.length; si$12++) {\n            if (charTypes[seqIndices$1[si$12]] & NEUTRAL_ISOLATE_TYPES) {\n              var niRunStart = si$12, niRunEnd = si$12;\n              var prevType$2 = sosType; //si === 0 ? sosType : (charTypes[seqIndices[si - 1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L\n              for (var si2 = si$12 - 1; si2 >= 0; si2--) {\n                if (charTypes[seqIndices$1[si2]] & BN_LIKE_TYPES) {\n                  niRunStart = si2; //5.2 treat BNs adjacent to NIs as NIs\n                } else {\n                  prevType$2 = (charTypes[seqIndices$1[si2]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              var nextType$1 = eosType;\n              for (var si2$1 = si$12 + 1; si2$1 < seqIndices$1.length; si2$1++) {\n                if (charTypes[seqIndices$1[si2$1]] & (NEUTRAL_ISOLATE_TYPES | BN_LIKE_TYPES)) {\n                  niRunEnd = si2$1;\n                } else {\n                  nextType$1 = (charTypes[seqIndices$1[si2$1]] & R_TYPES_FOR_N_STEPS) ? TYPE_R : TYPE_L;\n                  break\n                }\n              }\n              for (var sj$7 = niRunStart; sj$7 <= niRunEnd; sj$7++) {\n                charTypes[seqIndices$1[sj$7]] = prevType$2 === nextType$1 ? prevType$2 : embedDirection;\n              }\n              si$12 = niRunEnd;\n            }\n          }\n        }\n      }\n\n      // === 3.3.6 Resolving Implicit Levels ===\n\n      for (var i$17 = paragraph.start; i$17 <= paragraph.end; i$17++) {\n        var level$3 = embedLevels[i$17];\n        var type$1 = charTypes[i$17];\n        // I2. For all characters with an odd (right-to-left) embedding level, those of type L, EN or AN go up one level.\n        if (level$3 & 1) {\n          if (type$1 & (TYPE_L | TYPE_EN | TYPE_AN)) {\n            embedLevels[i$17]++;\n          }\n        }\n          // I1. For all characters with an even (left-to-right) embedding level, those of type R go up one level\n        // and those of type AN or EN go up two levels.\n        else {\n          if (type$1 & TYPE_R) {\n            embedLevels[i$17]++;\n          } else if (type$1 & (TYPE_AN | TYPE_EN)) {\n            embedLevels[i$17] += 2;\n          }\n        }\n\n        // 5.2: Resolve any LRE, RLE, LRO, RLO, PDF, or BN to the level of the preceding character if there is one,\n        // and otherwise to the base level.\n        if (type$1 & BN_LIKE_TYPES) {\n          embedLevels[i$17] = i$17 === 0 ? paragraph.level : embedLevels[i$17 - 1];\n        }\n\n        // 3.4 L1.1-4: Reset the embedding level of segment/paragraph separators, and any sequence of whitespace or\n        // isolate formatting characters preceding them or the end of the paragraph, to the paragraph level.\n        // NOTE: this will also need to be applied to each individual line ending after line wrapping occurs.\n        if (i$17 === paragraph.end || getBidiCharType(string[i$17]) & (TYPE_S | TYPE_B)) {\n          for (var j$1 = i$17; j$1 >= 0 && (getBidiCharType(string[j$1]) & TRAILING_TYPES); j$1--) {\n            embedLevels[j$1] = paragraph.level;\n          }\n        }\n      }\n    }\n\n    // DONE! The resolved levels can then be used, after line wrapping, to flip runs of characters\n    // according to section 3.4 Reordering Resolved Levels\n    return {\n      levels: embedLevels,\n      paragraphs: paragraphs\n    }\n\n    function determineAutoEmbedLevel (start, isFSI) {\n      // 3.3.1 P2 - P3\n      for (var i = start; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & (TYPE_R | TYPE_AL)) {\n          return 1\n        }\n        if ((charType & (TYPE_B | TYPE_L)) || (isFSI && charType === TYPE_PDI)) {\n          return 0\n        }\n        if (charType & ISOLATE_INIT_TYPES) {\n          var pdi = indexOfMatchingPDI(i);\n          i = pdi === -1 ? string.length : pdi;\n        }\n      }\n      return 0\n    }\n\n    function indexOfMatchingPDI (isolateStart) {\n      // 3.1.2 BD9\n      var isolationLevel = 1;\n      for (var i = isolateStart + 1; i < string.length; i++) {\n        var charType = charTypes[i];\n        if (charType & TYPE_B) {\n          break\n        }\n        if (charType & TYPE_PDI) {\n          if (--isolationLevel === 0) {\n            return i\n          }\n        } else if (charType & ISOLATE_INIT_TYPES) {\n          isolationLevel++;\n        }\n      }\n      return -1\n    }\n  }\n\n  // Bidi mirrored chars data, auto generated\n  var data = \"14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1\";\n\n  var mirrorMap;\n\n  function parse () {\n    if (!mirrorMap) {\n      //const start = performance.now()\n      var ref = parseCharacterMap(data, true);\n      var map = ref.map;\n      var reverseMap = ref.reverseMap;\n      // Combine both maps into one\n      reverseMap.forEach(function (value, key) {\n        map.set(key, value);\n      });\n      mirrorMap = map;\n      //console.log(`mirrored chars parsed in ${performance.now() - start}ms`)\n    }\n  }\n\n  function getMirroredCharacter (char) {\n    parse();\n    return mirrorMap.get(char) || null\n  }\n\n  /**\n   * Given a string and its resolved embedding levels, build a map of indices to replacement chars\n   * for any characters in right-to-left segments that have defined mirrored characters.\n   * @param string\n   * @param embeddingLevels\n   * @param [start]\n   * @param [end]\n   * @return {Map<number, string>}\n   */\n  function getMirroredCharactersMap(string, embeddingLevels, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var map = new Map();\n    for (var i = start; i <= end; i++) {\n      if (embeddingLevels[i] & 1) { //only odd (rtl) levels\n        var mirror = getMirroredCharacter(string[i]);\n        if (mirror !== null) {\n          map.set(i, mirror);\n        }\n      }\n    }\n    return map\n  }\n\n  /**\n   * Given a start and end denoting a single line within a string, and a set of precalculated\n   * bidi embedding levels, produce a list of segments whose ordering should be flipped, in sequence.\n   * @param {string} string - the full input string\n   * @param {GetEmbeddingLevelsResult} embeddingLevelsResult - the result object from getEmbeddingLevels\n   * @param {number} [start] - first character in a subset of the full string\n   * @param {number} [end] - last character in a subset of the full string\n   * @return {number[][]} - the list of start/end segments that should be flipped, in order.\n   */\n  function getReorderSegments(string, embeddingLevelsResult, start, end) {\n    var strLen = string.length;\n    start = Math.max(0, start == null ? 0 : +start);\n    end = Math.min(strLen - 1, end == null ? strLen - 1 : +end);\n\n    var segments = [];\n    embeddingLevelsResult.paragraphs.forEach(function (paragraph) {\n      var lineStart = Math.max(start, paragraph.start);\n      var lineEnd = Math.min(end, paragraph.end);\n      if (lineStart < lineEnd) {\n        // Local slice for mutation\n        var lineLevels = embeddingLevelsResult.levels.slice(lineStart, lineEnd + 1);\n\n        // 3.4 L1.4: Reset any sequence of whitespace characters and/or isolate formatting characters at the\n        // end of the line to the paragraph level.\n        for (var i = lineEnd; i >= lineStart && (getBidiCharType(string[i]) & TRAILING_TYPES); i--) {\n          lineLevels[i] = paragraph.level;\n        }\n\n        // L2. From the highest level found in the text to the lowest odd level on each line, including intermediate levels\n        // not actually present in the text, reverse any contiguous sequence of characters that are at that level or higher.\n        var maxLevel = paragraph.level;\n        var minOddLevel = Infinity;\n        for (var i$1 = 0; i$1 < lineLevels.length; i$1++) {\n          var level = lineLevels[i$1];\n          if (level > maxLevel) { maxLevel = level; }\n          if (level < minOddLevel) { minOddLevel = level | 1; }\n        }\n        for (var lvl = maxLevel; lvl >= minOddLevel; lvl--) {\n          for (var i$2 = 0; i$2 < lineLevels.length; i$2++) {\n            if (lineLevels[i$2] >= lvl) {\n              var segStart = i$2;\n              while (i$2 + 1 < lineLevels.length && lineLevels[i$2 + 1] >= lvl) {\n                i$2++;\n              }\n              if (i$2 > segStart) {\n                segments.push([segStart + lineStart, i$2 + lineStart]);\n              }\n            }\n          }\n        }\n      }\n    });\n    return segments\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {string} the new string with bidi segments reordered\n   */\n  function getReorderedString(string, embedLevelsResult, start, end) {\n    var indices = getReorderedIndices(string, embedLevelsResult, start, end);\n    var chars = [].concat( string );\n    indices.forEach(function (charIndex, i) {\n      chars[i] = (\n        (embedLevelsResult.levels[charIndex] & 1) ? getMirroredCharacter(string[charIndex]) : null\n      ) || string[charIndex];\n    });\n    return chars.join('')\n  }\n\n  /**\n   * @param {string} string\n   * @param {GetEmbeddingLevelsResult} embedLevelsResult\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {number[]} an array with character indices in their new bidi order\n   */\n  function getReorderedIndices(string, embedLevelsResult, start, end) {\n    var segments = getReorderSegments(string, embedLevelsResult, start, end);\n    // Fill an array with indices\n    var indices = [];\n    for (var i = 0; i < string.length; i++) {\n      indices[i] = i;\n    }\n    // Reverse each segment in order\n    segments.forEach(function (ref) {\n      var start = ref[0];\n      var end = ref[1];\n\n      var slice = indices.slice(start, end + 1);\n      for (var i = slice.length; i--;) {\n        indices[end - i] = slice[i];\n      }\n    });\n    return indices\n  }\n\n  exports.closingToOpeningBracket = closingToOpeningBracket;\n  exports.getBidiCharType = getBidiCharType;\n  exports.getBidiCharTypeName = getBidiCharTypeName;\n  exports.getCanonicalBracket = getCanonicalBracket;\n  exports.getEmbeddingLevels = getEmbeddingLevels;\n  exports.getMirroredCharacter = getMirroredCharacter;\n  exports.getMirroredCharactersMap = getMirroredCharactersMap;\n  exports.getReorderSegments = getReorderSegments;\n  exports.getReorderedIndices = getReorderedIndices;\n  exports.getReorderedString = getReorderedString;\n  exports.openingToClosingBracket = openingToClosingBracket;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn bidi}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (bidiFactory);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iaWRpLWpzL2Rpc3QvYmlkaS5tanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsMEJBQTBCO0FBQ3RFO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSTtBQUNqQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDBCQUEwQjtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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RUEsK0RBQWUsV0FBVyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iaWRpLWpzL2Rpc3QvYmlkaS5tanM/MDdiMSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBiaWRpRmFjdG9yeSgpIHtcbnZhciBiaWRpID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cbiAgLy8gQmlkaSBjaGFyYWN0ZXIgdHlwZXMgZGF0YSwgYXV0byBnZW5lcmF0ZWRcbiAgdmFyIERBVEEgPSB7XG4gICAgXCJSXCI6IFwiMTNrLDFhLDIsMywzLDIrMWosY2grMTYsYSsxLDUrMiwyK24sNSxhLDQsNisxNiw0KzMsaCsxYiw0bW8sMTc5cSwyKzksMisxMSwyaTkrN3ksMis2OCw0LDMrNCw1KzEzLDQrMywyKzRrLDMrMjksOCtjZiwxdCs3eix3KzE3LDMrM20sMXQrM3osMTZvMSs1ciw4KzMwLDgrbWMsMjkrMXIsMjkrNHYsNzUrNzNcIixcbiAgICBcIkVOXCI6IFwiMWMrOSwzZCsxLDYsMTg3KzksNTEzLDQrNSw3Kzksc2YraiwxNzVoKzkscXcrcSwxNjFmKzFkLDR4dCthLDI1aSs5XCIsXG4gICAgXCJFU1wiOiBcIjE3LDIsNmRwKzEsZisxLGF2LDE2dnIsbXgrMSw0bywyXCIsXG4gICAgXCJFVFwiOiBcInorMiwzaCszLGIrMSx5bSwzZSsxLDJvLHA0KzEsOCw2dSw3YyxnNiwxd2MsMW45KzQsMzArMWIsMm4sNmQscWh4KzEsaDBtLGErMSw0OSsyLDYzKzEsNCsxLDZiYiszLDEyampcIixcbiAgICBcIkFOXCI6IFwiMTZvKzUsMmorOSwyKzEsMzUsZWQsMWZmMis5LDg3K3VcIixcbiAgICBcIkNTXCI6IFwiMTgsMisxLGIsMnUsMTJrLDU1dixsLDE3djAsMiwzLDUzLDIrMSxiXCIsXG4gICAgXCJCXCI6IFwiYSwzLGYrMiwydiw2OTBcIixcbiAgICBcIlNcIjogXCI5LDIsa1wiLFxuICAgIFwiV1NcIjogXCJjLGssNGY0LDF2aythLHUsMWosMzM1XCIsXG4gICAgXCJPTlwiOiBcIngrMSw0KzQsaCs1LHIrNSxyKzMseiw1KzMsMisxLDIrMSw1LDIrMiwzKzQsbyx3LGNpKzEsOCtkLDMrZCw2KzgsMitnLDM5KzEsOSw2KzEsMiwzMyxiOCwzKzEsM2MrMSw3KzEsNXIsYiw3aCszLHNhKzUsMiwzaSs2LGpnKzMsdXIrOSwydixpaisxLDlnKzksNythLDhtLDQrMSw0OSt4LDE0dSwyKzIsYysyLGUrMixlKzIsZSsxLGkrbixlK2UsMitwLHUrMixlKzIsMzYrMSwyKzMsMisxLGIsMisyLDYrNSwyLDIsMixoKzEsNSs0LDYrMywzK2YsMTYrMiw1KzNsLDMrODEsMXkrcCwyKzQwLHErYSxtKzEzLDJyK2NoLDIrOWUsNzUraGYsMyt2LDIrMncsNmUrNSxmKzYsNzUrMmEsMWErcCwyKzJnLGQrNXgscitiLDYrMyw0K28sZyw2KzEsNisyLDJrKzEsNCwyaiw1aCt6LDFtKzEsMWUrZix0KzIsMWYrZSxkKzMsNG8rMywycysxLHcsNTM1KzFyLGgzbCsxaSw5MysyLDJzLGIrMSwzbCt4LDJ2LDRnKzMsMjErMyxreisxLGc1disxLDVhLGorOSxuK3YsMiwzLDIrOCwyKzEsMysyLDIsMyw0NisxLDQrNCxoKzUscis1LHIrYSwzaCsyLDQrNixiKzQsNzgsMXIrMjQsNCtjLDQsMWhiLGV5KzYsMTAzK2osMTZqK2MsMXV4KzcsNStnLGZzaCxqZHErMXQsNCw1NysyZSxwMSwxbSwxbSwxbSwxbSw0a3QrMSw3aisxNyw1KzJyLGQrZSwzK2UsMitlLDIrMTAsbSs0LHcsMW4rNSwxcSw0eis1LDRiK3JiLDkrYyw0K2MsNCszNyxkKzJnLDgrYixsK2IsNSsxaiw5KzksNysxMyw5K3QsMysxLDI3KzNjLDIrMjksMiszcSxkK2QsMys0LDQrMiw2KzYsYStvLDgrNixhKzIsZSs2LDE2KzQyLDIrMWlcIixcbiAgICBcIkJOXCI6IFwiMCs4LDYrZCwycys1LDIrcCxlLDRtOSwxa3QrMiwyYis1LDUrNSwxN3E5K3YsN2ssNnArOCw2KzEsMTE5ZCszLDQ0MCs3LDk2cysxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZisxLDFla2YrMSwxZWtmKzEsMWVrZis3NSw2cCsycnosMWJlbisxLDFla2YrMSwxZWtmKzFcIixcbiAgICBcIk5TTVwiOiBcImxjKzMzLDdvKzYsN2MrMTgsMiwyKzEsMisxLDIsMjErYSwxZCtrLGgsMnUrNiwzKzUsMysxLDIrMywxMCx2K3EsMmsrYSwxbis4LGEscCszLDIrOCwyKzIsMis0LDE4KzIsM2MrZSwyK3YsMWssMiw1KzcsNSw0KzYsYisxLHUsMW4sNSszLDksbCsxLHIsMysxLDFtLDUrMSw1KzEsMysyLDQsdisxLDQsYysxLDFtLDUrNCwyKzEsNSxsKzEsbis1LDIsMW4sMywyKzMsOSw4KzEsYysxLHYsMXEsZCwxZiw0LDFtKzIsNisyLDIrMyw4KzEsYysxLHUsMW4sZysxLGwrMSx0KzEsMW0rMSw1KzMsOSxsKzEsdSwyMSw4KzIsMiwyaiwzKzYsZCs3LDJyLDMrOCxjKzUsMjMrMSxzLDIsMiwxaytkLDIrNCwyKzEsNithLDIreixhLDJ2KzMsMis1LDIrMSwzKzEscSsxLDUrMixoKzMsZSwzKzEsNyxnLGprKzIscWIrMix1KzIsdSsxLHYrMSwxdCsxLDIrNiw5LDMrYSxhLDFhKzIsM2MrMSx6LDNiKzIsNSsxLGEsNysyLDY0KzEsMywxbiwyKzYsMiwyLDMrNyw3KzksMywxZCtnLDFzKzMsMWQsMis0LDIsNiwxNSs4LGQrMSx4KzMsMysxLDIrMiwxbCwyKzEsNCwyKzIsMW4rNywzKzEsNDkrMiwyK2MsMis2LDUsNyw0KzEsNWorMWwsMis0LGsxK3csMmRiKzIsM3ksMnArdixmZiszLDMwKzEsbjl4KzMsMis5LHgrMSwyOSsxLDdsLDQsNSxxKzEsNiw0OCsxLHIraCxlLDEzKzcscSthLDFiKzIsMWQsMyszLDMrMSwxNCwxdys1LDMrMSwzKzEsZCw5LDFjLDFnLDIrMiwzKzEsNisxLDIsMTcrMSw5LDZuLDMsNSxmbjUsa2krZixoK2YscjIsNmIsNDYrNCwxYWYrMiwyKzEsNiszLDE1KzIsNSw0bSsxLGZ5KzMsYXMrMSw0YSthLDR4LDFqK2UsMWwrMiwxZSszLDMrMSwxeSsyLDExKzQsMis3LDFyLGQrMSwxaCs4LGIrMywzLDJvKzIsMywyKzEsNyw0aCw0KzcsbSsxLDFtKzEsNCwxMis2LDQrNCw1Zys3LDMrMiwyLG8sMmQrNSwyLDUrMSwyKzEsNm4rMyw3KzEsMisxLHMrMSwyZSs3LDMsMisxLDJ6LDIsMys1LDIsMnUrMiwzKzMsMis0LDc4KzgsMisxLDc1KzEsMiw1LDQxKzMsMysxLDUseCs1LDMrMSwxNSs1LDMrMyw5LGErNSwzKzIsMWIrYywyKzEsYmIrNiwyKzUsMmQrbCwzKzYsMisxLDIrMSwzZis1LDQsMisxLDIrNiwyLDIxKzEsNCwyLDlvKzEsZjBjKzQsMW8rNix0NSwxcyszLDJhLGY1bCsxLDQzdCsyLGkrNywzKzYsdiszLDQ1KzIsMWowKzFpLDUrMWQsOSxmLG4rNCwyK2UsMTF0KzYsMitnLDMrNiwyKzEsMis0LDdhKzYsYzYrMywxNXQrNiwzMis2LGd6aHkrNm5cIixcbiAgICBcIkFMXCI6IFwiMTZ3LDMsMixlKzFiLHorMiwyKzJzLGcrMSw4KzEsYittLDIrdCxzKzJpLGMrZSw0aCtmLDFkKzFlLDFid2UrZHAsMyszeix4K2MsMisxLDM1KzN5LDJybSt6LDUrNyxiKzUsZHQrbCxjK3UsMTdubCsyNywxdCsyNyw0eCs2biwzK2RcIixcbiAgICBcIkxST1wiOiBcIjZjdFwiLFxuICAgIFwiUkxPXCI6IFwiNmN1XCIsXG4gICAgXCJMUkVcIjogXCI2Y3FcIixcbiAgICBcIlJMRVwiOiBcIjZjclwiLFxuICAgIFwiUERGXCI6IFwiNmNzXCIsXG4gICAgXCJMUklcIjogXCI2ZWVcIixcbiAgICBcIlJMSVwiOiBcIjZlZlwiLFxuICAgIFwiRlNJXCI6IFwiNmVnXCIsXG4gICAgXCJQRElcIjogXCI2ZWhcIlxuICB9O1xuXG4gIHZhciBUWVBFUyA9IHt9O1xuICB2YXIgVFlQRVNfVE9fTkFNRVMgPSB7fTtcbiAgVFlQRVMuTCA9IDE7IC8vTCBpcyB0aGUgZGVmYXVsdFxuICBUWVBFU19UT19OQU1FU1sxXSA9ICdMJztcbiAgT2JqZWN0LmtleXMoREFUQSkuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgIFRZUEVTW3R5cGVdID0gMSA8PCAoaSArIDEpO1xuICAgIFRZUEVTX1RPX05BTUVTW1RZUEVTW3R5cGVdXSA9IHR5cGU7XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKFRZUEVTKTtcblxuICB2YXIgSVNPTEFURV9JTklUX1RZUEVTID0gVFlQRVMuTFJJIHwgVFlQRVMuUkxJIHwgVFlQRVMuRlNJO1xuICB2YXIgU1RST05HX1RZUEVTID0gVFlQRVMuTCB8IFRZUEVTLlIgfCBUWVBFUy5BTDtcbiAgdmFyIE5FVVRSQUxfSVNPTEFURV9UWVBFUyA9IFRZUEVTLkIgfCBUWVBFUy5TIHwgVFlQRVMuV1MgfCBUWVBFUy5PTiB8IFRZUEVTLkZTSSB8IFRZUEVTLkxSSSB8IFRZUEVTLlJMSSB8IFRZUEVTLlBESTtcbiAgdmFyIEJOX0xJS0VfVFlQRVMgPSBUWVBFUy5CTiB8IFRZUEVTLlJMRSB8IFRZUEVTLkxSRSB8IFRZUEVTLlJMTyB8IFRZUEVTLkxSTyB8IFRZUEVTLlBERjtcbiAgdmFyIFRSQUlMSU5HX1RZUEVTID0gVFlQRVMuUyB8IFRZUEVTLldTIHwgVFlQRVMuQiB8IElTT0xBVEVfSU5JVF9UWVBFUyB8IFRZUEVTLlBESSB8IEJOX0xJS0VfVFlQRVM7XG5cbiAgdmFyIG1hcCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gcGFyc2VEYXRhICgpIHtcbiAgICBpZiAoIW1hcCkge1xuICAgICAgLy9jb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgICBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggdHlwZSApIHtcbiAgICAgICAgaWYgKERBVEEuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICAgICAgICB2YXIgbGFzdENvZGUgPSAwO1xuICAgICAgICAgIERBVEFbdHlwZV0uc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgICAgdmFyIHJlZiA9IHJhbmdlLnNwbGl0KCcrJyk7XG4gICAgICAgICAgICB2YXIgc2tpcCA9IHJlZlswXTtcbiAgICAgICAgICAgIHZhciBzdGVwID0gcmVmWzFdO1xuICAgICAgICAgICAgc2tpcCA9IHBhcnNlSW50KHNraXAsIDM2KTtcbiAgICAgICAgICAgIHN0ZXAgPSBzdGVwID8gcGFyc2VJbnQoc3RlcCwgMzYpIDogMDtcbiAgICAgICAgICAgIG1hcC5zZXQobGFzdENvZGUgKz0gc2tpcCwgVFlQRVNbdHlwZV0pO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwOyBpKyspIHtcbiAgICAgICAgICAgICAgbWFwLnNldCgrK2xhc3RDb2RlLCBUWVBFU1t0eXBlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHR5cGUgaW4gREFUQSkgbG9vcCggdHlwZSApO1xuICAgICAgLy9jb25zb2xlLmxvZyhgY2hhciB0eXBlcyBwYXJzZWQgaW4gJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0fW1zYClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0QmlkaUNoYXJUeXBlIChjaGFyKSB7XG4gICAgcGFyc2VEYXRhKCk7XG4gICAgcmV0dXJuIG1hcC5nZXQoY2hhci5jb2RlUG9pbnRBdCgwKSkgfHwgVFlQRVMuTFxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0QmlkaUNoYXJUeXBlTmFtZShjaGFyKSB7XG4gICAgcmV0dXJuIFRZUEVTX1RPX05BTUVTW2dldEJpZGlDaGFyVHlwZShjaGFyKV1cbiAgfVxuXG4gIC8vIEJpZGkgYnJhY2tldCBwYWlycyBkYXRhLCBhdXRvIGdlbmVyYXRlZFxuICB2YXIgZGF0YSQxID0ge1xuICAgIFwicGFpcnNcIjogXCIxND4xLDFlPjIsdT4yLDJ3dD4xLDE+MSwxZ2U+MSwxd3A+MSwxaj4xLGY+MSxobT4xLDE+MSx1PjEsdTY+MSwxPjEsKzUsMjg+MSx3PjEsMT4xLCszLGI4PjEsMT4xLCszLDE+MywtMT4tMSwzPjEsMT4xLCsyLDFzPjEsMT4xLHg+MSx0aD4xLDE+MSwrMixkYj4xLDE+MSwrMywzPjEsMT4xLCsyLDE0cW0+MSwxPjEsKzEsNHE+MSwxZT4yLHU+MiwyPjEsKzFcIixcbiAgICBcImNhbm9uaWNhbFwiOiBcIjZmMT4tNmR4LDZkeT4tNmR4LDZlYz4tNmVkLDZlZT4tNmVkLDZ3dz4yamosLTJqaT4yamosMTRyND4tMWU3bCwxZTdtPi0xZTdsLDFlN20+LTFlNWMsMWU1ZD4tMWU1YiwxZTVjPi0xNHF4LDE0cXk+LTE0cXgsMTR2bj4tMWVjZywxZWNoPi0xZWNnLDFlZHU+LTFlY2csMWVjaT4tMWVjZywxZWRhPi0xZWNnLDFlY2k+LTFlY2csMWVjaT4tMTY4cSwxNjhyPi0xNjhxLDE2OHM+LTE0eWUsMTR5Zj4tMTR5ZVwiXG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBzdHJpbmcgdGhhdCBob2xkcyBlbmNvZGVkIGNvZGVwb2ludCBtYXBwaW5ncywgZS5nLiBmb3IgYnJhY2tldCBwYWlycyBvclxuICAgKiBtaXJyb3JpbmcgY2hhcmFjdGVycywgYXMgZW5jb2RlZCBieSBzY3JpcHRzL2dlbmVyYXRlQmlkaURhdGEuanMuIFJldHVybnMgYW4gb2JqZWN0XG4gICAqIGhvbGRpbmcgdGhlIGBtYXBgLCBhbmQgb3B0aW9uYWxseSBhIGByZXZlcnNlTWFwYCBpZiBgaW5jbHVkZVJldmVyc2U6dHJ1ZWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmNvZGVkU3RyaW5nXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZVJldmVyc2UgLSB0cnVlIGlmIHlvdSB3YW50IHJldmVyc2VNYXAgaW4gdGhlIG91dHB1dFxuICAgKiBAcmV0dXJuIHt7bWFwOiBNYXA8bnVtYmVyLCBudW1iZXI+LCByZXZlcnNlTWFwPzogTWFwPG51bWJlciwgbnVtYmVyPn19XG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZUNoYXJhY3Rlck1hcCAoZW5jb2RlZFN0cmluZywgaW5jbHVkZVJldmVyc2UpIHtcbiAgICB2YXIgcmFkaXggPSAzNjtcbiAgICB2YXIgbGFzdENvZGUgPSAwO1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHJldmVyc2VNYXAgPSBpbmNsdWRlUmV2ZXJzZSAmJiBuZXcgTWFwKCk7XG4gICAgdmFyIHByZXZQYWlyO1xuICAgIGVuY29kZWRTdHJpbmcuc3BsaXQoJywnKS5mb3JFYWNoKGZ1bmN0aW9uIHZpc2l0KGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkuaW5kZXhPZignKycpICE9PSAtMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gK2VudHJ5OyBpLS07KSB7XG4gICAgICAgICAgdmlzaXQocHJldlBhaXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2UGFpciA9IGVudHJ5O1xuICAgICAgICB2YXIgcmVmID0gZW50cnkuc3BsaXQoJz4nKTtcbiAgICAgICAgdmFyIGEgPSByZWZbMF07XG4gICAgICAgIHZhciBiID0gcmVmWzFdO1xuICAgICAgICBhID0gU3RyaW5nLmZyb21Db2RlUG9pbnQobGFzdENvZGUgKz0gcGFyc2VJbnQoYSwgcmFkaXgpKTtcbiAgICAgICAgYiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KGxhc3RDb2RlICs9IHBhcnNlSW50KGIsIHJhZGl4KSk7XG4gICAgICAgIG1hcC5zZXQoYSwgYik7XG4gICAgICAgIGluY2x1ZGVSZXZlcnNlICYmIHJldmVyc2VNYXAuc2V0KGIsIGEpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7IG1hcDogbWFwLCByZXZlcnNlTWFwOiByZXZlcnNlTWFwIH1cbiAgfVxuXG4gIHZhciBvcGVuVG9DbG9zZSwgY2xvc2VUb09wZW4sIGNhbm9uaWNhbDtcblxuICBmdW5jdGlvbiBwYXJzZSQxICgpIHtcbiAgICBpZiAoIW9wZW5Ub0Nsb3NlKSB7XG4gICAgICAvL2NvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICAgIHZhciByZWYgPSBwYXJzZUNoYXJhY3Rlck1hcChkYXRhJDEucGFpcnMsIHRydWUpO1xuICAgICAgdmFyIG1hcCA9IHJlZi5tYXA7XG4gICAgICB2YXIgcmV2ZXJzZU1hcCA9IHJlZi5yZXZlcnNlTWFwO1xuICAgICAgb3BlblRvQ2xvc2UgPSBtYXA7XG4gICAgICBjbG9zZVRvT3BlbiA9IHJldmVyc2VNYXA7XG4gICAgICBjYW5vbmljYWwgPSBwYXJzZUNoYXJhY3Rlck1hcChkYXRhJDEuY2Fub25pY2FsLCBmYWxzZSkubWFwO1xuICAgICAgLy9jb25zb2xlLmxvZyhgYnJhY2tldHMgcGFyc2VkIGluICR7cGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydH1tc2ApXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb3BlbmluZ1RvQ2xvc2luZ0JyYWNrZXQgKGNoYXIpIHtcbiAgICBwYXJzZSQxKCk7XG4gICAgcmV0dXJuIG9wZW5Ub0Nsb3NlLmdldChjaGFyKSB8fCBudWxsXG4gIH1cblxuICBmdW5jdGlvbiBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldCAoY2hhcikge1xuICAgIHBhcnNlJDEoKTtcbiAgICByZXR1cm4gY2xvc2VUb09wZW4uZ2V0KGNoYXIpIHx8IG51bGxcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENhbm9uaWNhbEJyYWNrZXQgKGNoYXIpIHtcbiAgICBwYXJzZSQxKCk7XG4gICAgcmV0dXJuIGNhbm9uaWNhbC5nZXQoY2hhcikgfHwgbnVsbFxuICB9XG5cbiAgLy8gTG9jYWwgdHlwZSBhbGlhc2VzXG4gIHZhciBUWVBFX0wgPSBUWVBFUy5MO1xuICB2YXIgVFlQRV9SID0gVFlQRVMuUjtcbiAgdmFyIFRZUEVfRU4gPSBUWVBFUy5FTjtcbiAgdmFyIFRZUEVfRVMgPSBUWVBFUy5FUztcbiAgdmFyIFRZUEVfRVQgPSBUWVBFUy5FVDtcbiAgdmFyIFRZUEVfQU4gPSBUWVBFUy5BTjtcbiAgdmFyIFRZUEVfQ1MgPSBUWVBFUy5DUztcbiAgdmFyIFRZUEVfQiA9IFRZUEVTLkI7XG4gIHZhciBUWVBFX1MgPSBUWVBFUy5TO1xuICB2YXIgVFlQRV9PTiA9IFRZUEVTLk9OO1xuICB2YXIgVFlQRV9CTiA9IFRZUEVTLkJOO1xuICB2YXIgVFlQRV9OU00gPSBUWVBFUy5OU007XG4gIHZhciBUWVBFX0FMID0gVFlQRVMuQUw7XG4gIHZhciBUWVBFX0xSTyA9IFRZUEVTLkxSTztcbiAgdmFyIFRZUEVfUkxPID0gVFlQRVMuUkxPO1xuICB2YXIgVFlQRV9MUkUgPSBUWVBFUy5MUkU7XG4gIHZhciBUWVBFX1JMRSA9IFRZUEVTLlJMRTtcbiAgdmFyIFRZUEVfUERGID0gVFlQRVMuUERGO1xuICB2YXIgVFlQRV9MUkkgPSBUWVBFUy5MUkk7XG4gIHZhciBUWVBFX1JMSSA9IFRZUEVTLlJMSTtcbiAgdmFyIFRZUEVfRlNJID0gVFlQRVMuRlNJO1xuICB2YXIgVFlQRV9QREkgPSBUWVBFUy5QREk7XG5cbiAgLyoqXG4gICAqIEB0eXBlZGVmIHtvYmplY3R9IEdldEVtYmVkZGluZ0xldmVsc1Jlc3VsdFxuICAgKiBAcHJvcGVydHkge3tzdGFydCwgZW5kLCBsZXZlbH1bXX0gcGFyYWdyYXBoc1xuICAgKiBAcHJvcGVydHkge1VpbnQ4QXJyYXl9IGxldmVsc1xuICAgKi9cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBhcHBsaWVzIHRoZSBCaWRpcmVjdGlvbmFsIEFsZ29yaXRobSB0byBhIHN0cmluZywgcmV0dXJuaW5nIHRoZSByZXNvbHZlZCBlbWJlZGRpbmcgbGV2ZWxzXG4gICAqIGluIGEgc2luZ2xlIFVpbnQ4QXJyYXkgcGx1cyBhIGxpc3Qgb2Ygb2JqZWN0cyBob2xkaW5nIGVhY2ggcGFyYWdyYXBoJ3Mgc3RhcnQgYW5kIGVuZCBpbmRpY2VzIGFuZCByZXNvbHZlZFxuICAgKiBiYXNlIGVtYmVkZGluZyBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIFRoZSBpbnB1dCBzdHJpbmdcbiAgICogQHBhcmFtIHtcImx0clwifFwicnRsXCJ8XCJhdXRvXCJ9IFtiYXNlRGlyZWN0aW9uXSAtIFVzZSBcImx0clwiIG9yIFwicnRsXCIgdG8gZm9yY2UgYSBiYXNlIHBhcmFncmFwaCBkaXJlY3Rpb24sXG4gICAqICAgICAgICBvdGhlcndpc2UgYSBkaXJlY3Rpb24gd2lsbCBiZSBjaG9zZW4gYXV0b21hdGljYWxseSBmcm9tIGVhY2ggcGFyYWdyYXBoJ3MgY29udGVudHMuXG4gICAqIEByZXR1cm4ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEVtYmVkZGluZ0xldmVscyAoc3RyaW5nLCBiYXNlRGlyZWN0aW9uKSB7XG4gICAgdmFyIE1BWF9ERVBUSCA9IDEyNTtcblxuICAgIC8vIFN0YXJ0IGJ5IG1hcHBpbmcgYWxsIGNoYXJhY3RlcnMgdG8gdGhlaXIgdW5pY29kZSB0eXBlLCBhcyBhIGJpdG1hc2sgaW50ZWdlclxuICAgIHZhciBjaGFyVHlwZXMgPSBuZXcgVWludDMyQXJyYXkoc3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJUeXBlc1tpXSA9IGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaV0pO1xuICAgIH1cblxuICAgIHZhciBjaGFyVHlwZUNvdW50cyA9IG5ldyBNYXAoKTsgLy93aWxsIGJlIGNsZWFyZWQgYXQgc3RhcnQgb2YgZWFjaCBwYXJhZ3JhcGhcbiAgICBmdW5jdGlvbiBjaGFuZ2VDaGFyVHlwZShpLCB0eXBlKSB7XG4gICAgICB2YXIgb2xkVHlwZSA9IGNoYXJUeXBlc1tpXTtcbiAgICAgIGNoYXJUeXBlc1tpXSA9IHR5cGU7XG4gICAgICBjaGFyVHlwZUNvdW50cy5zZXQob2xkVHlwZSwgY2hhclR5cGVDb3VudHMuZ2V0KG9sZFR5cGUpIC0gMSk7XG4gICAgICBpZiAob2xkVHlwZSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTLCBjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSAtIDEpO1xuICAgICAgfVxuICAgICAgY2hhclR5cGVDb3VudHMuc2V0KHR5cGUsIChjaGFyVHlwZUNvdW50cy5nZXQodHlwZSkgfHwgMCkgKyAxKTtcbiAgICAgIGlmICh0eXBlICYgTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB7XG4gICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChORVVUUkFMX0lTT0xBVEVfVFlQRVMsIChjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB8fCAwKSArIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBlbWJlZExldmVscyA9IG5ldyBVaW50OEFycmF5KHN0cmluZy5sZW5ndGgpO1xuICAgIHZhciBpc29sYXRpb25QYWlycyA9IG5ldyBNYXAoKTsgLy9pbml0LT5wZGkgYW5kIHBkaS0+aW5pdFxuXG4gICAgLy8gPT09IDMuMy4xIFRoZSBQYXJhZ3JhcGggTGV2ZWwgPT09XG4gICAgLy8gMy4zLjEgUDE6IFNwbGl0IHRoZSB0ZXh0IGludG8gcGFyYWdyYXBoc1xuICAgIHZhciBwYXJhZ3JhcGhzID0gW107IC8vIFt7c3RhcnQsIGVuZCwgbGV2ZWx9LCAuLi5dXG4gICAgdmFyIHBhcmFncmFwaCA9IG51bGw7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc3RyaW5nLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgIGlmICghcGFyYWdyYXBoKSB7XG4gICAgICAgIHBhcmFncmFwaHMucHVzaChwYXJhZ3JhcGggPSB7XG4gICAgICAgICAgc3RhcnQ6IGkkMSxcbiAgICAgICAgICBlbmQ6IHN0cmluZy5sZW5ndGggLSAxLFxuICAgICAgICAgIC8vIDMuMy4xIFAyLVAzOiBEZXRlcm1pbmUgdGhlIHBhcmFncmFwaCBsZXZlbFxuICAgICAgICAgIGxldmVsOiBiYXNlRGlyZWN0aW9uID09PSAncnRsJyA/IDEgOiBiYXNlRGlyZWN0aW9uID09PSAnbHRyJyA/IDAgOiBkZXRlcm1pbmVBdXRvRW1iZWRMZXZlbChpJDEsIGZhbHNlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjaGFyVHlwZXNbaSQxXSAmIFRZUEVfQikge1xuICAgICAgICBwYXJhZ3JhcGguZW5kID0gaSQxO1xuICAgICAgICBwYXJhZ3JhcGggPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBGT1JNQVRUSU5HX1RZUEVTID0gVFlQRV9STEUgfCBUWVBFX0xSRSB8IFRZUEVfUkxPIHwgVFlQRV9MUk8gfCBJU09MQVRFX0lOSVRfVFlQRVMgfCBUWVBFX1BESSB8IFRZUEVfUERGIHwgVFlQRV9CO1xuICAgIHZhciBuZXh0RXZlbiA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiBuICsgKChuICYgMSkgPyAxIDogMik7IH07XG4gICAgdmFyIG5leHRPZGQgPSBmdW5jdGlvbiAobikgeyByZXR1cm4gbiArICgobiAmIDEpID8gMiA6IDEpOyB9O1xuXG4gICAgLy8gRXZlcnl0aGluZyBmcm9tIGhlcmUgb24gd2lsbCBvcGVyYXRlIHBlciBwYXJhZ3JhcGguXG4gICAgZm9yICh2YXIgcGFyYUlkeCA9IDA7IHBhcmFJZHggPCBwYXJhZ3JhcGhzLmxlbmd0aDsgcGFyYUlkeCsrKSB7XG4gICAgICBwYXJhZ3JhcGggPSBwYXJhZ3JhcGhzW3BhcmFJZHhdO1xuICAgICAgdmFyIHN0YXR1c1N0YWNrID0gW3tcbiAgICAgICAgX2xldmVsOiBwYXJhZ3JhcGgubGV2ZWwsXG4gICAgICAgIF9vdmVycmlkZTogMCwgLy8wPW5ldXRyYWwsIDE9TCwgMj1SXG4gICAgICAgIF9pc29sYXRlOiAwIC8vYm9vbFxuICAgICAgfV07XG4gICAgICB2YXIgc3RhY2tUb3AgPSAodm9pZCAwKTtcbiAgICAgIHZhciBvdmVyZmxvd0lzb2xhdGVDb3VudCA9IDA7XG4gICAgICB2YXIgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9IDA7XG4gICAgICB2YXIgdmFsaWRJc29sYXRlQ291bnQgPSAwO1xuICAgICAgY2hhclR5cGVDb3VudHMuY2xlYXIoKTtcblxuICAgICAgLy8gPT09IDMuMy4yIEV4cGxpY2l0IExldmVscyBhbmQgRGlyZWN0aW9ucyA9PT1cbiAgICAgIGZvciAodmFyIGkkMiA9IHBhcmFncmFwaC5zdGFydDsgaSQyIDw9IHBhcmFncmFwaC5lbmQ7IGkkMisrKSB7XG4gICAgICAgIHZhciBjaGFyVHlwZSA9IGNoYXJUeXBlc1tpJDJdO1xuICAgICAgICBzdGFja1RvcCA9IHN0YXR1c1N0YWNrW3N0YXR1c1N0YWNrLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIC8vIFNldCBpbml0aWFsIGNvdW50c1xuICAgICAgICBjaGFyVHlwZUNvdW50cy5zZXQoY2hhclR5cGUsIChjaGFyVHlwZUNvdW50cy5nZXQoY2hhclR5cGUpIHx8IDApICsgMSk7XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgIGNoYXJUeXBlQ291bnRzLnNldChORVVUUkFMX0lTT0xBVEVfVFlQRVMsIChjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSB8fCAwKSArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRXhwbGljaXQgRW1iZWRkaW5nczogMy4zLjIgWDIgLSBYM1xuICAgICAgICBpZiAoY2hhclR5cGUgJiBGT1JNQVRUSU5HX1RZUEVTKSB7IC8vcHJlZmlsdGVyIGFsbCBmb3JtYXR0ZXJzXG4gICAgICAgICAgaWYgKGNoYXJUeXBlICYgKFRZUEVfUkxFIHwgVFlQRV9MUkUpKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsOyAvLyA1LjJcbiAgICAgICAgICAgIHZhciBsZXZlbCA9IChjaGFyVHlwZSA9PT0gVFlQRV9STEUgPyBuZXh0T2RkIDogbmV4dEV2ZW4pKHN0YWNrVG9wLl9sZXZlbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwgPD0gTUFYX0RFUFRIICYmICFvdmVyZmxvd0lzb2xhdGVDb3VudCAmJiAhb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCkge1xuICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wdXNoKHtcbiAgICAgICAgICAgICAgICBfbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgIF9vdmVycmlkZTogMCxcbiAgICAgICAgICAgICAgICBfaXNvbGF0ZTogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW92ZXJmbG93SXNvbGF0ZUNvdW50KSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHBsaWNpdCBPdmVycmlkZXM6IDMuMy4yIFg0IC0gWDVcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIChUWVBFX1JMTyB8IFRZUEVfTFJPKSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDsgLy8gNS4yXG4gICAgICAgICAgICB2YXIgbGV2ZWwkMSA9IChjaGFyVHlwZSA9PT0gVFlQRV9STE8gPyBuZXh0T2RkIDogbmV4dEV2ZW4pKHN0YWNrVG9wLl9sZXZlbCk7XG4gICAgICAgICAgICBpZiAobGV2ZWwkMSA8PSBNQVhfREVQVEggJiYgIW92ZXJmbG93SXNvbGF0ZUNvdW50ICYmICFvdmVyZmxvd0VtYmVkZGluZ0NvdW50KSB7XG4gICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnB1c2goe1xuICAgICAgICAgICAgICAgIF9sZXZlbDogbGV2ZWwkMSxcbiAgICAgICAgICAgICAgICBfb3ZlcnJpZGU6IChjaGFyVHlwZSAmIFRZUEVfUkxPKSA/IFRZUEVfUiA6IFRZUEVfTCxcbiAgICAgICAgICAgICAgICBfaXNvbGF0ZTogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW92ZXJmbG93SXNvbGF0ZUNvdW50KSB7XG4gICAgICAgICAgICAgIG92ZXJmbG93RW1iZWRkaW5nQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJc29sYXRlczogMy4zLjIgWDVhIC0gWDVjXG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBJU09MQVRFX0lOSVRfVFlQRVMpIHtcbiAgICAgICAgICAgIC8vIFg1YyAtIEZTSSBiZWNvbWVzIGVpdGhlciBSTEkgb3IgTFJJXG4gICAgICAgICAgICBpZiAoY2hhclR5cGUgJiBUWVBFX0ZTSSkge1xuICAgICAgICAgICAgICBjaGFyVHlwZSA9IGRldGVybWluZUF1dG9FbWJlZExldmVsKGkkMiArIDEsIHRydWUpID09PSAxID8gVFlQRV9STEkgOiBUWVBFX0xSSTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDtcbiAgICAgICAgICAgIGlmIChzdGFja1RvcC5fb3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQyLCBzdGFja1RvcC5fb3ZlcnJpZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxldmVsJDIgPSAoY2hhclR5cGUgPT09IFRZUEVfUkxJID8gbmV4dE9kZCA6IG5leHRFdmVuKShzdGFja1RvcC5fbGV2ZWwpO1xuICAgICAgICAgICAgaWYgKGxldmVsJDIgPD0gTUFYX0RFUFRIICYmIG92ZXJmbG93SXNvbGF0ZUNvdW50ID09PSAwICYmIG92ZXJmbG93RW1iZWRkaW5nQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgdmFsaWRJc29sYXRlQ291bnQrKztcbiAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucHVzaCh7XG4gICAgICAgICAgICAgICAgX2xldmVsOiBsZXZlbCQyLFxuICAgICAgICAgICAgICAgIF9vdmVycmlkZTogMCxcbiAgICAgICAgICAgICAgICBfaXNvbGF0ZTogMSxcbiAgICAgICAgICAgICAgICBfaXNvbEluaXRJbmRleDogaSQyXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dJc29sYXRlQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUZXJtaW5hdGluZyBJc29sYXRlczogMy4zLjIgWDZhXG4gICAgICAgICAgZWxzZSBpZiAoY2hhclR5cGUgJiBUWVBFX1BESSkge1xuICAgICAgICAgICAgaWYgKG92ZXJmbG93SXNvbGF0ZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICBvdmVyZmxvd0lzb2xhdGVDb3VudC0tO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWxpZElzb2xhdGVDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudCA9IDA7XG4gICAgICAgICAgICAgIHdoaWxlICghc3RhdHVzU3RhY2tbc3RhdHVzU3RhY2subGVuZ3RoIC0gMV0uX2lzb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXNTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBBZGQgdG8gaXNvbGF0aW9uIHBhaXJzIGJpZGlyZWN0aW9uYWwgbWFwcGluZzpcbiAgICAgICAgICAgICAgdmFyIGlzb2xJbml0SW5kZXggPSBzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXS5faXNvbEluaXRJbmRleDtcbiAgICAgICAgICAgICAgaWYgKGlzb2xJbml0SW5kZXggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlzb2xhdGlvblBhaXJzLnNldChpc29sSW5pdEluZGV4LCBpJDIpO1xuICAgICAgICAgICAgICAgIGlzb2xhdGlvblBhaXJzLnNldChpJDIsIGlzb2xJbml0SW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXR1c1N0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICB2YWxpZElzb2xhdGVDb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2tUb3AgPSBzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMl0gPSBzdGFja1RvcC5fbGV2ZWw7XG4gICAgICAgICAgICBpZiAoc3RhY2tUb3AuX292ZXJyaWRlKSB7XG4gICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMiwgc3RhY2tUb3AuX292ZXJyaWRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cblxuICAgICAgICAgIC8vIFRlcm1pbmF0aW5nIEVtYmVkZGluZ3MgYW5kIE92ZXJyaWRlczogMy4zLjIgWDdcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIFRZUEVfUERGKSB7XG4gICAgICAgICAgICBpZiAob3ZlcmZsb3dJc29sYXRlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgaWYgKG92ZXJmbG93RW1iZWRkaW5nQ291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgb3ZlcmZsb3dFbWJlZGRpbmdDb3VudC0tO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFzdGFja1RvcC5faXNvbGF0ZSAmJiBzdGF0dXNTdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgc3RhY2tUb3AgPSBzdGF0dXNTdGFja1tzdGF0dXNTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHN0YWNrVG9wLl9sZXZlbDsgLy8gNS4yXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRW5kIG9mIFBhcmFncmFwaDogMy4zLjIgWDhcbiAgICAgICAgICBlbHNlIGlmIChjaGFyVHlwZSAmIFRZUEVfQikge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQyXSA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBOb24tZm9ybWF0dGluZyBjaGFyYWN0ZXJzOiAzLjMuMiBYNlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBlbWJlZExldmVsc1tpJDJdID0gc3RhY2tUb3AuX2xldmVsO1xuICAgICAgICAgIC8vIE5PVEU6IFRoaXMgZXhjbHVzaW9uIG9mIEJOIHNlZW1zIHRvIGdvIGFnYWluc3Qgd2hhdCBzZWN0aW9uIDUuMiBzYXlzLCBidXQgaXMgcmVxdWlyZWQgZm9yIHRlc3QgcGFzc2FnZVxuICAgICAgICAgIGlmIChzdGFja1RvcC5fb3ZlcnJpZGUgJiYgY2hhclR5cGUgIT09IFRZUEVfQk4pIHtcbiAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkMiwgc3RhY2tUb3AuX292ZXJyaWRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gPT09IDMuMy4zIFByZXBhcmF0aW9ucyBmb3IgSW1wbGljaXQgUHJvY2Vzc2luZyA9PT1cblxuICAgICAgLy8gUmVtb3ZlIGFsbCBSTEUsIExSRSwgUkxPLCBMUk8sIFBERiwgYW5kIEJOIGNoYXJhY3RlcnM6IDMuMy4zIFg5XG4gICAgICAvLyBOb3RlOiBEdWUgdG8gc2VjdGlvbiA1LjIsIHdlIHdvbid0IHJlbW92ZSB0aGVtLCBidXQgd2UnbGwgdXNlIHRoZSBCTl9MSUtFX1RZUEVTIGJpdHNldCB0b1xuICAgICAgLy8gZWFzaWx5IGlnbm9yZSB0aGVtIGFsbCBmcm9tIGhlcmUgb24gb3V0LlxuXG4gICAgICAvLyAzLjMuMyBYMTBcbiAgICAgIC8vIENvbXB1dGUgdGhlIHNldCBvZiBpc29sYXRpbmcgcnVuIHNlcXVlbmNlcyBhcyBzcGVjaWZpZWQgYnkgQkQxM1xuICAgICAgdmFyIGxldmVsUnVucyA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSdW4gPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSQzID0gcGFyYWdyYXBoLnN0YXJ0OyBpJDMgPD0gcGFyYWdyYXBoLmVuZDsgaSQzKyspIHtcbiAgICAgICAgdmFyIGNoYXJUeXBlJDEgPSBjaGFyVHlwZXNbaSQzXTtcbiAgICAgICAgaWYgKCEoY2hhclR5cGUkMSAmIEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgdmFyIGx2bCA9IGVtYmVkTGV2ZWxzW2kkM107XG4gICAgICAgICAgdmFyIGlzSXNvbEluaXQgPSBjaGFyVHlwZSQxICYgSVNPTEFURV9JTklUX1RZUEVTO1xuICAgICAgICAgIHZhciBpc1BESSA9IGNoYXJUeXBlJDEgPT09IFRZUEVfUERJO1xuICAgICAgICAgIGlmIChjdXJyZW50UnVuICYmIGx2bCA9PT0gY3VycmVudFJ1bi5fbGV2ZWwpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSdW4uX2VuZCA9IGkkMztcbiAgICAgICAgICAgIGN1cnJlbnRSdW4uX2VuZHNXaXRoSXNvbEluaXQgPSBpc0lzb2xJbml0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXZlbFJ1bnMucHVzaChjdXJyZW50UnVuID0ge1xuICAgICAgICAgICAgICBfc3RhcnQ6IGkkMyxcbiAgICAgICAgICAgICAgX2VuZDogaSQzLFxuICAgICAgICAgICAgICBfbGV2ZWw6IGx2bCxcbiAgICAgICAgICAgICAgX3N0YXJ0c1dpdGhQREk6IGlzUERJLFxuICAgICAgICAgICAgICBfZW5kc1dpdGhJc29sSW5pdDogaXNJc29sSW5pdFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgaXNvbGF0aW5nUnVuU2VxcyA9IFtdOyAvLyBbe3NlcUluZGljZXM6IFtdLCBzb3NUeXBlOiBMfFIsIGVvc1R5cGU6IEx8Un1dXG4gICAgICBmb3IgKHZhciBydW5JZHggPSAwOyBydW5JZHggPCBsZXZlbFJ1bnMubGVuZ3RoOyBydW5JZHgrKykge1xuICAgICAgICB2YXIgcnVuID0gbGV2ZWxSdW5zW3J1bklkeF07XG4gICAgICAgIGlmICghcnVuLl9zdGFydHNXaXRoUERJIHx8IChydW4uX3N0YXJ0c1dpdGhQREkgJiYgIWlzb2xhdGlvblBhaXJzLmhhcyhydW4uX3N0YXJ0KSkpIHtcbiAgICAgICAgICB2YXIgc2VxUnVucyA9IFtjdXJyZW50UnVuID0gcnVuXTtcbiAgICAgICAgICBmb3IgKHZhciBwZGlJbmRleCA9ICh2b2lkIDApOyBjdXJyZW50UnVuICYmIGN1cnJlbnRSdW4uX2VuZHNXaXRoSXNvbEluaXQgJiYgKHBkaUluZGV4ID0gaXNvbGF0aW9uUGFpcnMuZ2V0KGN1cnJlbnRSdW4uX2VuZCkpICE9IG51bGw7KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDQgPSBydW5JZHggKyAxOyBpJDQgPCBsZXZlbFJ1bnMubGVuZ3RoOyBpJDQrKykge1xuICAgICAgICAgICAgICBpZiAobGV2ZWxSdW5zW2kkNF0uX3N0YXJ0ID09PSBwZGlJbmRleCkge1xuICAgICAgICAgICAgICAgIHNlcVJ1bnMucHVzaChjdXJyZW50UnVuID0gbGV2ZWxSdW5zW2kkNF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYnVpbGQgZmxhdCBsaXN0IG9mIGluZGljZXMgYWNyb3NzIGFsbCBydW5zOlxuICAgICAgICAgIHZhciBzZXFJbmRpY2VzID0gW107XG4gICAgICAgICAgZm9yICh2YXIgaSQ1ID0gMDsgaSQ1IDwgc2VxUnVucy5sZW5ndGg7IGkkNSsrKSB7XG4gICAgICAgICAgICB2YXIgcnVuJDEgPSBzZXFSdW5zW2kkNV07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gcnVuJDEuX3N0YXJ0OyBqIDw9IHJ1biQxLl9lbmQ7IGorKykge1xuICAgICAgICAgICAgICBzZXFJbmRpY2VzLnB1c2goaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGRldGVybWluZSB0aGUgc29zL2VvcyB0eXBlczpcbiAgICAgICAgICB2YXIgZmlyc3RMZXZlbCA9IGVtYmVkTGV2ZWxzW3NlcUluZGljZXNbMF1dO1xuICAgICAgICAgIHZhciBwcmV2TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgZm9yICh2YXIgaSQ2ID0gc2VxSW5kaWNlc1swXSAtIDE7IGkkNiA+PSAwOyBpJDYtLSkge1xuICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW2kkNl0gJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICBwcmV2TGV2ZWwgPSBlbWJlZExldmVsc1tpJDZdO1xuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gc2VxSW5kaWNlc1tzZXFJbmRpY2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIHZhciBsYXN0TGV2ZWwgPSBlbWJlZExldmVsc1tsYXN0SW5kZXhdO1xuICAgICAgICAgIHZhciBuZXh0TGV2ZWwgPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgICAgaWYgKCEoY2hhclR5cGVzW2xhc3RJbmRleF0gJiBJU09MQVRFX0lOSVRfVFlQRVMpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpJDcgPSBsYXN0SW5kZXggKyAxOyBpJDcgPD0gcGFyYWdyYXBoLmVuZDsgaSQ3KyspIHtcbiAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW2kkN10gJiBCTl9MSUtFX1RZUEVTKSkgeyAvLzUuMlxuICAgICAgICAgICAgICAgIG5leHRMZXZlbCA9IGVtYmVkTGV2ZWxzW2kkN107XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc29sYXRpbmdSdW5TZXFzLnB1c2goe1xuICAgICAgICAgICAgX3NlcUluZGljZXM6IHNlcUluZGljZXMsXG4gICAgICAgICAgICBfc29zVHlwZTogTWF0aC5tYXgocHJldkxldmVsLCBmaXJzdExldmVsKSAlIDIgPyBUWVBFX1IgOiBUWVBFX0wsXG4gICAgICAgICAgICBfZW9zVHlwZTogTWF0aC5tYXgobmV4dExldmVsLCBsYXN0TGV2ZWwpICUgMiA/IFRZUEVfUiA6IFRZUEVfTFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBuZXh0IHN0ZXBzIGFyZSBkb25lIHBlciBpc29sYXRpbmcgcnVuIHNlcXVlbmNlXG4gICAgICBmb3IgKHZhciBzZXFJZHggPSAwOyBzZXFJZHggPCBpc29sYXRpbmdSdW5TZXFzLmxlbmd0aDsgc2VxSWR4KyspIHtcbiAgICAgICAgdmFyIHJlZiA9IGlzb2xhdGluZ1J1blNlcXNbc2VxSWR4XTtcbiAgICAgICAgdmFyIHNlcUluZGljZXMkMSA9IHJlZi5fc2VxSW5kaWNlcztcbiAgICAgICAgdmFyIHNvc1R5cGUgPSByZWYuX3Nvc1R5cGU7XG4gICAgICAgIHZhciBlb3NUeXBlID0gcmVmLl9lb3NUeXBlO1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIHRoZSBsZXZlbCBydW5zIGluIGFuIGlzb2xhdGluZyBydW4gc2VxdWVuY2UgaGF2ZSB0aGUgc2FtZSBlbWJlZGRpbmcgbGV2ZWwuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBETyBOT1QgY2hhbmdlIGFueSBgZW1iZWRMZXZlbHNbaV1gIHdpdGhpbiB0aGUgY3VycmVudCBzY29wZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBlbWJlZERpcmVjdGlvbiA9ICgoZW1iZWRMZXZlbHNbc2VxSW5kaWNlcyQxWzBdXSkgJiAxKSA/IFRZUEVfUiA6IFRZUEVfTDtcblxuICAgICAgICAvLyA9PT0gMy4zLjQgUmVzb2x2aW5nIFdlYWsgVHlwZXMgPT09XG5cbiAgICAgICAgLy8gVzEgKyA1LjIuIFNlYXJjaCBiYWNrd2FyZCBmcm9tIGVhY2ggTlNNIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gdGhlIGlzb2xhdGluZyBydW4gc2VxdWVuY2Ugd2hvc2VcbiAgICAgICAgLy8gYmlkaXJlY3Rpb25hbCB0eXBlIGlzIG5vdCBCTiwgYW5kIHNldCB0aGUgTlNNIHRvIE9OIGlmIGl0IGlzIGFuIGlzb2xhdGUgaW5pdGlhdG9yIG9yIFBESSwgYW5kIHRvIGl0c1xuICAgICAgICAvLyB0eXBlIG90aGVyd2lzZS4gSWYgdGhlIE5TTSBpcyB0aGUgZmlyc3Qgbm9uLUJOIGNoYXJhY3RlciwgY2hhbmdlIHRoZSBOU00gdG8gdGhlIHR5cGUgb2Ygc29zLlxuICAgICAgICBpZiAoY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfTlNNKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpID0gMDsgc2kgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSsrKSB7XG4gICAgICAgICAgICB2YXIgaSQ4ID0gc2VxSW5kaWNlcyQxW3NpXTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQ4XSAmIFRZUEVfTlNNKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2VHlwZSA9IHNvc1R5cGU7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqID0gc2kgLSAxOyBzaiA+PSAwOyBzai0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzal1dICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjIgc2NhbiBiYWNrIHRvIGZpcnN0IG5vbi1CTlxuICAgICAgICAgICAgICAgICAgcHJldlR5cGUgPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqXV07XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDgsIChwcmV2VHlwZSAmIChJU09MQVRFX0lOSVRfVFlQRVMgfCBUWVBFX1BESSkpID8gVFlQRV9PTiA6IHByZXZUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXMi4gU2VhcmNoIGJhY2t3YXJkIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlciB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIEFMLCBvciBzb3MpXG4gICAgICAgIC8vIGlzIGZvdW5kLiBJZiBhbiBBTCBpcyBmb3VuZCwgY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBFdXJvcGVhbiBudW1iZXIgdG8gQXJhYmljIG51bWJlci5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VOKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDEgPSAwOyBzaSQxIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkMSsrKSB7XG4gICAgICAgICAgICB2YXIgaSQ5ID0gc2VxSW5kaWNlcyQxW3NpJDFdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDldICYgVFlQRV9FTikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQxID0gc2kkMSAtIDE7IHNqJDEgPj0gLTE7IHNqJDEtLSkge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2Q2hhclR5cGUgPSBzaiQxID09PSAtMSA/IHNvc1R5cGUgOiBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDFdXTtcbiAgICAgICAgICAgICAgICBpZiAocHJldkNoYXJUeXBlICYgU1RST05HX1RZUEVTKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocHJldkNoYXJUeXBlID09PSBUWVBFX0FMKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKGkkOSwgVFlQRV9BTik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9BTCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQyID0gMDsgc2kkMiA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDIrKykge1xuICAgICAgICAgICAgdmFyIGkkMTAgPSBzZXFJbmRpY2VzJDFbc2kkMl07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTBdICYgVFlQRV9BTCkge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDEwLCBUWVBFX1IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFc0LiBBIHNpbmdsZSBFdXJvcGVhbiBzZXBhcmF0b3IgYmV0d2VlbiB0d28gRXVyb3BlYW4gbnVtYmVycyBjaGFuZ2VzIHRvIGEgRXVyb3BlYW4gbnVtYmVyLiBBIHNpbmdsZSBjb21tb25cbiAgICAgICAgLy8gc2VwYXJhdG9yIGJldHdlZW4gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VTKSB8fCBjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9DUykpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQzID0gMTsgc2kkMyA8IHNlcUluZGljZXMkMS5sZW5ndGggLSAxOyBzaSQzKyspIHtcbiAgICAgICAgICAgIHZhciBpJDExID0gc2VxSW5kaWNlcyQxW3NpJDNdO1xuICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDExXSAmIChUWVBFX0VTIHwgVFlQRV9DUykpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZUeXBlJDEgPSAwLCBuZXh0VHlwZSA9IDA7XG4gICAgICAgICAgICAgIGZvciAodmFyIHNqJDIgPSBzaSQzIC0gMTsgc2okMiA+PSAwOyBzaiQyLS0pIHtcbiAgICAgICAgICAgICAgICBwcmV2VHlwZSQxID0gY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQyXV07XG4gICAgICAgICAgICAgICAgaWYgKCEocHJldlR5cGUkMSAmIEJOX0xJS0VfVFlQRVMpKSB7IC8vNS4yXG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQzID0gc2kkMyArIDE7IHNqJDMgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaiQzKyspIHtcbiAgICAgICAgICAgICAgICBuZXh0VHlwZSA9IGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2okM11dO1xuICAgICAgICAgICAgICAgIGlmICghKG5leHRUeXBlICYgQk5fTElLRV9UWVBFUykpIHsgLy81LjJcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChwcmV2VHlwZSQxID09PSBuZXh0VHlwZSAmJiAoY2hhclR5cGVzW2kkMTFdID09PSBUWVBFX0VTID8gcHJldlR5cGUkMSA9PT0gVFlQRV9FTiA6IChwcmV2VHlwZSQxICYgKFRZUEVfRU4gfCBUWVBFX0FOKSkpKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoaSQxMSwgcHJldlR5cGUkMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXNS4gQSBzZXF1ZW5jZSBvZiBFdXJvcGVhbiB0ZXJtaW5hdG9ycyBhZGphY2VudCB0byBFdXJvcGVhbiBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FTikpIHtcbiAgICAgICAgICBmb3IgKHZhciBzaSQ0ID0gMDsgc2kkNCA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDQrKykge1xuICAgICAgICAgICAgdmFyIGkkMTIgPSBzZXFJbmRpY2VzJDFbc2kkNF07XG4gICAgICAgICAgICBpZiAoY2hhclR5cGVzW2kkMTJdICYgVFlQRV9FTikge1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQ0ID0gc2kkNCAtIDE7IHNqJDQgPj0gMCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ0XV0gJiAoVFlQRV9FVCB8IEJOX0xJS0VfVFlQRVMpKTsgc2okNC0tKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NqJDRdLCBUWVBFX0VOKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHNpJDQrKzsgc2kkNCA8IHNlcUluZGljZXMkMS5sZW5ndGggJiYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkNF1dICYgKFRZUEVfRVQgfCBCTl9MSUtFX1RZUEVTIHwgVFlQRV9FTikpOyBzaSQ0KyspIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQ0XV0gIT09IFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgICAgIGNoYW5nZUNoYXJUeXBlKHNlcUluZGljZXMkMVtzaSQ0XSwgVFlQRV9FTik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzYuIE90aGVyd2lzZSwgc2VwYXJhdG9ycyBhbmQgdGVybWluYXRvcnMgY2hhbmdlIHRvIE90aGVyIE5ldXRyYWwuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoVFlQRV9FVCkgfHwgY2hhclR5cGVDb3VudHMuZ2V0KFRZUEVfRVMpIHx8IGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0NTKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDUgPSAwOyBzaSQ1IDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kkNSsrKSB7XG4gICAgICAgICAgICB2YXIgaSQxMyA9IHNlcUluZGljZXMkMVtzaSQ1XTtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbaSQxM10gJiAoVFlQRV9FVCB8IFRZUEVfRVMgfCBUWVBFX0NTKSkge1xuICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDEzLCBUWVBFX09OKTtcbiAgICAgICAgICAgICAgLy8gNS4yIHRyYW5zZm9ybSBhZGphY2VudCBCTnMgdG9vOlxuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQ1ID0gc2kkNSAtIDE7IHNqJDUgPj0gMCAmJiAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ1XV0gJiBCTl9MSUtFX1RZUEVTKTsgc2okNS0tKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ2hhclR5cGUoc2VxSW5kaWNlcyQxW3NqJDVdLCBUWVBFX09OKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQ2ID0gc2kkNSArIDE7IHNqJDYgPCBzZXFJbmRpY2VzJDEubGVuZ3RoICYmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NqJDZdXSAmIEJOX0xJS0VfVFlQRVMpOyBzaiQ2KyspIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShzZXFJbmRpY2VzJDFbc2okNl0sIFRZUEVfT04pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZCBmcm9tIGVhY2ggaW5zdGFuY2Ugb2YgYSBFdXJvcGVhbiBudW1iZXIgdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBvciBzb3MpXG4gICAgICAgIC8vIGlzIGZvdW5kLiBJZiBhbiBMIGlzIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICAgIC8vIE5PVEU6IGltcGxlbWVudGVkIGluIHNpbmdsZSBmb3J3YXJkIHBhc3MgZm9yIGVmZmljaWVuY3lcbiAgICAgICAgaWYgKGNoYXJUeXBlQ291bnRzLmdldChUWVBFX0VOKSkge1xuICAgICAgICAgIGZvciAodmFyIHNpJDYgPSAwLCBwcmV2U3Ryb25nVHlwZSA9IHNvc1R5cGU7IHNpJDYgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ2KyspIHtcbiAgICAgICAgICAgIHZhciBpJDE0ID0gc2VxSW5kaWNlcyQxW3NpJDZdO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBjaGFyVHlwZXNbaSQxNF07XG4gICAgICAgICAgICBpZiAodHlwZSAmIFRZUEVfRU4pIHtcbiAgICAgICAgICAgICAgaWYgKHByZXZTdHJvbmdUeXBlID09PSBUWVBFX0wpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VDaGFyVHlwZShpJDE0LCBUWVBFX0wpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgJiBTVFJPTkdfVFlQRVMpIHtcbiAgICAgICAgICAgICAgcHJldlN0cm9uZ1R5cGUgPSB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vID09PSAzLjMuNSBSZXNvbHZpbmcgTmV1dHJhbCBhbmQgSXNvbGF0ZSBGb3JtYXR0aW5nIFR5cGVzID09PVxuXG4gICAgICAgIGlmIChjaGFyVHlwZUNvdW50cy5nZXQoTkVVVFJBTF9JU09MQVRFX1RZUEVTKSkge1xuICAgICAgICAgIC8vIE4wLiBQcm9jZXNzIGJyYWNrZXQgcGFpcnMgaW4gYW4gaXNvbGF0aW5nIHJ1biBzZXF1ZW5jZSBzZXF1ZW50aWFsbHkgaW4gdGhlIGxvZ2ljYWwgb3JkZXIgb2YgdGhlIHRleHRcbiAgICAgICAgICAvLyBwb3NpdGlvbnMgb2YgdGhlIG9wZW5pbmcgcGFpcmVkIGJyYWNrZXRzIHVzaW5nIHRoZSBsb2dpYyBnaXZlbiBiZWxvdy4gV2l0aGluIHRoaXMgc2NvcGUsIGJpZGlyZWN0aW9uYWxcbiAgICAgICAgICAvLyB0eXBlcyBFTiBhbmQgQU4gYXJlIHRyZWF0ZWQgYXMgUi5cbiAgICAgICAgICB2YXIgUl9UWVBFU19GT1JfTl9TVEVQUyA9IChUWVBFX1IgfCBUWVBFX0VOIHwgVFlQRV9BTik7XG4gICAgICAgICAgdmFyIFNUUk9OR19UWVBFU19GT1JfTl9TVEVQUyA9IFJfVFlQRVNfRk9SX05fU1RFUFMgfCBUWVBFX0w7XG5cbiAgICAgICAgICAvLyAqIElkZW50aWZ5IHRoZSBicmFja2V0IHBhaXJzIGluIHRoZSBjdXJyZW50IGlzb2xhdGluZyBydW4gc2VxdWVuY2UgYWNjb3JkaW5nIHRvIEJEMTYuXG4gICAgICAgICAgdmFyIGJyYWNrZXRQYWlycyA9IFtdO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBvcGVuZXJTdGFjayA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgc2kkNyA9IDA7IHNpJDcgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQ3KyspIHtcbiAgICAgICAgICAgICAgLy8gTk9URTogZm9yIGFueSBwb3RlbnRpYWwgYnJhY2tldCBjaGFyYWN0ZXIgd2UgYWxzbyB0ZXN0IHRoYXQgaXQgc3RpbGwgY2FycmllcyBhIE5JXG4gICAgICAgICAgICAgIC8vIHR5cGUsIGFzIHRoYXQgbWF5IGhhdmUgYmVlbiBjaGFuZ2VkIGVhcmxpZXIuIFRoaXMgZG9lc24ndCBzZWVtIHRvIGJlIGV4cGxpY2l0bHlcbiAgICAgICAgICAgICAgLy8gY2FsbGVkIG91dCBpbiB0aGUgc3BlYywgYnV0IGlzIHJlcXVpcmVkIGZvciBwYXNzYWdlIG9mIGNlcnRhaW4gdGVzdHMuXG4gICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDddXSAmIE5FVVRSQUxfSVNPTEFURV9UWVBFUykge1xuICAgICAgICAgICAgICAgIHZhciBjaGFyID0gc3RyaW5nW3NlcUluZGljZXMkMVtzaSQ3XV07XG4gICAgICAgICAgICAgICAgdmFyIG9wcG9zaXRlQnJhY2tldCA9ICh2b2lkIDApO1xuICAgICAgICAgICAgICAgIC8vIE9wZW5pbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgIGlmIChvcGVuaW5nVG9DbG9zaW5nQnJhY2tldChjaGFyKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKG9wZW5lclN0YWNrLmxlbmd0aCA8IDYzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW5lclN0YWNrLnB1c2goeyBjaGFyOiBjaGFyLCBzZXFJbmRleDogc2kkNyB9KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENsb3NpbmcgYnJhY2tldFxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChvcHBvc2l0ZUJyYWNrZXQgPSBjbG9zaW5nVG9PcGVuaW5nQnJhY2tldChjaGFyKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIHN0YWNrSWR4ID0gb3BlbmVyU3RhY2subGVuZ3RoIC0gMTsgc3RhY2tJZHggPj0gMDsgc3RhY2tJZHgtLSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhY2tDaGFyID0gb3BlbmVyU3RhY2tbc3RhY2tJZHhdLmNoYXI7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFja0NoYXIgPT09IG9wcG9zaXRlQnJhY2tldCB8fFxuICAgICAgICAgICAgICAgICAgICAgIHN0YWNrQ2hhciA9PT0gY2xvc2luZ1RvT3BlbmluZ0JyYWNrZXQoZ2V0Q2Fub25pY2FsQnJhY2tldChjaGFyKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICBvcGVuaW5nVG9DbG9zaW5nQnJhY2tldChnZXRDYW5vbmljYWxCcmFja2V0KHN0YWNrQ2hhcikpID09PSBjaGFyXG4gICAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAgIGJyYWNrZXRQYWlycy5wdXNoKFtvcGVuZXJTdGFja1tzdGFja0lkeF0uc2VxSW5kZXgsIHNpJDddKTtcbiAgICAgICAgICAgICAgICAgICAgICBvcGVuZXJTdGFjay5sZW5ndGggPSBzdGFja0lkeDsgLy9wb3AgdGhlIG1hdGNoaW5nIGJyYWNrZXQgYW5kIGFsbCBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmFja2V0UGFpcnMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyAqIEZvciBlYWNoIGJyYWNrZXQtcGFpciBlbGVtZW50IGluIHRoZSBsaXN0IG9mIHBhaXJzIG9mIHRleHQgcG9zaXRpb25zXG4gICAgICAgICAgZm9yICh2YXIgcGFpcklkeCA9IDA7IHBhaXJJZHggPCBicmFja2V0UGFpcnMubGVuZ3RoOyBwYWlySWR4KyspIHtcbiAgICAgICAgICAgIHZhciByZWYkMSA9IGJyYWNrZXRQYWlyc1twYWlySWR4XTtcbiAgICAgICAgICAgIHZhciBvcGVuU2VxSWR4ID0gcmVmJDFbMF07XG4gICAgICAgICAgICB2YXIgY2xvc2VTZXFJZHggPSByZWYkMVsxXTtcbiAgICAgICAgICAgIC8vIGEuIEluc3BlY3QgdGhlIGJpZGlyZWN0aW9uYWwgdHlwZXMgb2YgdGhlIGNoYXJhY3RlcnMgZW5jbG9zZWQgd2l0aGluIHRoZSBicmFja2V0IHBhaXIuXG4gICAgICAgICAgICAvLyBiLiBJZiBhbnkgc3Ryb25nIHR5cGUgKGVpdGhlciBMIG9yIFIpIG1hdGNoaW5nIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uIGlzIGZvdW5kLCBzZXQgdGhlIHR5cGUgZm9yIGJvdGhcbiAgICAgICAgICAgIC8vIGJyYWNrZXRzIGluIHRoZSBwYWlyIHRvIG1hdGNoIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgICAgICAgdmFyIGZvdW5kU3Ryb25nVHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIHVzZVN0cm9uZ1R5cGUgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgc2kkOCA9IG9wZW5TZXFJZHggKyAxOyBzaSQ4IDwgY2xvc2VTZXFJZHg7IHNpJDgrKykge1xuICAgICAgICAgICAgICB2YXIgaSQxNSA9IHNlcUluZGljZXMkMVtzaSQ4XTtcbiAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDE1XSAmIFNUUk9OR19UWVBFU19GT1JfTl9TVEVQUykge1xuICAgICAgICAgICAgICAgIGZvdW5kU3Ryb25nVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIGxyID0gKGNoYXJUeXBlc1tpJDE1XSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MO1xuICAgICAgICAgICAgICAgIGlmIChsciA9PT0gZW1iZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBscjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjLiBPdGhlcndpc2UsIGlmIHRoZXJlIGlzIGEgc3Ryb25nIHR5cGUgaXQgbXVzdCBiZSBvcHBvc2l0ZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbi4gVGhlcmVmb3JlLCB0ZXN0XG4gICAgICAgICAgICAvLyBmb3IgYW4gZXN0YWJsaXNoZWQgY29udGV4dCB3aXRoIGEgcHJlY2VkaW5nIHN0cm9uZyB0eXBlIGJ5IGNoZWNraW5nIGJhY2t3YXJkcyBiZWZvcmUgdGhlIG9wZW5pbmcgcGFpcmVkXG4gICAgICAgICAgICAvLyBicmFja2V0IHVudGlsIHRoZSBmaXJzdCBzdHJvbmcgdHlwZSAoTCwgUiwgb3Igc29zKSBpcyBmb3VuZC5cbiAgICAgICAgICAgIC8vICAgIDEuIElmIHRoZSBwcmVjZWRpbmcgc3Ryb25nIHR5cGUgaXMgYWxzbyBvcHBvc2l0ZSB0aGUgZW1iZWRkaW5nIGRpcmVjdGlvbiwgY29udGV4dCBpcyBlc3RhYmxpc2hlZCwgc29cbiAgICAgICAgICAgIC8vICAgIHNldCB0aGUgdHlwZSBmb3IgYm90aCBicmFja2V0cyBpbiB0aGUgcGFpciB0byB0aGF0IGRpcmVjdGlvbi5cbiAgICAgICAgICAgIC8vICAgIDIuIE90aGVyd2lzZSBzZXQgdGhlIHR5cGUgZm9yIGJvdGggYnJhY2tldHMgaW4gdGhlIHBhaXIgdG8gdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAgICBpZiAoZm91bmRTdHJvbmdUeXBlICYmICF1c2VTdHJvbmdUeXBlKSB7XG4gICAgICAgICAgICAgIHVzZVN0cm9uZ1R5cGUgPSBzb3NUeXBlO1xuICAgICAgICAgICAgICBmb3IgKHZhciBzaSQ5ID0gb3BlblNlcUlkeCAtIDE7IHNpJDkgPj0gMDsgc2kkOS0tKSB7XG4gICAgICAgICAgICAgICAgdmFyIGkkMTYgPSBzZXFJbmRpY2VzJDFbc2kkOV07XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tpJDE2XSAmIFNUUk9OR19UWVBFU19GT1JfTl9TVEVQUykge1xuICAgICAgICAgICAgICAgICAgdmFyIGxyJDEgPSAoY2hhclR5cGVzW2kkMTZdICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgICBpZiAobHIkMSAhPT0gZW1iZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgdXNlU3Ryb25nVHlwZSA9IGxyJDE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1c2VTdHJvbmdUeXBlID0gZW1iZWREaXJlY3Rpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVzZVN0cm9uZ1R5cGUpIHtcbiAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtvcGVuU2VxSWR4XV0gPSBjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW2Nsb3NlU2VxSWR4XV0gPSB1c2VTdHJvbmdUeXBlO1xuICAgICAgICAgICAgICAvLyAqIEFueSBudW1iZXIgb2YgY2hhcmFjdGVycyB0aGF0IGhhZCBvcmlnaW5hbCBiaWRpcmVjdGlvbmFsIGNoYXJhY3RlciB0eXBlIE5TTSBwcmlvciB0byB0aGUgYXBwbGljYXRpb25cbiAgICAgICAgICAgICAgLy8gb2YgVzEgdGhhdCBpbW1lZGlhdGVseSBmb2xsb3cgYSBwYWlyZWQgYnJhY2tldCB3aGljaCBjaGFuZ2VkIHRvIEwgb3IgUiB1bmRlciBOMCBzaG91bGQgY2hhbmdlIHRvIG1hdGNoXG4gICAgICAgICAgICAgIC8vIHRoZSB0eXBlIG9mIHRoZWlyIHByZWNlZGluZyBicmFja2V0LlxuICAgICAgICAgICAgICBpZiAodXNlU3Ryb25nVHlwZSAhPT0gZW1iZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSQxMCA9IG9wZW5TZXFJZHggKyAxOyBzaSQxMCA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDEwKyspIHtcbiAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTBdXSAmIEJOX0xJS0VfVFlQRVMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW3NlcUluZGljZXMkMVtzaSQxMF1dKSAmIFRZUEVfTlNNKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaSQxMF1dID0gdXNlU3Ryb25nVHlwZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodXNlU3Ryb25nVHlwZSAhPT0gZW1iZWREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBzaSQxMSA9IGNsb3NlU2VxSWR4ICsgMTsgc2kkMTEgPCBzZXFJbmRpY2VzJDEubGVuZ3RoOyBzaSQxMSsrKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIShjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDExXV0gJiBCTl9MSUtFX1RZUEVTKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tzZXFJbmRpY2VzJDFbc2kkMTFdXSkgJiBUWVBFX05TTSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kkMTFdXSA9IHVzZVN0cm9uZ1R5cGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOMS4gQSBzZXF1ZW5jZSBvZiBOSXMgdGFrZXMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3Vycm91bmRpbmcgc3Ryb25nIHRleHQgaWYgdGhlIHRleHQgb24gYm90aCBzaWRlcyBoYXMgdGhlXG4gICAgICAgICAgLy8gc2FtZSBkaXJlY3Rpb24uXG4gICAgICAgICAgLy8gTjIuIEFueSByZW1haW5pbmcgTklzIHRha2UgdGhlIGVtYmVkZGluZyBkaXJlY3Rpb24uXG4gICAgICAgICAgZm9yICh2YXIgc2kkMTIgPSAwOyBzaSQxMiA8IHNlcUluZGljZXMkMS5sZW5ndGg7IHNpJDEyKyspIHtcbiAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpJDEyXV0gJiBORVVUUkFMX0lTT0xBVEVfVFlQRVMpIHtcbiAgICAgICAgICAgICAgdmFyIG5pUnVuU3RhcnQgPSBzaSQxMiwgbmlSdW5FbmQgPSBzaSQxMjtcbiAgICAgICAgICAgICAgdmFyIHByZXZUeXBlJDIgPSBzb3NUeXBlOyAvL3NpID09PSAwID8gc29zVHlwZSA6IChjaGFyVHlwZXNbc2VxSW5kaWNlc1tzaSAtIDFdXSAmIFJfVFlQRVNfRk9SX05fU1RFUFMpID8gVFlQRV9SIDogVFlQRV9MXG4gICAgICAgICAgICAgIGZvciAodmFyIHNpMiA9IHNpJDEyIC0gMTsgc2kyID49IDA7IHNpMi0tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyXV0gJiBCTl9MSUtFX1RZUEVTKSB7XG4gICAgICAgICAgICAgICAgICBuaVJ1blN0YXJ0ID0gc2kyOyAvLzUuMiB0cmVhdCBCTnMgYWRqYWNlbnQgdG8gTklzIGFzIE5Jc1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwcmV2VHlwZSQyID0gKGNoYXJUeXBlc1tzZXFJbmRpY2VzJDFbc2kyXV0gJiBSX1RZUEVTX0ZPUl9OX1NURVBTKSA/IFRZUEVfUiA6IFRZUEVfTDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHZhciBuZXh0VHlwZSQxID0gZW9zVHlwZTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgc2kyJDEgPSBzaSQxMiArIDE7IHNpMiQxIDwgc2VxSW5kaWNlcyQxLmxlbmd0aDsgc2kyJDErKykge1xuICAgICAgICAgICAgICAgIGlmIChjaGFyVHlwZXNbc2VxSW5kaWNlcyQxW3NpMiQxXV0gJiAoTkVVVFJBTF9JU09MQVRFX1RZUEVTIHwgQk5fTElLRV9UWVBFUykpIHtcbiAgICAgICAgICAgICAgICAgIG5pUnVuRW5kID0gc2kyJDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5leHRUeXBlJDEgPSAoY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaTIkMV1dICYgUl9UWVBFU19GT1JfTl9TVEVQUykgPyBUWVBFX1IgOiBUWVBFX0w7XG4gICAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmb3IgKHZhciBzaiQ3ID0gbmlSdW5TdGFydDsgc2okNyA8PSBuaVJ1bkVuZDsgc2okNysrKSB7XG4gICAgICAgICAgICAgICAgY2hhclR5cGVzW3NlcUluZGljZXMkMVtzaiQ3XV0gPSBwcmV2VHlwZSQyID09PSBuZXh0VHlwZSQxID8gcHJldlR5cGUkMiA6IGVtYmVkRGlyZWN0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHNpJDEyID0gbmlSdW5FbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vID09PSAzLjMuNiBSZXNvbHZpbmcgSW1wbGljaXQgTGV2ZWxzID09PVxuXG4gICAgICBmb3IgKHZhciBpJDE3ID0gcGFyYWdyYXBoLnN0YXJ0OyBpJDE3IDw9IHBhcmFncmFwaC5lbmQ7IGkkMTcrKykge1xuICAgICAgICB2YXIgbGV2ZWwkMyA9IGVtYmVkTGV2ZWxzW2kkMTddO1xuICAgICAgICB2YXIgdHlwZSQxID0gY2hhclR5cGVzW2kkMTddO1xuICAgICAgICAvLyBJMi4gRm9yIGFsbCBjaGFyYWN0ZXJzIHdpdGggYW4gb2RkIChyaWdodC10by1sZWZ0KSBlbWJlZGRpbmcgbGV2ZWwsIHRob3NlIG9mIHR5cGUgTCwgRU4gb3IgQU4gZ28gdXAgb25lIGxldmVsLlxuICAgICAgICBpZiAobGV2ZWwkMyAmIDEpIHtcbiAgICAgICAgICBpZiAodHlwZSQxICYgKFRZUEVfTCB8IFRZUEVfRU4gfCBUWVBFX0FOKSkge1xuICAgICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10rKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgICAvLyBJMS4gRm9yIGFsbCBjaGFyYWN0ZXJzIHdpdGggYW4gZXZlbiAobGVmdC10by1yaWdodCkgZW1iZWRkaW5nIGxldmVsLCB0aG9zZSBvZiB0eXBlIFIgZ28gdXAgb25lIGxldmVsXG4gICAgICAgIC8vIGFuZCB0aG9zZSBvZiB0eXBlIEFOIG9yIEVOIGdvIHVwIHR3byBsZXZlbHMuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlJDEgJiBUWVBFX1IpIHtcbiAgICAgICAgICAgIGVtYmVkTGV2ZWxzW2kkMTddKys7XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlJDEgJiAoVFlQRV9BTiB8IFRZUEVfRU4pKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tpJDE3XSArPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDUuMjogUmVzb2x2ZSBhbnkgTFJFLCBSTEUsIExSTywgUkxPLCBQREYsIG9yIEJOIHRvIHRoZSBsZXZlbCBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3RlciBpZiB0aGVyZSBpcyBvbmUsXG4gICAgICAgIC8vIGFuZCBvdGhlcndpc2UgdG8gdGhlIGJhc2UgbGV2ZWwuXG4gICAgICAgIGlmICh0eXBlJDEgJiBCTl9MSUtFX1RZUEVTKSB7XG4gICAgICAgICAgZW1iZWRMZXZlbHNbaSQxN10gPSBpJDE3ID09PSAwID8gcGFyYWdyYXBoLmxldmVsIDogZW1iZWRMZXZlbHNbaSQxNyAtIDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMy40IEwxLjEtNDogUmVzZXQgdGhlIGVtYmVkZGluZyBsZXZlbCBvZiBzZWdtZW50L3BhcmFncmFwaCBzZXBhcmF0b3JzLCBhbmQgYW55IHNlcXVlbmNlIG9mIHdoaXRlc3BhY2Ugb3JcbiAgICAgICAgLy8gaXNvbGF0ZSBmb3JtYXR0aW5nIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZW0gb3IgdGhlIGVuZCBvZiB0aGUgcGFyYWdyYXBoLCB0byB0aGUgcGFyYWdyYXBoIGxldmVsLlxuICAgICAgICAvLyBOT1RFOiB0aGlzIHdpbGwgYWxzbyBuZWVkIHRvIGJlIGFwcGxpZWQgdG8gZWFjaCBpbmRpdmlkdWFsIGxpbmUgZW5kaW5nIGFmdGVyIGxpbmUgd3JhcHBpbmcgb2NjdXJzLlxuICAgICAgICBpZiAoaSQxNyA9PT0gcGFyYWdyYXBoLmVuZCB8fCBnZXRCaWRpQ2hhclR5cGUoc3RyaW5nW2kkMTddKSAmIChUWVBFX1MgfCBUWVBFX0IpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiQxID0gaSQxNzsgaiQxID49IDAgJiYgKGdldEJpZGlDaGFyVHlwZShzdHJpbmdbaiQxXSkgJiBUUkFJTElOR19UWVBFUyk7IGokMS0tKSB7XG4gICAgICAgICAgICBlbWJlZExldmVsc1tqJDFdID0gcGFyYWdyYXBoLmxldmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERPTkUhIFRoZSByZXNvbHZlZCBsZXZlbHMgY2FuIHRoZW4gYmUgdXNlZCwgYWZ0ZXIgbGluZSB3cmFwcGluZywgdG8gZmxpcCBydW5zIG9mIGNoYXJhY3RlcnNcbiAgICAvLyBhY2NvcmRpbmcgdG8gc2VjdGlvbiAzLjQgUmVvcmRlcmluZyBSZXNvbHZlZCBMZXZlbHNcbiAgICByZXR1cm4ge1xuICAgICAgbGV2ZWxzOiBlbWJlZExldmVscyxcbiAgICAgIHBhcmFncmFwaHM6IHBhcmFncmFwaHNcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZXRlcm1pbmVBdXRvRW1iZWRMZXZlbCAoc3RhcnQsIGlzRlNJKSB7XG4gICAgICAvLyAzLjMuMSBQMiAtIFAzXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJUeXBlID0gY2hhclR5cGVzW2ldO1xuICAgICAgICBpZiAoY2hhclR5cGUgJiAoVFlQRV9SIHwgVFlQRV9BTCkpIHtcbiAgICAgICAgICByZXR1cm4gMVxuICAgICAgICB9XG4gICAgICAgIGlmICgoY2hhclR5cGUgJiAoVFlQRV9CIHwgVFlQRV9MKSkgfHwgKGlzRlNJICYmIGNoYXJUeXBlID09PSBUWVBFX1BESSkpIHtcbiAgICAgICAgICByZXR1cm4gMFxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIElTT0xBVEVfSU5JVF9UWVBFUykge1xuICAgICAgICAgIHZhciBwZGkgPSBpbmRleE9mTWF0Y2hpbmdQREkoaSk7XG4gICAgICAgICAgaSA9IHBkaSA9PT0gLTEgPyBzdHJpbmcubGVuZ3RoIDogcGRpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluZGV4T2ZNYXRjaGluZ1BESSAoaXNvbGF0ZVN0YXJ0KSB7XG4gICAgICAvLyAzLjEuMiBCRDlcbiAgICAgIHZhciBpc29sYXRpb25MZXZlbCA9IDE7XG4gICAgICBmb3IgKHZhciBpID0gaXNvbGF0ZVN0YXJ0ICsgMTsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhclR5cGUgPSBjaGFyVHlwZXNbaV07XG4gICAgICAgIGlmIChjaGFyVHlwZSAmIFRZUEVfQikge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYXJUeXBlICYgVFlQRV9QREkpIHtcbiAgICAgICAgICBpZiAoLS1pc29sYXRpb25MZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhclR5cGUgJiBJU09MQVRFX0lOSVRfVFlQRVMpIHtcbiAgICAgICAgICBpc29sYXRpb25MZXZlbCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gIH1cblxuICAvLyBCaWRpIG1pcnJvcmVkIGNoYXJzIGRhdGEsIGF1dG8gZ2VuZXJhdGVkXG4gIHZhciBkYXRhID0gXCIxND4xLGo+Mix0PjIsdT4yLDFhPmcsMnYzPjEsMT4xLDFnZT4xLDF3ZD4xLGI+MSwxaj4xLGY+MSxhaT4zLC0yPjMsKzEsOD4xazAsLTFqcT4xeTcsLTF5Nj4xaGYsLTFoZT4xaDYsLTFoNT4xaGEsLTFoOD4xcWksLTFwdT4xLDY+M3UsLTNzPjcsNj4xLDE+MSxmPjEsMT4xLCsyLDM+MSwxPjEsKzEzLDQ+MSwxPjEsNj4xZW8sLTFlZT4xLDM+MW1nLC0xbWU+MW1rLC0xbWo+MW1pLC0xbWc+MW1pLC0xbWQ+MSwxPjEsKzIsMT4xMGssLTEwMz4xLDE+MSw0PjEsNT4xLDE+MSwrMTAsMz4xLDE+OCwtNz44LCsxLC02PjcsKzEsYT4xLDE+MSx1PjEsdTY+MSwxPjEsKzUsMjY+MSwxPjEsMj4xLDI+Miw4PjEsNz4xLDQ+MSwxPjEsKzUsYjg+MSwxPjEsKzMsMT4zLC0yPjEsMj4xLDE+MSwrMixjPjEsMz4xLDE+MSwrMixoPjEsMz4xLGE+MSwxPjEsMj4xLDM+MSwxPjEsZD4xLGY+MSwzPjEsMWE+MSwxPjEsNj4xLDc+MSwxMz4xLGs+MSwxPjEsKzE5LDQ+MSwxPjEsKzIsMj4xLDE+MSwrMTgsbT4xLGE+MSwxPjEsbGs+MSwxPjEsND4xLDI+MSxmPjEsMz4xLDE+MSwrMyxkYj4xLDE+MSwrMywzPjEsMT4xLCsyLDE0cW0+MSwxPjEsKzEsNj4xLDRqPjEsaj4yLHQ+Mix1PjIsMj4xLCsxXCI7XG5cbiAgdmFyIG1pcnJvck1hcDtcblxuICBmdW5jdGlvbiBwYXJzZSAoKSB7XG4gICAgaWYgKCFtaXJyb3JNYXApIHtcbiAgICAgIC8vY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgICAgdmFyIHJlZiA9IHBhcnNlQ2hhcmFjdGVyTWFwKGRhdGEsIHRydWUpO1xuICAgICAgdmFyIG1hcCA9IHJlZi5tYXA7XG4gICAgICB2YXIgcmV2ZXJzZU1hcCA9IHJlZi5yZXZlcnNlTWFwO1xuICAgICAgLy8gQ29tYmluZSBib3RoIG1hcHMgaW50byBvbmVcbiAgICAgIHJldmVyc2VNYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgICBtaXJyb3JNYXAgPSBtYXA7XG4gICAgICAvL2NvbnNvbGUubG9nKGBtaXJyb3JlZCBjaGFycyBwYXJzZWQgaW4gJHtwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0fW1zYClcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNaXJyb3JlZENoYXJhY3RlciAoY2hhcikge1xuICAgIHBhcnNlKCk7XG4gICAgcmV0dXJuIG1pcnJvck1hcC5nZXQoY2hhcikgfHwgbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgc3RyaW5nIGFuZCBpdHMgcmVzb2x2ZWQgZW1iZWRkaW5nIGxldmVscywgYnVpbGQgYSBtYXAgb2YgaW5kaWNlcyB0byByZXBsYWNlbWVudCBjaGFyc1xuICAgKiBmb3IgYW55IGNoYXJhY3RlcnMgaW4gcmlnaHQtdG8tbGVmdCBzZWdtZW50cyB0aGF0IGhhdmUgZGVmaW5lZCBtaXJyb3JlZCBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gc3RyaW5nXG4gICAqIEBwYXJhbSBlbWJlZGRpbmdMZXZlbHNcbiAgICogQHBhcmFtIFtzdGFydF1cbiAgICogQHBhcmFtIFtlbmRdXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsIHN0cmluZz59XG4gICAqL1xuICBmdW5jdGlvbiBnZXRNaXJyb3JlZENoYXJhY3RlcnNNYXAoc3RyaW5nLCBlbWJlZGRpbmdMZXZlbHMsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aDtcbiAgICBzdGFydCA9IE1hdGgubWF4KDAsIHN0YXJ0ID09IG51bGwgPyAwIDogK3N0YXJ0KTtcbiAgICBlbmQgPSBNYXRoLm1pbihzdHJMZW4gLSAxLCBlbmQgPT0gbnVsbCA/IHN0ckxlbiAtIDEgOiArZW5kKTtcblxuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDw9IGVuZDsgaSsrKSB7XG4gICAgICBpZiAoZW1iZWRkaW5nTGV2ZWxzW2ldICYgMSkgeyAvL29ubHkgb2RkIChydGwpIGxldmVsc1xuICAgICAgICB2YXIgbWlycm9yID0gZ2V0TWlycm9yZWRDaGFyYWN0ZXIoc3RyaW5nW2ldKTtcbiAgICAgICAgaWYgKG1pcnJvciAhPT0gbnVsbCkge1xuICAgICAgICAgIG1hcC5zZXQoaSwgbWlycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogR2l2ZW4gYSBzdGFydCBhbmQgZW5kIGRlbm90aW5nIGEgc2luZ2xlIGxpbmUgd2l0aGluIGEgc3RyaW5nLCBhbmQgYSBzZXQgb2YgcHJlY2FsY3VsYXRlZFxuICAgKiBiaWRpIGVtYmVkZGluZyBsZXZlbHMsIHByb2R1Y2UgYSBsaXN0IG9mIHNlZ21lbnRzIHdob3NlIG9yZGVyaW5nIHNob3VsZCBiZSBmbGlwcGVkLCBpbiBzZXF1ZW5jZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAtIHRoZSBmdWxsIGlucHV0IHN0cmluZ1xuICAgKiBAcGFyYW0ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH0gZW1iZWRkaW5nTGV2ZWxzUmVzdWx0IC0gdGhlIHJlc3VsdCBvYmplY3QgZnJvbSBnZXRFbWJlZGRpbmdMZXZlbHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF0gLSBmaXJzdCBjaGFyYWN0ZXIgaW4gYSBzdWJzZXQgb2YgdGhlIGZ1bGwgc3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kXSAtIGxhc3QgY2hhcmFjdGVyIGluIGEgc3Vic2V0IG9mIHRoZSBmdWxsIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJbXVtdfSAtIHRoZSBsaXN0IG9mIHN0YXJ0L2VuZCBzZWdtZW50cyB0aGF0IHNob3VsZCBiZSBmbGlwcGVkLCBpbiBvcmRlci5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlb3JkZXJTZWdtZW50cyhzdHJpbmcsIGVtYmVkZGluZ0xldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoO1xuICAgIHN0YXJ0ID0gTWF0aC5tYXgoMCwgc3RhcnQgPT0gbnVsbCA/IDAgOiArc3RhcnQpO1xuICAgIGVuZCA9IE1hdGgubWluKHN0ckxlbiAtIDEsIGVuZCA9PSBudWxsID8gc3RyTGVuIC0gMSA6ICtlbmQpO1xuXG4gICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgZW1iZWRkaW5nTGV2ZWxzUmVzdWx0LnBhcmFncmFwaHMuZm9yRWFjaChmdW5jdGlvbiAocGFyYWdyYXBoKSB7XG4gICAgICB2YXIgbGluZVN0YXJ0ID0gTWF0aC5tYXgoc3RhcnQsIHBhcmFncmFwaC5zdGFydCk7XG4gICAgICB2YXIgbGluZUVuZCA9IE1hdGgubWluKGVuZCwgcGFyYWdyYXBoLmVuZCk7XG4gICAgICBpZiAobGluZVN0YXJ0IDwgbGluZUVuZCkge1xuICAgICAgICAvLyBMb2NhbCBzbGljZSBmb3IgbXV0YXRpb25cbiAgICAgICAgdmFyIGxpbmVMZXZlbHMgPSBlbWJlZGRpbmdMZXZlbHNSZXN1bHQubGV2ZWxzLnNsaWNlKGxpbmVTdGFydCwgbGluZUVuZCArIDEpO1xuXG4gICAgICAgIC8vIDMuNCBMMS40OiBSZXNldCBhbnkgc2VxdWVuY2Ugb2Ygd2hpdGVzcGFjZSBjaGFyYWN0ZXJzIGFuZC9vciBpc29sYXRlIGZvcm1hdHRpbmcgY2hhcmFjdGVycyBhdCB0aGVcbiAgICAgICAgLy8gZW5kIG9mIHRoZSBsaW5lIHRvIHRoZSBwYXJhZ3JhcGggbGV2ZWwuXG4gICAgICAgIGZvciAodmFyIGkgPSBsaW5lRW5kOyBpID49IGxpbmVTdGFydCAmJiAoZ2V0QmlkaUNoYXJUeXBlKHN0cmluZ1tpXSkgJiBUUkFJTElOR19UWVBFUyk7IGktLSkge1xuICAgICAgICAgIGxpbmVMZXZlbHNbaV0gPSBwYXJhZ3JhcGgubGV2ZWw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMMi4gRnJvbSB0aGUgaGlnaGVzdCBsZXZlbCBmb3VuZCBpbiB0aGUgdGV4dCB0byB0aGUgbG93ZXN0IG9kZCBsZXZlbCBvbiBlYWNoIGxpbmUsIGluY2x1ZGluZyBpbnRlcm1lZGlhdGUgbGV2ZWxzXG4gICAgICAgIC8vIG5vdCBhY3R1YWxseSBwcmVzZW50IGluIHRoZSB0ZXh0LCByZXZlcnNlIGFueSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgdGhhdCBhcmUgYXQgdGhhdCBsZXZlbCBvciBoaWdoZXIuXG4gICAgICAgIHZhciBtYXhMZXZlbCA9IHBhcmFncmFwaC5sZXZlbDtcbiAgICAgICAgdmFyIG1pbk9kZExldmVsID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGxpbmVMZXZlbHMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgIHZhciBsZXZlbCA9IGxpbmVMZXZlbHNbaSQxXTtcbiAgICAgICAgICBpZiAobGV2ZWwgPiBtYXhMZXZlbCkgeyBtYXhMZXZlbCA9IGxldmVsOyB9XG4gICAgICAgICAgaWYgKGxldmVsIDwgbWluT2RkTGV2ZWwpIHsgbWluT2RkTGV2ZWwgPSBsZXZlbCB8IDE7IH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBsdmwgPSBtYXhMZXZlbDsgbHZsID49IG1pbk9kZExldmVsOyBsdmwtLSkge1xuICAgICAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGxpbmVMZXZlbHMubGVuZ3RoOyBpJDIrKykge1xuICAgICAgICAgICAgaWYgKGxpbmVMZXZlbHNbaSQyXSA+PSBsdmwpIHtcbiAgICAgICAgICAgICAgdmFyIHNlZ1N0YXJ0ID0gaSQyO1xuICAgICAgICAgICAgICB3aGlsZSAoaSQyICsgMSA8IGxpbmVMZXZlbHMubGVuZ3RoICYmIGxpbmVMZXZlbHNbaSQyICsgMV0gPj0gbHZsKSB7XG4gICAgICAgICAgICAgICAgaSQyKys7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGkkMiA+IHNlZ1N0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChbc2VnU3RhcnQgKyBsaW5lU3RhcnQsIGkkMiArIGxpbmVTdGFydF0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlZ21lbnRzXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgKiBAcGFyYW0ge0dldEVtYmVkZGluZ0xldmVsc1Jlc3VsdH0gZW1iZWRMZXZlbHNSZXN1bHRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge3N0cmluZ30gdGhlIG5ldyBzdHJpbmcgd2l0aCBiaWRpIHNlZ21lbnRzIHJlb3JkZXJlZFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0UmVvcmRlcmVkU3RyaW5nKHN0cmluZywgZW1iZWRMZXZlbHNSZXN1bHQsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgaW5kaWNlcyA9IGdldFJlb3JkZXJlZEluZGljZXMoc3RyaW5nLCBlbWJlZExldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCk7XG4gICAgdmFyIGNoYXJzID0gW10uY29uY2F0KCBzdHJpbmcgKTtcbiAgICBpbmRpY2VzLmZvckVhY2goZnVuY3Rpb24gKGNoYXJJbmRleCwgaSkge1xuICAgICAgY2hhcnNbaV0gPSAoXG4gICAgICAgIChlbWJlZExldmVsc1Jlc3VsdC5sZXZlbHNbY2hhckluZGV4XSAmIDEpID8gZ2V0TWlycm9yZWRDaGFyYWN0ZXIoc3RyaW5nW2NoYXJJbmRleF0pIDogbnVsbFxuICAgICAgKSB8fCBzdHJpbmdbY2hhckluZGV4XTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2hhcnMuam9pbignJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gICAqIEBwYXJhbSB7R2V0RW1iZWRkaW5nTGV2ZWxzUmVzdWx0fSBlbWJlZExldmVsc1Jlc3VsdFxuICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0XVxuICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZF1cbiAgICogQHJldHVybiB7bnVtYmVyW119IGFuIGFycmF5IHdpdGggY2hhcmFjdGVyIGluZGljZXMgaW4gdGhlaXIgbmV3IGJpZGkgb3JkZXJcbiAgICovXG4gIGZ1bmN0aW9uIGdldFJlb3JkZXJlZEluZGljZXMoc3RyaW5nLCBlbWJlZExldmVsc1Jlc3VsdCwgc3RhcnQsIGVuZCkge1xuICAgIHZhciBzZWdtZW50cyA9IGdldFJlb3JkZXJTZWdtZW50cyhzdHJpbmcsIGVtYmVkTGV2ZWxzUmVzdWx0LCBzdGFydCwgZW5kKTtcbiAgICAvLyBGaWxsIGFuIGFycmF5IHdpdGggaW5kaWNlc1xuICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGluZGljZXNbaV0gPSBpO1xuICAgIH1cbiAgICAvLyBSZXZlcnNlIGVhY2ggc2VnbWVudCBpbiBvcmRlclxuICAgIHNlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIHN0YXJ0ID0gcmVmWzBdO1xuICAgICAgdmFyIGVuZCA9IHJlZlsxXTtcblxuICAgICAgdmFyIHNsaWNlID0gaW5kaWNlcy5zbGljZShzdGFydCwgZW5kICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gc2xpY2UubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgIGluZGljZXNbZW5kIC0gaV0gPSBzbGljZVtpXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW5kaWNlc1xuICB9XG5cbiAgZXhwb3J0cy5jbG9zaW5nVG9PcGVuaW5nQnJhY2tldCA9IGNsb3NpbmdUb09wZW5pbmdCcmFja2V0O1xuICBleHBvcnRzLmdldEJpZGlDaGFyVHlwZSA9IGdldEJpZGlDaGFyVHlwZTtcbiAgZXhwb3J0cy5nZXRCaWRpQ2hhclR5cGVOYW1lID0gZ2V0QmlkaUNoYXJUeXBlTmFtZTtcbiAgZXhwb3J0cy5nZXRDYW5vbmljYWxCcmFja2V0ID0gZ2V0Q2Fub25pY2FsQnJhY2tldDtcbiAgZXhwb3J0cy5nZXRFbWJlZGRpbmdMZXZlbHMgPSBnZXRFbWJlZGRpbmdMZXZlbHM7XG4gIGV4cG9ydHMuZ2V0TWlycm9yZWRDaGFyYWN0ZXIgPSBnZXRNaXJyb3JlZENoYXJhY3RlcjtcbiAgZXhwb3J0cy5nZXRNaXJyb3JlZENoYXJhY3RlcnNNYXAgPSBnZXRNaXJyb3JlZENoYXJhY3RlcnNNYXA7XG4gIGV4cG9ydHMuZ2V0UmVvcmRlclNlZ21lbnRzID0gZ2V0UmVvcmRlclNlZ21lbnRzO1xuICBleHBvcnRzLmdldFJlb3JkZXJlZEluZGljZXMgPSBnZXRSZW9yZGVyZWRJbmRpY2VzO1xuICBleHBvcnRzLmdldFJlb3JkZXJlZFN0cmluZyA9IGdldFJlb3JkZXJlZFN0cmluZztcbiAgZXhwb3J0cy5vcGVuaW5nVG9DbG9zaW5nQnJhY2tldCA9IG9wZW5pbmdUb0Nsb3NpbmdCcmFja2V0O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oe30pKTtcbnJldHVybiBiaWRpfVxuXG5leHBvcnQgZGVmYXVsdCBiaWRpRmFjdG9yeTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/bidi-js/dist/bidi.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs":
/*!***********************************************************************!*\
  !*** ./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ SDFGenerator; }\n/* harmony export */ });\nfunction SDFGenerator() {\nvar exports = (function (exports) {\n\n  /**\n   * Find the point on a quadratic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnQuadraticBezier (x0, y0, x1, y1, x2, y2, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2;\n    pointOut.y = t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2;\n  }\n\n  /**\n   * Find the point on a cubic bezier curve at t where t is in the range [0, 1]\n   */\n  function pointOnCubicBezier (x0, y0, x1, y1, x2, y2, x3, y3, t, pointOut) {\n    var t2 = 1 - t;\n    pointOut.x = t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3;\n    pointOut.y = t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3;\n  }\n\n  /**\n   * Parse a path string into its constituent line/curve commands, invoking a callback for each.\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(\n   *   command: 'L'|'Q'|'C',\n   *   startX: number,\n   *   startY: number,\n   *   endX: number,\n   *   endY: number,\n   *   ctrl1X?: number,\n   *   ctrl1Y?: number,\n   *   ctrl2X?: number,\n   *   ctrl2Y?: number\n   * )} commandCallback - A callback function that will be called once for each parsed path command, passing the\n   *                      command identifier (only L/Q/C commands) and its numeric arguments.\n   */\n  function forEachPathCommand(pathString, commandCallback) {\n    var segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    var match, firstX, firstY, prevX, prevY;\n    while ((match = segmentRE.exec(pathString))) {\n      var args = match[2]\n        .replace(/^\\s*|\\s*$/g, '')\n        .split(/[,\\s]+/)\n        .map(function (v) { return parseFloat(v); });\n      switch (match[1]) {\n        case 'M':\n          prevX = firstX = args[0];\n          prevY = firstY = args[1];\n          break\n        case 'L':\n          if (args[0] !== prevX || args[1] !== prevY) { // yup, some fonts have zero-length line commands\n            commandCallback('L', prevX, prevY, (prevX = args[0]), (prevY = args[1]));\n          }\n          break\n        case 'Q': {\n          commandCallback('Q', prevX, prevY, (prevX = args[2]), (prevY = args[3]), args[0], args[1]);\n          break\n        }\n        case 'C': {\n          commandCallback('C', prevX, prevY, (prevX = args[4]), (prevY = args[5]), args[0], args[1], args[2], args[3]);\n          break\n        }\n        case 'Z':\n          if (prevX !== firstX || prevY !== firstY) {\n            commandCallback('L', prevX, prevY, firstX, firstY);\n          }\n          break\n      }\n    }\n  }\n\n  /**\n   * Convert a path string to a series of straight line segments\n   * @param {string} pathString - An SVG-like path string to parse; should only contain commands: M/L/Q/C/Z\n   * @param {function(x1:number, y1:number, x2:number, y2:number)} segmentCallback - A callback\n   *        function that will be called once for every line segment\n   * @param {number} [curvePoints] - How many straight line segments to use when approximating a\n   *        bezier curve in the path. Defaults to 16.\n   */\n  function pathToLineSegments (pathString, segmentCallback, curvePoints) {\n    if ( curvePoints === void 0 ) curvePoints = 16;\n\n    var tempPoint = { x: 0, y: 0 };\n    forEachPathCommand(pathString, function (command, startX, startY, endX, endY, ctrl1X, ctrl1Y, ctrl2X, ctrl2Y) {\n      switch (command) {\n        case 'L':\n          segmentCallback(startX, startY, endX, endY);\n          break\n        case 'Q': {\n          var prevCurveX = startX;\n          var prevCurveY = startY;\n          for (var i = 1; i < curvePoints; i++) {\n            pointOnQuadraticBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              endX, endY,\n              i / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX, prevCurveY, tempPoint.x, tempPoint.y);\n            prevCurveX = tempPoint.x;\n            prevCurveY = tempPoint.y;\n          }\n          break\n        }\n        case 'C': {\n          var prevCurveX$1 = startX;\n          var prevCurveY$1 = startY;\n          for (var i$1 = 1; i$1 < curvePoints; i$1++) {\n            pointOnCubicBezier(\n              startX, startY,\n              ctrl1X, ctrl1Y,\n              ctrl2X, ctrl2Y,\n              endX, endY,\n              i$1 / (curvePoints - 1),\n              tempPoint\n            );\n            segmentCallback(prevCurveX$1, prevCurveY$1, tempPoint.x, tempPoint.y);\n            prevCurveX$1 = tempPoint.x;\n            prevCurveY$1 = tempPoint.y;\n          }\n          break\n        }\n      }\n    });\n  }\n\n  var viewportQuadVertex = \"precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var copyTexFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}\";\n\n  var cache = new WeakMap();\n\n  var glContextParams = {\n    premultipliedAlpha: false,\n    preserveDrawingBuffer: true,\n    antialias: false,\n    depth: false,\n  };\n\n  /**\n   * This is a little helper library for WebGL. It assists with state management for a GL context.\n   * It's pretty tightly wrapped to the needs of this package, not very general-purpose.\n   *\n   * @param { WebGLRenderingContext | HTMLCanvasElement | OffscreenCanvas } glOrCanvas - the GL context to wrap\n   * @param { ({gl, getExtension, withProgram, withTexture, withTextureFramebuffer, handleContextLoss}) => void } callback\n   */\n  function withWebGLContext (glOrCanvas, callback) {\n    var gl = glOrCanvas.getContext ? glOrCanvas.getContext('webgl', glContextParams) : glOrCanvas;\n    var wrapper = cache.get(gl);\n    if (!wrapper) {\n      var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n      var extensions = {};\n      var programs = {};\n      var textures = {};\n      var textureUnit = -1;\n      var framebufferStack = [];\n\n      gl.canvas.addEventListener('webglcontextlost', function (e) {\n        handleContextLoss();\n        e.preventDefault();\n      }, false);\n\n      function getExtension (name) {\n        var ext = extensions[name];\n        if (!ext) {\n          ext = extensions[name] = gl.getExtension(name);\n          if (!ext) {\n            throw new Error((name + \" not supported\"))\n          }\n        }\n        return ext\n      }\n\n      function compileShader (src, type) {\n        var shader = gl.createShader(type);\n        gl.shaderSource(shader, src);\n        gl.compileShader(shader);\n        // const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS)\n        // if (!status && !gl.isContextLost()) {\n        //   throw new Error(gl.getShaderInfoLog(shader).trim())\n        // }\n        return shader\n      }\n\n      function withProgram (name, vert, frag, func) {\n        if (!programs[name]) {\n          var attributes = {};\n          var uniforms = {};\n          var program = gl.createProgram();\n          gl.attachShader(program, compileShader(vert, gl.VERTEX_SHADER));\n          gl.attachShader(program, compileShader(frag, gl.FRAGMENT_SHADER));\n          gl.linkProgram(program);\n\n          programs[name] = {\n            program: program,\n            transaction: function transaction (func) {\n              gl.useProgram(program);\n              func({\n                setUniform: function setUniform (type, name) {\n                  var values = [], len = arguments.length - 2;\n                  while ( len-- > 0 ) values[ len ] = arguments[ len + 2 ];\n\n                  var uniformLoc = uniforms[name] || (uniforms[name] = gl.getUniformLocation(program, name));\n                  gl[(\"uniform\" + type)].apply(gl, [ uniformLoc ].concat( values ));\n                },\n\n                setAttribute: function setAttribute (name, size, usage, instancingDivisor, data) {\n                  var attr = attributes[name];\n                  if (!attr) {\n                    attr = attributes[name] = {\n                      buf: gl.createBuffer(), // TODO should we destroy our buffers?\n                      loc: gl.getAttribLocation(program, name),\n                      data: null\n                    };\n                  }\n                  gl.bindBuffer(gl.ARRAY_BUFFER, attr.buf);\n                  gl.vertexAttribPointer(attr.loc, size, gl.FLOAT, false, 0, 0);\n                  gl.enableVertexAttribArray(attr.loc);\n                  if (isWebGL2) {\n                    gl.vertexAttribDivisor(attr.loc, instancingDivisor);\n                  } else {\n                    getExtension('ANGLE_instanced_arrays').vertexAttribDivisorANGLE(attr.loc, instancingDivisor);\n                  }\n                  if (data !== attr.data) {\n                    gl.bufferData(gl.ARRAY_BUFFER, data, usage);\n                    attr.data = data;\n                  }\n                }\n              });\n            }\n          };\n        }\n\n        programs[name].transaction(func);\n      }\n\n      function withTexture (name, func) {\n        textureUnit++;\n        try {\n          gl.activeTexture(gl.TEXTURE0 + textureUnit);\n          var texture = textures[name];\n          if (!texture) {\n            texture = textures[name] = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n          }\n          gl.bindTexture(gl.TEXTURE_2D, texture);\n          func(texture, textureUnit);\n        } finally {\n          textureUnit--;\n        }\n      }\n\n      function withTextureFramebuffer (texture, textureUnit, func) {\n        var framebuffer = gl.createFramebuffer();\n        framebufferStack.push(framebuffer);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n        gl.activeTexture(gl.TEXTURE0 + textureUnit);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        try {\n          func(framebuffer);\n        } finally {\n          gl.deleteFramebuffer(framebuffer);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferStack[--framebufferStack.length - 1] || null);\n        }\n      }\n\n      function handleContextLoss () {\n        extensions = {};\n        programs = {};\n        textures = {};\n        textureUnit = -1;\n        framebufferStack.length = 0;\n      }\n\n      cache.set(gl, wrapper = {\n        gl: gl,\n        isWebGL2: isWebGL2,\n        getExtension: getExtension,\n        withProgram: withProgram,\n        withTexture: withTexture,\n        withTextureFramebuffer: withTextureFramebuffer,\n        handleContextLoss: handleContextLoss,\n      });\n    }\n    callback(wrapper);\n  }\n\n\n  function renderImageData(glOrCanvas, imageData, x, y, width, height, channels, framebuffer) {\n    if ( channels === void 0 ) channels = 15;\n    if ( framebuffer === void 0 ) framebuffer = null;\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n\n      withTexture('copy', function (tex, texUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, imageData);\n        withProgram('copy', viewportQuadVertex, copyTexFragment, function (ref) {\n          var setUniform = ref.setUniform;\n          var setAttribute = ref.setAttribute;\n\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2]));\n          setUniform('1i', 'image', texUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer || null);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channels & 8, channels & 4, channels & 2, channels & 1);\n          gl.viewport(x, y, width, height);\n          gl.scissor(x, y, width, height);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n    });\n  }\n\n  /**\n   * Resizing a canvas clears its contents; this utility copies the previous contents over.\n   * @param canvas\n   * @param newWidth\n   * @param newHeight\n   */\n  function resizeWebGLCanvasWithoutClearing(canvas, newWidth, newHeight) {\n    var width = canvas.width;\n    var height = canvas.height;\n    withWebGLContext(canvas, function (ref) {\n      var gl = ref.gl;\n\n      var data = new Uint8Array(width * height * 4);\n      gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, data);\n      canvas.width = newWidth;\n      canvas.height = newHeight;\n      renderImageData(gl, data, 0, 0, width, height);\n    });\n  }\n\n  var webglUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    withWebGLContext: withWebGLContext,\n    renderImageData: renderImageData,\n    resizeWebGLCanvasWithoutClearing: resizeWebGLCanvasWithoutClearing\n  });\n\n  function generate$2 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    var textureData = new Uint8Array(sdfWidth * sdfHeight);\n\n    var viewBoxWidth = viewBox[2] - viewBox[0];\n    var viewBoxHeight = viewBox[3] - viewBox[1];\n\n    // Decompose all paths into straight line segments and add them to an index\n    var segments = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      segments.push({\n        x1: x1, y1: y1, x2: x2, y2: y2,\n        minX: Math.min(x1, x2),\n        minY: Math.min(y1, y2),\n        maxX: Math.max(x1, x2),\n        maxY: Math.max(y1, y2)\n      });\n    });\n\n    // Sort segments by maxX, this will let us short-circuit some loops below\n    segments.sort(function (a, b) { return a.maxX - b.maxX; });\n\n    // For each target SDF texel, find the distance from its center to its nearest line segment,\n    // map that distance to an alpha value, and write that alpha to the texel\n    for (var sdfX = 0; sdfX < sdfWidth; sdfX++) {\n      for (var sdfY = 0; sdfY < sdfHeight; sdfY++) {\n        var signedDist = findNearestSignedDistance(\n          viewBox[0] + viewBoxWidth * (sdfX + 0.5) / sdfWidth,\n          viewBox[1] + viewBoxHeight * (sdfY + 0.5) / sdfHeight\n        );\n\n        // Use an exponential scale to ensure the texels very near the glyph path have adequate\n        // precision, while allowing the distance field to cover the entire texture, given that\n        // there are only 8 bits available. Formula visualized: https://www.desmos.com/calculator/uiaq5aqiam\n        var alpha = Math.pow((1 - Math.abs(signedDist) / maxDistance), sdfExponent) / 2;\n        if (signedDist < 0) {\n          alpha = 1 - alpha;\n        }\n\n        alpha = Math.max(0, Math.min(255, Math.round(alpha * 255))); //clamp\n        textureData[sdfY * sdfWidth + sdfX] = alpha;\n      }\n    }\n\n    return textureData\n\n    /**\n     * For a given x/y, search the index for the closest line segment and return\n     * its signed distance. Negative = inside, positive = outside, zero = on edge\n     * @param x\n     * @param y\n     * @returns {number}\n     */\n    function findNearestSignedDistance (x, y) {\n      var closestDistSq = Infinity;\n      var closestDist = Infinity;\n\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX + closestDist <= x) { break } //sorting by maxX means no more can be closer, so we can short-circuit\n        if (x + closestDist > seg.minX && y - closestDist < seg.maxY && y + closestDist > seg.minY) {\n          var distSq = absSquareDistanceToLineSegment(x, y, seg.x1, seg.y1, seg.x2, seg.y2);\n          if (distSq < closestDistSq) {\n            closestDistSq = distSq;\n            closestDist = Math.sqrt(closestDistSq);\n          }\n        }\n      }\n\n      // Flip to negative distance if inside the poly\n      if (isPointInPoly(x, y)) {\n        closestDist = -closestDist;\n      }\n      return closestDist\n    }\n\n    /**\n     * Determine whether the given point lies inside or outside the glyph. Uses a simple\n     * winding-number ray casting algorithm using a ray pointing east from the point.\n     */\n    function isPointInPoly (x, y) {\n      var winding = 0;\n      for (var i = segments.length; i--;) {\n        var seg = segments[i];\n        if (seg.maxX <= x) { break } //sorting by maxX means no more can cross, so we can short-circuit\n        var intersects = ((seg.y1 > y) !== (seg.y2 > y)) && (x < (seg.x2 - seg.x1) * (y - seg.y1) / (seg.y2 - seg.y1) + seg.x1);\n        if (intersects) {\n          winding += seg.y1 < seg.y2 ? 1 : -1;\n        }\n      }\n      return winding !== 0\n    }\n  }\n\n  function generateIntoCanvas$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    var data = generate$2(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent);\n    // Expand single-channel data to rbga\n    var rgbaData = new Uint8Array(data.length * 4);\n    for (var i = 0; i < data.length; i++) {\n      rgbaData[i * 4 + channel] = data[i];\n    }\n    renderImageData(glOrCanvas, rgbaData, x, y, sdfWidth, sdfHeight, 1 << (3 - channel), framebuffer);\n  }\n\n  /**\n   * Find the absolute distance from a point to a line segment at closest approach\n   */\n  function absSquareDistanceToLineSegment (x, y, lineX0, lineY0, lineX1, lineY1) {\n    var ldx = lineX1 - lineX0;\n    var ldy = lineY1 - lineY0;\n    var lengthSq = ldx * ldx + ldy * ldy;\n    var t = lengthSq ? Math.max(0, Math.min(1, ((x - lineX0) * ldx + (y - lineY0) * ldy) / lengthSq)) : 0;\n    var dx = x - (lineX0 + t * ldx);\n    var dy = y - (lineY0 + t * ldy);\n    return dx * dx + dy * dy\n  }\n\n  var javascript = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$2,\n    generateIntoCanvas: generateIntoCanvas$2,\n    generateIntoFramebuffer: generateIntoFramebuffer$1\n  });\n\n  var mainVertex = \"precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}\";\n\n  var mainFragment = \"precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}\";\n\n  var postFragment = \"precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}\";\n\n  // Single triangle covering viewport\n  var viewportUVs = new Float32Array([0, 0, 2, 0, 0, 2]);\n\n  var implicitContext = null;\n  var isTestingSupport = false;\n  var NULL_OBJECT = {};\n  var supportByCanvas = new WeakMap(); // canvas -> bool\n\n  function validateSupport (glOrCanvas) {\n    if (!isTestingSupport && !isSupported(glOrCanvas)) {\n      throw new Error('WebGL generation not supported')\n    }\n  }\n\n  function generate$1 (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( glOrCanvas === void 0 ) glOrCanvas = null;\n\n    if (!glOrCanvas) {\n      glOrCanvas = implicitContext;\n      if (!glOrCanvas) {\n        var canvas = typeof OffscreenCanvas === 'function'\n          ? new OffscreenCanvas(1, 1)\n          : typeof document !== 'undefined'\n            ? document.createElement('canvas')\n            : null;\n        if (!canvas) {\n          throw new Error('OffscreenCanvas or DOM canvas not supported')\n        }\n        glOrCanvas = implicitContext = canvas.getContext('webgl', { depth: false });\n      }\n    }\n\n    validateSupport(glOrCanvas);\n\n    var rgbaData = new Uint8Array(sdfWidth * sdfHeight * 4); //not Uint8ClampedArray, cuz Safari\n\n    // Render into a background texture framebuffer\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n\n      withTexture('readable', function (texture, textureUnit) {\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, sdfWidth, sdfHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        withTextureFramebuffer(texture, textureUnit, function (framebuffer) {\n          generateIntoFramebuffer(\n            sdfWidth,\n            sdfHeight,\n            path,\n            viewBox,\n            maxDistance,\n            sdfExponent,\n            gl,\n            framebuffer,\n            0,\n            0,\n            0 // red channel\n          );\n          gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, rgbaData);\n        });\n      });\n    });\n\n    // Throw away all but the red channel\n    var data = new Uint8Array(sdfWidth * sdfHeight);\n    for (var i = 0, j = 0; i < rgbaData.length; i += 4) {\n      data[j++] = rgbaData[i];\n    }\n\n    return data\n  }\n\n  function generateIntoCanvas$1(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    generateIntoFramebuffer(sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, canvas, null, x, y, channel);\n  }\n\n  function generateIntoFramebuffer (sdfWidth, sdfHeight, path, viewBox, maxDistance, sdfExponent, glOrCanvas, framebuffer, x, y, channel) {\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    // Verify support\n    validateSupport(glOrCanvas);\n\n    // Compute path segments\n    var lineSegmentCoords = [];\n    pathToLineSegments(path, function (x1, y1, x2, y2) {\n      lineSegmentCoords.push(x1, y1, x2, y2);\n    });\n    lineSegmentCoords = new Float32Array(lineSegmentCoords);\n\n    withWebGLContext(glOrCanvas, function (ref) {\n      var gl = ref.gl;\n      var isWebGL2 = ref.isWebGL2;\n      var getExtension = ref.getExtension;\n      var withProgram = ref.withProgram;\n      var withTexture = ref.withTexture;\n      var withTextureFramebuffer = ref.withTextureFramebuffer;\n      var handleContextLoss = ref.handleContextLoss;\n\n      withTexture('rawDistances', function (intermediateTexture, intermediateTextureUnit) {\n        if (sdfWidth !== intermediateTexture._lastWidth || sdfHeight !== intermediateTexture._lastHeight) {\n          gl.texImage2D(\n            gl.TEXTURE_2D, 0, gl.RGBA,\n            intermediateTexture._lastWidth = sdfWidth,\n            intermediateTexture._lastHeight = sdfHeight,\n            0, gl.RGBA, gl.UNSIGNED_BYTE, null\n          );\n        }\n\n        // Unsigned distance pass\n        withProgram('main', mainVertex, mainFragment, function (ref) {\n          var setAttribute = ref.setAttribute;\n          var setUniform = ref.setUniform;\n\n          // Init extensions\n          var instancingExtension = !isWebGL2 && getExtension('ANGLE_instanced_arrays');\n          var blendMinMaxExtension = !isWebGL2 && getExtension('EXT_blend_minmax');\n\n          // Init/update attributes\n          setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          setAttribute('aLineSegment', 4, gl.DYNAMIC_DRAW, 1, lineSegmentCoords);\n\n          // Init/update uniforms\n          setUniform.apply(void 0, [ '4f', 'uGlyphBounds' ].concat( viewBox ));\n          setUniform('1f', 'uMaxDistance', maxDistance);\n          setUniform('1f', 'uExponent', sdfExponent);\n\n          // Render initial unsigned distance / winding number info to a texture\n          withTextureFramebuffer(intermediateTexture, intermediateTextureUnit, function (framebuffer) {\n            gl.enable(gl.BLEND);\n            gl.colorMask(true, true, true, true);\n            gl.viewport(0, 0, sdfWidth, sdfHeight);\n            gl.scissor(0, 0, sdfWidth, sdfHeight);\n            gl.blendFunc(gl.ONE, gl.ONE);\n            // Red+Green channels are incremented (FUNC_ADD) for segment-ray crossings to give a \"winding number\".\n            // Alpha holds the closest (MAX) unsigned distance.\n            gl.blendEquationSeparate(gl.FUNC_ADD, isWebGL2 ? gl.MAX : blendMinMaxExtension.MAX_EXT);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n            if (isWebGL2) {\n              gl.drawArraysInstanced(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            } else {\n              instancingExtension.drawArraysInstancedANGLE(gl.TRIANGLES, 0, 3, lineSegmentCoords.length / 4);\n            }\n            // Debug\n            // const debug = new Uint8Array(sdfWidth * sdfHeight * 4)\n            // gl.readPixels(0, 0, sdfWidth, sdfHeight, gl.RGBA, gl.UNSIGNED_BYTE, debug)\n            // console.log('intermediate texture data: ', debug)\n          });\n        });\n\n        // Use the data stored in the texture to apply inside/outside and write to the output framebuffer rect+channel.\n        withProgram('post', viewportQuadVertex, postFragment, function (program) {\n          program.setAttribute('aUV', 2, gl.STATIC_DRAW, 0, viewportUVs);\n          program.setUniform('1i', 'tex', intermediateTextureUnit);\n          gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n          gl.disable(gl.BLEND);\n          gl.colorMask(channel === 0, channel === 1, channel === 2, channel === 3);\n          gl.viewport(x, y, sdfWidth, sdfHeight);\n          gl.scissor(x, y, sdfWidth, sdfHeight);\n          gl.drawArrays(gl.TRIANGLES, 0, 3);\n        });\n      });\n\n      // Handle context loss occurring during any of the above calls\n      if (gl.isContextLost()) {\n        handleContextLoss();\n        throw new Error('webgl context lost')\n      }\n    });\n  }\n\n  function isSupported (glOrCanvas) {\n    var key = (!glOrCanvas || glOrCanvas === implicitContext) ? NULL_OBJECT : (glOrCanvas.canvas || glOrCanvas);\n    var supported = supportByCanvas.get(key);\n    if (supported === undefined) {\n      isTestingSupport = true;\n      var failReason = null;\n      try {\n        // Since we can't detect all failure modes up front, let's just do a trial run of a\n        // simple path and compare what we get back to the correct expected result. This will\n        // also serve to prime the shader compilation.\n        var expectedResult = [\n          97, 106, 97, 61,\n          99, 137, 118, 80,\n          80, 118, 137, 99,\n          61, 97, 106, 97\n        ];\n        var testResult = generate$1(\n          4,\n          4,\n          'M8,8L16,8L24,24L16,24Z',\n          [0, 0, 32, 32],\n          24,\n          1,\n          glOrCanvas\n        );\n        supported = testResult && expectedResult.length === testResult.length &&\n          testResult.every(function (val, i) { return val === expectedResult[i]; });\n        if (!supported) {\n          failReason = 'bad trial run results';\n          console.info(expectedResult, testResult);\n        }\n      } catch (err) {\n        // TODO if it threw due to webgl context loss, should we maybe leave isSupported as null and try again later?\n        supported = false;\n        failReason = err.message;\n      }\n      if (failReason) {\n        console.warn('WebGL SDF generation not supported:', failReason);\n      }\n      isTestingSupport = false;\n      supportByCanvas.set(key, supported);\n    }\n    return supported\n  }\n\n  var webgl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    generate: generate$1,\n    generateIntoCanvas: generateIntoCanvas$1,\n    generateIntoFramebuffer: generateIntoFramebuffer,\n    isSupported: isSupported\n  });\n\n  /**\n   * Generate an SDF texture image for a 2D path.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @return {Uint8Array}\n   */\n  function generate(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n\n    try {\n      return generate$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generate$2.apply(javascript, arguments)\n    }\n  }\n\n  /**\n   * Generate an SDF texture image for a 2D path, inserting the result into a WebGL `canvas` at a given x/y position\n   * and color channel. This is generally much faster than calling `generate` because it does not require reading pixels\n   * back from the GPU->CPU -- the `canvas` can be used directly as a WebGL texture image, so it all stays on the GPU.\n   *\n   * @param {number} sdfWidth - width of the SDF output image in pixels.\n   * @param {number} sdfHeight - height of the SDF output image in pixels.\n   * @param {string} path - an SVG-like path string describing the glyph; should only contain commands: M/L/Q/C/Z.\n   * @param {number[]} viewBox - [minX, minY, maxX, maxY] in font units aligning with the texture's edges.\n   * @param {number} maxDistance - the maximum distance from the glyph path in font units that will be encoded; defaults\n   *        to half the maximum viewBox dimension.\n   * @param {number} [sdfExponent] - specifies an exponent for encoding the SDF's distance values; higher exponents\n   *        will give greater precision nearer the glyph's path.\n   * @param {HTMLCanvasElement|OffscreenCanvas} canvas - a WebGL-enabled canvas into which the SDF will be rendered.\n   *        Only the relevant rect/channel will be modified, the rest will be preserved. To avoid unpredictable results\n   *        due to shared GL context state, this canvas should be dedicated to use by this library alone.\n   * @param {number} x - the x position at which to render the SDF.\n   * @param {number} y - the y position at which to render the SDF.\n   * @param {number} channel - the color channel index (0-4) into which the SDF will be rendered.\n   * @return {Uint8Array}\n   */\n  function generateIntoCanvas(\n    sdfWidth,\n    sdfHeight,\n    path,\n    viewBox,\n    maxDistance,\n    sdfExponent,\n    canvas,\n    x,\n    y,\n    channel\n  ) {\n    if ( maxDistance === void 0 ) maxDistance = Math.max(viewBox[2] - viewBox[0], viewBox[3] - viewBox[1]) / 2;\n    if ( sdfExponent === void 0 ) sdfExponent = 1;\n    if ( x === void 0 ) x = 0;\n    if ( y === void 0 ) y = 0;\n    if ( channel === void 0 ) channel = 0;\n\n    try {\n      return generateIntoCanvas$1.apply(webgl, arguments)\n    } catch(e) {\n      console.info('WebGL SDF generation failed, falling back to JS', e);\n      return generateIntoCanvas$2.apply(javascript, arguments)\n    }\n  }\n\n  exports.forEachPathCommand = forEachPathCommand;\n  exports.generate = generate;\n  exports.generateIntoCanvas = generateIntoCanvas;\n  exports.javascript = javascript;\n  exports.pathToLineSegments = pathToLineSegments;\n  exports.webgl = webgl;\n  exports.webglUtils = webglUtils;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}({}));\nreturn exports\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93ZWJnbC1zZGYtZ2VuZXJhdG9yL2Rpc3Qvd2ViZ2wtc2RmLWdlbmVyYXRvci5tanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVEsK0NBQStDO0FBQ3BFLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUSwrQ0FBK0M7QUFDcEUsYUFBYSxzREFBc0Q7QUFDbkU7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsa0RBQWtELG1CQUFtQixpQkFBaUIs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O0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRLHFEQUFxRDtBQUMxRSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRLDJGQUEyRjtBQUNoSDtBQUNBLGFBQWEsUUFBUSw4RUFBOEU7QUFDbkc7QUFDQSxhQUFhLG1DQUFtQztBQUNoRDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxhQUFhOztBQUU5RDs7QUFFQSxDQUFDLEdBQUc7QUFDSjtBQUNBOztBQUVtQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvd2ViZ2wtc2RmLWdlbmVyYXRvci9kaXN0L3dlYmdsLXNkZi1nZW5lcmF0b3IubWpzPzFlZGUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gU0RGR2VuZXJhdG9yKCkge1xudmFyIGV4cG9ydHMgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcblxuICAvKipcbiAgICogRmluZCB0aGUgcG9pbnQgb24gYSBxdWFkcmF0aWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAqL1xuICBmdW5jdGlvbiBwb2ludE9uUXVhZHJhdGljQmV6aWVyICh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB0LCBwb2ludE91dCkge1xuICAgIHZhciB0MiA9IDEgLSB0O1xuICAgIHBvaW50T3V0LnggPSB0MiAqIHQyICogeDAgKyAyICogdDIgKiB0ICogeDEgKyB0ICogdCAqIHgyO1xuICAgIHBvaW50T3V0LnkgPSB0MiAqIHQyICogeTAgKyAyICogdDIgKiB0ICogeTEgKyB0ICogdCAqIHkyO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBvaW50IG9uIGEgY3ViaWMgYmV6aWVyIGN1cnZlIGF0IHQgd2hlcmUgdCBpcyBpbiB0aGUgcmFuZ2UgWzAsIDFdXG4gICAqL1xuICBmdW5jdGlvbiBwb2ludE9uQ3ViaWNCZXppZXIgKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgdCwgcG9pbnRPdXQpIHtcbiAgICB2YXIgdDIgPSAxIC0gdDtcbiAgICBwb2ludE91dC54ID0gdDIgKiB0MiAqIHQyICogeDAgKyAzICogdDIgKiB0MiAqIHQgKiB4MSArIDMgKiB0MiAqIHQgKiB0ICogeDIgKyB0ICogdCAqIHQgKiB4MztcbiAgICBwb2ludE91dC55ID0gdDIgKiB0MiAqIHQyICogeTAgKyAzICogdDIgKiB0MiAqIHQgKiB5MSArIDMgKiB0MiAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhIHBhdGggc3RyaW5nIGludG8gaXRzIGNvbnN0aXR1ZW50IGxpbmUvY3VydmUgY29tbWFuZHMsIGludm9raW5nIGEgY2FsbGJhY2sgZm9yIGVhY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nIC0gQW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgdG8gcGFyc2U7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFxuICAgKiAgIGNvbW1hbmQ6ICdMJ3wnUSd8J0MnLFxuICAgKiAgIHN0YXJ0WDogbnVtYmVyLFxuICAgKiAgIHN0YXJ0WTogbnVtYmVyLFxuICAgKiAgIGVuZFg6IG51bWJlcixcbiAgICogICBlbmRZOiBudW1iZXIsXG4gICAqICAgY3RybDFYPzogbnVtYmVyLFxuICAgKiAgIGN0cmwxWT86IG51bWJlcixcbiAgICogICBjdHJsMlg/OiBudW1iZXIsXG4gICAqICAgY3RybDJZPzogbnVtYmVyXG4gICAqICl9IGNvbW1hbmRDYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCBvbmNlIGZvciBlYWNoIHBhcnNlZCBwYXRoIGNvbW1hbmQsIHBhc3NpbmcgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgIGNvbW1hbmQgaWRlbnRpZmllciAob25seSBML1EvQyBjb21tYW5kcykgYW5kIGl0cyBudW1lcmljIGFyZ3VtZW50cy5cbiAgICovXG4gIGZ1bmN0aW9uIGZvckVhY2hQYXRoQ29tbWFuZChwYXRoU3RyaW5nLCBjb21tYW5kQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VnbWVudFJFID0gLyhbTUxRQ1pdKShbXk1MUUNaXSopL2c7XG4gICAgdmFyIG1hdGNoLCBmaXJzdFgsIGZpcnN0WSwgcHJldlgsIHByZXZZO1xuICAgIHdoaWxlICgobWF0Y2ggPSBzZWdtZW50UkUuZXhlYyhwYXRoU3RyaW5nKSkpIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2hbMl1cbiAgICAgICAgLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKVxuICAgICAgICAuc3BsaXQoL1ssXFxzXSsvKVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh2KSB7IHJldHVybiBwYXJzZUZsb2F0KHYpOyB9KTtcbiAgICAgIHN3aXRjaCAobWF0Y2hbMV0pIHtcbiAgICAgICAgY2FzZSAnTSc6XG4gICAgICAgICAgcHJldlggPSBmaXJzdFggPSBhcmdzWzBdO1xuICAgICAgICAgIHByZXZZID0gZmlyc3RZID0gYXJnc1sxXTtcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBpZiAoYXJnc1swXSAhPT0gcHJldlggfHwgYXJnc1sxXSAhPT0gcHJldlkpIHsgLy8geXVwLCBzb21lIGZvbnRzIGhhdmUgemVyby1sZW5ndGggbGluZSBjb21tYW5kc1xuICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdMJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzBdKSwgKHByZXZZID0gYXJnc1sxXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlICdRJzoge1xuICAgICAgICAgIGNvbW1hbmRDYWxsYmFjaygnUScsIHByZXZYLCBwcmV2WSwgKHByZXZYID0gYXJnc1syXSksIChwcmV2WSA9IGFyZ3NbM10pLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0MnOiB7XG4gICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdDJywgcHJldlgsIHByZXZZLCAocHJldlggPSBhcmdzWzRdKSwgKHByZXZZID0gYXJnc1s1XSksIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnWic6XG4gICAgICAgICAgaWYgKHByZXZYICE9PSBmaXJzdFggfHwgcHJldlkgIT09IGZpcnN0WSkge1xuICAgICAgICAgICAgY29tbWFuZENhbGxiYWNrKCdMJywgcHJldlgsIHByZXZZLCBmaXJzdFgsIGZpcnN0WSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBwYXRoIHN0cmluZyB0byBhIHNlcmllcyBvZiBzdHJhaWdodCBsaW5lIHNlZ21lbnRzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoU3RyaW5nIC0gQW4gU1ZHLWxpa2UgcGF0aCBzdHJpbmcgdG8gcGFyc2U7IHNob3VsZCBvbmx5IGNvbnRhaW4gY29tbWFuZHM6IE0vTC9RL0MvWlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHgxOm51bWJlciwgeTE6bnVtYmVyLCB4MjpudW1iZXIsIHkyOm51bWJlcil9IHNlZ21lbnRDYWxsYmFjayAtIEEgY2FsbGJhY2tcbiAgICogICAgICAgIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgb25jZSBmb3IgZXZlcnkgbGluZSBzZWdtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VydmVQb2ludHNdIC0gSG93IG1hbnkgc3RyYWlnaHQgbGluZSBzZWdtZW50cyB0byB1c2Ugd2hlbiBhcHByb3hpbWF0aW5nIGFcbiAgICogICAgICAgIGJlemllciBjdXJ2ZSBpbiB0aGUgcGF0aC4gRGVmYXVsdHMgdG8gMTYuXG4gICAqL1xuICBmdW5jdGlvbiBwYXRoVG9MaW5lU2VnbWVudHMgKHBhdGhTdHJpbmcsIHNlZ21lbnRDYWxsYmFjaywgY3VydmVQb2ludHMpIHtcbiAgICBpZiAoIGN1cnZlUG9pbnRzID09PSB2b2lkIDAgKSBjdXJ2ZVBvaW50cyA9IDE2O1xuXG4gICAgdmFyIHRlbXBQb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGZvckVhY2hQYXRoQ29tbWFuZChwYXRoU3RyaW5nLCBmdW5jdGlvbiAoY29tbWFuZCwgc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGN0cmwxWCwgY3RybDFZLCBjdHJsMlgsIGN0cmwyWSkge1xuICAgICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgJ0wnOlxuICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSk7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAnUSc6IHtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWCA9IHN0YXJ0WDtcbiAgICAgICAgICB2YXIgcHJldkN1cnZlWSA9IHN0YXJ0WTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGN1cnZlUG9pbnRzOyBpKyspIHtcbiAgICAgICAgICAgIHBvaW50T25RdWFkcmF0aWNCZXppZXIoXG4gICAgICAgICAgICAgIHN0YXJ0WCwgc3RhcnRZLFxuICAgICAgICAgICAgICBjdHJsMVgsIGN0cmwxWSxcbiAgICAgICAgICAgICAgZW5kWCwgZW5kWSxcbiAgICAgICAgICAgICAgaSAvIChjdXJ2ZVBvaW50cyAtIDEpLFxuICAgICAgICAgICAgICB0ZW1wUG9pbnRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBzZWdtZW50Q2FsbGJhY2socHJldkN1cnZlWCwgcHJldkN1cnZlWSwgdGVtcFBvaW50LngsIHRlbXBQb2ludC55KTtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVggPSB0ZW1wUG9pbnQueDtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVkgPSB0ZW1wUG9pbnQueTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdDJzoge1xuICAgICAgICAgIHZhciBwcmV2Q3VydmVYJDEgPSBzdGFydFg7XG4gICAgICAgICAgdmFyIHByZXZDdXJ2ZVkkMSA9IHN0YXJ0WTtcbiAgICAgICAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCBjdXJ2ZVBvaW50czsgaSQxKyspIHtcbiAgICAgICAgICAgIHBvaW50T25DdWJpY0JlemllcihcbiAgICAgICAgICAgICAgc3RhcnRYLCBzdGFydFksXG4gICAgICAgICAgICAgIGN0cmwxWCwgY3RybDFZLFxuICAgICAgICAgICAgICBjdHJsMlgsIGN0cmwyWSxcbiAgICAgICAgICAgICAgZW5kWCwgZW5kWSxcbiAgICAgICAgICAgICAgaSQxIC8gKGN1cnZlUG9pbnRzIC0gMSksXG4gICAgICAgICAgICAgIHRlbXBQb2ludFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHNlZ21lbnRDYWxsYmFjayhwcmV2Q3VydmVYJDEsIHByZXZDdXJ2ZVkkMSwgdGVtcFBvaW50LngsIHRlbXBQb2ludC55KTtcbiAgICAgICAgICAgIHByZXZDdXJ2ZVgkMSA9IHRlbXBQb2ludC54O1xuICAgICAgICAgICAgcHJldkN1cnZlWSQxID0gdGVtcFBvaW50Lnk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHZhciB2aWV3cG9ydFF1YWRWZXJ0ZXggPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDthdHRyaWJ1dGUgdmVjMiBhVVY7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXt2VVY9YVVWO2dsX1Bvc2l0aW9uPXZlYzQobWl4KHZlYzIoLTEuMCksdmVjMigxLjApLGFVViksMC4wLDEuMCk7fVwiO1xuXG4gIHZhciBjb3B5VGV4RnJhZ21lbnQgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDt1bmlmb3JtIHNhbXBsZXIyRCB0ZXg7dmFyeWluZyB2ZWMyIHZVVjt2b2lkIG1haW4oKXtnbF9GcmFnQ29sb3I9dGV4dHVyZTJEKHRleCx2VVYpO31cIjtcblxuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIHZhciBnbENvbnRleHRQYXJhbXMgPSB7XG4gICAgcHJlbXVsdGlwbGllZEFscGhhOiBmYWxzZSxcbiAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IHRydWUsXG4gICAgYW50aWFsaWFzOiBmYWxzZSxcbiAgICBkZXB0aDogZmFsc2UsXG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBsaXR0bGUgaGVscGVyIGxpYnJhcnkgZm9yIFdlYkdMLiBJdCBhc3Npc3RzIHdpdGggc3RhdGUgbWFuYWdlbWVudCBmb3IgYSBHTCBjb250ZXh0LlxuICAgKiBJdCdzIHByZXR0eSB0aWdodGx5IHdyYXBwZWQgdG8gdGhlIG5lZWRzIG9mIHRoaXMgcGFja2FnZSwgbm90IHZlcnkgZ2VuZXJhbC1wdXJwb3NlLlxuICAgKlxuICAgKiBAcGFyYW0geyBXZWJHTFJlbmRlcmluZ0NvbnRleHQgfCBIVE1MQ2FudmFzRWxlbWVudCB8IE9mZnNjcmVlbkNhbnZhcyB9IGdsT3JDYW52YXMgLSB0aGUgR0wgY29udGV4dCB0byB3cmFwXG4gICAqIEBwYXJhbSB7ICh7Z2wsIGdldEV4dGVuc2lvbiwgd2l0aFByb2dyYW0sIHdpdGhUZXh0dXJlLCB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyLCBoYW5kbGVDb250ZXh0TG9zc30pID0+IHZvaWQgfSBjYWxsYmFja1xuICAgKi9cbiAgZnVuY3Rpb24gd2l0aFdlYkdMQ29udGV4dCAoZ2xPckNhbnZhcywgY2FsbGJhY2spIHtcbiAgICB2YXIgZ2wgPSBnbE9yQ2FudmFzLmdldENvbnRleHQgPyBnbE9yQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgZ2xDb250ZXh0UGFyYW1zKSA6IGdsT3JDYW52YXM7XG4gICAgdmFyIHdyYXBwZXIgPSBjYWNoZS5nZXQoZ2wpO1xuICAgIGlmICghd3JhcHBlcikge1xuICAgICAgdmFyIGlzV2ViR0wyID0gdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dDtcbiAgICAgIHZhciBleHRlbnNpb25zID0ge307XG4gICAgICB2YXIgcHJvZ3JhbXMgPSB7fTtcbiAgICAgIHZhciB0ZXh0dXJlcyA9IHt9O1xuICAgICAgdmFyIHRleHR1cmVVbml0ID0gLTE7XG4gICAgICB2YXIgZnJhbWVidWZmZXJTdGFjayA9IFtdO1xuXG4gICAgICBnbC5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGhhbmRsZUNvbnRleHRMb3NzKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBleHQgPSBleHRlbnNpb25zW25hbWVdO1xuICAgICAgICBpZiAoIWV4dCkge1xuICAgICAgICAgIGV4dCA9IGV4dGVuc2lvbnNbbmFtZV0gPSBnbC5nZXRFeHRlbnNpb24obmFtZSk7XG4gICAgICAgICAgaWYgKCFleHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigobmFtZSArIFwiIG5vdCBzdXBwb3J0ZWRcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGlsZVNoYWRlciAoc3JjLCB0eXBlKSB7XG4gICAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNyYyk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcbiAgICAgICAgLy8gY29uc3Qgc3RhdHVzID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpXG4gICAgICAgIC8vIGlmICghc3RhdHVzICYmICFnbC5pc0NvbnRleHRMb3N0KCkpIHtcbiAgICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpLnRyaW0oKSlcbiAgICAgICAgLy8gfVxuICAgICAgICByZXR1cm4gc2hhZGVyXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdpdGhQcm9ncmFtIChuYW1lLCB2ZXJ0LCBmcmFnLCBmdW5jKSB7XG4gICAgICAgIGlmICghcHJvZ3JhbXNbbmFtZV0pIHtcbiAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgIHZhciB1bmlmb3JtcyA9IHt9O1xuICAgICAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBjb21waWxlU2hhZGVyKHZlcnQsIGdsLlZFUlRFWF9TSEFERVIpKTtcbiAgICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgY29tcGlsZVNoYWRlcihmcmFnLCBnbC5GUkFHTUVOVF9TSEFERVIpKTtcbiAgICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAgICAgICAgIHByb2dyYW1zW25hbWVdID0ge1xuICAgICAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBmdW5jdGlvbiB0cmFuc2FjdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICAgICAgICBmdW5jKHtcbiAgICAgICAgICAgICAgICBzZXRVbmlmb3JtOiBmdW5jdGlvbiBzZXRVbmlmb3JtICh0eXBlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKCBsZW4tLSA+IDAgKSB2YWx1ZXNbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gKyAyIF07XG5cbiAgICAgICAgICAgICAgICAgIHZhciB1bmlmb3JtTG9jID0gdW5pZm9ybXNbbmFtZV0gfHwgKHVuaWZvcm1zW25hbWVdID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpKTtcbiAgICAgICAgICAgICAgICAgIGdsWyhcInVuaWZvcm1cIiArIHR5cGUpXS5hcHBseShnbCwgWyB1bmlmb3JtTG9jIF0uY29uY2F0KCB2YWx1ZXMgKSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24gc2V0QXR0cmlidXRlIChuYW1lLCBzaXplLCB1c2FnZSwgaW5zdGFuY2luZ0Rpdmlzb3IsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBhdHRyID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgIGlmICghYXR0cikge1xuICAgICAgICAgICAgICAgICAgICBhdHRyID0gYXR0cmlidXRlc1tuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICBidWY6IGdsLmNyZWF0ZUJ1ZmZlcigpLCAvLyBUT0RPIHNob3VsZCB3ZSBkZXN0cm95IG91ciBidWZmZXJzP1xuICAgICAgICAgICAgICAgICAgICAgIGxvYzogZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgZGF0YTogbnVsbFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGF0dHIuYnVmKTtcbiAgICAgICAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoYXR0ci5sb2MsIHNpemUsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICAgICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShhdHRyLmxvYyk7XG4gICAgICAgICAgICAgICAgICBpZiAoaXNXZWJHTDIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihhdHRyLmxvYywgaW5zdGFuY2luZ0Rpdmlzb3IpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RXh0ZW5zaW9uKCdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJykudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGF0dHIubG9jLCBpbnN0YW5jaW5nRGl2aXNvcik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gYXR0ci5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCBkYXRhLCB1c2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGF0dHIuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvZ3JhbXNbbmFtZV0udHJhbnNhY3Rpb24oZnVuYyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdpdGhUZXh0dXJlIChuYW1lLCBmdW5jKSB7XG4gICAgICAgIHRleHR1cmVVbml0Kys7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRleHR1cmVVbml0KTtcbiAgICAgICAgICB2YXIgdGV4dHVyZSA9IHRleHR1cmVzW25hbWVdO1xuICAgICAgICAgIGlmICghdGV4dHVyZSkge1xuICAgICAgICAgICAgdGV4dHVyZSA9IHRleHR1cmVzW25hbWVdID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICAgIGZ1bmModGV4dHVyZSwgdGV4dHVyZVVuaXQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHRleHR1cmVVbml0LS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gd2l0aFRleHR1cmVGcmFtZWJ1ZmZlciAodGV4dHVyZSwgdGV4dHVyZVVuaXQsIGZ1bmMpIHtcbiAgICAgICAgdmFyIGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgZnJhbWVidWZmZXJTdGFjay5wdXNoKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZ1bmMoZnJhbWVidWZmZXIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyU3RhY2tbLS1mcmFtZWJ1ZmZlclN0YWNrLmxlbmd0aCAtIDFdIHx8IG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZUNvbnRleHRMb3NzICgpIHtcbiAgICAgICAgZXh0ZW5zaW9ucyA9IHt9O1xuICAgICAgICBwcm9ncmFtcyA9IHt9O1xuICAgICAgICB0ZXh0dXJlcyA9IHt9O1xuICAgICAgICB0ZXh0dXJlVW5pdCA9IC0xO1xuICAgICAgICBmcmFtZWJ1ZmZlclN0YWNrLmxlbmd0aCA9IDA7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlLnNldChnbCwgd3JhcHBlciA9IHtcbiAgICAgICAgZ2w6IGdsLFxuICAgICAgICBpc1dlYkdMMjogaXNXZWJHTDIsXG4gICAgICAgIGdldEV4dGVuc2lvbjogZ2V0RXh0ZW5zaW9uLFxuICAgICAgICB3aXRoUHJvZ3JhbTogd2l0aFByb2dyYW0sXG4gICAgICAgIHdpdGhUZXh0dXJlOiB3aXRoVGV4dHVyZSxcbiAgICAgICAgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcjogd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcixcbiAgICAgICAgaGFuZGxlQ29udGV4dExvc3M6IGhhbmRsZUNvbnRleHRMb3NzLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGxiYWNrKHdyYXBwZXIpO1xuICB9XG5cblxuICBmdW5jdGlvbiByZW5kZXJJbWFnZURhdGEoZ2xPckNhbnZhcywgaW1hZ2VEYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZnJhbWVidWZmZXIpIHtcbiAgICBpZiAoIGNoYW5uZWxzID09PSB2b2lkIDAgKSBjaGFubmVscyA9IDE1O1xuICAgIGlmICggZnJhbWVidWZmZXIgPT09IHZvaWQgMCApIGZyYW1lYnVmZmVyID0gbnVsbDtcblxuICAgIHdpdGhXZWJHTENvbnRleHQoZ2xPckNhbnZhcywgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGdsID0gcmVmLmdsO1xuICAgICAgdmFyIHdpdGhQcm9ncmFtID0gcmVmLndpdGhQcm9ncmFtO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlID0gcmVmLndpdGhUZXh0dXJlO1xuXG4gICAgICB3aXRoVGV4dHVyZSgnY29weScsIGZ1bmN0aW9uICh0ZXgsIHRleFVuaXQpIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZURhdGEpO1xuICAgICAgICB3aXRoUHJvZ3JhbSgnY29weScsIHZpZXdwb3J0UXVhZFZlcnRleCwgY29weVRleEZyYWdtZW50LCBmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgdmFyIHNldFVuaWZvcm0gPSByZWYuc2V0VW5pZm9ybTtcbiAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlID0gcmVmLnNldEF0dHJpYnV0ZTtcblxuICAgICAgICAgIHNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIDIsIDAsIDAsIDJdKSk7XG4gICAgICAgICAgc2V0VW5pZm9ybSgnMWknLCAnaW1hZ2UnLCB0ZXhVbml0KTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyIHx8IG51bGwpO1xuICAgICAgICAgIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgIGdsLmNvbG9yTWFzayhjaGFubmVscyAmIDgsIGNoYW5uZWxzICYgNCwgY2hhbm5lbHMgJiAyLCBjaGFubmVscyAmIDEpO1xuICAgICAgICAgIGdsLnZpZXdwb3J0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgIGdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6aW5nIGEgY2FudmFzIGNsZWFycyBpdHMgY29udGVudHM7IHRoaXMgdXRpbGl0eSBjb3BpZXMgdGhlIHByZXZpb3VzIGNvbnRlbnRzIG92ZXIuXG4gICAqIEBwYXJhbSBjYW52YXNcbiAgICogQHBhcmFtIG5ld1dpZHRoXG4gICAqIEBwYXJhbSBuZXdIZWlnaHRcbiAgICovXG4gIGZ1bmN0aW9uIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nKGNhbnZhcywgbmV3V2lkdGgsIG5ld0hlaWdodCkge1xuICAgIHZhciB3aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB3aXRoV2ViR0xDb250ZXh0KGNhbnZhcywgZnVuY3Rpb24gKHJlZikge1xuICAgICAgdmFyIGdsID0gcmVmLmdsO1xuXG4gICAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuICAgICAgY2FudmFzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gbmV3SGVpZ2h0O1xuICAgICAgcmVuZGVySW1hZ2VEYXRhKGdsLCBkYXRhLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciB3ZWJnbFV0aWxzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICB3aXRoV2ViR0xDb250ZXh0OiB3aXRoV2ViR0xDb250ZXh0LFxuICAgIHJlbmRlckltYWdlRGF0YTogcmVuZGVySW1hZ2VEYXRhLFxuICAgIHJlc2l6ZVdlYkdMQ2FudmFzV2l0aG91dENsZWFyaW5nOiByZXNpemVXZWJHTENhbnZhc1dpdGhvdXRDbGVhcmluZ1xuICB9KTtcblxuICBmdW5jdGlvbiBnZW5lcmF0ZSQyIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG5cbiAgICB2YXIgdGV4dHVyZURhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCk7XG5cbiAgICB2YXIgdmlld0JveFdpZHRoID0gdmlld0JveFsyXSAtIHZpZXdCb3hbMF07XG4gICAgdmFyIHZpZXdCb3hIZWlnaHQgPSB2aWV3Qm94WzNdIC0gdmlld0JveFsxXTtcblxuICAgIC8vIERlY29tcG9zZSBhbGwgcGF0aHMgaW50byBzdHJhaWdodCBsaW5lIHNlZ21lbnRzIGFuZCBhZGQgdGhlbSB0byBhbiBpbmRleFxuICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgIHBhdGhUb0xpbmVTZWdtZW50cyhwYXRoLCBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICB4MTogeDEsIHkxOiB5MSwgeDI6IHgyLCB5MjogeTIsXG4gICAgICAgIG1pblg6IE1hdGgubWluKHgxLCB4MiksXG4gICAgICAgIG1pblk6IE1hdGgubWluKHkxLCB5MiksXG4gICAgICAgIG1heFg6IE1hdGgubWF4KHgxLCB4MiksXG4gICAgICAgIG1heFk6IE1hdGgubWF4KHkxLCB5MilcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gU29ydCBzZWdtZW50cyBieSBtYXhYLCB0aGlzIHdpbGwgbGV0IHVzIHNob3J0LWNpcmN1aXQgc29tZSBsb29wcyBiZWxvd1xuICAgIHNlZ21lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEubWF4WCAtIGIubWF4WDsgfSk7XG5cbiAgICAvLyBGb3IgZWFjaCB0YXJnZXQgU0RGIHRleGVsLCBmaW5kIHRoZSBkaXN0YW5jZSBmcm9tIGl0cyBjZW50ZXIgdG8gaXRzIG5lYXJlc3QgbGluZSBzZWdtZW50LFxuICAgIC8vIG1hcCB0aGF0IGRpc3RhbmNlIHRvIGFuIGFscGhhIHZhbHVlLCBhbmQgd3JpdGUgdGhhdCBhbHBoYSB0byB0aGUgdGV4ZWxcbiAgICBmb3IgKHZhciBzZGZYID0gMDsgc2RmWCA8IHNkZldpZHRoOyBzZGZYKyspIHtcbiAgICAgIGZvciAodmFyIHNkZlkgPSAwOyBzZGZZIDwgc2RmSGVpZ2h0OyBzZGZZKyspIHtcbiAgICAgICAgdmFyIHNpZ25lZERpc3QgPSBmaW5kTmVhcmVzdFNpZ25lZERpc3RhbmNlKFxuICAgICAgICAgIHZpZXdCb3hbMF0gKyB2aWV3Qm94V2lkdGggKiAoc2RmWCArIDAuNSkgLyBzZGZXaWR0aCxcbiAgICAgICAgICB2aWV3Qm94WzFdICsgdmlld0JveEhlaWdodCAqIChzZGZZICsgMC41KSAvIHNkZkhlaWdodFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFVzZSBhbiBleHBvbmVudGlhbCBzY2FsZSB0byBlbnN1cmUgdGhlIHRleGVscyB2ZXJ5IG5lYXIgdGhlIGdseXBoIHBhdGggaGF2ZSBhZGVxdWF0ZVxuICAgICAgICAvLyBwcmVjaXNpb24sIHdoaWxlIGFsbG93aW5nIHRoZSBkaXN0YW5jZSBmaWVsZCB0byBjb3ZlciB0aGUgZW50aXJlIHRleHR1cmUsIGdpdmVuIHRoYXRcbiAgICAgICAgLy8gdGhlcmUgYXJlIG9ubHkgOCBiaXRzIGF2YWlsYWJsZS4gRm9ybXVsYSB2aXN1YWxpemVkOiBodHRwczovL3d3dy5kZXNtb3MuY29tL2NhbGN1bGF0b3IvdWlhcTVhcWlhbVxuICAgICAgICB2YXIgYWxwaGEgPSBNYXRoLnBvdygoMSAtIE1hdGguYWJzKHNpZ25lZERpc3QpIC8gbWF4RGlzdGFuY2UpLCBzZGZFeHBvbmVudCkgLyAyO1xuICAgICAgICBpZiAoc2lnbmVkRGlzdCA8IDApIHtcbiAgICAgICAgICBhbHBoYSA9IDEgLSBhbHBoYTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFscGhhID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKGFscGhhICogMjU1KSkpOyAvL2NsYW1wXG4gICAgICAgIHRleHR1cmVEYXRhW3NkZlkgKiBzZGZXaWR0aCArIHNkZlhdID0gYWxwaGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRleHR1cmVEYXRhXG5cbiAgICAvKipcbiAgICAgKiBGb3IgYSBnaXZlbiB4L3ksIHNlYXJjaCB0aGUgaW5kZXggZm9yIHRoZSBjbG9zZXN0IGxpbmUgc2VnbWVudCBhbmQgcmV0dXJuXG4gICAgICogaXRzIHNpZ25lZCBkaXN0YW5jZS4gTmVnYXRpdmUgPSBpbnNpZGUsIHBvc2l0aXZlID0gb3V0c2lkZSwgemVybyA9IG9uIGVkZ2VcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTmVhcmVzdFNpZ25lZERpc3RhbmNlICh4LCB5KSB7XG4gICAgICB2YXIgY2xvc2VzdERpc3RTcSA9IEluZmluaXR5O1xuICAgICAgdmFyIGNsb3Nlc3REaXN0ID0gSW5maW5pdHk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBzZWdtZW50cy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ21lbnRzW2ldO1xuICAgICAgICBpZiAoc2VnLm1heFggKyBjbG9zZXN0RGlzdCA8PSB4KSB7IGJyZWFrIH0gLy9zb3J0aW5nIGJ5IG1heFggbWVhbnMgbm8gbW9yZSBjYW4gYmUgY2xvc2VyLCBzbyB3ZSBjYW4gc2hvcnQtY2lyY3VpdFxuICAgICAgICBpZiAoeCArIGNsb3Nlc3REaXN0ID4gc2VnLm1pblggJiYgeSAtIGNsb3Nlc3REaXN0IDwgc2VnLm1heFkgJiYgeSArIGNsb3Nlc3REaXN0ID4gc2VnLm1pblkpIHtcbiAgICAgICAgICB2YXIgZGlzdFNxID0gYWJzU3F1YXJlRGlzdGFuY2VUb0xpbmVTZWdtZW50KHgsIHksIHNlZy54MSwgc2VnLnkxLCBzZWcueDIsIHNlZy55Mik7XG4gICAgICAgICAgaWYgKGRpc3RTcSA8IGNsb3Nlc3REaXN0U3EpIHtcbiAgICAgICAgICAgIGNsb3Nlc3REaXN0U3EgPSBkaXN0U3E7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdCA9IE1hdGguc3FydChjbG9zZXN0RGlzdFNxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmxpcCB0byBuZWdhdGl2ZSBkaXN0YW5jZSBpZiBpbnNpZGUgdGhlIHBvbHlcbiAgICAgIGlmIChpc1BvaW50SW5Qb2x5KHgsIHkpKSB7XG4gICAgICAgIGNsb3Nlc3REaXN0ID0gLWNsb3Nlc3REaXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb3Nlc3REaXN0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGdpdmVuIHBvaW50IGxpZXMgaW5zaWRlIG9yIG91dHNpZGUgdGhlIGdseXBoLiBVc2VzIGEgc2ltcGxlXG4gICAgICogd2luZGluZy1udW1iZXIgcmF5IGNhc3RpbmcgYWxnb3JpdGhtIHVzaW5nIGEgcmF5IHBvaW50aW5nIGVhc3QgZnJvbSB0aGUgcG9pbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQb2ludEluUG9seSAoeCwgeSkge1xuICAgICAgdmFyIHdpbmRpbmcgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IHNlZ21lbnRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICB2YXIgc2VnID0gc2VnbWVudHNbaV07XG4gICAgICAgIGlmIChzZWcubWF4WCA8PSB4KSB7IGJyZWFrIH0gLy9zb3J0aW5nIGJ5IG1heFggbWVhbnMgbm8gbW9yZSBjYW4gY3Jvc3MsIHNvIHdlIGNhbiBzaG9ydC1jaXJjdWl0XG4gICAgICAgIHZhciBpbnRlcnNlY3RzID0gKChzZWcueTEgPiB5KSAhPT0gKHNlZy55MiA+IHkpKSAmJiAoeCA8IChzZWcueDIgLSBzZWcueDEpICogKHkgLSBzZWcueTEpIC8gKHNlZy55MiAtIHNlZy55MSkgKyBzZWcueDEpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0cykge1xuICAgICAgICAgIHdpbmRpbmcgKz0gc2VnLnkxIDwgc2VnLnkyID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gd2luZGluZyAhPT0gMFxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyQyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIkMShzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGNhbnZhcywgbnVsbCwgeCwgeSwgY2hhbm5lbCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxIChzZGZXaWR0aCwgc2RmSGVpZ2h0LCBwYXRoLCB2aWV3Qm94LCBtYXhEaXN0YW5jZSwgc2RmRXhwb25lbnQsIGdsT3JDYW52YXMsIGZyYW1lYnVmZmVyLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgdmFyIGRhdGEgPSBnZW5lcmF0ZSQyKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCk7XG4gICAgLy8gRXhwYW5kIHNpbmdsZS1jaGFubmVsIGRhdGEgdG8gcmJnYVxuICAgIHZhciByZ2JhRGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoICogNCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZ2JhRGF0YVtpICogNCArIGNoYW5uZWxdID0gZGF0YVtpXTtcbiAgICB9XG4gICAgcmVuZGVySW1hZ2VEYXRhKGdsT3JDYW52YXMsIHJnYmFEYXRhLCB4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0LCAxIDw8ICgzIC0gY2hhbm5lbCksIGZyYW1lYnVmZmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBhYnNvbHV0ZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBsaW5lIHNlZ21lbnQgYXQgY2xvc2VzdCBhcHByb2FjaFxuICAgKi9cbiAgZnVuY3Rpb24gYWJzU3F1YXJlRGlzdGFuY2VUb0xpbmVTZWdtZW50ICh4LCB5LCBsaW5lWDAsIGxpbmVZMCwgbGluZVgxLCBsaW5lWTEpIHtcbiAgICB2YXIgbGR4ID0gbGluZVgxIC0gbGluZVgwO1xuICAgIHZhciBsZHkgPSBsaW5lWTEgLSBsaW5lWTA7XG4gICAgdmFyIGxlbmd0aFNxID0gbGR4ICogbGR4ICsgbGR5ICogbGR5O1xuICAgIHZhciB0ID0gbGVuZ3RoU3EgPyBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCAoKHggLSBsaW5lWDApICogbGR4ICsgKHkgLSBsaW5lWTApICogbGR5KSAvIGxlbmd0aFNxKSkgOiAwO1xuICAgIHZhciBkeCA9IHggLSAobGluZVgwICsgdCAqIGxkeCk7XG4gICAgdmFyIGR5ID0geSAtIChsaW5lWTAgKyB0ICogbGR5KTtcbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHlcbiAgfVxuXG4gIHZhciBqYXZhc2NyaXB0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZW5lcmF0ZTogZ2VuZXJhdGUkMixcbiAgICBnZW5lcmF0ZUludG9DYW52YXM6IGdlbmVyYXRlSW50b0NhbnZhcyQyLFxuICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyOiBnZW5lcmF0ZUludG9GcmFtZWJ1ZmZlciQxXG4gIH0pO1xuXG4gIHZhciBtYWluVmVydGV4ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSB2ZWM0IHVHbHlwaEJvdW5kczthdHRyaWJ1dGUgdmVjMiBhVVY7YXR0cmlidXRlIHZlYzQgYUxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjNCB2TGluZVNlZ21lbnQ7dmFyeWluZyB2ZWMyIHZHbHlwaFhZO3ZvaWQgbWFpbigpe3ZMaW5lU2VnbWVudD1hTGluZVNlZ21lbnQ7dkdseXBoWFk9bWl4KHVHbHlwaEJvdW5kcy54eSx1R2x5cGhCb3VuZHMuencsYVVWKTtnbF9Qb3NpdGlvbj12ZWM0KG1peCh2ZWMyKC0xLjApLHZlYzIoMS4wKSxhVVYpLDAuMCwxLjApO31cIjtcblxuICB2YXIgbWFpbkZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSB2ZWM0IHVHbHlwaEJvdW5kczt1bmlmb3JtIGZsb2F0IHVNYXhEaXN0YW5jZTt1bmlmb3JtIGZsb2F0IHVFeHBvbmVudDt2YXJ5aW5nIHZlYzQgdkxpbmVTZWdtZW50O3ZhcnlpbmcgdmVjMiB2R2x5cGhYWTtmbG9hdCBhYnNEaXN0VG9TZWdtZW50KHZlYzIgcG9pbnQsdmVjMiBsaW5lQSx2ZWMyIGxpbmVCKXt2ZWMyIGxpbmVEaXI9bGluZUItbGluZUE7ZmxvYXQgbGVuU3E9ZG90KGxpbmVEaXIsbGluZURpcik7ZmxvYXQgdD1sZW5TcT09MC4wID8gMC4wIDogY2xhbXAoZG90KHBvaW50LWxpbmVBLGxpbmVEaXIpL2xlblNxLDAuMCwxLjApO3ZlYzIgbGluZVB0PWxpbmVBK3QqbGluZURpcjtyZXR1cm4gZGlzdGFuY2UocG9pbnQsbGluZVB0KTt9dm9pZCBtYWluKCl7dmVjNCBzZWc9dkxpbmVTZWdtZW50O3ZlYzIgcD12R2x5cGhYWTtmbG9hdCBkaXN0PWFic0Rpc3RUb1NlZ21lbnQocCxzZWcueHksc2VnLnp3KTtmbG9hdCB2YWw9cG93KDEuMC1jbGFtcChkaXN0L3VNYXhEaXN0YW5jZSwwLjAsMS4wKSx1RXhwb25lbnQpKjAuNTtib29sIGNyb3NzaW5nPShzZWcueT5wLnkhPXNlZy53PnAueSkmJihwLng8KHNlZy56LXNlZy54KSoocC55LXNlZy55KS8oc2VnLnctc2VnLnkpK3NlZy54KTtib29sIGNyb3NzaW5nVXA9Y3Jvc3NpbmcmJnZMaW5lU2VnbWVudC55PHZMaW5lU2VnbWVudC53O2dsX0ZyYWdDb2xvcj12ZWM0KGNyb3NzaW5nVXAgPyAxLjAvMjU1LjAgOiAwLjAsY3Jvc3NpbmcmJiFjcm9zc2luZ1VwID8gMS4wLzI1NS4wIDogMC4wLDAuMCx2YWwpO31cIjtcblxuICB2YXIgcG9zdEZyYWdtZW50ID0gXCJwcmVjaXNpb24gaGlnaHAgZmxvYXQ7dW5pZm9ybSBzYW1wbGVyMkQgdGV4O3ZhcnlpbmcgdmVjMiB2VVY7dm9pZCBtYWluKCl7dmVjNCBjb2xvcj10ZXh0dXJlMkQodGV4LHZVVik7Ym9vbCBpbnNpZGU9Y29sb3IuciE9Y29sb3IuZztmbG9hdCB2YWw9aW5zaWRlID8gMS4wLWNvbG9yLmEgOiBjb2xvci5hO2dsX0ZyYWdDb2xvcj12ZWM0KHZhbCk7fVwiO1xuXG4gIC8vIFNpbmdsZSB0cmlhbmdsZSBjb3ZlcmluZyB2aWV3cG9ydFxuICB2YXIgdmlld3BvcnRVVnMgPSBuZXcgRmxvYXQzMkFycmF5KFswLCAwLCAyLCAwLCAwLCAyXSk7XG5cbiAgdmFyIGltcGxpY2l0Q29udGV4dCA9IG51bGw7XG4gIHZhciBpc1Rlc3RpbmdTdXBwb3J0ID0gZmFsc2U7XG4gIHZhciBOVUxMX09CSkVDVCA9IHt9O1xuICB2YXIgc3VwcG9ydEJ5Q2FudmFzID0gbmV3IFdlYWtNYXAoKTsgLy8gY2FudmFzIC0+IGJvb2xcblxuICBmdW5jdGlvbiB2YWxpZGF0ZVN1cHBvcnQgKGdsT3JDYW52YXMpIHtcbiAgICBpZiAoIWlzVGVzdGluZ1N1cHBvcnQgJiYgIWlzU3VwcG9ydGVkKGdsT3JDYW52YXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZCcpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGUkMSAoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBnbE9yQ2FudmFzKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggZ2xPckNhbnZhcyA9PT0gdm9pZCAwICkgZ2xPckNhbnZhcyA9IG51bGw7XG5cbiAgICBpZiAoIWdsT3JDYW52YXMpIHtcbiAgICAgIGdsT3JDYW52YXMgPSBpbXBsaWNpdENvbnRleHQ7XG4gICAgICBpZiAoIWdsT3JDYW52YXMpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICA/IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSlcbiAgICAgICAgICA6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICAgICAgaWYgKCFjYW52YXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09mZnNjcmVlbkNhbnZhcyBvciBET00gY2FudmFzIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICB9XG4gICAgICAgIGdsT3JDYW52YXMgPSBpbXBsaWNpdENvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7IGRlcHRoOiBmYWxzZSB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWxpZGF0ZVN1cHBvcnQoZ2xPckNhbnZhcyk7XG5cbiAgICB2YXIgcmdiYURhdGEgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCAqIDQpOyAvL25vdCBVaW50OENsYW1wZWRBcnJheSwgY3V6IFNhZmFyaVxuXG4gICAgLy8gUmVuZGVyIGludG8gYSBiYWNrZ3JvdW5kIHRleHR1cmUgZnJhbWVidWZmZXJcbiAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgIHZhciB3aXRoVGV4dHVyZSA9IHJlZi53aXRoVGV4dHVyZTtcbiAgICAgIHZhciB3aXRoVGV4dHVyZUZyYW1lYnVmZmVyID0gcmVmLndpdGhUZXh0dXJlRnJhbWVidWZmZXI7XG5cbiAgICAgIHdpdGhUZXh0dXJlKCdyZWFkYWJsZScsIGZ1bmN0aW9uICh0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNkZldpZHRoLCBzZGZIZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgICAgIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIodGV4dHVyZSwgdGV4dHVyZVVuaXQsIGZ1bmN0aW9uIChmcmFtZWJ1ZmZlcikge1xuICAgICAgICAgIGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyKFxuICAgICAgICAgICAgc2RmV2lkdGgsXG4gICAgICAgICAgICBzZGZIZWlnaHQsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgdmlld0JveCxcbiAgICAgICAgICAgIG1heERpc3RhbmNlLFxuICAgICAgICAgICAgc2RmRXhwb25lbnQsXG4gICAgICAgICAgICBnbCxcbiAgICAgICAgICAgIGZyYW1lYnVmZmVyLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAwIC8vIHJlZCBjaGFubmVsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBnbC5yZWFkUGl4ZWxzKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHJnYmFEYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFRocm93IGF3YXkgYWxsIGJ1dCB0aGUgcmVkIGNoYW5uZWxcbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHNkZldpZHRoICogc2RmSGVpZ2h0KTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCByZ2JhRGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgZGF0YVtqKytdID0gcmdiYURhdGFbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50b0NhbnZhcyQxKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgY2FudmFzLCB4LCB5LCBjaGFubmVsKSB7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIoc2RmV2lkdGgsIHNkZkhlaWdodCwgcGF0aCwgdmlld0JveCwgbWF4RGlzdGFuY2UsIHNkZkV4cG9uZW50LCBjYW52YXMsIG51bGwsIHgsIHksIGNoYW5uZWwpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXIgKHNkZldpZHRoLCBzZGZIZWlnaHQsIHBhdGgsIHZpZXdCb3gsIG1heERpc3RhbmNlLCBzZGZFeHBvbmVudCwgZ2xPckNhbnZhcywgZnJhbWVidWZmZXIsIHgsIHksIGNoYW5uZWwpIHtcbiAgICBpZiAoIHNkZkV4cG9uZW50ID09PSB2b2lkIDAgKSBzZGZFeHBvbmVudCA9IDE7XG4gICAgaWYgKCB4ID09PSB2b2lkIDAgKSB4ID0gMDtcbiAgICBpZiAoIHkgPT09IHZvaWQgMCApIHkgPSAwO1xuICAgIGlmICggY2hhbm5lbCA9PT0gdm9pZCAwICkgY2hhbm5lbCA9IDA7XG5cbiAgICAvLyBWZXJpZnkgc3VwcG9ydFxuICAgIHZhbGlkYXRlU3VwcG9ydChnbE9yQ2FudmFzKTtcblxuICAgIC8vIENvbXB1dGUgcGF0aCBzZWdtZW50c1xuICAgIHZhciBsaW5lU2VnbWVudENvb3JkcyA9IFtdO1xuICAgIHBhdGhUb0xpbmVTZWdtZW50cyhwYXRoLCBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICAgIGxpbmVTZWdtZW50Q29vcmRzLnB1c2goeDEsIHkxLCB4MiwgeTIpO1xuICAgIH0pO1xuICAgIGxpbmVTZWdtZW50Q29vcmRzID0gbmV3IEZsb2F0MzJBcnJheShsaW5lU2VnbWVudENvb3Jkcyk7XG5cbiAgICB3aXRoV2ViR0xDb250ZXh0KGdsT3JDYW52YXMsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgIHZhciBnbCA9IHJlZi5nbDtcbiAgICAgIHZhciBpc1dlYkdMMiA9IHJlZi5pc1dlYkdMMjtcbiAgICAgIHZhciBnZXRFeHRlbnNpb24gPSByZWYuZ2V0RXh0ZW5zaW9uO1xuICAgICAgdmFyIHdpdGhQcm9ncmFtID0gcmVmLndpdGhQcm9ncmFtO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlID0gcmVmLndpdGhUZXh0dXJlO1xuICAgICAgdmFyIHdpdGhUZXh0dXJlRnJhbWVidWZmZXIgPSByZWYud2l0aFRleHR1cmVGcmFtZWJ1ZmZlcjtcbiAgICAgIHZhciBoYW5kbGVDb250ZXh0TG9zcyA9IHJlZi5oYW5kbGVDb250ZXh0TG9zcztcblxuICAgICAgd2l0aFRleHR1cmUoJ3Jhd0Rpc3RhbmNlcycsIGZ1bmN0aW9uIChpbnRlcm1lZGlhdGVUZXh0dXJlLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCkge1xuICAgICAgICBpZiAoc2RmV2lkdGggIT09IGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RXaWR0aCB8fCBzZGZIZWlnaHQgIT09IGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RIZWlnaHQpIHtcbiAgICAgICAgICBnbC50ZXhJbWFnZTJEKFxuICAgICAgICAgICAgZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSxcbiAgICAgICAgICAgIGludGVybWVkaWF0ZVRleHR1cmUuX2xhc3RXaWR0aCA9IHNkZldpZHRoLFxuICAgICAgICAgICAgaW50ZXJtZWRpYXRlVGV4dHVyZS5fbGFzdEhlaWdodCA9IHNkZkhlaWdodCxcbiAgICAgICAgICAgIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGxcbiAgICAgICAgICApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5zaWduZWQgZGlzdGFuY2UgcGFzc1xuICAgICAgICB3aXRoUHJvZ3JhbSgnbWFpbicsIG1haW5WZXJ0ZXgsIG1haW5GcmFnbWVudCwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGUgPSByZWYuc2V0QXR0cmlidXRlO1xuICAgICAgICAgIHZhciBzZXRVbmlmb3JtID0gcmVmLnNldFVuaWZvcm07XG5cbiAgICAgICAgICAvLyBJbml0IGV4dGVuc2lvbnNcbiAgICAgICAgICB2YXIgaW5zdGFuY2luZ0V4dGVuc2lvbiA9ICFpc1dlYkdMMiAmJiBnZXRFeHRlbnNpb24oJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnKTtcbiAgICAgICAgICB2YXIgYmxlbmRNaW5NYXhFeHRlbnNpb24gPSAhaXNXZWJHTDIgJiYgZ2V0RXh0ZW5zaW9uKCdFWFRfYmxlbmRfbWlubWF4Jyk7XG5cbiAgICAgICAgICAvLyBJbml0L3VwZGF0ZSBhdHRyaWJ1dGVzXG4gICAgICAgICAgc2V0QXR0cmlidXRlKCdhVVYnLCAyLCBnbC5TVEFUSUNfRFJBVywgMCwgdmlld3BvcnRVVnMpO1xuICAgICAgICAgIHNldEF0dHJpYnV0ZSgnYUxpbmVTZWdtZW50JywgNCwgZ2wuRFlOQU1JQ19EUkFXLCAxLCBsaW5lU2VnbWVudENvb3Jkcyk7XG5cbiAgICAgICAgICAvLyBJbml0L3VwZGF0ZSB1bmlmb3Jtc1xuICAgICAgICAgIHNldFVuaWZvcm0uYXBwbHkodm9pZCAwLCBbICc0ZicsICd1R2x5cGhCb3VuZHMnIF0uY29uY2F0KCB2aWV3Qm94ICkpO1xuICAgICAgICAgIHNldFVuaWZvcm0oJzFmJywgJ3VNYXhEaXN0YW5jZScsIG1heERpc3RhbmNlKTtcbiAgICAgICAgICBzZXRVbmlmb3JtKCcxZicsICd1RXhwb25lbnQnLCBzZGZFeHBvbmVudCk7XG5cbiAgICAgICAgICAvLyBSZW5kZXIgaW5pdGlhbCB1bnNpZ25lZCBkaXN0YW5jZSAvIHdpbmRpbmcgbnVtYmVyIGluZm8gdG8gYSB0ZXh0dXJlXG4gICAgICAgICAgd2l0aFRleHR1cmVGcmFtZWJ1ZmZlcihpbnRlcm1lZGlhdGVUZXh0dXJlLCBpbnRlcm1lZGlhdGVUZXh0dXJlVW5pdCwgZnVuY3Rpb24gKGZyYW1lYnVmZmVyKSB7XG4gICAgICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgICAgICAgZ2wuY29sb3JNYXNrKHRydWUsIHRydWUsIHRydWUsIHRydWUpO1xuICAgICAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgICBnbC5zY2lzc29yKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQpO1xuICAgICAgICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FKTtcbiAgICAgICAgICAgIC8vIFJlZCtHcmVlbiBjaGFubmVscyBhcmUgaW5jcmVtZW50ZWQgKEZVTkNfQUREKSBmb3Igc2VnbWVudC1yYXkgY3Jvc3NpbmdzIHRvIGdpdmUgYSBcIndpbmRpbmcgbnVtYmVyXCIuXG4gICAgICAgICAgICAvLyBBbHBoYSBob2xkcyB0aGUgY2xvc2VzdCAoTUFYKSB1bnNpZ25lZCBkaXN0YW5jZS5cbiAgICAgICAgICAgIGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZShnbC5GVU5DX0FERCwgaXNXZWJHTDIgPyBnbC5NQVggOiBibGVuZE1pbk1heEV4dGVuc2lvbi5NQVhfRVhUKTtcbiAgICAgICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgICAgICAgaWYgKGlzV2ViR0wyKSB7XG4gICAgICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQoZ2wuVFJJQU5HTEVTLCAwLCAzLCBsaW5lU2VnbWVudENvb3Jkcy5sZW5ndGggLyA0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGluc3RhbmNpbmdFeHRlbnNpb24uZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKGdsLlRSSUFOR0xFUywgMCwgMywgbGluZVNlZ21lbnRDb29yZHMubGVuZ3RoIC8gNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWJ1Z1xuICAgICAgICAgICAgLy8gY29uc3QgZGVidWcgPSBuZXcgVWludDhBcnJheShzZGZXaWR0aCAqIHNkZkhlaWdodCAqIDQpXG4gICAgICAgICAgICAvLyBnbC5yZWFkUGl4ZWxzKDAsIDAsIHNkZldpZHRoLCBzZGZIZWlnaHQsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRlYnVnKVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coJ2ludGVybWVkaWF0ZSB0ZXh0dXJlIGRhdGE6ICcsIGRlYnVnKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBVc2UgdGhlIGRhdGEgc3RvcmVkIGluIHRoZSB0ZXh0dXJlIHRvIGFwcGx5IGluc2lkZS9vdXRzaWRlIGFuZCB3cml0ZSB0byB0aGUgb3V0cHV0IGZyYW1lYnVmZmVyIHJlY3QrY2hhbm5lbC5cbiAgICAgICAgd2l0aFByb2dyYW0oJ3Bvc3QnLCB2aWV3cG9ydFF1YWRWZXJ0ZXgsIHBvc3RGcmFnbWVudCwgZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICBwcm9ncmFtLnNldEF0dHJpYnV0ZSgnYVVWJywgMiwgZ2wuU1RBVElDX0RSQVcsIDAsIHZpZXdwb3J0VVZzKTtcbiAgICAgICAgICBwcm9ncmFtLnNldFVuaWZvcm0oJzFpJywgJ3RleCcsIGludGVybWVkaWF0ZVRleHR1cmVVbml0KTtcbiAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcbiAgICAgICAgICBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcbiAgICAgICAgICBnbC5jb2xvck1hc2soY2hhbm5lbCA9PT0gMCwgY2hhbm5lbCA9PT0gMSwgY2hhbm5lbCA9PT0gMiwgY2hhbm5lbCA9PT0gMyk7XG4gICAgICAgICAgZ2wudmlld3BvcnQoeCwgeSwgc2RmV2lkdGgsIHNkZkhlaWdodCk7XG4gICAgICAgICAgZ2wuc2Npc3Nvcih4LCB5LCBzZGZXaWR0aCwgc2RmSGVpZ2h0KTtcbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgMyk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEhhbmRsZSBjb250ZXh0IGxvc3Mgb2NjdXJyaW5nIGR1cmluZyBhbnkgb2YgdGhlIGFib3ZlIGNhbGxzXG4gICAgICBpZiAoZ2wuaXNDb250ZXh0TG9zdCgpKSB7XG4gICAgICAgIGhhbmRsZUNvbnRleHRMb3NzKCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignd2ViZ2wgY29udGV4dCBsb3N0JylcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3VwcG9ydGVkIChnbE9yQ2FudmFzKSB7XG4gICAgdmFyIGtleSA9ICghZ2xPckNhbnZhcyB8fCBnbE9yQ2FudmFzID09PSBpbXBsaWNpdENvbnRleHQpID8gTlVMTF9PQkpFQ1QgOiAoZ2xPckNhbnZhcy5jYW52YXMgfHwgZ2xPckNhbnZhcyk7XG4gICAgdmFyIHN1cHBvcnRlZCA9IHN1cHBvcnRCeUNhbnZhcy5nZXQoa2V5KTtcbiAgICBpZiAoc3VwcG9ydGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlzVGVzdGluZ1N1cHBvcnQgPSB0cnVlO1xuICAgICAgdmFyIGZhaWxSZWFzb24gPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gU2luY2Ugd2UgY2FuJ3QgZGV0ZWN0IGFsbCBmYWlsdXJlIG1vZGVzIHVwIGZyb250LCBsZXQncyBqdXN0IGRvIGEgdHJpYWwgcnVuIG9mIGFcbiAgICAgICAgLy8gc2ltcGxlIHBhdGggYW5kIGNvbXBhcmUgd2hhdCB3ZSBnZXQgYmFjayB0byB0aGUgY29ycmVjdCBleHBlY3RlZCByZXN1bHQuIFRoaXMgd2lsbFxuICAgICAgICAvLyBhbHNvIHNlcnZlIHRvIHByaW1lIHRoZSBzaGFkZXIgY29tcGlsYXRpb24uXG4gICAgICAgIHZhciBleHBlY3RlZFJlc3VsdCA9IFtcbiAgICAgICAgICA5NywgMTA2LCA5NywgNjEsXG4gICAgICAgICAgOTksIDEzNywgMTE4LCA4MCxcbiAgICAgICAgICA4MCwgMTE4LCAxMzcsIDk5LFxuICAgICAgICAgIDYxLCA5NywgMTA2LCA5N1xuICAgICAgICBdO1xuICAgICAgICB2YXIgdGVzdFJlc3VsdCA9IGdlbmVyYXRlJDEoXG4gICAgICAgICAgNCxcbiAgICAgICAgICA0LFxuICAgICAgICAgICdNOCw4TDE2LDhMMjQsMjRMMTYsMjRaJyxcbiAgICAgICAgICBbMCwgMCwgMzIsIDMyXSxcbiAgICAgICAgICAyNCxcbiAgICAgICAgICAxLFxuICAgICAgICAgIGdsT3JDYW52YXNcbiAgICAgICAgKTtcbiAgICAgICAgc3VwcG9ydGVkID0gdGVzdFJlc3VsdCAmJiBleHBlY3RlZFJlc3VsdC5sZW5ndGggPT09IHRlc3RSZXN1bHQubGVuZ3RoICYmXG4gICAgICAgICAgdGVzdFJlc3VsdC5ldmVyeShmdW5jdGlvbiAodmFsLCBpKSB7IHJldHVybiB2YWwgPT09IGV4cGVjdGVkUmVzdWx0W2ldOyB9KTtcbiAgICAgICAgaWYgKCFzdXBwb3J0ZWQpIHtcbiAgICAgICAgICBmYWlsUmVhc29uID0gJ2JhZCB0cmlhbCBydW4gcmVzdWx0cyc7XG4gICAgICAgICAgY29uc29sZS5pbmZvKGV4cGVjdGVkUmVzdWx0LCB0ZXN0UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIFRPRE8gaWYgaXQgdGhyZXcgZHVlIHRvIHdlYmdsIGNvbnRleHQgbG9zcywgc2hvdWxkIHdlIG1heWJlIGxlYXZlIGlzU3VwcG9ydGVkIGFzIG51bGwgYW5kIHRyeSBhZ2FpbiBsYXRlcj9cbiAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgIGZhaWxSZWFzb24gPSBlcnIubWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWlsUmVhc29uKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignV2ViR0wgU0RGIGdlbmVyYXRpb24gbm90IHN1cHBvcnRlZDonLCBmYWlsUmVhc29uKTtcbiAgICAgIH1cbiAgICAgIGlzVGVzdGluZ1N1cHBvcnQgPSBmYWxzZTtcbiAgICAgIHN1cHBvcnRCeUNhbnZhcy5zZXQoa2V5LCBzdXBwb3J0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwcG9ydGVkXG4gIH1cblxuICB2YXIgd2ViZ2wgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIGdlbmVyYXRlOiBnZW5lcmF0ZSQxLFxuICAgIGdlbmVyYXRlSW50b0NhbnZhczogZ2VuZXJhdGVJbnRvQ2FudmFzJDEsXG4gICAgZ2VuZXJhdGVJbnRvRnJhbWVidWZmZXI6IGdlbmVyYXRlSW50b0ZyYW1lYnVmZmVyLFxuICAgIGlzU3VwcG9ydGVkOiBpc1N1cHBvcnRlZFxuICB9KTtcblxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gU0RGIHRleHR1cmUgaW1hZ2UgZm9yIGEgMkQgcGF0aC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNkZldpZHRoIC0gd2lkdGggb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmSGVpZ2h0IC0gaGVpZ2h0IG9mIHRoZSBTREYgb3V0cHV0IGltYWdlIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggLSBhbiBTVkctbGlrZSBwYXRoIHN0cmluZyBkZXNjcmliaW5nIHRoZSBnbHlwaDsgc2hvdWxkIG9ubHkgY29udGFpbiBjb21tYW5kczogTS9ML1EvQy9aLlxuICAgKiBAcGFyYW0ge251bWJlcltdfSB2aWV3Qm94IC0gW21pblgsIG1pblksIG1heFgsIG1heFldIGluIGZvbnQgdW5pdHMgYWxpZ25pbmcgd2l0aCB0aGUgdGV4dHVyZSdzIGVkZ2VzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4RGlzdGFuY2UgLSB0aGUgbWF4aW11bSBkaXN0YW5jZSBmcm9tIHRoZSBnbHlwaCBwYXRoIGluIGZvbnQgdW5pdHMgdGhhdCB3aWxsIGJlIGVuY29kZWQ7IGRlZmF1bHRzXG4gICAqICAgICAgICB0byBoYWxmIHRoZSBtYXhpbXVtIHZpZXdCb3ggZGltZW5zaW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NkZkV4cG9uZW50XSAtIHNwZWNpZmllcyBhbiBleHBvbmVudCBmb3IgZW5jb2RpbmcgdGhlIFNERidzIGRpc3RhbmNlIHZhbHVlczsgaGlnaGVyIGV4cG9uZW50c1xuICAgKiAgICAgICAgd2lsbCBnaXZlIGdyZWF0ZXIgcHJlY2lzaW9uIG5lYXJlciB0aGUgZ2x5cGgncyBwYXRoLlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGUoXG4gICAgc2RmV2lkdGgsXG4gICAgc2RmSGVpZ2h0LFxuICAgIHBhdGgsXG4gICAgdmlld0JveCxcbiAgICBtYXhEaXN0YW5jZSxcbiAgICBzZGZFeHBvbmVudFxuICApIHtcbiAgICBpZiAoIG1heERpc3RhbmNlID09PSB2b2lkIDAgKSBtYXhEaXN0YW5jZSA9IE1hdGgubWF4KHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLCB2aWV3Qm94WzNdIC0gdmlld0JveFsxXSkgLyAyO1xuICAgIGlmICggc2RmRXhwb25lbnQgPT09IHZvaWQgMCApIHNkZkV4cG9uZW50ID0gMTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZ2VuZXJhdGUkMS5hcHBseSh3ZWJnbCwgYXJndW1lbnRzKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5pbmZvKCdXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKUycsIGUpO1xuICAgICAgcmV0dXJuIGdlbmVyYXRlJDIuYXBwbHkoamF2YXNjcmlwdCwgYXJndW1lbnRzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBTREYgdGV4dHVyZSBpbWFnZSBmb3IgYSAyRCBwYXRoLCBpbnNlcnRpbmcgdGhlIHJlc3VsdCBpbnRvIGEgV2ViR0wgYGNhbnZhc2AgYXQgYSBnaXZlbiB4L3kgcG9zaXRpb25cbiAgICogYW5kIGNvbG9yIGNoYW5uZWwuIFRoaXMgaXMgZ2VuZXJhbGx5IG11Y2ggZmFzdGVyIHRoYW4gY2FsbGluZyBgZ2VuZXJhdGVgIGJlY2F1c2UgaXQgZG9lcyBub3QgcmVxdWlyZSByZWFkaW5nIHBpeGVsc1xuICAgKiBiYWNrIGZyb20gdGhlIEdQVS0+Q1BVIC0tIHRoZSBgY2FudmFzYCBjYW4gYmUgdXNlZCBkaXJlY3RseSBhcyBhIFdlYkdMIHRleHR1cmUgaW1hZ2UsIHNvIGl0IGFsbCBzdGF5cyBvbiB0aGUgR1BVLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2RmV2lkdGggLSB3aWR0aCBvZiB0aGUgU0RGIG91dHB1dCBpbWFnZSBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzZGZIZWlnaHQgLSBoZWlnaHQgb2YgdGhlIFNERiBvdXRwdXQgaW1hZ2UgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIGFuIFNWRy1saWtlIHBhdGggc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGdseXBoOyBzaG91bGQgb25seSBjb250YWluIGNvbW1hbmRzOiBNL0wvUS9DL1ouXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHZpZXdCb3ggLSBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gaW4gZm9udCB1bml0cyBhbGlnbmluZyB3aXRoIHRoZSB0ZXh0dXJlJ3MgZWRnZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhEaXN0YW5jZSAtIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGdseXBoIHBhdGggaW4gZm9udCB1bml0cyB0aGF0IHdpbGwgYmUgZW5jb2RlZDsgZGVmYXVsdHNcbiAgICogICAgICAgIHRvIGhhbGYgdGhlIG1heGltdW0gdmlld0JveCBkaW1lbnNpb24uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2RmRXhwb25lbnRdIC0gc3BlY2lmaWVzIGFuIGV4cG9uZW50IGZvciBlbmNvZGluZyB0aGUgU0RGJ3MgZGlzdGFuY2UgdmFsdWVzOyBoaWdoZXIgZXhwb25lbnRzXG4gICAqICAgICAgICB3aWxsIGdpdmUgZ3JlYXRlciBwcmVjaXNpb24gbmVhcmVyIHRoZSBnbHlwaCdzIHBhdGguXG4gICAqIEBwYXJhbSB7SFRNTENhbnZhc0VsZW1lbnR8T2Zmc2NyZWVuQ2FudmFzfSBjYW52YXMgLSBhIFdlYkdMLWVuYWJsZWQgY2FudmFzIGludG8gd2hpY2ggdGhlIFNERiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiAgICAgICAgT25seSB0aGUgcmVsZXZhbnQgcmVjdC9jaGFubmVsIHdpbGwgYmUgbW9kaWZpZWQsIHRoZSByZXN0IHdpbGwgYmUgcHJlc2VydmVkLiBUbyBhdm9pZCB1bnByZWRpY3RhYmxlIHJlc3VsdHNcbiAgICogICAgICAgIGR1ZSB0byBzaGFyZWQgR0wgY29udGV4dCBzdGF0ZSwgdGhpcyBjYW52YXMgc2hvdWxkIGJlIGRlZGljYXRlZCB0byB1c2UgYnkgdGhpcyBsaWJyYXJ5IGFsb25lLlxuICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHBvc2l0aW9uIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgU0RGLlxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IHBvc2l0aW9uIGF0IHdoaWNoIHRvIHJlbmRlciB0aGUgU0RGLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2hhbm5lbCAtIHRoZSBjb2xvciBjaGFubmVsIGluZGV4ICgwLTQpIGludG8gd2hpY2ggdGhlIFNERiB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICAgKi9cbiAgZnVuY3Rpb24gZ2VuZXJhdGVJbnRvQ2FudmFzKFxuICAgIHNkZldpZHRoLFxuICAgIHNkZkhlaWdodCxcbiAgICBwYXRoLFxuICAgIHZpZXdCb3gsXG4gICAgbWF4RGlzdGFuY2UsXG4gICAgc2RmRXhwb25lbnQsXG4gICAgY2FudmFzLFxuICAgIHgsXG4gICAgeSxcbiAgICBjaGFubmVsXG4gICkge1xuICAgIGlmICggbWF4RGlzdGFuY2UgPT09IHZvaWQgMCApIG1heERpc3RhbmNlID0gTWF0aC5tYXgodmlld0JveFsyXSAtIHZpZXdCb3hbMF0sIHZpZXdCb3hbM10gLSB2aWV3Qm94WzFdKSAvIDI7XG4gICAgaWYgKCBzZGZFeHBvbmVudCA9PT0gdm9pZCAwICkgc2RmRXhwb25lbnQgPSAxO1xuICAgIGlmICggeCA9PT0gdm9pZCAwICkgeCA9IDA7XG4gICAgaWYgKCB5ID09PSB2b2lkIDAgKSB5ID0gMDtcbiAgICBpZiAoIGNoYW5uZWwgPT09IHZvaWQgMCApIGNoYW5uZWwgPSAwO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZW5lcmF0ZUludG9DYW52YXMkMS5hcHBseSh3ZWJnbCwgYXJndW1lbnRzKVxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgY29uc29sZS5pbmZvKCdXZWJHTCBTREYgZ2VuZXJhdGlvbiBmYWlsZWQsIGZhbGxpbmcgYmFjayB0byBKUycsIGUpO1xuICAgICAgcmV0dXJuIGdlbmVyYXRlSW50b0NhbnZhcyQyLmFwcGx5KGphdmFzY3JpcHQsIGFyZ3VtZW50cylcbiAgICB9XG4gIH1cblxuICBleHBvcnRzLmZvckVhY2hQYXRoQ29tbWFuZCA9IGZvckVhY2hQYXRoQ29tbWFuZDtcbiAgZXhwb3J0cy5nZW5lcmF0ZSA9IGdlbmVyYXRlO1xuICBleHBvcnRzLmdlbmVyYXRlSW50b0NhbnZhcyA9IGdlbmVyYXRlSW50b0NhbnZhcztcbiAgZXhwb3J0cy5qYXZhc2NyaXB0ID0gamF2YXNjcmlwdDtcbiAgZXhwb3J0cy5wYXRoVG9MaW5lU2VnbWVudHMgPSBwYXRoVG9MaW5lU2VnbWVudHM7XG4gIGV4cG9ydHMud2ViZ2wgPSB3ZWJnbDtcbiAgZXhwb3J0cy53ZWJnbFV0aWxzID0gd2ViZ2xVdGlscztcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KHt9KSk7XG5yZXR1cm4gZXhwb3J0c1xufVxuXG5leHBvcnQgeyBTREZHZW5lcmF0b3IgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/webgl-sdf-generator/dist/webgl-sdf-generator.mjs\n"));

/***/ })

}]);