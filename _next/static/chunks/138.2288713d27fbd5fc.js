"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[138],{4138:function(n,e,i){i.r(e),i.d(e,{default:function(){return f}});var o=i(7437),t=i(2265),r=i(6375),s=i(2860);function l(n,e,i,o){let t=class extends r.ShaderMaterial{constructor(t={}){let s=Object.entries(n);super({uniforms:s.reduce((n,[e,i])=>{let o=r.UniformsUtils.clone({[e]:{value:i}});return{...n,...o}},{}),vertexShader:e,fragmentShader:i}),this.key="",s.forEach(([n])=>Object.defineProperty(this,n,{get:()=>this.uniforms[n].value,set:e=>this.uniforms[n].value=e})),Object.assign(this,t),o&&o(this)}};return t.key=r.MathUtils.generateUUID(),t}let a=l({time:0,radius:5,baseColor:new r.Color("#aaddff"),pulseColor:new r.Color("#ffffff")},"\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    uniform float time;\n    uniform float radius;\n    \n    void main() {\n      vNormal = normalize(normalMatrix * normal);\n      vec3 pos = position;\n      \n      // Create crystalline surface displacement\n      float displacement = sin(position.x * 10.0 + time) * \n                         cos(position.y * 8.0 + time * 0.5) * \n                         sin(position.z * 12.0 + time * 0.7) * 0.05;\n                         \n      pos += normal * displacement;\n      vPosition = pos;\n      \n      gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\n    }\n  ","\n    varying vec3 vNormal;\n    varying vec3 vPosition;\n    uniform float time;\n    uniform vec3 baseColor;\n    uniform vec3 pulseColor;\n    \n    void main() {\n      // Create dynamic fresnel effect\n      float fresnel = pow(1.0 - abs(dot(normalize(vNormal), vec3(0.0, 0.0, 1.0))), 3.0);\n      \n      // Add crystalline patterns\n      float pattern = sin(vPosition.x * 20.0 + time) * \n                     cos(vPosition.y * 15.0 + time * 0.7) * \n                     sin(vPosition.z * 25.0 + time * 0.5);\n                     \n      // Create pulsing glow\n      float pulse = sin(time * 0.5) * 0.5 + 0.5;\n      \n      // Mix colors based on effects\n      vec3 finalColor = mix(baseColor, pulseColor, fresnel * (0.3 + pulse * 0.2));\n      finalColor += pattern * 0.1 * pulseColor;\n      \n      // Add subtle iridescence\n      float iridescence = sin(fresnel * 8.0 + time * 0.5) * 0.1 + 0.1;\n      finalColor += vec3(sin(time * 0.7), cos(time * 0.8), sin(time * 0.9)) * iridescence;\n      \n      float alpha = 0.3 + fresnel * 0.7;\n      gl_FragColor = vec4(finalColor, alpha);\n    }\n  "),c=l({time:0,color:new r.Color("#4466ff")},"\n    varying vec3 vNormal;\n    void main() {\n      vNormal = normalize(normalMatrix * normal);\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ","\n    varying vec3 vNormal;\n    uniform float time;\n    uniform vec3 color;\n    \n    void main() {\n      float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 4.0);\n      vec3 glow = color * intensity * (1.0 + sin(time * 0.5) * 0.2);\n      gl_FragColor = vec4(glow, intensity);\n    }\n  ");function f(n){let{radius:e=5}=n,i=(0,t.useRef)(null),r=(0,t.useRef)(null),l=(0,t.useRef)(null),f=(0,t.useRef)(0);return(0,s.F)((n,e)=>{f.current+=.5*e,r.current&&(r.current.time=f.current),l.current&&(l.current.time=f.current),i.current&&(i.current.rotation.y+=.1*e)}),(0,o.jsxs)("group",{ref:i,children:[(0,o.jsxs)("mesh",{children:[(0,o.jsx)("sphereGeometry",{args:[.98*e,128,128]}),(0,o.jsx)("primitive",{object:new a,ref:r})]}),(0,o.jsxs)("mesh",{children:[(0,o.jsx)("icosahedronGeometry",{args:[1.001*e,1]}),(0,o.jsx)("meshPhysicalMaterial",{color:"#aaddff",wireframe:!0,transparent:!0,opacity:.1,metalness:1,roughness:0})]}),(0,o.jsxs)("mesh",{children:[(0,o.jsx)("sphereGeometry",{args:[1.02*e,64,64]}),(0,o.jsx)("primitive",{object:new c,ref:l})]}),(0,o.jsx)("pointLight",{position:[10,10,10],intensity:.8,color:"#4488ff",distance:20}),(0,o.jsx)("pointLight",{position:[-10,-10,-10],intensity:.4,color:"#88ffff",distance:20}),(0,o.jsx)("pointLight",{position:[0,0,10],intensity:.6,color:"#ffffff",distance:15})]})}}}]);